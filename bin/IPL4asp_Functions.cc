// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "IPL4asp_Functions.hh"

namespace IPL4asp__Functions {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const CHARSTRING cs_2(0, NULL),
cs_1('.'),
cs_0(':');
static const unsigned char module_checksum[] = { 0x60, 0x0e, 0xa9, 0x4f, 0xd5, 0x5b, 0x40, 0x7e, 0x8a, 0x7b, 0x60, 0xdd, 0xc2, 0xc0, 0x16, 0x0d };

/* Global variable definitions */

TTCN_Module module_object("IPL4asp_Functions", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__setUpInterface(const CHARSTRING& startIPAddress, const CHARSTRING& netmask, const CHARSTRING& broadcast, const INTEGER& count, const CHARSTRING& ifname, const INTEGER& virtualIfaceStart)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 24, TTCN_Location::LOCATION_FUNCTION, "f_setUpInterface");
current_location.update_lineno(32);
#line 32 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
Socket__API__Definitions::ro__integer startIPAddress__Record(f__splitIpAddress(startIPAddress));
{
current_location.update_lineno(36);
#line 36 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(virtualIfaceStart);
current_location.update_lineno(36);
#line 36 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(37);
#line 37 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i < (virtualIfaceStart + count))) break;
current_location.update_lineno(38);
#line 38 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
TCCInterface__Functions::f__setIP(((ifname + cs_0) + int2str(i)), f__presentIpAddress(startIPAddress__Record), netmask, broadcast, TCCInterface__Functions::f__setIP_number_defval);
current_location.update_lineno(40);
#line 40 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
f__nextIpAddress(startIPAddress__Record);
current_location.update_lineno(37);
#line 37 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_0;
++i;
}
}
}
}

void f__setDownInterface(const CHARSTRING& ifname, const INTEGER& count, const INTEGER& virtualIfaceStart)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 44, TTCN_Location::LOCATION_FUNCTION, "f_setDownInterface");
{
current_location.update_lineno(49);
#line 49 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(virtualIfaceStart);
current_location.update_lineno(49);
#line 49 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(50);
#line 50 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i < (virtualIfaceStart + count))) break;
current_location.update_lineno(51);
#line 51 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
TCCInterface__Functions::f__deleteIP(((ifname + cs_0) + int2str(i)));
current_location.update_lineno(50);
#line 50 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_1;
++i;
}
}
}
}

BOOLEAN f__hasColon(const CHARSTRING& str)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 55, TTCN_Location::LOCATION_FUNCTION, "f_hasColon");
current_location.update_lineno(56);
#line 56 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((!(str.is_value()))) {
current_location.update_lineno(56);
#line 56 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return FALSE;
}
{
current_location.update_lineno(57);
#line 57 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(0);
current_location.update_lineno(57);
#line 57 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(57);
#line 57 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i < str.lengthof())) break;
current_location.update_lineno(58);
#line 58 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((const_cast< const CHARSTRING&>(str)[i] == cs_0)) {
current_location.update_lineno(58);
#line 58 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return TRUE;
}
current_location.update_lineno(57);
#line 57 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_2;
++i;
}
}
}
current_location.update_lineno(60);
#line 60 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return FALSE;
}

Socket__API__Definitions::ro__charstring f__tokenizeIP(const CHARSTRING& addr)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 63, TTCN_Location::LOCATION_FUNCTION, "f_tokenizeIP");
current_location.update_lineno(64);
#line 64 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
Socket__API__Definitions::ro__charstring tokens(NULL_VALUE);
current_location.update_lineno(65);
#line 65 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
CHARSTRING l__delim(cs_1);
current_location.update_lineno(66);
#line 66 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (f__hasColon(addr)) {
current_location.update_lineno(66);
#line 66 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
l__delim = cs_0;
}
current_location.update_lineno(67);
#line 67 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
CHARSTRING l__token(cs_2);
current_location.update_lineno(68);
#line 68 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER addrlen(addr.lengthof());
{
current_location.update_lineno(69);
#line 69 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(0);
current_location.update_lineno(69);
#line 69 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(69);
#line 69 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i < addrlen)) break;
current_location.update_lineno(71);
#line 71 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((const_cast< const CHARSTRING&>(addr)[i] == l__delim)) {
current_location.update_lineno(72);
#line 72 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
tokens[tokens.size_of()] = l__token;
current_location.update_lineno(73);
#line 73 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
l__token = cs_2;
}
else {
current_location.update_lineno(75);
#line 75 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
CHARSTRING tmp_6;
tmp_6 = (l__token + const_cast< const CHARSTRING&>(addr)[i]);
l__token = tmp_6;
}
}
current_location.update_lineno(69);
#line 69 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_7;
++i;
}
}
}
current_location.update_lineno(78);
#line 78 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((l__token != cs_2)) {
current_location.update_lineno(79);
#line 79 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
tokens[tokens.size_of()] = l__token;
}
current_location.update_lineno(81);
#line 81 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return tokens;
}

Socket__API__Definitions::ro__integer f__splitIpAddress(const CHARSTRING& addr)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 84, TTCN_Location::LOCATION_FUNCTION, "f_splitIpAddress");
current_location.update_lineno(87);
#line 87 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
Socket__API__Definitions::ro__integer segAddr(NULL_VALUE);
current_location.update_lineno(88);
#line 88 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
Socket__API__Definitions::ro__charstring ip(f__tokenizeIP(addr));
current_location.update_lineno(89);
#line 89 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (f__hasColon(addr)) {
current_location.update_lineno(91);
#line 91 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(0);
for ( ; ; ) {
current_location.update_lineno(92);
#line 92 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(const_cast< const Socket__API__Definitions::ro__charstring&>(ip)[i] != cs_2)) break;
current_location.update_lineno(93);
#line 93 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
segAddr[i] = hex2int(str2hex(const_cast< const Socket__API__Definitions::ro__charstring&>(ip)[i]));
current_location.update_lineno(94);
#line 94 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_10;
++i;
}
current_location.update_lineno(95);
#line 95 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((i == ip.size_of())) {
current_location.update_lineno(96);
#line 96 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return segAddr;
}
}
current_location.update_lineno(99);
#line 99 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER memo((i + 1));
current_location.update_lineno(100);
#line 100 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER zs(((8 - ip.size_of()) + 1));
{
current_location.update_lineno(101);
#line 101 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER k(i);
current_location.update_lineno(101);
#line 101 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(101);
#line 101 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(k < (zs + i))) break;
current_location.update_lineno(102);
#line 102 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
segAddr[k] = 0;
current_location.update_lineno(101);
#line 101 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_12;
++k;
}
}
}
current_location.update_lineno(104);
#line 104 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_13;
tmp_13 = (i + zs);
i = tmp_13;
}
for ( ; ; ) {
current_location.update_lineno(105);
#line 105 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
boolean tmp_14;
tmp_14 = (i < 8);
if (tmp_14) tmp_14 = (memo < ip.size_of());
if (!tmp_14) break;
}
current_location.update_lineno(106);
#line 106 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
segAddr[i] = hex2int(str2hex(const_cast< const Socket__API__Definitions::ro__charstring&>(ip)[memo]));
current_location.update_lineno(107);
#line 107 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_16;
++i;
}
current_location.update_lineno(107);
#line 107 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_17;
++memo;
}
}
}
else {
{
current_location.update_lineno(111);
#line 111 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i(0);
current_location.update_lineno(111);
#line 111 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(111);
#line 111 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i < 4)) break;
current_location.update_lineno(112);
#line 112 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
segAddr[i] = str2int(const_cast< const Socket__API__Definitions::ro__charstring&>(ip)[i]);
current_location.update_lineno(111);
#line 111 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_19;
++i;
}
}
}
}
current_location.update_lineno(116);
#line 116 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return segAddr;
}

CHARSTRING f__presentIpAddress(const Socket__API__Definitions::ro__integer& addr)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 119, TTCN_Location::LOCATION_FUNCTION, "f_presentIpAddress");
current_location.update_lineno(120);
#line 120 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((addr.size_of() == 4)) {
current_location.update_lineno(121);
#line 121 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return ((((((int2str(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[0]) + cs_1) + int2str(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[1])) + cs_1) + int2str(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[2])) + cs_1) + int2str(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[3]));
}
else {
current_location.update_lineno(126);
#line 126 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return ((((((((((((((hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[0], 4)) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[1], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[2], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[3], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[4], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[5], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[6], 4))) + cs_0) + hex2str(int2hex(const_cast< const Socket__API__Definitions::ro__integer&>(addr)[7], 4)));
}
}

void f__nextIpAddress(Socket__API__Definitions::ro__integer& addr)
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 139, TTCN_Location::LOCATION_FUNCTION, "f_nextIpAddress");
current_location.update_lineno(142);
#line 142 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER n(addr.size_of());
current_location.update_lineno(143);
#line 143 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER segMax(255);
current_location.update_lineno(144);
#line 144 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((n == 8)) {
current_location.update_lineno(145);
#line 145 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
segMax = 65535;
}
{
current_location.update_lineno(148);
#line 148 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
INTEGER i((n - 1));
current_location.update_lineno(148);
#line 148 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
for ( ; ; ) {
current_location.update_lineno(148);
#line 148 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if (!(i >= 0)) break;
current_location.update_lineno(149);
#line 149 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
if ((const_cast< const Socket__API__Definitions::ro__integer&>(addr)[i] < segMax)) {
current_location.update_lineno(150);
#line 150 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_21;
tmp_21 = (const_cast< const Socket__API__Definitions::ro__integer&>(addr)[i] + 1);
addr[i] = tmp_21;
}
current_location.update_lineno(151);
#line 151 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
return;
}
else {
current_location.update_lineno(153);
#line 153 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
addr[i] = 0;
}
current_location.update_lineno(148);
#line 148 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn"
{
INTEGER tmp_23;
--i;
}
}
}
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "IPL4asp_Functions");
IPL4asp__PortType::module_object.pre_init_module();
TCCInterface__Functions::module_object.pre_init_module();
module_object.add_function("f_setUpInterface", (genericfunc_t)&f__setUpInterface, NULL);
module_object.add_function("f_setDownInterface", (genericfunc_t)&f__setDownInterface, NULL);
module_object.add_function("f_hasColon", (genericfunc_t)&f__hasColon, NULL);
module_object.add_function("f_tokenizeIP", (genericfunc_t)&f__tokenizeIP, NULL);
module_object.add_function("f_splitIpAddress", (genericfunc_t)&f__splitIpAddress, NULL);
module_object.add_function("f_presentIpAddress", (genericfunc_t)&f__presentIpAddress, NULL);
module_object.add_function("f_nextIpAddress", (genericfunc_t)&f__nextIpAddress, NULL);
module_object.add_function("f_findIpAddressesWithDhcp", (genericfunc_t)&f__findIpAddressesWithDhcp, NULL);
module_object.add_function("f_releaseIpAddressesFromDhcp", (genericfunc_t)&f__releaseIpAddressesFromDhcp, NULL);
module_object.add_function("f_findIpAddressesWithARP", (genericfunc_t)&f__findIpAddressesWithARP, NULL);
module_object.add_function("f_findIpAddresses", (genericfunc_t)&f__findIpAddresses, NULL);
}

static void post_init_module()
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "IPL4asp_Functions");
IPL4asp__PortType::module_object.post_init_module();
TCCInterface__Functions::module_object.post_init_module();
}


} /* end of namespace */
