// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "Mqtt_v3_1_1_Types.hh"

namespace Mqtt__v3__1__1__Types {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x55, 0x3b, 0x82, 0x5e, 0x6a, 0x59, 0xa9, 0x26, 0x96, 0xe1, 0xa4, 0xf3, 0x4d, 0x2b, 0x2e, 0x65 };

/* Global variable definitions */

const XERdescriptor_t       OCT0__65535_xer_ = { {"OCT0_65535>\n", "OCT0_65535>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t OCT0__65535_descr_ = { "@Mqtt_v3_1_1_Types.OCT0_65535", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &OCT0__65535_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR0__65535_xer_ = { {"UCHAR0_65535>\n", "UCHAR0_65535>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR0__65535_descr_ = { "@Mqtt_v3_1_1_Types.UCHAR0_65535", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR0__65535_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BIT1n_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
const XERdescriptor_t       BIT1n_xer_ = { {"BIT1n>\n", "BIT1n>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BIT1n_descr_ = { "@Mqtt_v3_1_1_Types.BIT1n", &BITSTRING_ber_, &BIT1n_raw_, NULL, &BIT1n_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BIT4n_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
const XERdescriptor_t       BIT4n_xer_ = { {"BIT4n>\n", "BIT4n>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BIT4n_descr_ = { "@Mqtt_v3_1_1_Types.BIT4n", &BITSTRING_ber_, &BIT4n_raw_, NULL, &BIT4n_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       INT0__255_xer_ = { {"INT0_255>\n", "INT0_255>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t INT0__255_descr_ = { "@Mqtt_v3_1_1_Types.INT0_255", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &INT0__255_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for QoS
const TTCN_Typedescriptor_t QoS_descr_ = { "@Mqtt_v3_1_1_Types.QoS", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Header_flags_xer_ = { {"flags>\n", "flags>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Header_flags_descr_ = { "@Mqtt_v3_1_1_Types.Header.flags", &BITSTRING_ber_, &BIT4n_raw_, NULL, &Header_flags_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Header
const TTCN_Typedescriptor_t Header_descr_ = { "@Mqtt_v3_1_1_Types.Header", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__PublishHeader_dup__flag_xer_ = { {"dup_flag>\n", "dup_flag>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__PublishHeader_dup__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.dup_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__PublishHeader_dup__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__PublishHeader_retain__flag_xer_ = { {"retain_flag>\n", "retain_flag>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__PublishHeader_retain__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.retain_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__PublishHeader_retain__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__PublishHeader
const TTCN_Typedescriptor_t MQTT__v3__1__1__PublishHeader_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectFlags_user__name__flag_xer_ = { {"user_name_flag>\n", "user_name_flag>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_user__name__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.user_name_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__ConnectFlags_user__name__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectFlags_password__flag_xer_ = { {"password_flag>\n", "password_flag>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_password__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.password_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__ConnectFlags_password__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectFlags_will__retain_xer_ = { {"will_retain>\n", "will_retain>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_will__retain_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.will_retain", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__ConnectFlags_will__retain_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectFlags_will__flag_xer_ = { {"will_flag>\n", "will_flag>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_will__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.will_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__ConnectFlags_will__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectFlags_clean__session_xer_ = { {"clean_session>\n", "clean_session>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_clean__session_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.clean_session", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__ConnectFlags_clean__session_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__ConnectFlags
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectFlags_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectPayload_client__identifier_xer_ = { {"client_identifier>\n", "client_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_client__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.client_identifier", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__ConnectPayload_client__identifier_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__ConnectPayload
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectPayload_will__topic_xer_ = { {"will_topic>\n", "will_topic>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_will__topic_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.will_topic", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__ConnectPayload_will__topic_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectPayload_will__message_xer_ = { {"will_message>\n", "will_message>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_will__message_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.will_message", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &MQTT__v3__1__1__ConnectPayload_will__message_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectPayload_user__name_xer_ = { {"user_name>\n", "user_name>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_user__name_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.user_name", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__ConnectPayload_user__name_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__ConnectPayload_password_xer_ = { {"password>\n", "password>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__ConnectPayload_password_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.password", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &MQTT__v3__1__1__ConnectPayload_password_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Connect_name_xer_ = { {"name>\n", "name>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connect_name_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.name", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__Connect_name_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Connect_protocol__level_xer_ = { {"protocol_level>\n", "protocol_level>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connect_protocol__level_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.protocol_level", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Connect_protocol__level_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Connect_keep__alive_xer_ = { {"keep_alive>\n", "keep_alive>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connect_keep__alive_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.keep_alive", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Connect_keep__alive_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Connect
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connect_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Connack_session__present__flag_xer_ = { {"session_present_flag>\n", "session_present_flag>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connack_session__present__flag_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.session_present_flag", &BITSTRING_ber_, &BIT1n_raw_, NULL, &MQTT__v3__1__1__Connack_session__present__flag_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Connack_connect__return__code_xer_ = { {"connect_return_code>\n", "connect_return_code>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connack_connect__return__code_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.connect_return_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Connack_connect__return__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Connack
const TTCN_Typedescriptor_t MQTT__v3__1__1__Connack_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Publish_topic__name_xer_ = { {"topic_name>\n", "topic_name>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Publish_topic__name_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.topic_name", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__Publish_topic__name_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Publish_payload_xer_ = { {"payload>\n", "payload>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Publish_payload_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.payload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &MQTT__v3__1__1__Publish_payload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Publish
const TTCN_Typedescriptor_t MQTT__v3__1__1__Publish_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Publish_packet__identifier_xer_ = { {"packet_identifier>\n", "packet_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Publish_packet__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.packet_identifier", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Publish_packet__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Identifier_packet__identifier_xer_ = { {"packet_identifier>\n", "packet_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Identifier_packet__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.packet_identifier", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Identifier_packet__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Identifier
const TTCN_Typedescriptor_t MQTT__v3__1__1__Identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__SubscribePayload_topic__filter_xer_ = { {"topic_filter>\n", "topic_filter>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__SubscribePayload_topic__filter_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.topic_filter", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &MQTT__v3__1__1__SubscribePayload_topic__filter_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__SubscribePayload
const TTCN_Typedescriptor_t MQTT__v3__1__1__SubscribePayload_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__SubscribePayloadList
const TTCN_Typedescriptor_t MQTT__v3__1__1__SubscribePayloadList_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList", NULL, NULL, NULL, NULL, NULL, &MQTT__v3__1__1__SubscribePayload_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Subscribe_packet__identifier_xer_ = { {"packet_identifier>\n", "packet_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Subscribe_packet__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.packet_identifier", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Subscribe_packet__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Subscribe
const TTCN_Typedescriptor_t MQTT__v3__1__1__Subscribe_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IntegerList
const TTCN_Typedescriptor_t IntegerList_descr_ = { "@Mqtt_v3_1_1_Types.IntegerList", NULL, NULL, NULL, NULL, NULL, &INT0__255_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IntegerList_0_xer_ = { {"INT0_255>\n", "INT0_255>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IntegerList_0_descr_ = { "@Mqtt_v3_1_1_Types.IntegerList.<oftype>", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &IntegerList_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__SubackPayload
const TTCN_Typedescriptor_t MQTT__v3__1__1__SubackPayload_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Suback_packet__identifier_xer_ = { {"packet_identifier>\n", "packet_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Suback_packet__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.packet_identifier", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Suback_packet__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Suback
const TTCN_Typedescriptor_t MQTT__v3__1__1__Suback_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for UCHAR0__65535List
const TTCN_Typedescriptor_t UCHAR0__65535List_descr_ = { "@Mqtt_v3_1_1_Types.UCHAR0_65535List", NULL, NULL, NULL, NULL, NULL, &UCHAR0__65535_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR0__65535List_0_xer_ = { {"UCHAR0_65535>\n", "UCHAR0_65535>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR0__65535List_0_descr_ = { "@Mqtt_v3_1_1_Types.UCHAR0_65535List.<oftype>", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR0__65535List_0_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__UnsubscribePayload
const TTCN_Typedescriptor_t MQTT__v3__1__1__UnsubscribePayload_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Unsubscribe_packet__identifier_xer_ = { {"packet_identifier>\n", "packet_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Unsubscribe_packet__identifier_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.packet_identifier", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &MQTT__v3__1__1__Unsubscribe_packet__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Unsubscribe
const TTCN_Typedescriptor_t MQTT__v3__1__1__Unsubscribe_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Empty
const TTCN_Typedescriptor_t MQTT__v3__1__1__Empty_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__ReqResp
const TTCN_Typedescriptor_t MQTT__v3__1__1__ReqResp_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MQTT__v3__1__1__Message
const TTCN_Typedescriptor_t MQTT__v3__1__1__Message_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MQTT__v3__1__1__Message_raw__message_xer_ = { {"raw_message>\n", "raw_message>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t MQTT__v3__1__1__Message_raw__message_descr_ = { "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.raw_message", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &MQTT__v3__1__1__Message_raw__message_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("Mqtt_v3_1_1_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

QoS::QoS()
{
enum_value = UNBOUND_VALUE;
}

QoS::QoS(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @Mqtt_v3_1_1_Types.QoS with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

QoS::QoS(enum_type other_value)
{
enum_value = other_value;
}

QoS::QoS(const QoS& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
enum_value = other_value.enum_value;
}

QoS& QoS::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @Mqtt_v3_1_1_Types.QoS.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

QoS& QoS::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

QoS& QoS::operator=(const QoS& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
enum_value = other_value.enum_value;
return *this;
}

boolean QoS::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value == other_value;
}

boolean QoS::operator==(const QoS& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value == other_value.enum_value;
}

boolean QoS::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value < other_value;
}

boolean QoS::operator<(const QoS& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value < other_value.enum_value;
}

boolean QoS::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value > other_value;
}

boolean QoS::operator>(const QoS& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value > other_value.enum_value;
}

const char *QoS::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case AT__MOST__ONCE__DELIVERY: return "AT_MOST_ONCE_DELIVERY";
case AT__LEAST__ONCE__DELIVERY: return "AT_LEAST_ONCE_DELIVERY";
case EXACTLY__ONE__DELIVERY: return "EXACTLY_ONE_DELIVERY";
case RESERVED: return "RESERVED";
default: return "<unknown>";
}
}

QoS::enum_type QoS::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "AT_MOST_ONCE_DELIVERY")) return AT__MOST__ONCE__DELIVERY;
else if (!strcmp(str_par, "AT_LEAST_ONCE_DELIVERY")) return AT__LEAST__ONCE__DELIVERY;
else if (!strcmp(str_par, "EXACTLY_ONE_DELIVERY")) return EXACTLY__ONE__DELIVERY;
else if (!strcmp(str_par, "RESERVED")) return RESERVED;
else return UNKNOWN_VALUE;
}

boolean QoS::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int QoS::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Mqtt_v3_1_1_Types.QoS.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int QoS::enum2int(const QoS& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Mqtt_v3_1_1_Types.QoS.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void QoS::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @Mqtt_v3_1_1_Types.QoS.", int_val);
enum_value = (enum_type)int_val;
}

QoS::operator QoS::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return enum_value;
}

void QoS::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void QoS::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@Mqtt_v3_1_1_Types.QoS");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @Mqtt_v3_1_1_Types.QoS.");
  }
}

void QoS::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
text_buf.push_int(enum_value);
}

void QoS::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @Mqtt_v3_1_1_Types.QoS.", enum_value);
}

void QoS_template::copy_template(const QoS_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new QoS_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
}
}

QoS_template::QoS_template()
{
}

QoS_template::QoS_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

QoS_template::QoS_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!QoS::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @Mqtt_v3_1_1_Types.QoS with unknown numeric value %d.", other_value);
single_value = (QoS::enum_type)other_value;
}

QoS_template::QoS_template(QoS::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

QoS_template::QoS_template(const QoS& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == QoS::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS.");
single_value = other_value.enum_value;
}

QoS_template::QoS_template(const OPTIONAL<QoS>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (QoS::enum_type)(const QoS&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @Mqtt_v3_1_1_Types.QoS from an unbound optional field.");
}
}

QoS_template::QoS_template(const QoS_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

QoS_template::~QoS_template()
{
clean_up();
}

boolean QoS_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean QoS_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != QoS::UNBOUND_VALUE;
}

void QoS_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

QoS_template& QoS_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

QoS_template& QoS_template::operator=(int other_value)
{
if (!QoS::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @Mqtt_v3_1_1_Types.QoS.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (QoS::enum_type)other_value;
return *this;
}

QoS_template& QoS_template::operator=(QoS::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

QoS_template& QoS_template::operator=(const QoS& other_value)
{
if (other_value.enum_value == QoS::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Mqtt_v3_1_1_Types.QoS to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

QoS_template& QoS_template::operator=(const OPTIONAL<QoS>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (QoS::enum_type)(const QoS&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
}
return *this;
}

QoS_template& QoS_template::operator=(const QoS_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean QoS_template::match(QoS::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
}
return FALSE;
}

boolean QoS_template::match(const QoS& other_value, boolean) const
{
if (other_value.enum_value == QoS::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @Mqtt_v3_1_1_Types.QoS with an unbound value.");
return match(other_value.enum_value);
}

QoS::enum_type QoS_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return single_value;
}

void QoS_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new QoS_template[list_length];
}

QoS_template& QoS_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
return value_list.list_value[list_index];
}

void QoS_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(QoS::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void QoS_template::log_match(const QoS& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void QoS_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
}
}

void QoS_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (QoS::enum_type)text_buf.pull_int().get_val();
if (!QoS::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @Mqtt_v3_1_1_Types.QoS.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new QoS_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @Mqtt_v3_1_1_Types.QoS.");
}
}

boolean QoS_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean QoS_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void QoS_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    QoS_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    QoS::enum_type enum_val = QoS::str_to_enum(m_p->get_enumerated());
    if (!QoS::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @Mqtt_v3_1_1_Types.QoS.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@Mqtt_v3_1_1_Types.QoS");
  }
  is_ifpresent = param.get_ifpresent();
}

void QoS_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.QoS");
}

Header::Header()
{
}

Header::Header(const BITSTRING& par_flags)
  :   field_flags(par_flags)
{
}

Header::Header(const Header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.Header.");
if (other_value.flags().is_bound()) field_flags = other_value.flags();
else field_flags.clean_up();
}

void Header::clean_up()
{
field_flags.clean_up();
}

Header& Header::operator=(const Header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.Header.");
  if (other_value.flags().is_bound()) field_flags = other_value.flags();
  else field_flags.clean_up();
}
return *this;
}

boolean Header::operator==(const Header& other_value) const
{
return field_flags==other_value.field_flags;
}

boolean Header::is_bound() const
{
if(field_flags.is_bound()) return TRUE;
return FALSE;
}
boolean Header::is_value() const
{
if(!field_flags.is_value()) return FALSE;
return TRUE;
}
void Header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ flags := ");
field_flags.log();
TTCN_Logger::log_event_str(" }");
}

void Header::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.Header has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.Header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.Header");
  }
}

void Header::set_implicit_omit()
{
if (flags().is_bound()) flags().set_implicit_omit();
}

void Header::encode_text(Text_Buf& text_buf) const
{
field_flags.encode_text(text_buf);
}

void Header::decode_text(Text_Buf& text_buf)
{
field_flags.decode_text(text_buf);
}

struct Header_template::single_value_struct {
BITSTRING_template field_flags;
};

void Header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_flags = ANY_VALUE;
}
}
}

void Header_template::copy_value(const Header& other_value)
{
single_value = new single_value_struct;
if (other_value.flags().is_bound()) {
  single_value->field_flags = other_value.flags();
} else {
  single_value->field_flags.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Header_template::copy_template(const Header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.flags().get_selection()) {
single_value->field_flags = other_value.flags();
} else {
single_value->field_flags.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.Header.");
break;
}
set_selection(other_value);
}

Header_template::Header_template()
{
}

Header_template::Header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Header_template::Header_template(const Header& other_value)
{
copy_value(other_value);
}

Header_template::Header_template(const OPTIONAL<Header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.Header from an unbound optional field.");
}
}

Header_template::Header_template(const Header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Header_template::~Header_template()
{
clean_up();
}

Header_template& Header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Header_template& Header_template::operator=(const Header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Header_template& Header_template::operator=(const OPTIONAL<Header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.Header.");
}
return *this;
}

Header_template& Header_template::operator=(const Header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Header_template::match(const Header& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.flags().is_bound()) return FALSE;
if(!single_value->field_flags.match(other_value.flags(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.Header.");
}
return FALSE;
}

boolean Header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_flags.is_bound()) return TRUE;
return FALSE;
}

boolean Header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_flags.is_value()) return FALSE;
return TRUE;
}

void Header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Header Header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.Header.");
Header ret_val;
if (single_value->field_flags.is_bound()) {
ret_val.flags() = single_value->field_flags.valueof();
}
return ret_val;
}

void Header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.Header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Header_template[list_length];
}

Header_template& Header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.Header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.Header.");
return value_list.list_value[list_index];
}

BITSTRING_template& Header_template::flags()
{
set_specific();
return single_value->field_flags;
}

const BITSTRING_template& Header_template::flags() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flags of a non-specific template of type @Mqtt_v3_1_1_Types.Header.");
return single_value->field_flags;
}

int Header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.Header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.Header.");
  }
  return 0;
}

void Header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ flags := ");
single_value->field_flags.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Header_template::log_match(const Header& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_flags.match(match_value.flags(), legacy)){
TTCN_Logger::log_logmatch_info(".flags");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ flags := ");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_flags.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.Header.");
}
}

void Header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_flags.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.Header.");
}
}

void Header_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Header_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.Header has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.Header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.Header");
  }
  is_ifpresent = param.get_ifpresent();
}

void Header_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_flags.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.Header");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.Header");
}

boolean Header_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Header_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__PublishHeader::MQTT__v3__1__1__PublishHeader()
{
}

MQTT__v3__1__1__PublishHeader::MQTT__v3__1__1__PublishHeader(const BITSTRING& par_dup__flag,
    const QoS& par_qos__level,
    const BITSTRING& par_retain__flag)
  :   field_dup__flag(par_dup__flag),
  field_qos__level(par_qos__level),
  field_retain__flag(par_retain__flag)
{
}

MQTT__v3__1__1__PublishHeader::MQTT__v3__1__1__PublishHeader(const MQTT__v3__1__1__PublishHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
if (other_value.dup__flag().is_bound()) field_dup__flag = other_value.dup__flag();
else field_dup__flag.clean_up();
if (other_value.qos__level().is_bound()) field_qos__level = other_value.qos__level();
else field_qos__level.clean_up();
if (other_value.retain__flag().is_bound()) field_retain__flag = other_value.retain__flag();
else field_retain__flag.clean_up();
}

void MQTT__v3__1__1__PublishHeader::clean_up()
{
field_dup__flag.clean_up();
field_qos__level.clean_up();
field_retain__flag.clean_up();
}

MQTT__v3__1__1__PublishHeader& MQTT__v3__1__1__PublishHeader::operator=(const MQTT__v3__1__1__PublishHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
  if (other_value.dup__flag().is_bound()) field_dup__flag = other_value.dup__flag();
  else field_dup__flag.clean_up();
  if (other_value.qos__level().is_bound()) field_qos__level = other_value.qos__level();
  else field_qos__level.clean_up();
  if (other_value.retain__flag().is_bound()) field_retain__flag = other_value.retain__flag();
  else field_retain__flag.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__PublishHeader::operator==(const MQTT__v3__1__1__PublishHeader& other_value) const
{
return field_dup__flag==other_value.field_dup__flag
  && field_qos__level==other_value.field_qos__level
  && field_retain__flag==other_value.field_retain__flag;
}

boolean MQTT__v3__1__1__PublishHeader::is_bound() const
{
if(field_dup__flag.is_bound()) return TRUE;
if(field_qos__level.is_bound()) return TRUE;
if(field_retain__flag.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__PublishHeader::is_value() const
{
if(!field_dup__flag.is_value()) return FALSE;
if(!field_qos__level.is_value()) return FALSE;
if(!field_retain__flag.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__PublishHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ dup_flag := ");
field_dup__flag.log();
TTCN_Logger::log_event_str(", qos_level := ");
field_qos__level.log();
TTCN_Logger::log_event_str(", retain_flag := ");
field_retain__flag.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__PublishHeader::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dup__flag().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) qos__level().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) retain__flag().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dup_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dup__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "qos_level")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          qos__level().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "retain_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          retain__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
  }
}

void MQTT__v3__1__1__PublishHeader::set_implicit_omit()
{
if (dup__flag().is_bound()) dup__flag().set_implicit_omit();
if (qos__level().is_bound()) qos__level().set_implicit_omit();
if (retain__flag().is_bound()) retain__flag().set_implicit_omit();
}

void MQTT__v3__1__1__PublishHeader::encode_text(Text_Buf& text_buf) const
{
field_dup__flag.encode_text(text_buf);
field_qos__level.encode_text(text_buf);
field_retain__flag.encode_text(text_buf);
}

void MQTT__v3__1__1__PublishHeader::decode_text(Text_Buf& text_buf)
{
field_dup__flag.decode_text(text_buf);
field_qos__level.decode_text(text_buf);
field_retain__flag.decode_text(text_buf);
}

struct MQTT__v3__1__1__PublishHeader_template::single_value_struct {
BITSTRING_template field_dup__flag;
QoS_template field_qos__level;
BITSTRING_template field_retain__flag;
};

void MQTT__v3__1__1__PublishHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_dup__flag = ANY_VALUE;
single_value->field_qos__level = ANY_VALUE;
single_value->field_retain__flag = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__PublishHeader_template::copy_value(const MQTT__v3__1__1__PublishHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.dup__flag().is_bound()) {
  single_value->field_dup__flag = other_value.dup__flag();
} else {
  single_value->field_dup__flag.clean_up();
}
if (other_value.qos__level().is_bound()) {
  single_value->field_qos__level = other_value.qos__level();
} else {
  single_value->field_qos__level.clean_up();
}
if (other_value.retain__flag().is_bound()) {
  single_value->field_retain__flag = other_value.retain__flag();
} else {
  single_value->field_retain__flag.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__PublishHeader_template::copy_template(const MQTT__v3__1__1__PublishHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.dup__flag().get_selection()) {
single_value->field_dup__flag = other_value.dup__flag();
} else {
single_value->field_dup__flag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.qos__level().get_selection()) {
single_value->field_qos__level = other_value.qos__level();
} else {
single_value->field_qos__level.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.retain__flag().get_selection()) {
single_value->field_retain__flag = other_value.retain__flag();
} else {
single_value->field_retain__flag.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__PublishHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__PublishHeader_template::MQTT__v3__1__1__PublishHeader_template()
{
}

MQTT__v3__1__1__PublishHeader_template::MQTT__v3__1__1__PublishHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__PublishHeader_template::MQTT__v3__1__1__PublishHeader_template(const MQTT__v3__1__1__PublishHeader& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__PublishHeader_template::MQTT__v3__1__1__PublishHeader_template(const OPTIONAL<MQTT__v3__1__1__PublishHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__PublishHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader from an unbound optional field.");
}
}

MQTT__v3__1__1__PublishHeader_template::MQTT__v3__1__1__PublishHeader_template(const MQTT__v3__1__1__PublishHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__PublishHeader_template::~MQTT__v3__1__1__PublishHeader_template()
{
clean_up();
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__PublishHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__PublishHeader_template::operator=(const MQTT__v3__1__1__PublishHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__PublishHeader_template::operator=(const OPTIONAL<MQTT__v3__1__1__PublishHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__PublishHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
}
return *this;
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__PublishHeader_template::operator=(const MQTT__v3__1__1__PublishHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__PublishHeader_template::match(const MQTT__v3__1__1__PublishHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.dup__flag().is_bound()) return FALSE;
if(!single_value->field_dup__flag.match(other_value.dup__flag(), legacy))return FALSE;
if(!other_value.qos__level().is_bound()) return FALSE;
if(!single_value->field_qos__level.match(other_value.qos__level(), legacy))return FALSE;
if(!other_value.retain__flag().is_bound()) return FALSE;
if(!single_value->field_retain__flag.match(other_value.retain__flag(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
}
return FALSE;
}

boolean MQTT__v3__1__1__PublishHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_dup__flag.is_bound()) return TRUE;
if (single_value->field_qos__level.is_bound()) return TRUE;
if (single_value->field_retain__flag.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__PublishHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_dup__flag.is_value()) return FALSE;
if (!single_value->field_qos__level.is_value()) return FALSE;
if (!single_value->field_retain__flag.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__PublishHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__PublishHeader MQTT__v3__1__1__PublishHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
MQTT__v3__1__1__PublishHeader ret_val;
if (single_value->field_dup__flag.is_bound()) {
ret_val.dup__flag() = single_value->field_dup__flag.valueof();
}
if (single_value->field_qos__level.is_bound()) {
ret_val.qos__level() = single_value->field_qos__level.valueof();
}
if (single_value->field_retain__flag.is_bound()) {
ret_val.retain__flag() = single_value->field_retain__flag.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__PublishHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__PublishHeader_template[list_length];
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__PublishHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
return value_list.list_value[list_index];
}

BITSTRING_template& MQTT__v3__1__1__PublishHeader_template::dup__flag()
{
set_specific();
return single_value->field_dup__flag;
}

const BITSTRING_template& MQTT__v3__1__1__PublishHeader_template::dup__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dup_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
return single_value->field_dup__flag;
}

QoS_template& MQTT__v3__1__1__PublishHeader_template::qos__level()
{
set_specific();
return single_value->field_qos__level;
}

const QoS_template& MQTT__v3__1__1__PublishHeader_template::qos__level() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field qos_level of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
return single_value->field_qos__level;
}

BITSTRING_template& MQTT__v3__1__1__PublishHeader_template::retain__flag()
{
set_specific();
return single_value->field_retain__flag;
}

const BITSTRING_template& MQTT__v3__1__1__PublishHeader_template::retain__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field retain_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
return single_value->field_retain__flag;
}

int MQTT__v3__1__1__PublishHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
  }
  return 0;
}

void MQTT__v3__1__1__PublishHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ dup_flag := ");
single_value->field_dup__flag.log();
TTCN_Logger::log_event_str(", qos_level := ");
single_value->field_qos__level.log();
TTCN_Logger::log_event_str(", retain_flag := ");
single_value->field_retain__flag.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__PublishHeader_template::log_match(const MQTT__v3__1__1__PublishHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_dup__flag.match(match_value.dup__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".dup_flag");
single_value->field_dup__flag.log_match(match_value.dup__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_qos__level.match(match_value.qos__level(), legacy)){
TTCN_Logger::log_logmatch_info(".qos_level");
single_value->field_qos__level.log_match(match_value.qos__level(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_retain__flag.match(match_value.retain__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".retain_flag");
single_value->field_retain__flag.log_match(match_value.retain__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ dup_flag := ");
single_value->field_dup__flag.log_match(match_value.dup__flag(), legacy);
TTCN_Logger::log_event_str(", qos_level := ");
single_value->field_qos__level.log_match(match_value.qos__level(), legacy);
TTCN_Logger::log_event_str(", retain_flag := ");
single_value->field_retain__flag.log_match(match_value.retain__flag(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__PublishHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_dup__flag.encode_text(text_buf);
single_value->field_qos__level.encode_text(text_buf);
single_value->field_retain__flag.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
}
}

void MQTT__v3__1__1__PublishHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_dup__flag.decode_text(text_buf);
single_value->field_qos__level.decode_text(text_buf);
single_value->field_retain__flag.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__PublishHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader.");
}
}

void MQTT__v3__1__1__PublishHeader_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__PublishHeader_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) dup__flag().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) qos__level().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) retain__flag().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dup_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dup__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "qos_level")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          qos__level().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "retain_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          retain__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__PublishHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_dup__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
single_value->field_qos__level.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
single_value->field_retain__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_PublishHeader");
}

boolean MQTT__v3__1__1__PublishHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__PublishHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__ConnectFlags::MQTT__v3__1__1__ConnectFlags()
{
}

MQTT__v3__1__1__ConnectFlags::MQTT__v3__1__1__ConnectFlags(const BITSTRING& par_user__name__flag,
    const BITSTRING& par_password__flag,
    const BITSTRING& par_will__retain,
    const QoS& par_will__qos,
    const BITSTRING& par_will__flag,
    const BITSTRING& par_clean__session)
  :   field_user__name__flag(par_user__name__flag),
  field_password__flag(par_password__flag),
  field_will__retain(par_will__retain),
  field_will__qos(par_will__qos),
  field_will__flag(par_will__flag),
  field_clean__session(par_clean__session)
{
}

MQTT__v3__1__1__ConnectFlags::MQTT__v3__1__1__ConnectFlags(const MQTT__v3__1__1__ConnectFlags& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
if (other_value.user__name__flag().is_bound()) field_user__name__flag = other_value.user__name__flag();
else field_user__name__flag.clean_up();
if (other_value.password__flag().is_bound()) field_password__flag = other_value.password__flag();
else field_password__flag.clean_up();
if (other_value.will__retain().is_bound()) field_will__retain = other_value.will__retain();
else field_will__retain.clean_up();
if (other_value.will__qos().is_bound()) field_will__qos = other_value.will__qos();
else field_will__qos.clean_up();
if (other_value.will__flag().is_bound()) field_will__flag = other_value.will__flag();
else field_will__flag.clean_up();
if (other_value.clean__session().is_bound()) field_clean__session = other_value.clean__session();
else field_clean__session.clean_up();
}

void MQTT__v3__1__1__ConnectFlags::clean_up()
{
field_user__name__flag.clean_up();
field_password__flag.clean_up();
field_will__retain.clean_up();
field_will__qos.clean_up();
field_will__flag.clean_up();
field_clean__session.clean_up();
}

MQTT__v3__1__1__ConnectFlags& MQTT__v3__1__1__ConnectFlags::operator=(const MQTT__v3__1__1__ConnectFlags& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
  if (other_value.user__name__flag().is_bound()) field_user__name__flag = other_value.user__name__flag();
  else field_user__name__flag.clean_up();
  if (other_value.password__flag().is_bound()) field_password__flag = other_value.password__flag();
  else field_password__flag.clean_up();
  if (other_value.will__retain().is_bound()) field_will__retain = other_value.will__retain();
  else field_will__retain.clean_up();
  if (other_value.will__qos().is_bound()) field_will__qos = other_value.will__qos();
  else field_will__qos.clean_up();
  if (other_value.will__flag().is_bound()) field_will__flag = other_value.will__flag();
  else field_will__flag.clean_up();
  if (other_value.clean__session().is_bound()) field_clean__session = other_value.clean__session();
  else field_clean__session.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__ConnectFlags::operator==(const MQTT__v3__1__1__ConnectFlags& other_value) const
{
return field_user__name__flag==other_value.field_user__name__flag
  && field_password__flag==other_value.field_password__flag
  && field_will__retain==other_value.field_will__retain
  && field_will__qos==other_value.field_will__qos
  && field_will__flag==other_value.field_will__flag
  && field_clean__session==other_value.field_clean__session;
}

boolean MQTT__v3__1__1__ConnectFlags::is_bound() const
{
if(field_user__name__flag.is_bound()) return TRUE;
if(field_password__flag.is_bound()) return TRUE;
if(field_will__retain.is_bound()) return TRUE;
if(field_will__qos.is_bound()) return TRUE;
if(field_will__flag.is_bound()) return TRUE;
if(field_clean__session.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__ConnectFlags::is_value() const
{
if(!field_user__name__flag.is_value()) return FALSE;
if(!field_password__flag.is_value()) return FALSE;
if(!field_will__retain.is_value()) return FALSE;
if(!field_will__qos.is_value()) return FALSE;
if(!field_will__flag.is_value()) return FALSE;
if(!field_clean__session.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__ConnectFlags::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ user_name_flag := ");
field_user__name__flag.log();
TTCN_Logger::log_event_str(", password_flag := ");
field_password__flag.log();
TTCN_Logger::log_event_str(", will_retain := ");
field_will__retain.log();
TTCN_Logger::log_event_str(", will_qos := ");
field_will__qos.log();
TTCN_Logger::log_event_str(", will_flag := ");
field_will__flag.log();
TTCN_Logger::log_event_str(", clean_session := ");
field_clean__session.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__ConnectFlags::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) user__name__flag().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) password__flag().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) will__retain().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) will__qos().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) will__flag().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) clean__session().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_name_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__name__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "password_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          password__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_retain")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__retain().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_qos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__qos().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clean_session")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clean__session().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
  }
}

void MQTT__v3__1__1__ConnectFlags::set_implicit_omit()
{
if (user__name__flag().is_bound()) user__name__flag().set_implicit_omit();
if (password__flag().is_bound()) password__flag().set_implicit_omit();
if (will__retain().is_bound()) will__retain().set_implicit_omit();
if (will__qos().is_bound()) will__qos().set_implicit_omit();
if (will__flag().is_bound()) will__flag().set_implicit_omit();
if (clean__session().is_bound()) clean__session().set_implicit_omit();
}

void MQTT__v3__1__1__ConnectFlags::encode_text(Text_Buf& text_buf) const
{
field_user__name__flag.encode_text(text_buf);
field_password__flag.encode_text(text_buf);
field_will__retain.encode_text(text_buf);
field_will__qos.encode_text(text_buf);
field_will__flag.encode_text(text_buf);
field_clean__session.encode_text(text_buf);
}

void MQTT__v3__1__1__ConnectFlags::decode_text(Text_Buf& text_buf)
{
field_user__name__flag.decode_text(text_buf);
field_password__flag.decode_text(text_buf);
field_will__retain.decode_text(text_buf);
field_will__qos.decode_text(text_buf);
field_will__flag.decode_text(text_buf);
field_clean__session.decode_text(text_buf);
}

struct MQTT__v3__1__1__ConnectFlags_template::single_value_struct {
BITSTRING_template field_user__name__flag;
BITSTRING_template field_password__flag;
BITSTRING_template field_will__retain;
QoS_template field_will__qos;
BITSTRING_template field_will__flag;
BITSTRING_template field_clean__session;
};

void MQTT__v3__1__1__ConnectFlags_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_user__name__flag = ANY_VALUE;
single_value->field_password__flag = ANY_VALUE;
single_value->field_will__retain = ANY_VALUE;
single_value->field_will__qos = ANY_VALUE;
single_value->field_will__flag = ANY_VALUE;
single_value->field_clean__session = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__ConnectFlags_template::copy_value(const MQTT__v3__1__1__ConnectFlags& other_value)
{
single_value = new single_value_struct;
if (other_value.user__name__flag().is_bound()) {
  single_value->field_user__name__flag = other_value.user__name__flag();
} else {
  single_value->field_user__name__flag.clean_up();
}
if (other_value.password__flag().is_bound()) {
  single_value->field_password__flag = other_value.password__flag();
} else {
  single_value->field_password__flag.clean_up();
}
if (other_value.will__retain().is_bound()) {
  single_value->field_will__retain = other_value.will__retain();
} else {
  single_value->field_will__retain.clean_up();
}
if (other_value.will__qos().is_bound()) {
  single_value->field_will__qos = other_value.will__qos();
} else {
  single_value->field_will__qos.clean_up();
}
if (other_value.will__flag().is_bound()) {
  single_value->field_will__flag = other_value.will__flag();
} else {
  single_value->field_will__flag.clean_up();
}
if (other_value.clean__session().is_bound()) {
  single_value->field_clean__session = other_value.clean__session();
} else {
  single_value->field_clean__session.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__ConnectFlags_template::copy_template(const MQTT__v3__1__1__ConnectFlags_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.user__name__flag().get_selection()) {
single_value->field_user__name__flag = other_value.user__name__flag();
} else {
single_value->field_user__name__flag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.password__flag().get_selection()) {
single_value->field_password__flag = other_value.password__flag();
} else {
single_value->field_password__flag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.will__retain().get_selection()) {
single_value->field_will__retain = other_value.will__retain();
} else {
single_value->field_will__retain.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.will__qos().get_selection()) {
single_value->field_will__qos = other_value.will__qos();
} else {
single_value->field_will__qos.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.will__flag().get_selection()) {
single_value->field_will__flag = other_value.will__flag();
} else {
single_value->field_will__flag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.clean__session().get_selection()) {
single_value->field_clean__session = other_value.clean__session();
} else {
single_value->field_clean__session.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__ConnectFlags_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__ConnectFlags_template::MQTT__v3__1__1__ConnectFlags_template()
{
}

MQTT__v3__1__1__ConnectFlags_template::MQTT__v3__1__1__ConnectFlags_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__ConnectFlags_template::MQTT__v3__1__1__ConnectFlags_template(const MQTT__v3__1__1__ConnectFlags& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__ConnectFlags_template::MQTT__v3__1__1__ConnectFlags_template(const OPTIONAL<MQTT__v3__1__1__ConnectFlags>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ConnectFlags&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags from an unbound optional field.");
}
}

MQTT__v3__1__1__ConnectFlags_template::MQTT__v3__1__1__ConnectFlags_template(const MQTT__v3__1__1__ConnectFlags_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__ConnectFlags_template::~MQTT__v3__1__1__ConnectFlags_template()
{
clean_up();
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__ConnectFlags_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__ConnectFlags_template::operator=(const MQTT__v3__1__1__ConnectFlags& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__ConnectFlags_template::operator=(const OPTIONAL<MQTT__v3__1__1__ConnectFlags>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ConnectFlags&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
}
return *this;
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__ConnectFlags_template::operator=(const MQTT__v3__1__1__ConnectFlags_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__ConnectFlags_template::match(const MQTT__v3__1__1__ConnectFlags& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.user__name__flag().is_bound()) return FALSE;
if(!single_value->field_user__name__flag.match(other_value.user__name__flag(), legacy))return FALSE;
if(!other_value.password__flag().is_bound()) return FALSE;
if(!single_value->field_password__flag.match(other_value.password__flag(), legacy))return FALSE;
if(!other_value.will__retain().is_bound()) return FALSE;
if(!single_value->field_will__retain.match(other_value.will__retain(), legacy))return FALSE;
if(!other_value.will__qos().is_bound()) return FALSE;
if(!single_value->field_will__qos.match(other_value.will__qos(), legacy))return FALSE;
if(!other_value.will__flag().is_bound()) return FALSE;
if(!single_value->field_will__flag.match(other_value.will__flag(), legacy))return FALSE;
if(!other_value.clean__session().is_bound()) return FALSE;
if(!single_value->field_clean__session.match(other_value.clean__session(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
}
return FALSE;
}

boolean MQTT__v3__1__1__ConnectFlags_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_user__name__flag.is_bound()) return TRUE;
if (single_value->field_password__flag.is_bound()) return TRUE;
if (single_value->field_will__retain.is_bound()) return TRUE;
if (single_value->field_will__qos.is_bound()) return TRUE;
if (single_value->field_will__flag.is_bound()) return TRUE;
if (single_value->field_clean__session.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__ConnectFlags_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_user__name__flag.is_value()) return FALSE;
if (!single_value->field_password__flag.is_value()) return FALSE;
if (!single_value->field_will__retain.is_value()) return FALSE;
if (!single_value->field_will__qos.is_value()) return FALSE;
if (!single_value->field_will__flag.is_value()) return FALSE;
if (!single_value->field_clean__session.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__ConnectFlags_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__ConnectFlags MQTT__v3__1__1__ConnectFlags_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
MQTT__v3__1__1__ConnectFlags ret_val;
if (single_value->field_user__name__flag.is_bound()) {
ret_val.user__name__flag() = single_value->field_user__name__flag.valueof();
}
if (single_value->field_password__flag.is_bound()) {
ret_val.password__flag() = single_value->field_password__flag.valueof();
}
if (single_value->field_will__retain.is_bound()) {
ret_val.will__retain() = single_value->field_will__retain.valueof();
}
if (single_value->field_will__qos.is_bound()) {
ret_val.will__qos() = single_value->field_will__qos.valueof();
}
if (single_value->field_will__flag.is_bound()) {
ret_val.will__flag() = single_value->field_will__flag.valueof();
}
if (single_value->field_clean__session.is_bound()) {
ret_val.clean__session() = single_value->field_clean__session.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__ConnectFlags_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__ConnectFlags_template[list_length];
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__ConnectFlags_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return value_list.list_value[list_index];
}

BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::user__name__flag()
{
set_specific();
return single_value->field_user__name__flag;
}

const BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::user__name__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field user_name_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_user__name__flag;
}

BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::password__flag()
{
set_specific();
return single_value->field_password__flag;
}

const BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::password__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field password_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_password__flag;
}

BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::will__retain()
{
set_specific();
return single_value->field_will__retain;
}

const BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::will__retain() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field will_retain of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_will__retain;
}

QoS_template& MQTT__v3__1__1__ConnectFlags_template::will__qos()
{
set_specific();
return single_value->field_will__qos;
}

const QoS_template& MQTT__v3__1__1__ConnectFlags_template::will__qos() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field will_qos of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_will__qos;
}

BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::will__flag()
{
set_specific();
return single_value->field_will__flag;
}

const BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::will__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field will_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_will__flag;
}

BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::clean__session()
{
set_specific();
return single_value->field_clean__session;
}

const BITSTRING_template& MQTT__v3__1__1__ConnectFlags_template::clean__session() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clean_session of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
return single_value->field_clean__session;
}

int MQTT__v3__1__1__ConnectFlags_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
  }
  return 0;
}

void MQTT__v3__1__1__ConnectFlags_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ user_name_flag := ");
single_value->field_user__name__flag.log();
TTCN_Logger::log_event_str(", password_flag := ");
single_value->field_password__flag.log();
TTCN_Logger::log_event_str(", will_retain := ");
single_value->field_will__retain.log();
TTCN_Logger::log_event_str(", will_qos := ");
single_value->field_will__qos.log();
TTCN_Logger::log_event_str(", will_flag := ");
single_value->field_will__flag.log();
TTCN_Logger::log_event_str(", clean_session := ");
single_value->field_clean__session.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__ConnectFlags_template::log_match(const MQTT__v3__1__1__ConnectFlags& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_user__name__flag.match(match_value.user__name__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".user_name_flag");
single_value->field_user__name__flag.log_match(match_value.user__name__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_password__flag.match(match_value.password__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".password_flag");
single_value->field_password__flag.log_match(match_value.password__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_will__retain.match(match_value.will__retain(), legacy)){
TTCN_Logger::log_logmatch_info(".will_retain");
single_value->field_will__retain.log_match(match_value.will__retain(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_will__qos.match(match_value.will__qos(), legacy)){
TTCN_Logger::log_logmatch_info(".will_qos");
single_value->field_will__qos.log_match(match_value.will__qos(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_will__flag.match(match_value.will__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".will_flag");
single_value->field_will__flag.log_match(match_value.will__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_clean__session.match(match_value.clean__session(), legacy)){
TTCN_Logger::log_logmatch_info(".clean_session");
single_value->field_clean__session.log_match(match_value.clean__session(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ user_name_flag := ");
single_value->field_user__name__flag.log_match(match_value.user__name__flag(), legacy);
TTCN_Logger::log_event_str(", password_flag := ");
single_value->field_password__flag.log_match(match_value.password__flag(), legacy);
TTCN_Logger::log_event_str(", will_retain := ");
single_value->field_will__retain.log_match(match_value.will__retain(), legacy);
TTCN_Logger::log_event_str(", will_qos := ");
single_value->field_will__qos.log_match(match_value.will__qos(), legacy);
TTCN_Logger::log_event_str(", will_flag := ");
single_value->field_will__flag.log_match(match_value.will__flag(), legacy);
TTCN_Logger::log_event_str(", clean_session := ");
single_value->field_clean__session.log_match(match_value.clean__session(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__ConnectFlags_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_user__name__flag.encode_text(text_buf);
single_value->field_password__flag.encode_text(text_buf);
single_value->field_will__retain.encode_text(text_buf);
single_value->field_will__qos.encode_text(text_buf);
single_value->field_will__flag.encode_text(text_buf);
single_value->field_clean__session.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
}
}

void MQTT__v3__1__1__ConnectFlags_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_user__name__flag.decode_text(text_buf);
single_value->field_password__flag.decode_text(text_buf);
single_value->field_will__retain.decode_text(text_buf);
single_value->field_will__qos.decode_text(text_buf);
single_value->field_will__flag.decode_text(text_buf);
single_value->field_clean__session.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__ConnectFlags_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags.");
}
}

void MQTT__v3__1__1__ConnectFlags_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__ConnectFlags_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) user__name__flag().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) password__flag().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) will__retain().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) will__qos().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) will__flag().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) clean__session().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_name_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__name__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "password_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          password__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_retain")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__retain().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_qos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__qos().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clean_session")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clean__session().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__ConnectFlags_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_user__name__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
single_value->field_password__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
single_value->field_will__retain.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
single_value->field_will__qos.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
single_value->field_will__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
single_value->field_clean__session.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectFlags");
}

boolean MQTT__v3__1__1__ConnectFlags_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__ConnectFlags_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__ConnectPayload::MQTT__v3__1__1__ConnectPayload()
{
}

MQTT__v3__1__1__ConnectPayload::MQTT__v3__1__1__ConnectPayload(const UNIVERSAL_CHARSTRING& par_client__identifier,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_will__topic,
    const OPTIONAL<OCTETSTRING>& par_will__message,
    const OPTIONAL<UNIVERSAL_CHARSTRING>& par_user__name,
    const OPTIONAL<OCTETSTRING>& par_password)
  :   field_client__identifier(par_client__identifier),
  field_will__topic(par_will__topic),
  field_will__message(par_will__message),
  field_user__name(par_user__name),
  field_password(par_password)
{
}

MQTT__v3__1__1__ConnectPayload::MQTT__v3__1__1__ConnectPayload(const MQTT__v3__1__1__ConnectPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
if (other_value.client__identifier().is_bound()) field_client__identifier = other_value.client__identifier();
else field_client__identifier.clean_up();
if (other_value.will__topic().is_bound()) field_will__topic = other_value.will__topic();
else field_will__topic.clean_up();
if (other_value.will__message().is_bound()) field_will__message = other_value.will__message();
else field_will__message.clean_up();
if (other_value.user__name().is_bound()) field_user__name = other_value.user__name();
else field_user__name.clean_up();
if (other_value.password().is_bound()) field_password = other_value.password();
else field_password.clean_up();
}

void MQTT__v3__1__1__ConnectPayload::clean_up()
{
field_client__identifier.clean_up();
field_will__topic.clean_up();
field_will__message.clean_up();
field_user__name.clean_up();
field_password.clean_up();
}

MQTT__v3__1__1__ConnectPayload& MQTT__v3__1__1__ConnectPayload::operator=(const MQTT__v3__1__1__ConnectPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
  if (other_value.client__identifier().is_bound()) field_client__identifier = other_value.client__identifier();
  else field_client__identifier.clean_up();
  if (other_value.will__topic().is_bound()) field_will__topic = other_value.will__topic();
  else field_will__topic.clean_up();
  if (other_value.will__message().is_bound()) field_will__message = other_value.will__message();
  else field_will__message.clean_up();
  if (other_value.user__name().is_bound()) field_user__name = other_value.user__name();
  else field_user__name.clean_up();
  if (other_value.password().is_bound()) field_password = other_value.password();
  else field_password.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__ConnectPayload::operator==(const MQTT__v3__1__1__ConnectPayload& other_value) const
{
return field_client__identifier==other_value.field_client__identifier
  && field_will__topic==other_value.field_will__topic
  && field_will__message==other_value.field_will__message
  && field_user__name==other_value.field_user__name
  && field_password==other_value.field_password;
}

boolean MQTT__v3__1__1__ConnectPayload::is_bound() const
{
if(field_client__identifier.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_will__topic.get_selection() || field_will__topic.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_will__message.get_selection() || field_will__message.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_user__name.get_selection() || field_user__name.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_password.get_selection() || field_password.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__ConnectPayload::is_value() const
{
if(!field_client__identifier.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_will__topic.get_selection() && !field_will__topic.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_will__message.get_selection() && !field_will__message.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_user__name.get_selection() && !field_user__name.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_password.get_selection() && !field_password.is_value()) return FALSE;
return TRUE;
}
int MQTT__v3__1__1__ConnectPayload::size_of() const
{
  int ret_val = 1;
  if (field_will__topic.ispresent()) ret_val++;
  if (field_will__message.ispresent()) ret_val++;
  if (field_user__name.ispresent()) ret_val++;
  if (field_password.ispresent()) ret_val++;
  return ret_val;
}

void MQTT__v3__1__1__ConnectPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ client_identifier := ");
field_client__identifier.log();
TTCN_Logger::log_event_str(", will_topic := ");
field_will__topic.log();
TTCN_Logger::log_event_str(", will_message := ");
field_will__message.log();
TTCN_Logger::log_event_str(", user_name := ");
field_user__name.log();
TTCN_Logger::log_event_str(", password := ");
field_password.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__ConnectPayload::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__identifier().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) will__topic().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) will__message().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) user__name().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) password().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_topic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__topic().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_message")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__message().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "password")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          password().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
  }
}

void MQTT__v3__1__1__ConnectPayload::set_implicit_omit()
{
if (client__identifier().is_bound()) client__identifier().set_implicit_omit();
if (!will__topic().is_bound()) will__topic() = OMIT_VALUE;
else will__topic().set_implicit_omit();
if (!will__message().is_bound()) will__message() = OMIT_VALUE;
else will__message().set_implicit_omit();
if (!user__name().is_bound()) user__name() = OMIT_VALUE;
else user__name().set_implicit_omit();
if (!password().is_bound()) password() = OMIT_VALUE;
else password().set_implicit_omit();
}

void MQTT__v3__1__1__ConnectPayload::encode_text(Text_Buf& text_buf) const
{
field_client__identifier.encode_text(text_buf);
field_will__topic.encode_text(text_buf);
field_will__message.encode_text(text_buf);
field_user__name.encode_text(text_buf);
field_password.encode_text(text_buf);
}

void MQTT__v3__1__1__ConnectPayload::decode_text(Text_Buf& text_buf)
{
field_client__identifier.decode_text(text_buf);
field_will__topic.decode_text(text_buf);
field_will__message.decode_text(text_buf);
field_user__name.decode_text(text_buf);
field_password.decode_text(text_buf);
}

struct MQTT__v3__1__1__ConnectPayload_template::single_value_struct {
UNIVERSAL_CHARSTRING_template field_client__identifier;
UNIVERSAL_CHARSTRING_template field_will__topic;
OCTETSTRING_template field_will__message;
UNIVERSAL_CHARSTRING_template field_user__name;
OCTETSTRING_template field_password;
};

void MQTT__v3__1__1__ConnectPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_client__identifier = ANY_VALUE;
single_value->field_will__topic = ANY_OR_OMIT;
single_value->field_will__message = ANY_OR_OMIT;
single_value->field_user__name = ANY_OR_OMIT;
single_value->field_password = ANY_OR_OMIT;
}
}
}

void MQTT__v3__1__1__ConnectPayload_template::copy_value(const MQTT__v3__1__1__ConnectPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.client__identifier().is_bound()) {
  single_value->field_client__identifier = other_value.client__identifier();
} else {
  single_value->field_client__identifier.clean_up();
}
if (other_value.will__topic().is_bound()) {
  if (other_value.will__topic().ispresent()) single_value->field_will__topic = other_value.will__topic()();
  else single_value->field_will__topic = OMIT_VALUE;
} else {
  single_value->field_will__topic.clean_up();
}
if (other_value.will__message().is_bound()) {
  if (other_value.will__message().ispresent()) single_value->field_will__message = other_value.will__message()();
  else single_value->field_will__message = OMIT_VALUE;
} else {
  single_value->field_will__message.clean_up();
}
if (other_value.user__name().is_bound()) {
  if (other_value.user__name().ispresent()) single_value->field_user__name = other_value.user__name()();
  else single_value->field_user__name = OMIT_VALUE;
} else {
  single_value->field_user__name.clean_up();
}
if (other_value.password().is_bound()) {
  if (other_value.password().ispresent()) single_value->field_password = other_value.password()();
  else single_value->field_password = OMIT_VALUE;
} else {
  single_value->field_password.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__ConnectPayload_template::copy_template(const MQTT__v3__1__1__ConnectPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.client__identifier().get_selection()) {
single_value->field_client__identifier = other_value.client__identifier();
} else {
single_value->field_client__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.will__topic().get_selection()) {
single_value->field_will__topic = other_value.will__topic();
} else {
single_value->field_will__topic.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.will__message().get_selection()) {
single_value->field_will__message = other_value.will__message();
} else {
single_value->field_will__message.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.user__name().get_selection()) {
single_value->field_user__name = other_value.user__name();
} else {
single_value->field_user__name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.password().get_selection()) {
single_value->field_password = other_value.password();
} else {
single_value->field_password.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__ConnectPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__ConnectPayload_template::MQTT__v3__1__1__ConnectPayload_template()
{
}

MQTT__v3__1__1__ConnectPayload_template::MQTT__v3__1__1__ConnectPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__ConnectPayload_template::MQTT__v3__1__1__ConnectPayload_template(const MQTT__v3__1__1__ConnectPayload& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__ConnectPayload_template::MQTT__v3__1__1__ConnectPayload_template(const OPTIONAL<MQTT__v3__1__1__ConnectPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ConnectPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload from an unbound optional field.");
}
}

MQTT__v3__1__1__ConnectPayload_template::MQTT__v3__1__1__ConnectPayload_template(const MQTT__v3__1__1__ConnectPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__ConnectPayload_template::~MQTT__v3__1__1__ConnectPayload_template()
{
clean_up();
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__ConnectPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__ConnectPayload_template::operator=(const MQTT__v3__1__1__ConnectPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__ConnectPayload_template::operator=(const OPTIONAL<MQTT__v3__1__1__ConnectPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ConnectPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
}
return *this;
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__ConnectPayload_template::operator=(const MQTT__v3__1__1__ConnectPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__ConnectPayload_template::match(const MQTT__v3__1__1__ConnectPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.client__identifier().is_bound()) return FALSE;
if(!single_value->field_client__identifier.match(other_value.client__identifier(), legacy))return FALSE;
if(!other_value.will__topic().is_bound()) return FALSE;
if((other_value.will__topic().ispresent() ? !single_value->field_will__topic.match((const UNIVERSAL_CHARSTRING&)other_value.will__topic(), legacy) : !single_value->field_will__topic.match_omit(legacy)))return FALSE;
if(!other_value.will__message().is_bound()) return FALSE;
if((other_value.will__message().ispresent() ? !single_value->field_will__message.match((const OCTETSTRING&)other_value.will__message(), legacy) : !single_value->field_will__message.match_omit(legacy)))return FALSE;
if(!other_value.user__name().is_bound()) return FALSE;
if((other_value.user__name().ispresent() ? !single_value->field_user__name.match((const UNIVERSAL_CHARSTRING&)other_value.user__name(), legacy) : !single_value->field_user__name.match_omit(legacy)))return FALSE;
if(!other_value.password().is_bound()) return FALSE;
if((other_value.password().ispresent() ? !single_value->field_password.match((const OCTETSTRING&)other_value.password(), legacy) : !single_value->field_password.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
}
return FALSE;
}

boolean MQTT__v3__1__1__ConnectPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_client__identifier.is_bound()) return TRUE;
if (single_value->field_will__topic.is_omit() || single_value->field_will__topic.is_bound()) return TRUE;
if (single_value->field_will__message.is_omit() || single_value->field_will__message.is_bound()) return TRUE;
if (single_value->field_user__name.is_omit() || single_value->field_user__name.is_bound()) return TRUE;
if (single_value->field_password.is_omit() || single_value->field_password.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__ConnectPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_client__identifier.is_value()) return FALSE;
if (!single_value->field_will__topic.is_omit() && !single_value->field_will__topic.is_value()) return FALSE;
if (!single_value->field_will__message.is_omit() && !single_value->field_will__message.is_value()) return FALSE;
if (!single_value->field_user__name.is_omit() && !single_value->field_user__name.is_value()) return FALSE;
if (!single_value->field_password.is_omit() && !single_value->field_password.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__ConnectPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__ConnectPayload MQTT__v3__1__1__ConnectPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
MQTT__v3__1__1__ConnectPayload ret_val;
if (single_value->field_client__identifier.is_bound()) {
ret_val.client__identifier() = single_value->field_client__identifier.valueof();
}
if (single_value->field_will__topic.is_omit()) ret_val.will__topic() = OMIT_VALUE;
else if (single_value->field_will__topic.is_bound()) {
ret_val.will__topic() = single_value->field_will__topic.valueof();
}
if (single_value->field_will__message.is_omit()) ret_val.will__message() = OMIT_VALUE;
else if (single_value->field_will__message.is_bound()) {
ret_val.will__message() = single_value->field_will__message.valueof();
}
if (single_value->field_user__name.is_omit()) ret_val.user__name() = OMIT_VALUE;
else if (single_value->field_user__name.is_bound()) {
ret_val.user__name() = single_value->field_user__name.valueof();
}
if (single_value->field_password.is_omit()) ret_val.password() = OMIT_VALUE;
else if (single_value->field_password.is_bound()) {
ret_val.password() = single_value->field_password.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__ConnectPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__ConnectPayload_template[list_length];
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__ConnectPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return value_list.list_value[list_index];
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::client__identifier()
{
set_specific();
return single_value->field_client__identifier;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::client__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field client_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return single_value->field_client__identifier;
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::will__topic()
{
set_specific();
return single_value->field_will__topic;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::will__topic() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field will_topic of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return single_value->field_will__topic;
}

OCTETSTRING_template& MQTT__v3__1__1__ConnectPayload_template::will__message()
{
set_specific();
return single_value->field_will__message;
}

const OCTETSTRING_template& MQTT__v3__1__1__ConnectPayload_template::will__message() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field will_message of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return single_value->field_will__message;
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::user__name()
{
set_specific();
return single_value->field_user__name;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__ConnectPayload_template::user__name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field user_name of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return single_value->field_user__name;
}

OCTETSTRING_template& MQTT__v3__1__1__ConnectPayload_template::password()
{
set_specific();
return single_value->field_password;
}

const OCTETSTRING_template& MQTT__v3__1__1__ConnectPayload_template::password() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field password of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
return single_value->field_password;
}

int MQTT__v3__1__1__ConnectPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_will__topic.is_present()) ret_val++;
      if (single_value->field_will__message.is_present()) ret_val++;
      if (single_value->field_user__name.is_present()) ret_val++;
      if (single_value->field_password.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
  }
  return 0;
}

void MQTT__v3__1__1__ConnectPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ client_identifier := ");
single_value->field_client__identifier.log();
TTCN_Logger::log_event_str(", will_topic := ");
single_value->field_will__topic.log();
TTCN_Logger::log_event_str(", will_message := ");
single_value->field_will__message.log();
TTCN_Logger::log_event_str(", user_name := ");
single_value->field_user__name.log();
TTCN_Logger::log_event_str(", password := ");
single_value->field_password.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__ConnectPayload_template::log_match(const MQTT__v3__1__1__ConnectPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_client__identifier.match(match_value.client__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".client_identifier");
single_value->field_client__identifier.log_match(match_value.client__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.will__topic().ispresent()){
if(!single_value->field_will__topic.match(match_value.will__topic(), legacy)){
TTCN_Logger::log_logmatch_info(".will_topic");
single_value->field_will__topic.log_match(match_value.will__topic(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_will__topic.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".will_topic := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_will__topic.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.will__message().ispresent()){
if(!single_value->field_will__message.match(match_value.will__message(), legacy)){
TTCN_Logger::log_logmatch_info(".will_message");
single_value->field_will__message.log_match(match_value.will__message(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_will__message.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".will_message := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_will__message.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.user__name().ispresent()){
if(!single_value->field_user__name.match(match_value.user__name(), legacy)){
TTCN_Logger::log_logmatch_info(".user_name");
single_value->field_user__name.log_match(match_value.user__name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_user__name.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".user_name := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_user__name.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.password().ispresent()){
if(!single_value->field_password.match(match_value.password(), legacy)){
TTCN_Logger::log_logmatch_info(".password");
single_value->field_password.log_match(match_value.password(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_password.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".password := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_password.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ client_identifier := ");
single_value->field_client__identifier.log_match(match_value.client__identifier(), legacy);
TTCN_Logger::log_event_str(", will_topic := ");
if (match_value.will__topic().ispresent()) single_value->field_will__topic.log_match(match_value.will__topic(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_will__topic.log();
if (single_value->field_will__topic.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", will_message := ");
if (match_value.will__message().ispresent()) single_value->field_will__message.log_match(match_value.will__message(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_will__message.log();
if (single_value->field_will__message.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", user_name := ");
if (match_value.user__name().ispresent()) single_value->field_user__name.log_match(match_value.user__name(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_user__name.log();
if (single_value->field_user__name.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", password := ");
if (match_value.password().ispresent()) single_value->field_password.log_match(match_value.password(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_password.log();
if (single_value->field_password.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__ConnectPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_client__identifier.encode_text(text_buf);
single_value->field_will__topic.encode_text(text_buf);
single_value->field_will__message.encode_text(text_buf);
single_value->field_user__name.encode_text(text_buf);
single_value->field_password.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
}
}

void MQTT__v3__1__1__ConnectPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_client__identifier.decode_text(text_buf);
single_value->field_will__topic.decode_text(text_buf);
single_value->field_will__message.decode_text(text_buf);
single_value->field_user__name.decode_text(text_buf);
single_value->field_password.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__ConnectPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload.");
}
}

void MQTT__v3__1__1__ConnectPayload_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__ConnectPayload_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) client__identifier().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) will__topic().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) will__message().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) user__name().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) password().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "client_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          client__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_topic")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__topic().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "will_message")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          will__message().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "user_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          user__name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "password")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          password().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__ConnectPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_client__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
single_value->field_will__topic.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
single_value->field_will__message.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
single_value->field_user__name.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
single_value->field_password.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ConnectPayload");
}

boolean MQTT__v3__1__1__ConnectPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__ConnectPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Connect::MQTT__v3__1__1__Connect()
{
}

MQTT__v3__1__1__Connect::MQTT__v3__1__1__Connect(const Header& par_header,
    const UNIVERSAL_CHARSTRING& par_name,
    const INTEGER& par_protocol__level,
    const MQTT__v3__1__1__ConnectFlags& par_flags,
    const INTEGER& par_keep__alive,
    const MQTT__v3__1__1__ConnectPayload& par_payload)
  :   field_header(par_header),
  field_name(par_name),
  field_protocol__level(par_protocol__level),
  field_flags(par_flags),
  field_keep__alive(par_keep__alive),
  field_payload(par_payload)
{
}

MQTT__v3__1__1__Connect::MQTT__v3__1__1__Connect(const MQTT__v3__1__1__Connect& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.name().is_bound()) field_name = other_value.name();
else field_name.clean_up();
if (other_value.protocol__level().is_bound()) field_protocol__level = other_value.protocol__level();
else field_protocol__level.clean_up();
if (other_value.flags().is_bound()) field_flags = other_value.flags();
else field_flags.clean_up();
if (other_value.keep__alive().is_bound()) field_keep__alive = other_value.keep__alive();
else field_keep__alive.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void MQTT__v3__1__1__Connect::clean_up()
{
field_header.clean_up();
field_name.clean_up();
field_protocol__level.clean_up();
field_flags.clean_up();
field_keep__alive.clean_up();
field_payload.clean_up();
}

MQTT__v3__1__1__Connect& MQTT__v3__1__1__Connect::operator=(const MQTT__v3__1__1__Connect& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.name().is_bound()) field_name = other_value.name();
  else field_name.clean_up();
  if (other_value.protocol__level().is_bound()) field_protocol__level = other_value.protocol__level();
  else field_protocol__level.clean_up();
  if (other_value.flags().is_bound()) field_flags = other_value.flags();
  else field_flags.clean_up();
  if (other_value.keep__alive().is_bound()) field_keep__alive = other_value.keep__alive();
  else field_keep__alive.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Connect::operator==(const MQTT__v3__1__1__Connect& other_value) const
{
return field_header==other_value.field_header
  && field_name==other_value.field_name
  && field_protocol__level==other_value.field_protocol__level
  && field_flags==other_value.field_flags
  && field_keep__alive==other_value.field_keep__alive
  && field_payload==other_value.field_payload;
}

boolean MQTT__v3__1__1__Connect::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_name.is_bound()) return TRUE;
if(field_protocol__level.is_bound()) return TRUE;
if(field_flags.is_bound()) return TRUE;
if(field_keep__alive.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Connect::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_name.is_value()) return FALSE;
if(!field_protocol__level.is_value()) return FALSE;
if(!field_flags.is_value()) return FALSE;
if(!field_keep__alive.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Connect::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", name := ");
field_name.log();
TTCN_Logger::log_event_str(", protocol_level := ");
field_protocol__level.log();
TTCN_Logger::log_event_str(", flags := ");
field_flags.log();
TTCN_Logger::log_event_str(", keep_alive := ");
field_keep__alive.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Connect::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) protocol__level().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) keep__alive().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_level")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__level().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "keep_alive")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          keep__alive().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
  }
}

void MQTT__v3__1__1__Connect::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (name().is_bound()) name().set_implicit_omit();
if (protocol__level().is_bound()) protocol__level().set_implicit_omit();
if (flags().is_bound()) flags().set_implicit_omit();
if (keep__alive().is_bound()) keep__alive().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void MQTT__v3__1__1__Connect::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_name.encode_text(text_buf);
field_protocol__level.encode_text(text_buf);
field_flags.encode_text(text_buf);
field_keep__alive.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void MQTT__v3__1__1__Connect::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_name.decode_text(text_buf);
field_protocol__level.decode_text(text_buf);
field_flags.decode_text(text_buf);
field_keep__alive.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct MQTT__v3__1__1__Connect_template::single_value_struct {
Header_template field_header;
UNIVERSAL_CHARSTRING_template field_name;
INTEGER_template field_protocol__level;
MQTT__v3__1__1__ConnectFlags_template field_flags;
INTEGER_template field_keep__alive;
MQTT__v3__1__1__ConnectPayload_template field_payload;
};

void MQTT__v3__1__1__Connect_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_name = ANY_VALUE;
single_value->field_protocol__level = ANY_VALUE;
single_value->field_flags = ANY_VALUE;
single_value->field_keep__alive = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Connect_template::copy_value(const MQTT__v3__1__1__Connect& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.name().is_bound()) {
  single_value->field_name = other_value.name();
} else {
  single_value->field_name.clean_up();
}
if (other_value.protocol__level().is_bound()) {
  single_value->field_protocol__level = other_value.protocol__level();
} else {
  single_value->field_protocol__level.clean_up();
}
if (other_value.flags().is_bound()) {
  single_value->field_flags = other_value.flags();
} else {
  single_value->field_flags.clean_up();
}
if (other_value.keep__alive().is_bound()) {
  single_value->field_keep__alive = other_value.keep__alive();
} else {
  single_value->field_keep__alive.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Connect_template::copy_template(const MQTT__v3__1__1__Connect_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.name().get_selection()) {
single_value->field_name = other_value.name();
} else {
single_value->field_name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.protocol__level().get_selection()) {
single_value->field_protocol__level = other_value.protocol__level();
} else {
single_value->field_protocol__level.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flags().get_selection()) {
single_value->field_flags = other_value.flags();
} else {
single_value->field_flags.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.keep__alive().get_selection()) {
single_value->field_keep__alive = other_value.keep__alive();
} else {
single_value->field_keep__alive.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Connect_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Connect_template::MQTT__v3__1__1__Connect_template()
{
}

MQTT__v3__1__1__Connect_template::MQTT__v3__1__1__Connect_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Connect_template::MQTT__v3__1__1__Connect_template(const MQTT__v3__1__1__Connect& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Connect_template::MQTT__v3__1__1__Connect_template(const OPTIONAL<MQTT__v3__1__1__Connect>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Connect&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect from an unbound optional field.");
}
}

MQTT__v3__1__1__Connect_template::MQTT__v3__1__1__Connect_template(const MQTT__v3__1__1__Connect_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Connect_template::~MQTT__v3__1__1__Connect_template()
{
clean_up();
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__Connect_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__Connect_template::operator=(const MQTT__v3__1__1__Connect& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__Connect_template::operator=(const OPTIONAL<MQTT__v3__1__1__Connect>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Connect&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
}
return *this;
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__Connect_template::operator=(const MQTT__v3__1__1__Connect_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Connect_template::match(const MQTT__v3__1__1__Connect& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.name().is_bound()) return FALSE;
if(!single_value->field_name.match(other_value.name(), legacy))return FALSE;
if(!other_value.protocol__level().is_bound()) return FALSE;
if(!single_value->field_protocol__level.match(other_value.protocol__level(), legacy))return FALSE;
if(!other_value.flags().is_bound()) return FALSE;
if(!single_value->field_flags.match(other_value.flags(), legacy))return FALSE;
if(!other_value.keep__alive().is_bound()) return FALSE;
if(!single_value->field_keep__alive.match(other_value.keep__alive(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Connect_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_name.is_bound()) return TRUE;
if (single_value->field_protocol__level.is_bound()) return TRUE;
if (single_value->field_flags.is_bound()) return TRUE;
if (single_value->field_keep__alive.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Connect_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_name.is_value()) return FALSE;
if (!single_value->field_protocol__level.is_value()) return FALSE;
if (!single_value->field_flags.is_value()) return FALSE;
if (!single_value->field_keep__alive.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Connect_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Connect MQTT__v3__1__1__Connect_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
MQTT__v3__1__1__Connect ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_name.is_bound()) {
ret_val.name() = single_value->field_name.valueof();
}
if (single_value->field_protocol__level.is_bound()) {
ret_val.protocol__level() = single_value->field_protocol__level.valueof();
}
if (single_value->field_flags.is_bound()) {
ret_val.flags() = single_value->field_flags.valueof();
}
if (single_value->field_keep__alive.is_bound()) {
ret_val.keep__alive() = single_value->field_keep__alive.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Connect_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Connect_template[list_length];
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__Connect_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Connect_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Connect_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_header;
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__Connect_template::name()
{
set_specific();
return single_value->field_name;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__Connect_template::name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field name of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_name;
}

INTEGER_template& MQTT__v3__1__1__Connect_template::protocol__level()
{
set_specific();
return single_value->field_protocol__level;
}

const INTEGER_template& MQTT__v3__1__1__Connect_template::protocol__level() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocol_level of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_protocol__level;
}

MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__Connect_template::flags()
{
set_specific();
return single_value->field_flags;
}

const MQTT__v3__1__1__ConnectFlags_template& MQTT__v3__1__1__Connect_template::flags() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flags of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_flags;
}

INTEGER_template& MQTT__v3__1__1__Connect_template::keep__alive()
{
set_specific();
return single_value->field_keep__alive;
}

const INTEGER_template& MQTT__v3__1__1__Connect_template::keep__alive() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field keep_alive of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_keep__alive;
}

MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__Connect_template::payload()
{
set_specific();
return single_value->field_payload;
}

const MQTT__v3__1__1__ConnectPayload_template& MQTT__v3__1__1__Connect_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
return single_value->field_payload;
}

int MQTT__v3__1__1__Connect_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
  }
  return 0;
}

void MQTT__v3__1__1__Connect_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", name := ");
single_value->field_name.log();
TTCN_Logger::log_event_str(", protocol_level := ");
single_value->field_protocol__level.log();
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log();
TTCN_Logger::log_event_str(", keep_alive := ");
single_value->field_keep__alive.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Connect_template::log_match(const MQTT__v3__1__1__Connect& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_name.match(match_value.name(), legacy)){
TTCN_Logger::log_logmatch_info(".name");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_protocol__level.match(match_value.protocol__level(), legacy)){
TTCN_Logger::log_logmatch_info(".protocol_level");
single_value->field_protocol__level.log_match(match_value.protocol__level(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flags.match(match_value.flags(), legacy)){
TTCN_Logger::log_logmatch_info(".flags");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_keep__alive.match(match_value.keep__alive(), legacy)){
TTCN_Logger::log_logmatch_info(".keep_alive");
single_value->field_keep__alive.log_match(match_value.keep__alive(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", name := ");
single_value->field_name.log_match(match_value.name(), legacy);
TTCN_Logger::log_event_str(", protocol_level := ");
single_value->field_protocol__level.log_match(match_value.protocol__level(), legacy);
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::log_event_str(", keep_alive := ");
single_value->field_keep__alive.log_match(match_value.keep__alive(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Connect_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_name.encode_text(text_buf);
single_value->field_protocol__level.encode_text(text_buf);
single_value->field_flags.encode_text(text_buf);
single_value->field_keep__alive.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
}
}

void MQTT__v3__1__1__Connect_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_name.decode_text(text_buf);
single_value->field_protocol__level.decode_text(text_buf);
single_value->field_flags.decode_text(text_buf);
single_value->field_keep__alive.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Connect_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect.");
}
}

void MQTT__v3__1__1__Connect_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Connect_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect has 6 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) name().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) protocol__level().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) keep__alive().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_level")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__level().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "keep_alive")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          keep__alive().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Connect_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
single_value->field_name.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
single_value->field_protocol__level.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
single_value->field_flags.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
single_value->field_keep__alive.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connect");
}

boolean MQTT__v3__1__1__Connect_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Connect_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Connack::MQTT__v3__1__1__Connack()
{
}

MQTT__v3__1__1__Connack::MQTT__v3__1__1__Connack(const Header& par_header,
    const BITSTRING& par_session__present__flag,
    const INTEGER& par_connect__return__code)
  :   field_header(par_header),
  field_session__present__flag(par_session__present__flag),
  field_connect__return__code(par_connect__return__code)
{
}

MQTT__v3__1__1__Connack::MQTT__v3__1__1__Connack(const MQTT__v3__1__1__Connack& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.session__present__flag().is_bound()) field_session__present__flag = other_value.session__present__flag();
else field_session__present__flag.clean_up();
if (other_value.connect__return__code().is_bound()) field_connect__return__code = other_value.connect__return__code();
else field_connect__return__code.clean_up();
}

void MQTT__v3__1__1__Connack::clean_up()
{
field_header.clean_up();
field_session__present__flag.clean_up();
field_connect__return__code.clean_up();
}

MQTT__v3__1__1__Connack& MQTT__v3__1__1__Connack::operator=(const MQTT__v3__1__1__Connack& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.session__present__flag().is_bound()) field_session__present__flag = other_value.session__present__flag();
  else field_session__present__flag.clean_up();
  if (other_value.connect__return__code().is_bound()) field_connect__return__code = other_value.connect__return__code();
  else field_connect__return__code.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Connack::operator==(const MQTT__v3__1__1__Connack& other_value) const
{
return field_header==other_value.field_header
  && field_session__present__flag==other_value.field_session__present__flag
  && field_connect__return__code==other_value.field_connect__return__code;
}

boolean MQTT__v3__1__1__Connack::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_session__present__flag.is_bound()) return TRUE;
if(field_connect__return__code.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Connack::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_session__present__flag.is_value()) return FALSE;
if(!field_connect__return__code.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Connack::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", session_present_flag := ");
field_session__present__flag.log();
TTCN_Logger::log_event_str(", connect_return_code := ");
field_connect__return__code.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Connack::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) session__present__flag().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) connect__return__code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "session_present_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          session__present__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connect_return_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connect__return__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
  }
}

void MQTT__v3__1__1__Connack::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (session__present__flag().is_bound()) session__present__flag().set_implicit_omit();
if (connect__return__code().is_bound()) connect__return__code().set_implicit_omit();
}

void MQTT__v3__1__1__Connack::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_session__present__flag.encode_text(text_buf);
field_connect__return__code.encode_text(text_buf);
}

void MQTT__v3__1__1__Connack::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_session__present__flag.decode_text(text_buf);
field_connect__return__code.decode_text(text_buf);
}

struct MQTT__v3__1__1__Connack_template::single_value_struct {
Header_template field_header;
BITSTRING_template field_session__present__flag;
INTEGER_template field_connect__return__code;
};

void MQTT__v3__1__1__Connack_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_session__present__flag = ANY_VALUE;
single_value->field_connect__return__code = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Connack_template::copy_value(const MQTT__v3__1__1__Connack& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.session__present__flag().is_bound()) {
  single_value->field_session__present__flag = other_value.session__present__flag();
} else {
  single_value->field_session__present__flag.clean_up();
}
if (other_value.connect__return__code().is_bound()) {
  single_value->field_connect__return__code = other_value.connect__return__code();
} else {
  single_value->field_connect__return__code.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Connack_template::copy_template(const MQTT__v3__1__1__Connack_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.session__present__flag().get_selection()) {
single_value->field_session__present__flag = other_value.session__present__flag();
} else {
single_value->field_session__present__flag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connect__return__code().get_selection()) {
single_value->field_connect__return__code = other_value.connect__return__code();
} else {
single_value->field_connect__return__code.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Connack_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Connack_template::MQTT__v3__1__1__Connack_template()
{
}

MQTT__v3__1__1__Connack_template::MQTT__v3__1__1__Connack_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Connack_template::MQTT__v3__1__1__Connack_template(const MQTT__v3__1__1__Connack& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Connack_template::MQTT__v3__1__1__Connack_template(const OPTIONAL<MQTT__v3__1__1__Connack>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Connack&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack from an unbound optional field.");
}
}

MQTT__v3__1__1__Connack_template::MQTT__v3__1__1__Connack_template(const MQTT__v3__1__1__Connack_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Connack_template::~MQTT__v3__1__1__Connack_template()
{
clean_up();
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__Connack_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__Connack_template::operator=(const MQTT__v3__1__1__Connack& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__Connack_template::operator=(const OPTIONAL<MQTT__v3__1__1__Connack>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Connack&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
}
return *this;
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__Connack_template::operator=(const MQTT__v3__1__1__Connack_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Connack_template::match(const MQTT__v3__1__1__Connack& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.session__present__flag().is_bound()) return FALSE;
if(!single_value->field_session__present__flag.match(other_value.session__present__flag(), legacy))return FALSE;
if(!other_value.connect__return__code().is_bound()) return FALSE;
if(!single_value->field_connect__return__code.match(other_value.connect__return__code(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Connack_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_session__present__flag.is_bound()) return TRUE;
if (single_value->field_connect__return__code.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Connack_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_session__present__flag.is_value()) return FALSE;
if (!single_value->field_connect__return__code.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Connack_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Connack MQTT__v3__1__1__Connack_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
MQTT__v3__1__1__Connack ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_session__present__flag.is_bound()) {
ret_val.session__present__flag() = single_value->field_session__present__flag.valueof();
}
if (single_value->field_connect__return__code.is_bound()) {
ret_val.connect__return__code() = single_value->field_connect__return__code.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Connack_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Connack_template[list_length];
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__Connack_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Connack_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Connack_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
return single_value->field_header;
}

BITSTRING_template& MQTT__v3__1__1__Connack_template::session__present__flag()
{
set_specific();
return single_value->field_session__present__flag;
}

const BITSTRING_template& MQTT__v3__1__1__Connack_template::session__present__flag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field session_present_flag of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
return single_value->field_session__present__flag;
}

INTEGER_template& MQTT__v3__1__1__Connack_template::connect__return__code()
{
set_specific();
return single_value->field_connect__return__code;
}

const INTEGER_template& MQTT__v3__1__1__Connack_template::connect__return__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connect_return_code of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
return single_value->field_connect__return__code;
}

int MQTT__v3__1__1__Connack_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
  }
  return 0;
}

void MQTT__v3__1__1__Connack_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", session_present_flag := ");
single_value->field_session__present__flag.log();
TTCN_Logger::log_event_str(", connect_return_code := ");
single_value->field_connect__return__code.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Connack_template::log_match(const MQTT__v3__1__1__Connack& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_session__present__flag.match(match_value.session__present__flag(), legacy)){
TTCN_Logger::log_logmatch_info(".session_present_flag");
single_value->field_session__present__flag.log_match(match_value.session__present__flag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_connect__return__code.match(match_value.connect__return__code(), legacy)){
TTCN_Logger::log_logmatch_info(".connect_return_code");
single_value->field_connect__return__code.log_match(match_value.connect__return__code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", session_present_flag := ");
single_value->field_session__present__flag.log_match(match_value.session__present__flag(), legacy);
TTCN_Logger::log_event_str(", connect_return_code := ");
single_value->field_connect__return__code.log_match(match_value.connect__return__code(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Connack_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_session__present__flag.encode_text(text_buf);
single_value->field_connect__return__code.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
}
}

void MQTT__v3__1__1__Connack_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_session__present__flag.decode_text(text_buf);
single_value->field_connect__return__code.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Connack_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack.");
}
}

void MQTT__v3__1__1__Connack_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Connack_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) session__present__flag().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) connect__return__code().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "session_present_flag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          session__present__flag().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connect_return_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connect__return__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Connack_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
single_value->field_session__present__flag.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
single_value->field_connect__return__code.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Connack");
}

boolean MQTT__v3__1__1__Connack_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Connack_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Publish::MQTT__v3__1__1__Publish()
{
}

MQTT__v3__1__1__Publish::MQTT__v3__1__1__Publish(const MQTT__v3__1__1__PublishHeader& par_header,
    const UNIVERSAL_CHARSTRING& par_topic__name,
    const OPTIONAL<INTEGER>& par_packet__identifier,
    const OCTETSTRING& par_payload)
  :   field_header(par_header),
  field_topic__name(par_topic__name),
  field_packet__identifier(par_packet__identifier),
  field_payload(par_payload)
{
}

MQTT__v3__1__1__Publish::MQTT__v3__1__1__Publish(const MQTT__v3__1__1__Publish& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.topic__name().is_bound()) field_topic__name = other_value.topic__name();
else field_topic__name.clean_up();
if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
else field_packet__identifier.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void MQTT__v3__1__1__Publish::clean_up()
{
field_header.clean_up();
field_topic__name.clean_up();
field_packet__identifier.clean_up();
field_payload.clean_up();
}

MQTT__v3__1__1__Publish& MQTT__v3__1__1__Publish::operator=(const MQTT__v3__1__1__Publish& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.topic__name().is_bound()) field_topic__name = other_value.topic__name();
  else field_topic__name.clean_up();
  if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
  else field_packet__identifier.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Publish::operator==(const MQTT__v3__1__1__Publish& other_value) const
{
return field_header==other_value.field_header
  && field_topic__name==other_value.field_topic__name
  && field_packet__identifier==other_value.field_packet__identifier
  && field_payload==other_value.field_payload;
}

boolean MQTT__v3__1__1__Publish::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_topic__name.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_packet__identifier.get_selection() || field_packet__identifier.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Publish::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_topic__name.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_packet__identifier.get_selection() && !field_packet__identifier.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int MQTT__v3__1__1__Publish::size_of() const
{
  int ret_val = 3;
  if (field_packet__identifier.ispresent()) ret_val++;
  return ret_val;
}

void MQTT__v3__1__1__Publish::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", topic_name := ");
field_topic__name.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Publish::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) topic__name().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
  }
}

void MQTT__v3__1__1__Publish::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (topic__name().is_bound()) topic__name().set_implicit_omit();
if (!packet__identifier().is_bound()) packet__identifier() = OMIT_VALUE;
else packet__identifier().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void MQTT__v3__1__1__Publish::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_topic__name.encode_text(text_buf);
field_packet__identifier.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void MQTT__v3__1__1__Publish::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_topic__name.decode_text(text_buf);
field_packet__identifier.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct MQTT__v3__1__1__Publish_template::single_value_struct {
MQTT__v3__1__1__PublishHeader_template field_header;
UNIVERSAL_CHARSTRING_template field_topic__name;
INTEGER_template field_packet__identifier;
OCTETSTRING_template field_payload;
};

void MQTT__v3__1__1__Publish_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_topic__name = ANY_VALUE;
single_value->field_packet__identifier = ANY_OR_OMIT;
single_value->field_payload = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Publish_template::copy_value(const MQTT__v3__1__1__Publish& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.topic__name().is_bound()) {
  single_value->field_topic__name = other_value.topic__name();
} else {
  single_value->field_topic__name.clean_up();
}
if (other_value.packet__identifier().is_bound()) {
  if (other_value.packet__identifier().ispresent()) single_value->field_packet__identifier = other_value.packet__identifier()();
  else single_value->field_packet__identifier = OMIT_VALUE;
} else {
  single_value->field_packet__identifier.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Publish_template::copy_template(const MQTT__v3__1__1__Publish_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.topic__name().get_selection()) {
single_value->field_topic__name = other_value.topic__name();
} else {
single_value->field_topic__name.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet__identifier().get_selection()) {
single_value->field_packet__identifier = other_value.packet__identifier();
} else {
single_value->field_packet__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Publish_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Publish_template::MQTT__v3__1__1__Publish_template()
{
}

MQTT__v3__1__1__Publish_template::MQTT__v3__1__1__Publish_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Publish_template::MQTT__v3__1__1__Publish_template(const MQTT__v3__1__1__Publish& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Publish_template::MQTT__v3__1__1__Publish_template(const OPTIONAL<MQTT__v3__1__1__Publish>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Publish&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish from an unbound optional field.");
}
}

MQTT__v3__1__1__Publish_template::MQTT__v3__1__1__Publish_template(const MQTT__v3__1__1__Publish_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Publish_template::~MQTT__v3__1__1__Publish_template()
{
clean_up();
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__Publish_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__Publish_template::operator=(const MQTT__v3__1__1__Publish& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__Publish_template::operator=(const OPTIONAL<MQTT__v3__1__1__Publish>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Publish&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
}
return *this;
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__Publish_template::operator=(const MQTT__v3__1__1__Publish_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Publish_template::match(const MQTT__v3__1__1__Publish& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.topic__name().is_bound()) return FALSE;
if(!single_value->field_topic__name.match(other_value.topic__name(), legacy))return FALSE;
if(!other_value.packet__identifier().is_bound()) return FALSE;
if((other_value.packet__identifier().ispresent() ? !single_value->field_packet__identifier.match((const INTEGER&)other_value.packet__identifier(), legacy) : !single_value->field_packet__identifier.match_omit(legacy)))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Publish_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_topic__name.is_bound()) return TRUE;
if (single_value->field_packet__identifier.is_omit() || single_value->field_packet__identifier.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Publish_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_topic__name.is_value()) return FALSE;
if (!single_value->field_packet__identifier.is_omit() && !single_value->field_packet__identifier.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Publish_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Publish MQTT__v3__1__1__Publish_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
MQTT__v3__1__1__Publish ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_topic__name.is_bound()) {
ret_val.topic__name() = single_value->field_topic__name.valueof();
}
if (single_value->field_packet__identifier.is_omit()) ret_val.packet__identifier() = OMIT_VALUE;
else if (single_value->field_packet__identifier.is_bound()) {
ret_val.packet__identifier() = single_value->field_packet__identifier.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Publish_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Publish_template[list_length];
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__Publish_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
return value_list.list_value[list_index];
}

MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__Publish_template::header()
{
set_specific();
return single_value->field_header;
}

const MQTT__v3__1__1__PublishHeader_template& MQTT__v3__1__1__Publish_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
return single_value->field_header;
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__Publish_template::topic__name()
{
set_specific();
return single_value->field_topic__name;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__Publish_template::topic__name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field topic_name of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
return single_value->field_topic__name;
}

INTEGER_template& MQTT__v3__1__1__Publish_template::packet__identifier()
{
set_specific();
return single_value->field_packet__identifier;
}

const INTEGER_template& MQTT__v3__1__1__Publish_template::packet__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
return single_value->field_packet__identifier;
}

OCTETSTRING_template& MQTT__v3__1__1__Publish_template::payload()
{
set_specific();
return single_value->field_payload;
}

const OCTETSTRING_template& MQTT__v3__1__1__Publish_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
return single_value->field_payload;
}

int MQTT__v3__1__1__Publish_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 3;
      if (single_value->field_packet__identifier.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
  }
  return 0;
}

void MQTT__v3__1__1__Publish_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", topic_name := ");
single_value->field_topic__name.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Publish_template::log_match(const MQTT__v3__1__1__Publish& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_topic__name.match(match_value.topic__name(), legacy)){
TTCN_Logger::log_logmatch_info(".topic_name");
single_value->field_topic__name.log_match(match_value.topic__name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.packet__identifier().ispresent()){
if(!single_value->field_packet__identifier.match(match_value.packet__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".packet_identifier");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_packet__identifier.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".packet_identifier := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", topic_name := ");
single_value->field_topic__name.log_match(match_value.topic__name(), legacy);
TTCN_Logger::log_event_str(", packet_identifier := ");
if (match_value.packet__identifier().ispresent()) single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_packet__identifier.log();
if (single_value->field_packet__identifier.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Publish_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_topic__name.encode_text(text_buf);
single_value->field_packet__identifier.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
}
}

void MQTT__v3__1__1__Publish_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_topic__name.decode_text(text_buf);
single_value->field_packet__identifier.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Publish_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish.");
}
}

void MQTT__v3__1__1__Publish_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Publish_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) topic__name().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__name().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Publish_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
single_value->field_topic__name.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
single_value->field_packet__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Publish");
}

boolean MQTT__v3__1__1__Publish_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Publish_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Identifier::MQTT__v3__1__1__Identifier()
{
}

MQTT__v3__1__1__Identifier::MQTT__v3__1__1__Identifier(const Header& par_header,
    const INTEGER& par_packet__identifier)
  :   field_header(par_header),
  field_packet__identifier(par_packet__identifier)
{
}

MQTT__v3__1__1__Identifier::MQTT__v3__1__1__Identifier(const MQTT__v3__1__1__Identifier& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
else field_packet__identifier.clean_up();
}

void MQTT__v3__1__1__Identifier::clean_up()
{
field_header.clean_up();
field_packet__identifier.clean_up();
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__Identifier::operator=(const MQTT__v3__1__1__Identifier& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
  else field_packet__identifier.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Identifier::operator==(const MQTT__v3__1__1__Identifier& other_value) const
{
return field_header==other_value.field_header
  && field_packet__identifier==other_value.field_packet__identifier;
}

boolean MQTT__v3__1__1__Identifier::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_packet__identifier.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Identifier::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_packet__identifier.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Identifier::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
field_packet__identifier.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Identifier::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier");
  }
}

void MQTT__v3__1__1__Identifier::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (packet__identifier().is_bound()) packet__identifier().set_implicit_omit();
}

void MQTT__v3__1__1__Identifier::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_packet__identifier.encode_text(text_buf);
}

void MQTT__v3__1__1__Identifier::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_packet__identifier.decode_text(text_buf);
}

struct MQTT__v3__1__1__Identifier_template::single_value_struct {
Header_template field_header;
INTEGER_template field_packet__identifier;
};

void MQTT__v3__1__1__Identifier_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_packet__identifier = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Identifier_template::copy_value(const MQTT__v3__1__1__Identifier& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.packet__identifier().is_bound()) {
  single_value->field_packet__identifier = other_value.packet__identifier();
} else {
  single_value->field_packet__identifier.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Identifier_template::copy_template(const MQTT__v3__1__1__Identifier_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet__identifier().get_selection()) {
single_value->field_packet__identifier = other_value.packet__identifier();
} else {
single_value->field_packet__identifier.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Identifier_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Identifier_template::MQTT__v3__1__1__Identifier_template()
{
}

MQTT__v3__1__1__Identifier_template::MQTT__v3__1__1__Identifier_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Identifier_template::MQTT__v3__1__1__Identifier_template(const MQTT__v3__1__1__Identifier& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Identifier_template::MQTT__v3__1__1__Identifier_template(const OPTIONAL<MQTT__v3__1__1__Identifier>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Identifier&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier from an unbound optional field.");
}
}

MQTT__v3__1__1__Identifier_template::MQTT__v3__1__1__Identifier_template(const MQTT__v3__1__1__Identifier_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Identifier_template::~MQTT__v3__1__1__Identifier_template()
{
clean_up();
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__Identifier_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__Identifier_template::operator=(const MQTT__v3__1__1__Identifier& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__Identifier_template::operator=(const OPTIONAL<MQTT__v3__1__1__Identifier>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Identifier&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
}
return *this;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__Identifier_template::operator=(const MQTT__v3__1__1__Identifier_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Identifier_template::match(const MQTT__v3__1__1__Identifier& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.packet__identifier().is_bound()) return FALSE;
if(!single_value->field_packet__identifier.match(other_value.packet__identifier(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Identifier_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_packet__identifier.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Identifier_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_packet__identifier.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Identifier_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Identifier MQTT__v3__1__1__Identifier_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
MQTT__v3__1__1__Identifier ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_packet__identifier.is_bound()) {
ret_val.packet__identifier() = single_value->field_packet__identifier.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Identifier_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Identifier_template[list_length];
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__Identifier_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Identifier_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Identifier_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
return single_value->field_header;
}

INTEGER_template& MQTT__v3__1__1__Identifier_template::packet__identifier()
{
set_specific();
return single_value->field_packet__identifier;
}

const INTEGER_template& MQTT__v3__1__1__Identifier_template::packet__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
return single_value->field_packet__identifier;
}

int MQTT__v3__1__1__Identifier_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
  }
  return 0;
}

void MQTT__v3__1__1__Identifier_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Identifier_template::log_match(const MQTT__v3__1__1__Identifier& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_packet__identifier.match(match_value.packet__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".packet_identifier");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Identifier_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_packet__identifier.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
}
}

void MQTT__v3__1__1__Identifier_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_packet__identifier.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Identifier_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier.");
}
}

void MQTT__v3__1__1__Identifier_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Identifier_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Identifier_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier");
single_value->field_packet__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Identifier");
}

boolean MQTT__v3__1__1__Identifier_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Identifier_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__SubscribePayload::MQTT__v3__1__1__SubscribePayload()
{
}

MQTT__v3__1__1__SubscribePayload::MQTT__v3__1__1__SubscribePayload(const UNIVERSAL_CHARSTRING& par_topic__filter,
    const QoS& par_requested__qos)
  :   field_topic__filter(par_topic__filter),
  field_requested__qos(par_requested__qos)
{
}

MQTT__v3__1__1__SubscribePayload::MQTT__v3__1__1__SubscribePayload(const MQTT__v3__1__1__SubscribePayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
if (other_value.topic__filter().is_bound()) field_topic__filter = other_value.topic__filter();
else field_topic__filter.clean_up();
if (other_value.requested__qos().is_bound()) field_requested__qos = other_value.requested__qos();
else field_requested__qos.clean_up();
}

void MQTT__v3__1__1__SubscribePayload::clean_up()
{
field_topic__filter.clean_up();
field_requested__qos.clean_up();
}

MQTT__v3__1__1__SubscribePayload& MQTT__v3__1__1__SubscribePayload::operator=(const MQTT__v3__1__1__SubscribePayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
  if (other_value.topic__filter().is_bound()) field_topic__filter = other_value.topic__filter();
  else field_topic__filter.clean_up();
  if (other_value.requested__qos().is_bound()) field_requested__qos = other_value.requested__qos();
  else field_requested__qos.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__SubscribePayload::operator==(const MQTT__v3__1__1__SubscribePayload& other_value) const
{
return field_topic__filter==other_value.field_topic__filter
  && field_requested__qos==other_value.field_requested__qos;
}

boolean MQTT__v3__1__1__SubscribePayload::is_bound() const
{
if(field_topic__filter.is_bound()) return TRUE;
if(field_requested__qos.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__SubscribePayload::is_value() const
{
if(!field_topic__filter.is_value()) return FALSE;
if(!field_requested__qos.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__SubscribePayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ topic_filter := ");
field_topic__filter.log();
TTCN_Logger::log_event_str(", requested_qos := ");
field_requested__qos.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__SubscribePayload::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) topic__filter().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) requested__qos().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_filter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__filter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requested_qos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requested__qos().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload");
  }
}

void MQTT__v3__1__1__SubscribePayload::set_implicit_omit()
{
if (topic__filter().is_bound()) topic__filter().set_implicit_omit();
if (requested__qos().is_bound()) requested__qos().set_implicit_omit();
}

void MQTT__v3__1__1__SubscribePayload::encode_text(Text_Buf& text_buf) const
{
field_topic__filter.encode_text(text_buf);
field_requested__qos.encode_text(text_buf);
}

void MQTT__v3__1__1__SubscribePayload::decode_text(Text_Buf& text_buf)
{
field_topic__filter.decode_text(text_buf);
field_requested__qos.decode_text(text_buf);
}

struct MQTT__v3__1__1__SubscribePayload_template::single_value_struct {
UNIVERSAL_CHARSTRING_template field_topic__filter;
QoS_template field_requested__qos;
};

void MQTT__v3__1__1__SubscribePayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_topic__filter = ANY_VALUE;
single_value->field_requested__qos = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__SubscribePayload_template::copy_value(const MQTT__v3__1__1__SubscribePayload& other_value)
{
single_value = new single_value_struct;
if (other_value.topic__filter().is_bound()) {
  single_value->field_topic__filter = other_value.topic__filter();
} else {
  single_value->field_topic__filter.clean_up();
}
if (other_value.requested__qos().is_bound()) {
  single_value->field_requested__qos = other_value.requested__qos();
} else {
  single_value->field_requested__qos.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__SubscribePayload_template::copy_template(const MQTT__v3__1__1__SubscribePayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.topic__filter().get_selection()) {
single_value->field_topic__filter = other_value.topic__filter();
} else {
single_value->field_topic__filter.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.requested__qos().get_selection()) {
single_value->field_requested__qos = other_value.requested__qos();
} else {
single_value->field_requested__qos.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__SubscribePayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__SubscribePayload_template::MQTT__v3__1__1__SubscribePayload_template()
{
}

MQTT__v3__1__1__SubscribePayload_template::MQTT__v3__1__1__SubscribePayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__SubscribePayload_template::MQTT__v3__1__1__SubscribePayload_template(const MQTT__v3__1__1__SubscribePayload& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__SubscribePayload_template::MQTT__v3__1__1__SubscribePayload_template(const OPTIONAL<MQTT__v3__1__1__SubscribePayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubscribePayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload from an unbound optional field.");
}
}

MQTT__v3__1__1__SubscribePayload_template::MQTT__v3__1__1__SubscribePayload_template(const MQTT__v3__1__1__SubscribePayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__SubscribePayload_template::~MQTT__v3__1__1__SubscribePayload_template()
{
clean_up();
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayload_template::operator=(const MQTT__v3__1__1__SubscribePayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayload_template::operator=(const OPTIONAL<MQTT__v3__1__1__SubscribePayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubscribePayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
}
return *this;
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayload_template::operator=(const MQTT__v3__1__1__SubscribePayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__SubscribePayload_template::match(const MQTT__v3__1__1__SubscribePayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.topic__filter().is_bound()) return FALSE;
if(!single_value->field_topic__filter.match(other_value.topic__filter(), legacy))return FALSE;
if(!other_value.requested__qos().is_bound()) return FALSE;
if(!single_value->field_requested__qos.match(other_value.requested__qos(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
}
return FALSE;
}

boolean MQTT__v3__1__1__SubscribePayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_topic__filter.is_bound()) return TRUE;
if (single_value->field_requested__qos.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__SubscribePayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_topic__filter.is_value()) return FALSE;
if (!single_value->field_requested__qos.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__SubscribePayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__SubscribePayload MQTT__v3__1__1__SubscribePayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
MQTT__v3__1__1__SubscribePayload ret_val;
if (single_value->field_topic__filter.is_bound()) {
ret_val.topic__filter() = single_value->field_topic__filter.valueof();
}
if (single_value->field_requested__qos.is_bound()) {
ret_val.requested__qos() = single_value->field_requested__qos.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__SubscribePayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__SubscribePayload_template[list_length];
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
return value_list.list_value[list_index];
}

UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__SubscribePayload_template::topic__filter()
{
set_specific();
return single_value->field_topic__filter;
}

const UNIVERSAL_CHARSTRING_template& MQTT__v3__1__1__SubscribePayload_template::topic__filter() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field topic_filter of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
return single_value->field_topic__filter;
}

QoS_template& MQTT__v3__1__1__SubscribePayload_template::requested__qos()
{
set_specific();
return single_value->field_requested__qos;
}

const QoS_template& MQTT__v3__1__1__SubscribePayload_template::requested__qos() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field requested_qos of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
return single_value->field_requested__qos;
}

int MQTT__v3__1__1__SubscribePayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
  }
  return 0;
}

void MQTT__v3__1__1__SubscribePayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ topic_filter := ");
single_value->field_topic__filter.log();
TTCN_Logger::log_event_str(", requested_qos := ");
single_value->field_requested__qos.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__SubscribePayload_template::log_match(const MQTT__v3__1__1__SubscribePayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_topic__filter.match(match_value.topic__filter(), legacy)){
TTCN_Logger::log_logmatch_info(".topic_filter");
single_value->field_topic__filter.log_match(match_value.topic__filter(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_requested__qos.match(match_value.requested__qos(), legacy)){
TTCN_Logger::log_logmatch_info(".requested_qos");
single_value->field_requested__qos.log_match(match_value.requested__qos(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ topic_filter := ");
single_value->field_topic__filter.log_match(match_value.topic__filter(), legacy);
TTCN_Logger::log_event_str(", requested_qos := ");
single_value->field_requested__qos.log_match(match_value.requested__qos(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__SubscribePayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_topic__filter.encode_text(text_buf);
single_value->field_requested__qos.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
}
}

void MQTT__v3__1__1__SubscribePayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_topic__filter.decode_text(text_buf);
single_value->field_requested__qos.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__SubscribePayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload.");
}
}

void MQTT__v3__1__1__SubscribePayload_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__SubscribePayload_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) topic__filter().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) requested__qos().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_filter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__filter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requested_qos")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requested__qos().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__SubscribePayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_topic__filter.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload");
single_value->field_requested__qos.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayload");
}

boolean MQTT__v3__1__1__SubscribePayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__SubscribePayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const MQTT__v3__1__1__SubscribePayload MQTT__v3__1__1__SubscribePayloadList::UNBOUND_ELEM;
MQTT__v3__1__1__SubscribePayloadList::MQTT__v3__1__1__SubscribePayloadList()
{
val_ptr = NULL;
}

MQTT__v3__1__1__SubscribePayloadList::MQTT__v3__1__1__SubscribePayloadList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

MQTT__v3__1__1__SubscribePayloadList::MQTT__v3__1__1__SubscribePayloadList(const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

MQTT__v3__1__1__SubscribePayloadList::~MQTT__v3__1__1__SubscribePayloadList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void MQTT__v3__1__1__SubscribePayloadList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

MQTT__v3__1__1__SubscribePayloadList& MQTT__v3__1__1__SubscribePayloadList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

MQTT__v3__1__1__SubscribePayloadList& MQTT__v3__1__1__SubscribePayloadList::operator=(const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean MQTT__v3__1__1__SubscribePayloadList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return val_ptr->n_elements == 0 ;
}

boolean MQTT__v3__1__1__SubscribePayloadList::operator==(const MQTT__v3__1__1__SubscribePayloadList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

MQTT__v3__1__1__SubscribePayload& MQTT__v3__1__1__SubscribePayloadList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (MQTT__v3__1__1__SubscribePayload**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new MQTT__v3__1__1__SubscribePayload;
}
return *val_ptr->value_elements[index_value];
}

MQTT__v3__1__1__SubscribePayload& MQTT__v3__1__1__SubscribePayloadList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return (*this)[(int)index_value];
}

const MQTT__v3__1__1__SubscribePayload& MQTT__v3__1__1__SubscribePayloadList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (index_value < 0) TTCN_error("Accessing an element of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const MQTT__v3__1__1__SubscribePayload& MQTT__v3__1__1__SubscribePayloadList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return (*this)[(int)index_value];
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
MQTT__v3__1__1__SubscribePayloadList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new MQTT__v3__1__1__SubscribePayload(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::operator+(const MQTT__v3__1__1__SubscribePayloadList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
MQTT__v3__1__1__SubscribePayloadList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MQTT__v3__1__1__SubscribePayload(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new MQTT__v3__1__1__SubscribePayload(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList","element");
MQTT__v3__1__1__SubscribePayloadList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new MQTT__v3__1__1__SubscribePayload(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::replace(int index, int len, const MQTT__v3__1__1__SubscribePayloadList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList","element");
MQTT__v3__1__1__SubscribePayloadList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new MQTT__v3__1__1__SubscribePayload(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new MQTT__v3__1__1__SubscribePayload(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new MQTT__v3__1__1__SubscribePayload(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList::replace(int index, int len, const MQTT__v3__1__1__SubscribePayloadList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void MQTT__v3__1__1__SubscribePayloadList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (MQTT__v3__1__1__SubscribePayload**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (MQTT__v3__1__1__SubscribePayload**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (MQTT__v3__1__1__SubscribePayload**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean MQTT__v3__1__1__SubscribePayloadList::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int MQTT__v3__1__1__SubscribePayloadList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return val_ptr->n_elements;
}

int MQTT__v3__1__1__SubscribePayloadList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void MQTT__v3__1__1__SubscribePayloadList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void MQTT__v3__1__1__SubscribePayloadList::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void MQTT__v3__1__1__SubscribePayloadList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void MQTT__v3__1__1__SubscribePayloadList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void MQTT__v3__1__1__SubscribePayloadList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
val_ptr->value_elements = (MQTT__v3__1__1__SubscribePayload**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void MQTT__v3__1__1__SubscribePayloadList_template::copy_value(const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (MQTT__v3__1__1__SubscribePayload_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__SubscribePayloadList_template::copy_template(const MQTT__v3__1__1__SubscribePayloadList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (MQTT__v3__1__1__SubscribePayload_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__SubscribePayloadList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
break;
}
set_selection(other_value);
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const MQTT__v3__1__1__SubscribePayloadList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const MQTT__v3__1__1__SubscribePayloadList*)value_ptr)[value_index], legacy);
else return ((const MQTT__v3__1__1__SubscribePayloadList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template()
{
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template(const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template(const OPTIONAL<MQTT__v3__1__1__SubscribePayloadList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubscribePayloadList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList from an unbound optional field.");
}
}

MQTT__v3__1__1__SubscribePayloadList_template::MQTT__v3__1__1__SubscribePayloadList_template(const MQTT__v3__1__1__SubscribePayloadList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__SubscribePayloadList_template::~MQTT__v3__1__1__SubscribePayloadList_template()
{
clean_up();
}

void MQTT__v3__1__1__SubscribePayloadList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::operator=(const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::operator=(const OPTIONAL<MQTT__v3__1__1__SubscribePayloadList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubscribePayloadList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
}
return *this;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::operator=(const MQTT__v3__1__1__SubscribePayloadList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayloadList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
    break;
}
return *single_value.value_elements[index_value];
}

MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayloadList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return (*this)[(int)index_value];
}

const MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayloadList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const MQTT__v3__1__1__SubscribePayload_template& MQTT__v3__1__1__SubscribePayloadList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return (*this)[(int)index_value];
}

void MQTT__v3__1__1__SubscribePayloadList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (MQTT__v3__1__1__SubscribePayload_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (MQTT__v3__1__1__SubscribePayload_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int MQTT__v3__1__1__SubscribePayloadList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int MQTT__v3__1__1__SubscribePayloadList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::match(const MQTT__v3__1__1__SubscribePayloadList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
}
return FALSE;
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
MQTT__v3__1__1__SubscribePayloadList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList_template::replace(int index, int len, const MQTT__v3__1__1__SubscribePayloadList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

MQTT__v3__1__1__SubscribePayloadList MQTT__v3__1__1__SubscribePayloadList_template::replace(int index, int len, const MQTT__v3__1__1__SubscribePayloadList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void MQTT__v3__1__1__SubscribePayloadList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__SubscribePayloadList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
}
set_selection(template_type);
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__SubscribePayloadList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return value_list.list_value[list_index];
}

void MQTT__v3__1__1__SubscribePayloadList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void MQTT__v3__1__1__SubscribePayloadList_template::log_match(const MQTT__v3__1__1__SubscribePayloadList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__SubscribePayloadList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
}
}

void MQTT__v3__1__1__SubscribePayloadList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
single_value.value_elements = (MQTT__v3__1__1__SubscribePayload_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new MQTT__v3__1__1__SubscribePayload_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__SubscribePayloadList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
}
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MQTT__v3__1__1__SubscribePayloadList_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__SubscribePayloadList_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void MQTT__v3__1__1__SubscribePayloadList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList");
}

boolean MQTT__v3__1__1__SubscribePayloadList_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
MQTT__v3__1__1__Subscribe::MQTT__v3__1__1__Subscribe()
{
}

MQTT__v3__1__1__Subscribe::MQTT__v3__1__1__Subscribe(const Header& par_header,
    const INTEGER& par_packet__identifier,
    const MQTT__v3__1__1__SubscribePayloadList& par_payload)
  :   field_header(par_header),
  field_packet__identifier(par_packet__identifier),
  field_payload(par_payload)
{
}

MQTT__v3__1__1__Subscribe::MQTT__v3__1__1__Subscribe(const MQTT__v3__1__1__Subscribe& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
else field_packet__identifier.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void MQTT__v3__1__1__Subscribe::clean_up()
{
field_header.clean_up();
field_packet__identifier.clean_up();
field_payload.clean_up();
}

MQTT__v3__1__1__Subscribe& MQTT__v3__1__1__Subscribe::operator=(const MQTT__v3__1__1__Subscribe& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
  else field_packet__identifier.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Subscribe::operator==(const MQTT__v3__1__1__Subscribe& other_value) const
{
return field_header==other_value.field_header
  && field_packet__identifier==other_value.field_packet__identifier
  && field_payload==other_value.field_payload;
}

boolean MQTT__v3__1__1__Subscribe::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_packet__identifier.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Subscribe::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_packet__identifier.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Subscribe::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Subscribe::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
  }
}

void MQTT__v3__1__1__Subscribe::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (packet__identifier().is_bound()) packet__identifier().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void MQTT__v3__1__1__Subscribe::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_packet__identifier.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void MQTT__v3__1__1__Subscribe::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_packet__identifier.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct MQTT__v3__1__1__Subscribe_template::single_value_struct {
Header_template field_header;
INTEGER_template field_packet__identifier;
MQTT__v3__1__1__SubscribePayloadList_template field_payload;
};

void MQTT__v3__1__1__Subscribe_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_packet__identifier = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Subscribe_template::copy_value(const MQTT__v3__1__1__Subscribe& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.packet__identifier().is_bound()) {
  single_value->field_packet__identifier = other_value.packet__identifier();
} else {
  single_value->field_packet__identifier.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Subscribe_template::copy_template(const MQTT__v3__1__1__Subscribe_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet__identifier().get_selection()) {
single_value->field_packet__identifier = other_value.packet__identifier();
} else {
single_value->field_packet__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Subscribe_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Subscribe_template::MQTT__v3__1__1__Subscribe_template()
{
}

MQTT__v3__1__1__Subscribe_template::MQTT__v3__1__1__Subscribe_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Subscribe_template::MQTT__v3__1__1__Subscribe_template(const MQTT__v3__1__1__Subscribe& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Subscribe_template::MQTT__v3__1__1__Subscribe_template(const OPTIONAL<MQTT__v3__1__1__Subscribe>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Subscribe&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe from an unbound optional field.");
}
}

MQTT__v3__1__1__Subscribe_template::MQTT__v3__1__1__Subscribe_template(const MQTT__v3__1__1__Subscribe_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Subscribe_template::~MQTT__v3__1__1__Subscribe_template()
{
clean_up();
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__Subscribe_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__Subscribe_template::operator=(const MQTT__v3__1__1__Subscribe& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__Subscribe_template::operator=(const OPTIONAL<MQTT__v3__1__1__Subscribe>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Subscribe&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
}
return *this;
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__Subscribe_template::operator=(const MQTT__v3__1__1__Subscribe_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Subscribe_template::match(const MQTT__v3__1__1__Subscribe& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.packet__identifier().is_bound()) return FALSE;
if(!single_value->field_packet__identifier.match(other_value.packet__identifier(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Subscribe_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_packet__identifier.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Subscribe_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_packet__identifier.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Subscribe_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Subscribe MQTT__v3__1__1__Subscribe_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
MQTT__v3__1__1__Subscribe ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_packet__identifier.is_bound()) {
ret_val.packet__identifier() = single_value->field_packet__identifier.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Subscribe_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Subscribe_template[list_length];
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__Subscribe_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Subscribe_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Subscribe_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
return single_value->field_header;
}

INTEGER_template& MQTT__v3__1__1__Subscribe_template::packet__identifier()
{
set_specific();
return single_value->field_packet__identifier;
}

const INTEGER_template& MQTT__v3__1__1__Subscribe_template::packet__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
return single_value->field_packet__identifier;
}

MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__Subscribe_template::payload()
{
set_specific();
return single_value->field_payload;
}

const MQTT__v3__1__1__SubscribePayloadList_template& MQTT__v3__1__1__Subscribe_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
return single_value->field_payload;
}

int MQTT__v3__1__1__Subscribe_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
  }
  return 0;
}

void MQTT__v3__1__1__Subscribe_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Subscribe_template::log_match(const MQTT__v3__1__1__Subscribe& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_packet__identifier.match(match_value.packet__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".packet_identifier");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Subscribe_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_packet__identifier.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
}
}

void MQTT__v3__1__1__Subscribe_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_packet__identifier.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Subscribe_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe.");
}
}

void MQTT__v3__1__1__Subscribe_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Subscribe_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Subscribe_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
single_value->field_packet__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Subscribe");
}

boolean MQTT__v3__1__1__Subscribe_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Subscribe_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__SubackPayload::MQTT__v3__1__1__SubackPayload()
{
}

MQTT__v3__1__1__SubackPayload::MQTT__v3__1__1__SubackPayload(const IntegerList& par_return__code)
  :   field_return__code(par_return__code)
{
}

MQTT__v3__1__1__SubackPayload::MQTT__v3__1__1__SubackPayload(const MQTT__v3__1__1__SubackPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
if (other_value.return__code().is_bound()) field_return__code = other_value.return__code();
else field_return__code.clean_up();
}

void MQTT__v3__1__1__SubackPayload::clean_up()
{
field_return__code.clean_up();
}

MQTT__v3__1__1__SubackPayload& MQTT__v3__1__1__SubackPayload::operator=(const MQTT__v3__1__1__SubackPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
  if (other_value.return__code().is_bound()) field_return__code = other_value.return__code();
  else field_return__code.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__SubackPayload::operator==(const MQTT__v3__1__1__SubackPayload& other_value) const
{
return field_return__code==other_value.field_return__code;
}

boolean MQTT__v3__1__1__SubackPayload::is_bound() const
{
if(field_return__code.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__SubackPayload::is_value() const
{
if(!field_return__code.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__SubackPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ return_code := ");
field_return__code.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__SubackPayload::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) return__code().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "return_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          return__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload");
  }
}

void MQTT__v3__1__1__SubackPayload::set_implicit_omit()
{
if (return__code().is_bound()) return__code().set_implicit_omit();
}

void MQTT__v3__1__1__SubackPayload::encode_text(Text_Buf& text_buf) const
{
field_return__code.encode_text(text_buf);
}

void MQTT__v3__1__1__SubackPayload::decode_text(Text_Buf& text_buf)
{
field_return__code.decode_text(text_buf);
}

struct MQTT__v3__1__1__SubackPayload_template::single_value_struct {
IntegerList_template field_return__code;
};

void MQTT__v3__1__1__SubackPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_return__code = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__SubackPayload_template::copy_value(const MQTT__v3__1__1__SubackPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.return__code().is_bound()) {
  single_value->field_return__code = other_value.return__code();
} else {
  single_value->field_return__code.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__SubackPayload_template::copy_template(const MQTT__v3__1__1__SubackPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.return__code().get_selection()) {
single_value->field_return__code = other_value.return__code();
} else {
single_value->field_return__code.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__SubackPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__SubackPayload_template::MQTT__v3__1__1__SubackPayload_template()
{
}

MQTT__v3__1__1__SubackPayload_template::MQTT__v3__1__1__SubackPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__SubackPayload_template::MQTT__v3__1__1__SubackPayload_template(const MQTT__v3__1__1__SubackPayload& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__SubackPayload_template::MQTT__v3__1__1__SubackPayload_template(const OPTIONAL<MQTT__v3__1__1__SubackPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubackPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload from an unbound optional field.");
}
}

MQTT__v3__1__1__SubackPayload_template::MQTT__v3__1__1__SubackPayload_template(const MQTT__v3__1__1__SubackPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__SubackPayload_template::~MQTT__v3__1__1__SubackPayload_template()
{
clean_up();
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__SubackPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__SubackPayload_template::operator=(const MQTT__v3__1__1__SubackPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__SubackPayload_template::operator=(const OPTIONAL<MQTT__v3__1__1__SubackPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__SubackPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
}
return *this;
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__SubackPayload_template::operator=(const MQTT__v3__1__1__SubackPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__SubackPayload_template::match(const MQTT__v3__1__1__SubackPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.return__code().is_bound()) return FALSE;
if(!single_value->field_return__code.match(other_value.return__code(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
}
return FALSE;
}

boolean MQTT__v3__1__1__SubackPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_return__code.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__SubackPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_return__code.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__SubackPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__SubackPayload MQTT__v3__1__1__SubackPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
MQTT__v3__1__1__SubackPayload ret_val;
if (single_value->field_return__code.is_bound()) {
ret_val.return__code() = single_value->field_return__code.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__SubackPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__SubackPayload_template[list_length];
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__SubackPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
return value_list.list_value[list_index];
}

IntegerList_template& MQTT__v3__1__1__SubackPayload_template::return__code()
{
set_specific();
return single_value->field_return__code;
}

const IntegerList_template& MQTT__v3__1__1__SubackPayload_template::return__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field return_code of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
return single_value->field_return__code;
}

int MQTT__v3__1__1__SubackPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
  }
  return 0;
}

void MQTT__v3__1__1__SubackPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ return_code := ");
single_value->field_return__code.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__SubackPayload_template::log_match(const MQTT__v3__1__1__SubackPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_return__code.match(match_value.return__code(), legacy)){
TTCN_Logger::log_logmatch_info(".return_code");
single_value->field_return__code.log_match(match_value.return__code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ return_code := ");
single_value->field_return__code.log_match(match_value.return__code(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__SubackPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_return__code.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
}
}

void MQTT__v3__1__1__SubackPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_return__code.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__SubackPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload.");
}
}

void MQTT__v3__1__1__SubackPayload_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__SubackPayload_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) return__code().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "return_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          return__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__SubackPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_return__code.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubackPayload");
}

boolean MQTT__v3__1__1__SubackPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__SubackPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Suback::MQTT__v3__1__1__Suback()
{
}

MQTT__v3__1__1__Suback::MQTT__v3__1__1__Suback(const Header& par_header,
    const INTEGER& par_packet__identifier,
    const MQTT__v3__1__1__SubackPayload& par_payload)
  :   field_header(par_header),
  field_packet__identifier(par_packet__identifier),
  field_payload(par_payload)
{
}

MQTT__v3__1__1__Suback::MQTT__v3__1__1__Suback(const MQTT__v3__1__1__Suback& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
else field_packet__identifier.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void MQTT__v3__1__1__Suback::clean_up()
{
field_header.clean_up();
field_packet__identifier.clean_up();
field_payload.clean_up();
}

MQTT__v3__1__1__Suback& MQTT__v3__1__1__Suback::operator=(const MQTT__v3__1__1__Suback& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
  else field_packet__identifier.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Suback::operator==(const MQTT__v3__1__1__Suback& other_value) const
{
return field_header==other_value.field_header
  && field_packet__identifier==other_value.field_packet__identifier
  && field_payload==other_value.field_payload;
}

boolean MQTT__v3__1__1__Suback::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_packet__identifier.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Suback::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_packet__identifier.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Suback::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Suback::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
  }
}

void MQTT__v3__1__1__Suback::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (packet__identifier().is_bound()) packet__identifier().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void MQTT__v3__1__1__Suback::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_packet__identifier.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void MQTT__v3__1__1__Suback::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_packet__identifier.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct MQTT__v3__1__1__Suback_template::single_value_struct {
Header_template field_header;
INTEGER_template field_packet__identifier;
MQTT__v3__1__1__SubackPayload_template field_payload;
};

void MQTT__v3__1__1__Suback_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_packet__identifier = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Suback_template::copy_value(const MQTT__v3__1__1__Suback& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.packet__identifier().is_bound()) {
  single_value->field_packet__identifier = other_value.packet__identifier();
} else {
  single_value->field_packet__identifier.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Suback_template::copy_template(const MQTT__v3__1__1__Suback_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet__identifier().get_selection()) {
single_value->field_packet__identifier = other_value.packet__identifier();
} else {
single_value->field_packet__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Suback_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Suback_template::MQTT__v3__1__1__Suback_template()
{
}

MQTT__v3__1__1__Suback_template::MQTT__v3__1__1__Suback_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Suback_template::MQTT__v3__1__1__Suback_template(const MQTT__v3__1__1__Suback& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Suback_template::MQTT__v3__1__1__Suback_template(const OPTIONAL<MQTT__v3__1__1__Suback>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Suback&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback from an unbound optional field.");
}
}

MQTT__v3__1__1__Suback_template::MQTT__v3__1__1__Suback_template(const MQTT__v3__1__1__Suback_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Suback_template::~MQTT__v3__1__1__Suback_template()
{
clean_up();
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__Suback_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__Suback_template::operator=(const MQTT__v3__1__1__Suback& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__Suback_template::operator=(const OPTIONAL<MQTT__v3__1__1__Suback>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Suback&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
}
return *this;
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__Suback_template::operator=(const MQTT__v3__1__1__Suback_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Suback_template::match(const MQTT__v3__1__1__Suback& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.packet__identifier().is_bound()) return FALSE;
if(!single_value->field_packet__identifier.match(other_value.packet__identifier(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Suback_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_packet__identifier.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Suback_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_packet__identifier.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Suback_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Suback MQTT__v3__1__1__Suback_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
MQTT__v3__1__1__Suback ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_packet__identifier.is_bound()) {
ret_val.packet__identifier() = single_value->field_packet__identifier.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Suback_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Suback_template[list_length];
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__Suback_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Suback_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Suback_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
return single_value->field_header;
}

INTEGER_template& MQTT__v3__1__1__Suback_template::packet__identifier()
{
set_specific();
return single_value->field_packet__identifier;
}

const INTEGER_template& MQTT__v3__1__1__Suback_template::packet__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
return single_value->field_packet__identifier;
}

MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__Suback_template::payload()
{
set_specific();
return single_value->field_payload;
}

const MQTT__v3__1__1__SubackPayload_template& MQTT__v3__1__1__Suback_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
return single_value->field_payload;
}

int MQTT__v3__1__1__Suback_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
  }
  return 0;
}

void MQTT__v3__1__1__Suback_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Suback_template::log_match(const MQTT__v3__1__1__Suback& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_packet__identifier.match(match_value.packet__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".packet_identifier");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Suback_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_packet__identifier.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
}
}

void MQTT__v3__1__1__Suback_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_packet__identifier.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Suback_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback.");
}
}

void MQTT__v3__1__1__Suback_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Suback_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Suback_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
single_value->field_packet__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Suback");
}

boolean MQTT__v3__1__1__Suback_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Suback_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__UnsubscribePayload::MQTT__v3__1__1__UnsubscribePayload()
{
}

MQTT__v3__1__1__UnsubscribePayload::MQTT__v3__1__1__UnsubscribePayload(const UCHAR0__65535List& par_topic__filter)
  :   field_topic__filter(par_topic__filter)
{
}

MQTT__v3__1__1__UnsubscribePayload::MQTT__v3__1__1__UnsubscribePayload(const MQTT__v3__1__1__UnsubscribePayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
if (other_value.topic__filter().is_bound()) field_topic__filter = other_value.topic__filter();
else field_topic__filter.clean_up();
}

void MQTT__v3__1__1__UnsubscribePayload::clean_up()
{
field_topic__filter.clean_up();
}

MQTT__v3__1__1__UnsubscribePayload& MQTT__v3__1__1__UnsubscribePayload::operator=(const MQTT__v3__1__1__UnsubscribePayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
  if (other_value.topic__filter().is_bound()) field_topic__filter = other_value.topic__filter();
  else field_topic__filter.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__UnsubscribePayload::operator==(const MQTT__v3__1__1__UnsubscribePayload& other_value) const
{
return field_topic__filter==other_value.field_topic__filter;
}

boolean MQTT__v3__1__1__UnsubscribePayload::is_bound() const
{
if(field_topic__filter.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__UnsubscribePayload::is_value() const
{
if(!field_topic__filter.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__UnsubscribePayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ topic_filter := ");
field_topic__filter.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__UnsubscribePayload::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) topic__filter().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_filter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__filter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload");
  }
}

void MQTT__v3__1__1__UnsubscribePayload::set_implicit_omit()
{
if (topic__filter().is_bound()) topic__filter().set_implicit_omit();
}

void MQTT__v3__1__1__UnsubscribePayload::encode_text(Text_Buf& text_buf) const
{
field_topic__filter.encode_text(text_buf);
}

void MQTT__v3__1__1__UnsubscribePayload::decode_text(Text_Buf& text_buf)
{
field_topic__filter.decode_text(text_buf);
}

struct MQTT__v3__1__1__UnsubscribePayload_template::single_value_struct {
UCHAR0__65535List_template field_topic__filter;
};

void MQTT__v3__1__1__UnsubscribePayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_topic__filter = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__UnsubscribePayload_template::copy_value(const MQTT__v3__1__1__UnsubscribePayload& other_value)
{
single_value = new single_value_struct;
if (other_value.topic__filter().is_bound()) {
  single_value->field_topic__filter = other_value.topic__filter();
} else {
  single_value->field_topic__filter.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__UnsubscribePayload_template::copy_template(const MQTT__v3__1__1__UnsubscribePayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.topic__filter().get_selection()) {
single_value->field_topic__filter = other_value.topic__filter();
} else {
single_value->field_topic__filter.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__UnsubscribePayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__UnsubscribePayload_template::MQTT__v3__1__1__UnsubscribePayload_template()
{
}

MQTT__v3__1__1__UnsubscribePayload_template::MQTT__v3__1__1__UnsubscribePayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__UnsubscribePayload_template::MQTT__v3__1__1__UnsubscribePayload_template(const MQTT__v3__1__1__UnsubscribePayload& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__UnsubscribePayload_template::MQTT__v3__1__1__UnsubscribePayload_template(const OPTIONAL<MQTT__v3__1__1__UnsubscribePayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__UnsubscribePayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload from an unbound optional field.");
}
}

MQTT__v3__1__1__UnsubscribePayload_template::MQTT__v3__1__1__UnsubscribePayload_template(const MQTT__v3__1__1__UnsubscribePayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__UnsubscribePayload_template::~MQTT__v3__1__1__UnsubscribePayload_template()
{
clean_up();
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__UnsubscribePayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__UnsubscribePayload_template::operator=(const MQTT__v3__1__1__UnsubscribePayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__UnsubscribePayload_template::operator=(const OPTIONAL<MQTT__v3__1__1__UnsubscribePayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__UnsubscribePayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
}
return *this;
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__UnsubscribePayload_template::operator=(const MQTT__v3__1__1__UnsubscribePayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__UnsubscribePayload_template::match(const MQTT__v3__1__1__UnsubscribePayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.topic__filter().is_bound()) return FALSE;
if(!single_value->field_topic__filter.match(other_value.topic__filter(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
}
return FALSE;
}

boolean MQTT__v3__1__1__UnsubscribePayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_topic__filter.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__UnsubscribePayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_topic__filter.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__UnsubscribePayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__UnsubscribePayload MQTT__v3__1__1__UnsubscribePayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
MQTT__v3__1__1__UnsubscribePayload ret_val;
if (single_value->field_topic__filter.is_bound()) {
ret_val.topic__filter() = single_value->field_topic__filter.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__UnsubscribePayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__UnsubscribePayload_template[list_length];
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__UnsubscribePayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
return value_list.list_value[list_index];
}

UCHAR0__65535List_template& MQTT__v3__1__1__UnsubscribePayload_template::topic__filter()
{
set_specific();
return single_value->field_topic__filter;
}

const UCHAR0__65535List_template& MQTT__v3__1__1__UnsubscribePayload_template::topic__filter() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field topic_filter of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
return single_value->field_topic__filter;
}

int MQTT__v3__1__1__UnsubscribePayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
  }
  return 0;
}

void MQTT__v3__1__1__UnsubscribePayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ topic_filter := ");
single_value->field_topic__filter.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__UnsubscribePayload_template::log_match(const MQTT__v3__1__1__UnsubscribePayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_topic__filter.match(match_value.topic__filter(), legacy)){
TTCN_Logger::log_logmatch_info(".topic_filter");
single_value->field_topic__filter.log_match(match_value.topic__filter(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ topic_filter := ");
single_value->field_topic__filter.log_match(match_value.topic__filter(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__UnsubscribePayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_topic__filter.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
}
}

void MQTT__v3__1__1__UnsubscribePayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_topic__filter.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__UnsubscribePayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload.");
}
}

void MQTT__v3__1__1__UnsubscribePayload_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__UnsubscribePayload_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) topic__filter().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "topic_filter")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          topic__filter().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__UnsubscribePayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_topic__filter.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_UnsubscribePayload");
}

boolean MQTT__v3__1__1__UnsubscribePayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__UnsubscribePayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Unsubscribe::MQTT__v3__1__1__Unsubscribe()
{
}

MQTT__v3__1__1__Unsubscribe::MQTT__v3__1__1__Unsubscribe(const Header& par_header,
    const INTEGER& par_packet__identifier,
    const MQTT__v3__1__1__UnsubscribePayload& par_payload)
  :   field_header(par_header),
  field_packet__identifier(par_packet__identifier),
  field_payload(par_payload)
{
}

MQTT__v3__1__1__Unsubscribe::MQTT__v3__1__1__Unsubscribe(const MQTT__v3__1__1__Unsubscribe& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
else field_packet__identifier.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void MQTT__v3__1__1__Unsubscribe::clean_up()
{
field_header.clean_up();
field_packet__identifier.clean_up();
field_payload.clean_up();
}

MQTT__v3__1__1__Unsubscribe& MQTT__v3__1__1__Unsubscribe::operator=(const MQTT__v3__1__1__Unsubscribe& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.packet__identifier().is_bound()) field_packet__identifier = other_value.packet__identifier();
  else field_packet__identifier.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Unsubscribe::operator==(const MQTT__v3__1__1__Unsubscribe& other_value) const
{
return field_header==other_value.field_header
  && field_packet__identifier==other_value.field_packet__identifier
  && field_payload==other_value.field_payload;
}

boolean MQTT__v3__1__1__Unsubscribe::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_packet__identifier.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Unsubscribe::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_packet__identifier.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Unsubscribe::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Unsubscribe::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
  }
}

void MQTT__v3__1__1__Unsubscribe::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (packet__identifier().is_bound()) packet__identifier().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void MQTT__v3__1__1__Unsubscribe::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_packet__identifier.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void MQTT__v3__1__1__Unsubscribe::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_packet__identifier.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct MQTT__v3__1__1__Unsubscribe_template::single_value_struct {
Header_template field_header;
INTEGER_template field_packet__identifier;
MQTT__v3__1__1__UnsubscribePayload_template field_payload;
};

void MQTT__v3__1__1__Unsubscribe_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_packet__identifier = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Unsubscribe_template::copy_value(const MQTT__v3__1__1__Unsubscribe& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.packet__identifier().is_bound()) {
  single_value->field_packet__identifier = other_value.packet__identifier();
} else {
  single_value->field_packet__identifier.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Unsubscribe_template::copy_template(const MQTT__v3__1__1__Unsubscribe_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.packet__identifier().get_selection()) {
single_value->field_packet__identifier = other_value.packet__identifier();
} else {
single_value->field_packet__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Unsubscribe_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Unsubscribe_template::MQTT__v3__1__1__Unsubscribe_template()
{
}

MQTT__v3__1__1__Unsubscribe_template::MQTT__v3__1__1__Unsubscribe_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Unsubscribe_template::MQTT__v3__1__1__Unsubscribe_template(const MQTT__v3__1__1__Unsubscribe& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Unsubscribe_template::MQTT__v3__1__1__Unsubscribe_template(const OPTIONAL<MQTT__v3__1__1__Unsubscribe>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Unsubscribe&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe from an unbound optional field.");
}
}

MQTT__v3__1__1__Unsubscribe_template::MQTT__v3__1__1__Unsubscribe_template(const MQTT__v3__1__1__Unsubscribe_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Unsubscribe_template::~MQTT__v3__1__1__Unsubscribe_template()
{
clean_up();
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__Unsubscribe_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__Unsubscribe_template::operator=(const MQTT__v3__1__1__Unsubscribe& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__Unsubscribe_template::operator=(const OPTIONAL<MQTT__v3__1__1__Unsubscribe>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Unsubscribe&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
}
return *this;
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__Unsubscribe_template::operator=(const MQTT__v3__1__1__Unsubscribe_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Unsubscribe_template::match(const MQTT__v3__1__1__Unsubscribe& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.packet__identifier().is_bound()) return FALSE;
if(!single_value->field_packet__identifier.match(other_value.packet__identifier(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Unsubscribe_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_packet__identifier.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Unsubscribe_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_packet__identifier.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Unsubscribe_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Unsubscribe MQTT__v3__1__1__Unsubscribe_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
MQTT__v3__1__1__Unsubscribe ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_packet__identifier.is_bound()) {
ret_val.packet__identifier() = single_value->field_packet__identifier.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Unsubscribe_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Unsubscribe_template[list_length];
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__Unsubscribe_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Unsubscribe_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Unsubscribe_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
return single_value->field_header;
}

INTEGER_template& MQTT__v3__1__1__Unsubscribe_template::packet__identifier()
{
set_specific();
return single_value->field_packet__identifier;
}

const INTEGER_template& MQTT__v3__1__1__Unsubscribe_template::packet__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet_identifier of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
return single_value->field_packet__identifier;
}

MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__Unsubscribe_template::payload()
{
set_specific();
return single_value->field_payload;
}

const MQTT__v3__1__1__UnsubscribePayload_template& MQTT__v3__1__1__Unsubscribe_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
return single_value->field_payload;
}

int MQTT__v3__1__1__Unsubscribe_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
  }
  return 0;
}

void MQTT__v3__1__1__Unsubscribe_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Unsubscribe_template::log_match(const MQTT__v3__1__1__Unsubscribe& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_packet__identifier.match(match_value.packet__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".packet_identifier");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", packet_identifier := ");
single_value->field_packet__identifier.log_match(match_value.packet__identifier(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Unsubscribe_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_packet__identifier.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
}
}

void MQTT__v3__1__1__Unsubscribe_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_packet__identifier.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Unsubscribe_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe.");
}
}

void MQTT__v3__1__1__Unsubscribe_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Unsubscribe_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) packet__identifier().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Unsubscribe_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
single_value->field_packet__identifier.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Unsubscribe");
}

boolean MQTT__v3__1__1__Unsubscribe_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Unsubscribe_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MQTT__v3__1__1__Empty::MQTT__v3__1__1__Empty()
{
}

MQTT__v3__1__1__Empty::MQTT__v3__1__1__Empty(const Header& par_header)
  :   field_header(par_header)
{
}

MQTT__v3__1__1__Empty::MQTT__v3__1__1__Empty(const MQTT__v3__1__1__Empty& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
}

void MQTT__v3__1__1__Empty::clean_up()
{
field_header.clean_up();
}

MQTT__v3__1__1__Empty& MQTT__v3__1__1__Empty::operator=(const MQTT__v3__1__1__Empty& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
}
return *this;
}

boolean MQTT__v3__1__1__Empty::operator==(const MQTT__v3__1__1__Empty& other_value) const
{
return field_header==other_value.field_header;
}

boolean MQTT__v3__1__1__Empty::is_bound() const
{
if(field_header.is_bound()) return TRUE;
return FALSE;
}
boolean MQTT__v3__1__1__Empty::is_value() const
{
if(!field_header.is_value()) return FALSE;
return TRUE;
}
void MQTT__v3__1__1__Empty::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(" }");
}

void MQTT__v3__1__1__Empty::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty");
  }
}

void MQTT__v3__1__1__Empty::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
}

void MQTT__v3__1__1__Empty::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
}

void MQTT__v3__1__1__Empty::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
}

struct MQTT__v3__1__1__Empty_template::single_value_struct {
Header_template field_header;
};

void MQTT__v3__1__1__Empty_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
}
}
}

void MQTT__v3__1__1__Empty_template::copy_value(const MQTT__v3__1__1__Empty& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Empty_template::copy_template(const MQTT__v3__1__1__Empty_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Empty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
break;
}
set_selection(other_value);
}

MQTT__v3__1__1__Empty_template::MQTT__v3__1__1__Empty_template()
{
}

MQTT__v3__1__1__Empty_template::MQTT__v3__1__1__Empty_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Empty_template::MQTT__v3__1__1__Empty_template(const MQTT__v3__1__1__Empty& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Empty_template::MQTT__v3__1__1__Empty_template(const OPTIONAL<MQTT__v3__1__1__Empty>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Empty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty from an unbound optional field.");
}
}

MQTT__v3__1__1__Empty_template::MQTT__v3__1__1__Empty_template(const MQTT__v3__1__1__Empty_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MQTT__v3__1__1__Empty_template::~MQTT__v3__1__1__Empty_template()
{
clean_up();
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__Empty_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__Empty_template::operator=(const MQTT__v3__1__1__Empty& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__Empty_template::operator=(const OPTIONAL<MQTT__v3__1__1__Empty>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Empty&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
}
return *this;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__Empty_template::operator=(const MQTT__v3__1__1__Empty_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Empty_template::match(const MQTT__v3__1__1__Empty& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Empty_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
return FALSE;
}

boolean MQTT__v3__1__1__Empty_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
return TRUE;
}

void MQTT__v3__1__1__Empty_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Empty MQTT__v3__1__1__Empty_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
MQTT__v3__1__1__Empty ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
return ret_val;
}

void MQTT__v3__1__1__Empty_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Empty_template[list_length];
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__Empty_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
return value_list.list_value[list_index];
}

Header_template& MQTT__v3__1__1__Empty_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& MQTT__v3__1__1__Empty_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
return single_value->field_header;
}

int MQTT__v3__1__1__Empty_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
  }
  return 0;
}

void MQTT__v3__1__1__Empty_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Empty_template::log_match(const MQTT__v3__1__1__Empty& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Empty_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
}
}

void MQTT__v3__1__1__Empty_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Empty_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty.");
}
}

void MQTT__v3__1__1__Empty_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Empty_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Empty_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Empty");
}

boolean MQTT__v3__1__1__Empty_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Empty_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MQTT__v3__1__1__ReqResp::copy_value(const MQTT__v3__1__1__ReqResp& other_value)
{
switch (other_value.union_selection) {
case ALT_connect__msg:
field_connect__msg = new MQTT__v3__1__1__Connect(*other_value.field_connect__msg);
break;
case ALT_connack:
field_connack = new MQTT__v3__1__1__Connack(*other_value.field_connack);
break;
case ALT_publish:
field_publish = new MQTT__v3__1__1__Publish(*other_value.field_publish);
break;
case ALT_puback:
field_puback = new MQTT__v3__1__1__Identifier(*other_value.field_puback);
break;
case ALT_pubrec:
field_pubrec = new MQTT__v3__1__1__Identifier(*other_value.field_pubrec);
break;
case ALT_pubrel:
field_pubrel = new MQTT__v3__1__1__Identifier(*other_value.field_pubrel);
break;
case ALT_pubcomp:
field_pubcomp = new MQTT__v3__1__1__Identifier(*other_value.field_pubcomp);
break;
case ALT_subscribe:
field_subscribe = new MQTT__v3__1__1__Subscribe(*other_value.field_subscribe);
break;
case ALT_suback:
field_suback = new MQTT__v3__1__1__Suback(*other_value.field_suback);
break;
case ALT_unsubscribe:
field_unsubscribe = new MQTT__v3__1__1__Unsubscribe(*other_value.field_unsubscribe);
break;
case ALT_unsuback:
field_unsuback = new MQTT__v3__1__1__Identifier(*other_value.field_unsuback);
break;
case ALT_pingreq:
field_pingreq = new MQTT__v3__1__1__Empty(*other_value.field_pingreq);
break;
case ALT_pingresp:
field_pingresp = new MQTT__v3__1__1__Empty(*other_value.field_pingresp);
break;
case ALT_disconnect__msg:
field_disconnect__msg = new MQTT__v3__1__1__Empty(*other_value.field_disconnect__msg);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
union_selection = other_value.union_selection;
}

MQTT__v3__1__1__ReqResp::MQTT__v3__1__1__ReqResp()
{
union_selection = UNBOUND_VALUE;
}

MQTT__v3__1__1__ReqResp::MQTT__v3__1__1__ReqResp(const MQTT__v3__1__1__ReqResp& other_value)
: Base_Type(){
copy_value(other_value);
}

MQTT__v3__1__1__ReqResp::~MQTT__v3__1__1__ReqResp()
{
clean_up();
}

MQTT__v3__1__1__ReqResp& MQTT__v3__1__1__ReqResp::operator=(const MQTT__v3__1__1__ReqResp& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__ReqResp::operator==(const MQTT__v3__1__1__ReqResp& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_connect__msg:
return *field_connect__msg == *other_value.field_connect__msg;
case ALT_connack:
return *field_connack == *other_value.field_connack;
case ALT_publish:
return *field_publish == *other_value.field_publish;
case ALT_puback:
return *field_puback == *other_value.field_puback;
case ALT_pubrec:
return *field_pubrec == *other_value.field_pubrec;
case ALT_pubrel:
return *field_pubrel == *other_value.field_pubrel;
case ALT_pubcomp:
return *field_pubcomp == *other_value.field_pubcomp;
case ALT_subscribe:
return *field_subscribe == *other_value.field_subscribe;
case ALT_suback:
return *field_suback == *other_value.field_suback;
case ALT_unsubscribe:
return *field_unsubscribe == *other_value.field_unsubscribe;
case ALT_unsuback:
return *field_unsuback == *other_value.field_unsuback;
case ALT_pingreq:
return *field_pingreq == *other_value.field_pingreq;
case ALT_pingresp:
return *field_pingresp == *other_value.field_pingresp;
case ALT_disconnect__msg:
return *field_disconnect__msg == *other_value.field_disconnect__msg;
default:
return FALSE;
}
}

MQTT__v3__1__1__Connect& MQTT__v3__1__1__ReqResp::connect__msg()
{
if (union_selection != ALT_connect__msg) {
clean_up();
field_connect__msg = new MQTT__v3__1__1__Connect;
union_selection = ALT_connect__msg;
}
return *field_connect__msg;
}

const MQTT__v3__1__1__Connect& MQTT__v3__1__1__ReqResp::connect__msg() const
{
if (union_selection != ALT_connect__msg) TTCN_error("Using non-selected field connect_msg in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_connect__msg;
}

MQTT__v3__1__1__Connack& MQTT__v3__1__1__ReqResp::connack()
{
if (union_selection != ALT_connack) {
clean_up();
field_connack = new MQTT__v3__1__1__Connack;
union_selection = ALT_connack;
}
return *field_connack;
}

const MQTT__v3__1__1__Connack& MQTT__v3__1__1__ReqResp::connack() const
{
if (union_selection != ALT_connack) TTCN_error("Using non-selected field connack in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_connack;
}

MQTT__v3__1__1__Publish& MQTT__v3__1__1__ReqResp::publish()
{
if (union_selection != ALT_publish) {
clean_up();
field_publish = new MQTT__v3__1__1__Publish;
union_selection = ALT_publish;
}
return *field_publish;
}

const MQTT__v3__1__1__Publish& MQTT__v3__1__1__ReqResp::publish() const
{
if (union_selection != ALT_publish) TTCN_error("Using non-selected field publish in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_publish;
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::puback()
{
if (union_selection != ALT_puback) {
clean_up();
field_puback = new MQTT__v3__1__1__Identifier;
union_selection = ALT_puback;
}
return *field_puback;
}

const MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::puback() const
{
if (union_selection != ALT_puback) TTCN_error("Using non-selected field puback in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_puback;
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubrec()
{
if (union_selection != ALT_pubrec) {
clean_up();
field_pubrec = new MQTT__v3__1__1__Identifier;
union_selection = ALT_pubrec;
}
return *field_pubrec;
}

const MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubrec() const
{
if (union_selection != ALT_pubrec) TTCN_error("Using non-selected field pubrec in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_pubrec;
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubrel()
{
if (union_selection != ALT_pubrel) {
clean_up();
field_pubrel = new MQTT__v3__1__1__Identifier;
union_selection = ALT_pubrel;
}
return *field_pubrel;
}

const MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubrel() const
{
if (union_selection != ALT_pubrel) TTCN_error("Using non-selected field pubrel in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_pubrel;
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubcomp()
{
if (union_selection != ALT_pubcomp) {
clean_up();
field_pubcomp = new MQTT__v3__1__1__Identifier;
union_selection = ALT_pubcomp;
}
return *field_pubcomp;
}

const MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::pubcomp() const
{
if (union_selection != ALT_pubcomp) TTCN_error("Using non-selected field pubcomp in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_pubcomp;
}

MQTT__v3__1__1__Subscribe& MQTT__v3__1__1__ReqResp::subscribe()
{
if (union_selection != ALT_subscribe) {
clean_up();
field_subscribe = new MQTT__v3__1__1__Subscribe;
union_selection = ALT_subscribe;
}
return *field_subscribe;
}

const MQTT__v3__1__1__Subscribe& MQTT__v3__1__1__ReqResp::subscribe() const
{
if (union_selection != ALT_subscribe) TTCN_error("Using non-selected field subscribe in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_subscribe;
}

MQTT__v3__1__1__Suback& MQTT__v3__1__1__ReqResp::suback()
{
if (union_selection != ALT_suback) {
clean_up();
field_suback = new MQTT__v3__1__1__Suback;
union_selection = ALT_suback;
}
return *field_suback;
}

const MQTT__v3__1__1__Suback& MQTT__v3__1__1__ReqResp::suback() const
{
if (union_selection != ALT_suback) TTCN_error("Using non-selected field suback in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_suback;
}

MQTT__v3__1__1__Unsubscribe& MQTT__v3__1__1__ReqResp::unsubscribe()
{
if (union_selection != ALT_unsubscribe) {
clean_up();
field_unsubscribe = new MQTT__v3__1__1__Unsubscribe;
union_selection = ALT_unsubscribe;
}
return *field_unsubscribe;
}

const MQTT__v3__1__1__Unsubscribe& MQTT__v3__1__1__ReqResp::unsubscribe() const
{
if (union_selection != ALT_unsubscribe) TTCN_error("Using non-selected field unsubscribe in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_unsubscribe;
}

MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::unsuback()
{
if (union_selection != ALT_unsuback) {
clean_up();
field_unsuback = new MQTT__v3__1__1__Identifier;
union_selection = ALT_unsuback;
}
return *field_unsuback;
}

const MQTT__v3__1__1__Identifier& MQTT__v3__1__1__ReqResp::unsuback() const
{
if (union_selection != ALT_unsuback) TTCN_error("Using non-selected field unsuback in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_unsuback;
}

MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::pingreq()
{
if (union_selection != ALT_pingreq) {
clean_up();
field_pingreq = new MQTT__v3__1__1__Empty;
union_selection = ALT_pingreq;
}
return *field_pingreq;
}

const MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::pingreq() const
{
if (union_selection != ALT_pingreq) TTCN_error("Using non-selected field pingreq in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_pingreq;
}

MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::pingresp()
{
if (union_selection != ALT_pingresp) {
clean_up();
field_pingresp = new MQTT__v3__1__1__Empty;
union_selection = ALT_pingresp;
}
return *field_pingresp;
}

const MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::pingresp() const
{
if (union_selection != ALT_pingresp) TTCN_error("Using non-selected field pingresp in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_pingresp;
}

MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::disconnect__msg()
{
if (union_selection != ALT_disconnect__msg) {
clean_up();
field_disconnect__msg = new MQTT__v3__1__1__Empty;
union_selection = ALT_disconnect__msg;
}
return *field_disconnect__msg;
}

const MQTT__v3__1__1__Empty& MQTT__v3__1__1__ReqResp::disconnect__msg() const
{
if (union_selection != ALT_disconnect__msg) TTCN_error("Using non-selected field disconnect_msg in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *field_disconnect__msg;
}

boolean MQTT__v3__1__1__ReqResp::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return union_selection == checked_selection;
}

boolean MQTT__v3__1__1__ReqResp::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean MQTT__v3__1__1__ReqResp::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_connect__msg: return field_connect__msg->is_value();
case ALT_connack: return field_connack->is_value();
case ALT_publish: return field_publish->is_value();
case ALT_puback: return field_puback->is_value();
case ALT_pubrec: return field_pubrec->is_value();
case ALT_pubrel: return field_pubrel->is_value();
case ALT_pubcomp: return field_pubcomp->is_value();
case ALT_subscribe: return field_subscribe->is_value();
case ALT_suback: return field_suback->is_value();
case ALT_unsubscribe: return field_unsubscribe->is_value();
case ALT_unsuback: return field_unsuback->is_value();
case ALT_pingreq: return field_pingreq->is_value();
case ALT_pingresp: return field_pingresp->is_value();
case ALT_disconnect__msg: return field_disconnect__msg->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void MQTT__v3__1__1__ReqResp::clean_up()
{
switch (union_selection) {
case ALT_connect__msg:
  delete field_connect__msg;
  break;
case ALT_connack:
  delete field_connack;
  break;
case ALT_publish:
  delete field_publish;
  break;
case ALT_puback:
  delete field_puback;
  break;
case ALT_pubrec:
  delete field_pubrec;
  break;
case ALT_pubrel:
  delete field_pubrel;
  break;
case ALT_pubcomp:
  delete field_pubcomp;
  break;
case ALT_subscribe:
  delete field_subscribe;
  break;
case ALT_suback:
  delete field_suback;
  break;
case ALT_unsubscribe:
  delete field_unsubscribe;
  break;
case ALT_unsuback:
  delete field_unsuback;
  break;
case ALT_pingreq:
  delete field_pingreq;
  break;
case ALT_pingresp:
  delete field_pingresp;
  break;
case ALT_disconnect__msg:
  delete field_disconnect__msg;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void MQTT__v3__1__1__ReqResp::log() const
{
switch (union_selection) {
case ALT_connect__msg:
TTCN_Logger::log_event_str("{ connect_msg := ");
field_connect__msg->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_connack:
TTCN_Logger::log_event_str("{ connack := ");
field_connack->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_publish:
TTCN_Logger::log_event_str("{ publish := ");
field_publish->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_puback:
TTCN_Logger::log_event_str("{ puback := ");
field_puback->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pubrec:
TTCN_Logger::log_event_str("{ pubrec := ");
field_pubrec->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pubrel:
TTCN_Logger::log_event_str("{ pubrel := ");
field_pubrel->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pubcomp:
TTCN_Logger::log_event_str("{ pubcomp := ");
field_pubcomp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_subscribe:
TTCN_Logger::log_event_str("{ subscribe := ");
field_subscribe->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_suback:
TTCN_Logger::log_event_str("{ suback := ");
field_suback->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unsubscribe:
TTCN_Logger::log_event_str("{ unsubscribe := ");
field_unsubscribe->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unsuback:
TTCN_Logger::log_event_str("{ unsuback := ");
field_unsuback->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pingreq:
TTCN_Logger::log_event_str("{ pingreq := ");
field_pingreq->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_pingresp:
TTCN_Logger::log_event_str("{ pingresp := ");
field_pingresp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_disconnect__msg:
TTCN_Logger::log_event_str("{ disconnect_msg := ");
field_disconnect__msg->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void MQTT__v3__1__1__ReqResp::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "connect_msg")) {
    connect__msg().set_param(*mp_last);
    if (!connect__msg().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "connack")) {
    connack().set_param(*mp_last);
    if (!connack().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "publish")) {
    publish().set_param(*mp_last);
    if (!publish().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "puback")) {
    puback().set_param(*mp_last);
    if (!puback().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "pubrec")) {
    pubrec().set_param(*mp_last);
    if (!pubrec().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "pubrel")) {
    pubrel().set_param(*mp_last);
    if (!pubrel().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "pubcomp")) {
    pubcomp().set_param(*mp_last);
    if (!pubcomp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "subscribe")) {
    subscribe().set_param(*mp_last);
    if (!subscribe().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "suback")) {
    suback().set_param(*mp_last);
    if (!suback().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unsubscribe")) {
    unsubscribe().set_param(*mp_last);
    if (!unsubscribe().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unsuback")) {
    unsuback().set_param(*mp_last);
    if (!unsuback().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "pingreq")) {
    pingreq().set_param(*mp_last);
    if (!pingreq().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "pingresp")) {
    pingresp().set_param(*mp_last);
    if (!pingresp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "disconnect_msg")) {
    disconnect__msg().set_param(*mp_last);
    if (!disconnect__msg().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.", mp_last->get_id()->get_name());
}

void MQTT__v3__1__1__ReqResp::set_implicit_omit()
{
switch (union_selection) {
case ALT_connect__msg:
field_connect__msg->set_implicit_omit(); break;
case ALT_connack:
field_connack->set_implicit_omit(); break;
case ALT_publish:
field_publish->set_implicit_omit(); break;
case ALT_puback:
field_puback->set_implicit_omit(); break;
case ALT_pubrec:
field_pubrec->set_implicit_omit(); break;
case ALT_pubrel:
field_pubrel->set_implicit_omit(); break;
case ALT_pubcomp:
field_pubcomp->set_implicit_omit(); break;
case ALT_subscribe:
field_subscribe->set_implicit_omit(); break;
case ALT_suback:
field_suback->set_implicit_omit(); break;
case ALT_unsubscribe:
field_unsubscribe->set_implicit_omit(); break;
case ALT_unsuback:
field_unsuback->set_implicit_omit(); break;
case ALT_pingreq:
field_pingreq->set_implicit_omit(); break;
case ALT_pingresp:
field_pingresp->set_implicit_omit(); break;
case ALT_disconnect__msg:
field_disconnect__msg->set_implicit_omit(); break;
default: break;
}
}

void MQTT__v3__1__1__ReqResp::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_connect__msg:
field_connect__msg->encode_text(text_buf);
break;
case ALT_connack:
field_connack->encode_text(text_buf);
break;
case ALT_publish:
field_publish->encode_text(text_buf);
break;
case ALT_puback:
field_puback->encode_text(text_buf);
break;
case ALT_pubrec:
field_pubrec->encode_text(text_buf);
break;
case ALT_pubrel:
field_pubrel->encode_text(text_buf);
break;
case ALT_pubcomp:
field_pubcomp->encode_text(text_buf);
break;
case ALT_subscribe:
field_subscribe->encode_text(text_buf);
break;
case ALT_suback:
field_suback->encode_text(text_buf);
break;
case ALT_unsubscribe:
field_unsubscribe->encode_text(text_buf);
break;
case ALT_unsuback:
field_unsuback->encode_text(text_buf);
break;
case ALT_pingreq:
field_pingreq->encode_text(text_buf);
break;
case ALT_pingresp:
field_pingresp->encode_text(text_buf);
break;
case ALT_disconnect__msg:
field_disconnect__msg->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}

void MQTT__v3__1__1__ReqResp::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_connect__msg:
connect__msg().decode_text(text_buf);
break;
case ALT_connack:
connack().decode_text(text_buf);
break;
case ALT_publish:
publish().decode_text(text_buf);
break;
case ALT_puback:
puback().decode_text(text_buf);
break;
case ALT_pubrec:
pubrec().decode_text(text_buf);
break;
case ALT_pubrel:
pubrel().decode_text(text_buf);
break;
case ALT_pubcomp:
pubcomp().decode_text(text_buf);
break;
case ALT_subscribe:
subscribe().decode_text(text_buf);
break;
case ALT_suback:
suback().decode_text(text_buf);
break;
case ALT_unsubscribe:
unsubscribe().decode_text(text_buf);
break;
case ALT_unsuback:
unsuback().decode_text(text_buf);
break;
case ALT_pingreq:
pingreq().decode_text(text_buf);
break;
case ALT_pingresp:
pingresp().decode_text(text_buf);
break;
case ALT_disconnect__msg:
disconnect__msg().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}

void MQTT__v3__1__1__ReqResp_template::copy_value(const MQTT__v3__1__1__ReqResp& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
single_value.field_connect__msg = new MQTT__v3__1__1__Connect_template(other_value.connect__msg());
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
single_value.field_connack = new MQTT__v3__1__1__Connack_template(other_value.connack());
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
single_value.field_publish = new MQTT__v3__1__1__Publish_template(other_value.publish());
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
single_value.field_puback = new MQTT__v3__1__1__Identifier_template(other_value.puback());
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
single_value.field_pubrec = new MQTT__v3__1__1__Identifier_template(other_value.pubrec());
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
single_value.field_pubrel = new MQTT__v3__1__1__Identifier_template(other_value.pubrel());
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
single_value.field_pubcomp = new MQTT__v3__1__1__Identifier_template(other_value.pubcomp());
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
single_value.field_subscribe = new MQTT__v3__1__1__Subscribe_template(other_value.subscribe());
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
single_value.field_suback = new MQTT__v3__1__1__Suback_template(other_value.suback());
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
single_value.field_unsubscribe = new MQTT__v3__1__1__Unsubscribe_template(other_value.unsubscribe());
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
single_value.field_unsuback = new MQTT__v3__1__1__Identifier_template(other_value.unsuback());
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
single_value.field_pingreq = new MQTT__v3__1__1__Empty_template(other_value.pingreq());
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
single_value.field_pingresp = new MQTT__v3__1__1__Empty_template(other_value.pingresp());
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
single_value.field_disconnect__msg = new MQTT__v3__1__1__Empty_template(other_value.disconnect__msg());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__ReqResp_template::copy_template(const MQTT__v3__1__1__ReqResp_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
single_value.field_connect__msg = new MQTT__v3__1__1__Connect_template(*other_value.single_value.field_connect__msg);
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
single_value.field_connack = new MQTT__v3__1__1__Connack_template(*other_value.single_value.field_connack);
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
single_value.field_publish = new MQTT__v3__1__1__Publish_template(*other_value.single_value.field_publish);
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
single_value.field_puback = new MQTT__v3__1__1__Identifier_template(*other_value.single_value.field_puback);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
single_value.field_pubrec = new MQTT__v3__1__1__Identifier_template(*other_value.single_value.field_pubrec);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
single_value.field_pubrel = new MQTT__v3__1__1__Identifier_template(*other_value.single_value.field_pubrel);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
single_value.field_pubcomp = new MQTT__v3__1__1__Identifier_template(*other_value.single_value.field_pubcomp);
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
single_value.field_subscribe = new MQTT__v3__1__1__Subscribe_template(*other_value.single_value.field_subscribe);
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
single_value.field_suback = new MQTT__v3__1__1__Suback_template(*other_value.single_value.field_suback);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
single_value.field_unsubscribe = new MQTT__v3__1__1__Unsubscribe_template(*other_value.single_value.field_unsubscribe);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
single_value.field_unsuback = new MQTT__v3__1__1__Identifier_template(*other_value.single_value.field_unsuback);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
single_value.field_pingreq = new MQTT__v3__1__1__Empty_template(*other_value.single_value.field_pingreq);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
single_value.field_pingresp = new MQTT__v3__1__1__Empty_template(*other_value.single_value.field_pingresp);
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
single_value.field_disconnect__msg = new MQTT__v3__1__1__Empty_template(*other_value.single_value.field_disconnect__msg);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__ReqResp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
set_selection(other_value);
}

MQTT__v3__1__1__ReqResp_template::MQTT__v3__1__1__ReqResp_template()
{
}

MQTT__v3__1__1__ReqResp_template::MQTT__v3__1__1__ReqResp_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__ReqResp_template::MQTT__v3__1__1__ReqResp_template(const MQTT__v3__1__1__ReqResp& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__ReqResp_template::MQTT__v3__1__1__ReqResp_template(const OPTIONAL<MQTT__v3__1__1__ReqResp>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ReqResp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp from an unbound optional field.");
}
}

MQTT__v3__1__1__ReqResp_template::MQTT__v3__1__1__ReqResp_template(const MQTT__v3__1__1__ReqResp_template& other_value)
: Base_Template(){
copy_template(other_value);
}

MQTT__v3__1__1__ReqResp_template::~MQTT__v3__1__1__ReqResp_template()
{
clean_up();
}

void MQTT__v3__1__1__ReqResp_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
delete single_value.field_connect__msg;
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
delete single_value.field_connack;
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
delete single_value.field_publish;
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
delete single_value.field_puback;
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
delete single_value.field_pubrec;
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
delete single_value.field_pubrel;
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
delete single_value.field_pubcomp;
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
delete single_value.field_subscribe;
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
delete single_value.field_suback;
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
delete single_value.field_unsubscribe;
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
delete single_value.field_unsuback;
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
delete single_value.field_pingreq;
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
delete single_value.field_pingresp;
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
delete single_value.field_disconnect__msg;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__ReqResp_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__ReqResp_template::operator=(const MQTT__v3__1__1__ReqResp& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__ReqResp_template::operator=(const OPTIONAL<MQTT__v3__1__1__ReqResp>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__ReqResp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
return *this;
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__ReqResp_template::operator=(const MQTT__v3__1__1__ReqResp_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__ReqResp_template::match(const MQTT__v3__1__1__ReqResp& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
MQTT__v3__1__1__ReqResp::union_selection_type value_selection = other_value.get_selection();
if (value_selection == MQTT__v3__1__1__ReqResp::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
return single_value.field_connect__msg->match(other_value.connect__msg(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_connack:
return single_value.field_connack->match(other_value.connack(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_publish:
return single_value.field_publish->match(other_value.publish(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_puback:
return single_value.field_puback->match(other_value.puback(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
return single_value.field_pubrec->match(other_value.pubrec(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
return single_value.field_pubrel->match(other_value.pubrel(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
return single_value.field_pubcomp->match(other_value.pubcomp(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
return single_value.field_subscribe->match(other_value.subscribe(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_suback:
return single_value.field_suback->match(other_value.suback(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
return single_value.field_unsubscribe->match(other_value.unsubscribe(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
return single_value.field_unsuback->match(other_value.unsuback(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
return single_value.field_pingreq->match(other_value.pingreq(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
return single_value.field_pingresp->match(other_value.pingresp(), legacy);
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
return single_value.field_disconnect__msg->match(other_value.disconnect__msg(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
return FALSE;
}

boolean MQTT__v3__1__1__ReqResp_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
return single_value.field_connect__msg->is_value();
case MQTT__v3__1__1__ReqResp::ALT_connack:
return single_value.field_connack->is_value();
case MQTT__v3__1__1__ReqResp::ALT_publish:
return single_value.field_publish->is_value();
case MQTT__v3__1__1__ReqResp::ALT_puback:
return single_value.field_puback->is_value();
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
return single_value.field_pubrec->is_value();
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
return single_value.field_pubrel->is_value();
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
return single_value.field_pubcomp->is_value();
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
return single_value.field_subscribe->is_value();
case MQTT__v3__1__1__ReqResp::ALT_suback:
return single_value.field_suback->is_value();
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
return single_value.field_unsubscribe->is_value();
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
return single_value.field_unsuback->is_value();
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
return single_value.field_pingreq->is_value();
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
return single_value.field_pingresp->is_value();
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
return single_value.field_disconnect__msg->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}

MQTT__v3__1__1__ReqResp MQTT__v3__1__1__ReqResp_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
MQTT__v3__1__1__ReqResp ret_val;
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
ret_val.connect__msg() = single_value.field_connect__msg->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
ret_val.connack() = single_value.field_connack->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
ret_val.publish() = single_value.field_publish->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
ret_val.puback() = single_value.field_puback->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
ret_val.pubrec() = single_value.field_pubrec->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
ret_val.pubrel() = single_value.field_pubrel->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
ret_val.pubcomp() = single_value.field_pubcomp->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
ret_val.subscribe() = single_value.field_subscribe->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
ret_val.suback() = single_value.field_suback->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
ret_val.unsubscribe() = single_value.field_unsubscribe->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
ret_val.unsuback() = single_value.field_unsuback->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
ret_val.pingreq() = single_value.field_pingreq->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
ret_val.pingresp() = single_value.field_pingresp->valueof();
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
ret_val.disconnect__msg() = single_value.field_disconnect__msg->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
return ret_val;
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__ReqResp_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return value_list.list_value[list_index];
}
void MQTT__v3__1__1__ReqResp_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__ReqResp_template[list_length];
}

MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__ReqResp_template::connect__msg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_connect__msg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_connect__msg = new MQTT__v3__1__1__Connect_template(ANY_VALUE);
else single_value.field_connect__msg = new MQTT__v3__1__1__Connect_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_connect__msg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_connect__msg;
}

const MQTT__v3__1__1__Connect_template& MQTT__v3__1__1__ReqResp_template::connect__msg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field connect_msg in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_connect__msg) TTCN_error("Accessing non-selected field connect_msg in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_connect__msg;
}

MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__ReqResp_template::connack()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_connack) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_connack = new MQTT__v3__1__1__Connack_template(ANY_VALUE);
else single_value.field_connack = new MQTT__v3__1__1__Connack_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_connack;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_connack;
}

const MQTT__v3__1__1__Connack_template& MQTT__v3__1__1__ReqResp_template::connack() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field connack in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_connack) TTCN_error("Accessing non-selected field connack in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_connack;
}

MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__ReqResp_template::publish()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_publish) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_publish = new MQTT__v3__1__1__Publish_template(ANY_VALUE);
else single_value.field_publish = new MQTT__v3__1__1__Publish_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_publish;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_publish;
}

const MQTT__v3__1__1__Publish_template& MQTT__v3__1__1__ReqResp_template::publish() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field publish in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_publish) TTCN_error("Accessing non-selected field publish in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_publish;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::puback()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_puback) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_puback = new MQTT__v3__1__1__Identifier_template(ANY_VALUE);
else single_value.field_puback = new MQTT__v3__1__1__Identifier_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_puback;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_puback;
}

const MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::puback() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field puback in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_puback) TTCN_error("Accessing non-selected field puback in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_puback;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubrec()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubrec) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pubrec = new MQTT__v3__1__1__Identifier_template(ANY_VALUE);
else single_value.field_pubrec = new MQTT__v3__1__1__Identifier_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_pubrec;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pubrec;
}

const MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubrec() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pubrec in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubrec) TTCN_error("Accessing non-selected field pubrec in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_pubrec;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubrel()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubrel) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pubrel = new MQTT__v3__1__1__Identifier_template(ANY_VALUE);
else single_value.field_pubrel = new MQTT__v3__1__1__Identifier_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_pubrel;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pubrel;
}

const MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubrel() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pubrel in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubrel) TTCN_error("Accessing non-selected field pubrel in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_pubrel;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubcomp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubcomp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pubcomp = new MQTT__v3__1__1__Identifier_template(ANY_VALUE);
else single_value.field_pubcomp = new MQTT__v3__1__1__Identifier_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_pubcomp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pubcomp;
}

const MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::pubcomp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pubcomp in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pubcomp) TTCN_error("Accessing non-selected field pubcomp in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_pubcomp;
}

MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__ReqResp_template::subscribe()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_subscribe) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_subscribe = new MQTT__v3__1__1__Subscribe_template(ANY_VALUE);
else single_value.field_subscribe = new MQTT__v3__1__1__Subscribe_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_subscribe;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_subscribe;
}

const MQTT__v3__1__1__Subscribe_template& MQTT__v3__1__1__ReqResp_template::subscribe() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field subscribe in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_subscribe) TTCN_error("Accessing non-selected field subscribe in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_subscribe;
}

MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__ReqResp_template::suback()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_suback) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_suback = new MQTT__v3__1__1__Suback_template(ANY_VALUE);
else single_value.field_suback = new MQTT__v3__1__1__Suback_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_suback;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_suback;
}

const MQTT__v3__1__1__Suback_template& MQTT__v3__1__1__ReqResp_template::suback() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field suback in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_suback) TTCN_error("Accessing non-selected field suback in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_suback;
}

MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__ReqResp_template::unsubscribe()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_unsubscribe) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unsubscribe = new MQTT__v3__1__1__Unsubscribe_template(ANY_VALUE);
else single_value.field_unsubscribe = new MQTT__v3__1__1__Unsubscribe_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_unsubscribe;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unsubscribe;
}

const MQTT__v3__1__1__Unsubscribe_template& MQTT__v3__1__1__ReqResp_template::unsubscribe() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unsubscribe in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_unsubscribe) TTCN_error("Accessing non-selected field unsubscribe in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_unsubscribe;
}

MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::unsuback()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_unsuback) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unsuback = new MQTT__v3__1__1__Identifier_template(ANY_VALUE);
else single_value.field_unsuback = new MQTT__v3__1__1__Identifier_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_unsuback;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unsuback;
}

const MQTT__v3__1__1__Identifier_template& MQTT__v3__1__1__ReqResp_template::unsuback() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unsuback in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_unsuback) TTCN_error("Accessing non-selected field unsuback in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_unsuback;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::pingreq()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pingreq) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pingreq = new MQTT__v3__1__1__Empty_template(ANY_VALUE);
else single_value.field_pingreq = new MQTT__v3__1__1__Empty_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_pingreq;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pingreq;
}

const MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::pingreq() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pingreq in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pingreq) TTCN_error("Accessing non-selected field pingreq in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_pingreq;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::pingresp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pingresp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_pingresp = new MQTT__v3__1__1__Empty_template(ANY_VALUE);
else single_value.field_pingresp = new MQTT__v3__1__1__Empty_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_pingresp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_pingresp;
}

const MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::pingresp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field pingresp in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_pingresp) TTCN_error("Accessing non-selected field pingresp in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_pingresp;
}

MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::disconnect__msg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_disconnect__msg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_disconnect__msg = new MQTT__v3__1__1__Empty_template(ANY_VALUE);
else single_value.field_disconnect__msg = new MQTT__v3__1__1__Empty_template;
single_value.union_selection = MQTT__v3__1__1__ReqResp::ALT_disconnect__msg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_disconnect__msg;
}

const MQTT__v3__1__1__Empty_template& MQTT__v3__1__1__ReqResp_template::disconnect__msg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field disconnect_msg in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
if (single_value.union_selection != MQTT__v3__1__1__ReqResp::ALT_disconnect__msg) TTCN_error("Accessing non-selected field disconnect_msg in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return *single_value.field_disconnect__msg;
}

boolean MQTT__v3__1__1__ReqResp_template::ischosen(MQTT__v3__1__1__ReqResp::union_selection_type checked_selection) const
{
if (checked_selection == MQTT__v3__1__1__ReqResp::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == MQTT__v3__1__1__ReqResp::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
}
return FALSE;
}

void MQTT__v3__1__1__ReqResp_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
TTCN_Logger::log_event_str("{ connect_msg := ");
single_value.field_connect__msg->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
TTCN_Logger::log_event_str("{ connack := ");
single_value.field_connack->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
TTCN_Logger::log_event_str("{ publish := ");
single_value.field_publish->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
TTCN_Logger::log_event_str("{ puback := ");
single_value.field_puback->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
TTCN_Logger::log_event_str("{ pubrec := ");
single_value.field_pubrec->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
TTCN_Logger::log_event_str("{ pubrel := ");
single_value.field_pubrel->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
TTCN_Logger::log_event_str("{ pubcomp := ");
single_value.field_pubcomp->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
TTCN_Logger::log_event_str("{ subscribe := ");
single_value.field_subscribe->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
TTCN_Logger::log_event_str("{ suback := ");
single_value.field_suback->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
TTCN_Logger::log_event_str("{ unsubscribe := ");
single_value.field_unsubscribe->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
TTCN_Logger::log_event_str("{ unsuback := ");
single_value.field_unsuback->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
TTCN_Logger::log_event_str("{ pingreq := ");
single_value.field_pingreq->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
TTCN_Logger::log_event_str("{ pingresp := ");
single_value.field_pingresp->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
TTCN_Logger::log_event_str("{ disconnect_msg := ");
single_value.field_disconnect__msg->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__ReqResp_template::log_match(const MQTT__v3__1__1__ReqResp& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".connect_msg");
single_value.field_connect__msg->log_match(match_value.connect__msg(), legacy);
} else {
TTCN_Logger::log_event_str("{ connect_msg := ");
single_value.field_connect__msg->log_match(match_value.connect__msg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".connack");
single_value.field_connack->log_match(match_value.connack(), legacy);
} else {
TTCN_Logger::log_event_str("{ connack := ");
single_value.field_connack->log_match(match_value.connack(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".publish");
single_value.field_publish->log_match(match_value.publish(), legacy);
} else {
TTCN_Logger::log_event_str("{ publish := ");
single_value.field_publish->log_match(match_value.publish(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".puback");
single_value.field_puback->log_match(match_value.puback(), legacy);
} else {
TTCN_Logger::log_event_str("{ puback := ");
single_value.field_puback->log_match(match_value.puback(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pubrec");
single_value.field_pubrec->log_match(match_value.pubrec(), legacy);
} else {
TTCN_Logger::log_event_str("{ pubrec := ");
single_value.field_pubrec->log_match(match_value.pubrec(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pubrel");
single_value.field_pubrel->log_match(match_value.pubrel(), legacy);
} else {
TTCN_Logger::log_event_str("{ pubrel := ");
single_value.field_pubrel->log_match(match_value.pubrel(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pubcomp");
single_value.field_pubcomp->log_match(match_value.pubcomp(), legacy);
} else {
TTCN_Logger::log_event_str("{ pubcomp := ");
single_value.field_pubcomp->log_match(match_value.pubcomp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".subscribe");
single_value.field_subscribe->log_match(match_value.subscribe(), legacy);
} else {
TTCN_Logger::log_event_str("{ subscribe := ");
single_value.field_subscribe->log_match(match_value.subscribe(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".suback");
single_value.field_suback->log_match(match_value.suback(), legacy);
} else {
TTCN_Logger::log_event_str("{ suback := ");
single_value.field_suback->log_match(match_value.suback(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unsubscribe");
single_value.field_unsubscribe->log_match(match_value.unsubscribe(), legacy);
} else {
TTCN_Logger::log_event_str("{ unsubscribe := ");
single_value.field_unsubscribe->log_match(match_value.unsubscribe(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unsuback");
single_value.field_unsuback->log_match(match_value.unsuback(), legacy);
} else {
TTCN_Logger::log_event_str("{ unsuback := ");
single_value.field_unsuback->log_match(match_value.unsuback(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pingreq");
single_value.field_pingreq->log_match(match_value.pingreq(), legacy);
} else {
TTCN_Logger::log_event_str("{ pingreq := ");
single_value.field_pingreq->log_match(match_value.pingreq(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".pingresp");
single_value.field_pingresp->log_match(match_value.pingresp(), legacy);
} else {
TTCN_Logger::log_event_str("{ pingresp := ");
single_value.field_pingresp->log_match(match_value.pingresp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".disconnect_msg");
single_value.field_disconnect__msg->log_match(match_value.disconnect__msg(), legacy);
} else {
TTCN_Logger::log_event_str("{ disconnect_msg := ");
single_value.field_disconnect__msg->log_match(match_value.disconnect__msg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__ReqResp_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
single_value.field_connect__msg->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
single_value.field_connack->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
single_value.field_publish->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
single_value.field_puback->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
single_value.field_pubrec->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
single_value.field_pubrel->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
single_value.field_pubcomp->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
single_value.field_subscribe->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
single_value.field_suback->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
single_value.field_unsubscribe->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
single_value.field_unsuback->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
single_value.field_pingreq->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
single_value.field_pingresp->encode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
single_value.field_disconnect__msg->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}

void MQTT__v3__1__1__ReqResp_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = MQTT__v3__1__1__ReqResp::UNBOUND_VALUE;
MQTT__v3__1__1__ReqResp::union_selection_type new_selection = (MQTT__v3__1__1__ReqResp::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
single_value.field_connect__msg = new MQTT__v3__1__1__Connect_template;
single_value.field_connect__msg->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_connack:
single_value.field_connack = new MQTT__v3__1__1__Connack_template;
single_value.field_connack->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_publish:
single_value.field_publish = new MQTT__v3__1__1__Publish_template;
single_value.field_publish->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_puback:
single_value.field_puback = new MQTT__v3__1__1__Identifier_template;
single_value.field_puback->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
single_value.field_pubrec = new MQTT__v3__1__1__Identifier_template;
single_value.field_pubrec->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
single_value.field_pubrel = new MQTT__v3__1__1__Identifier_template;
single_value.field_pubrel->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
single_value.field_pubcomp = new MQTT__v3__1__1__Identifier_template;
single_value.field_pubcomp->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
single_value.field_subscribe = new MQTT__v3__1__1__Subscribe_template;
single_value.field_subscribe->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_suback:
single_value.field_suback = new MQTT__v3__1__1__Suback_template;
single_value.field_suback->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
single_value.field_unsubscribe = new MQTT__v3__1__1__Unsubscribe_template;
single_value.field_unsubscribe->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
single_value.field_unsuback = new MQTT__v3__1__1__Identifier_template;
single_value.field_unsuback->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
single_value.field_pingreq = new MQTT__v3__1__1__Empty_template;
single_value.field_pingreq->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
single_value.field_pingresp = new MQTT__v3__1__1__Empty_template;
single_value.field_pingresp->decode_text(text_buf);
break;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
single_value.field_disconnect__msg = new MQTT__v3__1__1__Empty_template;
single_value.field_disconnect__msg->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__ReqResp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
}

boolean MQTT__v3__1__1__ReqResp_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__ReqResp_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MQTT__v3__1__1__ReqResp_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp'");
    }
    if (strcmp("connect_msg", param_field) == 0) {
      connect__msg().set_param(param);
      return;
    } else if (strcmp("connack", param_field) == 0) {
      connack().set_param(param);
      return;
    } else if (strcmp("publish", param_field) == 0) {
      publish().set_param(param);
      return;
    } else if (strcmp("puback", param_field) == 0) {
      puback().set_param(param);
      return;
    } else if (strcmp("pubrec", param_field) == 0) {
      pubrec().set_param(param);
      return;
    } else if (strcmp("pubrel", param_field) == 0) {
      pubrel().set_param(param);
      return;
    } else if (strcmp("pubcomp", param_field) == 0) {
      pubcomp().set_param(param);
      return;
    } else if (strcmp("subscribe", param_field) == 0) {
      subscribe().set_param(param);
      return;
    } else if (strcmp("suback", param_field) == 0) {
      suback().set_param(param);
      return;
    } else if (strcmp("unsubscribe", param_field) == 0) {
      unsubscribe().set_param(param);
      return;
    } else if (strcmp("unsuback", param_field) == 0) {
      unsuback().set_param(param);
      return;
    } else if (strcmp("pingreq", param_field) == 0) {
      pingreq().set_param(param);
      return;
    } else if (strcmp("pingresp", param_field) == 0) {
      pingresp().set_param(param);
      return;
    } else if (strcmp("disconnect_msg", param_field) == 0) {
      disconnect__msg().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__ReqResp_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "connect_msg")) {
      connect__msg().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "connack")) {
      connack().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "publish")) {
      publish().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "puback")) {
      puback().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "pubrec")) {
      pubrec().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "pubrel")) {
      pubrel().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "pubcomp")) {
      pubcomp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "subscribe")) {
      subscribe().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "suback")) {
      suback().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unsubscribe")) {
      unsubscribe().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unsuback")) {
      unsuback().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "pingreq")) {
      pingreq().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "pingresp")) {
      pingresp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "disconnect_msg")) {
      disconnect__msg().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__ReqResp_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case MQTT__v3__1__1__ReqResp::ALT_connect__msg:
single_value.field_connect__msg->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_connack:
single_value.field_connack->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_publish:
single_value.field_publish->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_puback:
single_value.field_puback->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_pubrec:
single_value.field_pubrec->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_pubrel:
single_value.field_pubrel->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_pubcomp:
single_value.field_pubcomp->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_subscribe:
single_value.field_subscribe->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_suback:
single_value.field_suback->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_unsubscribe:
single_value.field_unsubscribe->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_unsuback:
single_value.field_unsuback->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_pingreq:
single_value.field_pingreq->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_pingresp:
single_value.field_pingresp->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
case MQTT__v3__1__1__ReqResp::ALT_disconnect__msg:
single_value.field_disconnect__msg->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_ReqResp");
}

void MQTT__v3__1__1__Message::copy_value(const MQTT__v3__1__1__Message& other_value)
{
switch (other_value.union_selection) {
case ALT_msg:
field_msg = new MQTT__v3__1__1__ReqResp(*other_value.field_msg);
break;
case ALT_raw__message:
field_raw__message = new OCTETSTRING(*other_value.field_raw__message);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
union_selection = other_value.union_selection;
}

MQTT__v3__1__1__Message::MQTT__v3__1__1__Message()
{
union_selection = UNBOUND_VALUE;
}

MQTT__v3__1__1__Message::MQTT__v3__1__1__Message(const MQTT__v3__1__1__Message& other_value)
: Base_Type(){
copy_value(other_value);
}

MQTT__v3__1__1__Message::~MQTT__v3__1__1__Message()
{
clean_up();
}

MQTT__v3__1__1__Message& MQTT__v3__1__1__Message::operator=(const MQTT__v3__1__1__Message& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Message::operator==(const MQTT__v3__1__1__Message& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_msg:
return *field_msg == *other_value.field_msg;
case ALT_raw__message:
return *field_raw__message == *other_value.field_raw__message;
default:
return FALSE;
}
}

MQTT__v3__1__1__ReqResp& MQTT__v3__1__1__Message::msg()
{
if (union_selection != ALT_msg) {
clean_up();
field_msg = new MQTT__v3__1__1__ReqResp;
union_selection = ALT_msg;
}
return *field_msg;
}

const MQTT__v3__1__1__ReqResp& MQTT__v3__1__1__Message::msg() const
{
if (union_selection != ALT_msg) TTCN_error("Using non-selected field msg in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return *field_msg;
}

OCTETSTRING& MQTT__v3__1__1__Message::raw__message()
{
if (union_selection != ALT_raw__message) {
clean_up();
field_raw__message = new OCTETSTRING;
union_selection = ALT_raw__message;
}
return *field_raw__message;
}

const OCTETSTRING& MQTT__v3__1__1__Message::raw__message() const
{
if (union_selection != ALT_raw__message) TTCN_error("Using non-selected field raw_message in a value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return *field_raw__message;
}

boolean MQTT__v3__1__1__Message::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return union_selection == checked_selection;
}

boolean MQTT__v3__1__1__Message::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean MQTT__v3__1__1__Message::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_msg: return field_msg->is_value();
case ALT_raw__message: return field_raw__message->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void MQTT__v3__1__1__Message::clean_up()
{
switch (union_selection) {
case ALT_msg:
  delete field_msg;
  break;
case ALT_raw__message:
  delete field_raw__message;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void MQTT__v3__1__1__Message::log() const
{
switch (union_selection) {
case ALT_msg:
TTCN_Logger::log_event_str("{ msg := ");
field_msg->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_raw__message:
TTCN_Logger::log_event_str("{ raw_message := ");
field_raw__message->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void MQTT__v3__1__1__Message::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "msg")) {
    msg().set_param(*mp_last);
    if (!msg().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "raw_message")) {
    raw__message().set_param(*mp_last);
    if (!raw__message().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.", mp_last->get_id()->get_name());
}

void MQTT__v3__1__1__Message::set_implicit_omit()
{
switch (union_selection) {
case ALT_msg:
field_msg->set_implicit_omit(); break;
case ALT_raw__message:
field_raw__message->set_implicit_omit(); break;
default: break;
}
}

void MQTT__v3__1__1__Message::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_msg:
field_msg->encode_text(text_buf);
break;
case ALT_raw__message:
field_raw__message->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}

void MQTT__v3__1__1__Message::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_msg:
msg().decode_text(text_buf);
break;
case ALT_raw__message:
raw__message().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}

void MQTT__v3__1__1__Message_template::copy_value(const MQTT__v3__1__1__Message& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
single_value.field_msg = new MQTT__v3__1__1__ReqResp_template(other_value.msg());
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template(other_value.raw__message());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
set_selection(SPECIFIC_VALUE);
}

void MQTT__v3__1__1__Message_template::copy_template(const MQTT__v3__1__1__Message_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
single_value.field_msg = new MQTT__v3__1__1__ReqResp_template(*other_value.single_value.field_msg);
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template(*other_value.single_value.field_raw__message);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MQTT__v3__1__1__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
set_selection(other_value);
}

MQTT__v3__1__1__Message_template::MQTT__v3__1__1__Message_template()
{
}

MQTT__v3__1__1__Message_template::MQTT__v3__1__1__Message_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MQTT__v3__1__1__Message_template::MQTT__v3__1__1__Message_template(const MQTT__v3__1__1__Message& other_value)
{
copy_value(other_value);
}

MQTT__v3__1__1__Message_template::MQTT__v3__1__1__Message_template(const OPTIONAL<MQTT__v3__1__1__Message>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message from an unbound optional field.");
}
}

MQTT__v3__1__1__Message_template::MQTT__v3__1__1__Message_template(const MQTT__v3__1__1__Message_template& other_value)
: Base_Template(){
copy_template(other_value);
}

MQTT__v3__1__1__Message_template::~MQTT__v3__1__1__Message_template()
{
clean_up();
}

void MQTT__v3__1__1__Message_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
delete single_value.field_msg;
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
delete single_value.field_raw__message;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MQTT__v3__1__1__Message_template& MQTT__v3__1__1__Message_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MQTT__v3__1__1__Message_template& MQTT__v3__1__1__Message_template::operator=(const MQTT__v3__1__1__Message& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MQTT__v3__1__1__Message_template& MQTT__v3__1__1__Message_template::operator=(const OPTIONAL<MQTT__v3__1__1__Message>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MQTT__v3__1__1__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
return *this;
}

MQTT__v3__1__1__Message_template& MQTT__v3__1__1__Message_template::operator=(const MQTT__v3__1__1__Message_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MQTT__v3__1__1__Message_template::match(const MQTT__v3__1__1__Message& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
MQTT__v3__1__1__Message::union_selection_type value_selection = other_value.get_selection();
if (value_selection == MQTT__v3__1__1__Message::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
return single_value.field_msg->match(other_value.msg(), legacy);
case MQTT__v3__1__1__Message::ALT_raw__message:
return single_value.field_raw__message->match(other_value.raw__message(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
return FALSE;
}

boolean MQTT__v3__1__1__Message_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
return single_value.field_msg->is_value();
case MQTT__v3__1__1__Message::ALT_raw__message:
return single_value.field_raw__message->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}

MQTT__v3__1__1__Message MQTT__v3__1__1__Message_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
MQTT__v3__1__1__Message ret_val;
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
ret_val.msg() = single_value.field_msg->valueof();
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
ret_val.raw__message() = single_value.field_raw__message->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
return ret_val;
}

MQTT__v3__1__1__Message_template& MQTT__v3__1__1__Message_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return value_list.list_value[list_index];
}
void MQTT__v3__1__1__Message_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MQTT__v3__1__1__Message_template[list_length];
}

MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__Message_template::msg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__Message::ALT_msg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_msg = new MQTT__v3__1__1__ReqResp_template(ANY_VALUE);
else single_value.field_msg = new MQTT__v3__1__1__ReqResp_template;
single_value.union_selection = MQTT__v3__1__1__Message::ALT_msg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_msg;
}

const MQTT__v3__1__1__ReqResp_template& MQTT__v3__1__1__Message_template::msg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field msg in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (single_value.union_selection != MQTT__v3__1__1__Message::ALT_msg) TTCN_error("Accessing non-selected field msg in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return *single_value.field_msg;
}

OCTETSTRING_template& MQTT__v3__1__1__Message_template::raw__message()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != MQTT__v3__1__1__Message::ALT_raw__message) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__message = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__message = new OCTETSTRING_template;
single_value.union_selection = MQTT__v3__1__1__Message::ALT_raw__message;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__message;
}

const OCTETSTRING_template& MQTT__v3__1__1__Message_template::raw__message() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_message in a non-specific template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
if (single_value.union_selection != MQTT__v3__1__1__Message::ALT_raw__message) TTCN_error("Accessing non-selected field raw_message in a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return *single_value.field_raw__message;
}

boolean MQTT__v3__1__1__Message_template::ischosen(MQTT__v3__1__1__Message::union_selection_type checked_selection) const
{
if (checked_selection == MQTT__v3__1__1__Message::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == MQTT__v3__1__1__Message::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
}
return FALSE;
}

void MQTT__v3__1__1__Message_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
TTCN_Logger::log_event_str("{ msg := ");
single_value.field_msg->log();
TTCN_Logger::log_event_str(" }");
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
TTCN_Logger::log_event_str("{ raw_message := ");
single_value.field_raw__message->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MQTT__v3__1__1__Message_template::log_match(const MQTT__v3__1__1__Message& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".msg");
single_value.field_msg->log_match(match_value.msg(), legacy);
} else {
TTCN_Logger::log_event_str("{ msg := ");
single_value.field_msg->log_match(match_value.msg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_message");
single_value.field_raw__message->log_match(match_value.raw__message(), legacy);
} else {
TTCN_Logger::log_event_str("{ raw_message := ");
single_value.field_raw__message->log_match(match_value.raw__message(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MQTT__v3__1__1__Message_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
single_value.field_msg->encode_text(text_buf);
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
single_value.field_raw__message->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}

void MQTT__v3__1__1__Message_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = MQTT__v3__1__1__Message::UNBOUND_VALUE;
MQTT__v3__1__1__Message::union_selection_type new_selection = (MQTT__v3__1__1__Message::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
single_value.field_msg = new MQTT__v3__1__1__ReqResp_template;
single_value.field_msg->decode_text(text_buf);
break;
case MQTT__v3__1__1__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template;
single_value.field_raw__message->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MQTT__v3__1__1__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
}

boolean MQTT__v3__1__1__Message_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MQTT__v3__1__1__Message_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void MQTT__v3__1__1__Message_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message'");
    }
    if (strcmp("msg", param_field) == 0) {
      msg().set_param(param);
      return;
    } else if (strcmp("raw_message", param_field) == 0) {
      raw__message().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MQTT__v3__1__1__Message_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "msg")) {
      msg().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "raw_message")) {
      raw__message().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
  }
  is_ifpresent = param.get_ifpresent();
}

void MQTT__v3__1__1__Message_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case MQTT__v3__1__1__Message::ALT_msg:
single_value.field_msg->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
return;
case MQTT__v3__1__1__Message::ALT_raw__message:
single_value.field_raw__message->check_restriction(t_res, t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Mqtt_v3_1_1_Types.MQTT_v3_1_1_Message");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const MQTT__v3__1__1__SubscribePayloadList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @Mqtt_v3_1_1_Types.MQTT_v3_1_1_SubscribePayloadList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../oneM2MTester/ProtocolModules/MQTT/Mqtt_v3_1_1_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "Mqtt_v3_1_1_Types");
module_object.add_function("f_MQTT_v3_1_1_enc", (genericfunc_t)&f__MQTT__v3__1__1__enc, NULL);
module_object.add_function("f_MQTT_v3_1_1_dec", (genericfunc_t)&f__MQTT__v3__1__1__dec, NULL);
}


} /* end of namespace */
