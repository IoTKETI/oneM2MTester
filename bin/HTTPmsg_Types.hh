// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef HTTPmsg__Types_HH
#define HTTPmsg__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef HTTPmsg__Types_HH
#endif

namespace HTTPmsg__Types {

/* Forward declarations of classes */

class strict__crlf__mode;
class strict__crlf__mode_template;
class HeaderLine;
class HeaderLine_template;
class HeaderLines;
class HeaderLines_template;
class HTTPResponse;
class HTTPResponse_template;
class HTTPRequest;
class HTTPRequest_template;
class HTTPResponse__binary__body;
class HTTPResponse__binary__body_template;
class HTTPRequest__binary__body;
class HTTPRequest__binary__body_template;
class HTTP__erronous__msg;
class HTTP__erronous__msg_template;
class HTTPMessage;
class HTTPMessage_template;
class Close;
class Close_template;
class Connect;
class Connect_template;
class Connect__result;
class Connect__result_template;
class Client__connected;
class Client__connected_template;
class Half__close;
class Half__close_template;
class Listen;
class Listen_template;
class Listen__result;
class Listen__result_template;
class Shutdown;
class Shutdown_template;

} /* end of namespace */

#ifndef HTTPmsg__Types_HH
#define HTTPmsg__Types_HH

namespace HTTPmsg__Types {

/* Class definitions */

class strict__crlf__mode : public Base_Type { // enum
friend class strict__crlf__mode_template;
public:
enum enum_type { ERROR_ = 0, WARNING = 1, WARNING__ONCE = 2, ACCEPT = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
strict__crlf__mode();
strict__crlf__mode(int other_value);
strict__crlf__mode(enum_type other_value);
strict__crlf__mode(const strict__crlf__mode& other_value);

strict__crlf__mode& operator=(int other_value);
strict__crlf__mode& operator=(enum_type other_value);
strict__crlf__mode& operator=(const strict__crlf__mode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const strict__crlf__mode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const strict__crlf__mode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const strict__crlf__mode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const strict__crlf__mode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const strict__crlf__mode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const strict__crlf__mode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const strict__crlf__mode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class strict__crlf__mode_template : public Base_Template {
union {
strict__crlf__mode::enum_type single_value;
struct {
unsigned int n_values;
strict__crlf__mode_template *list_value;
} value_list;
};

void copy_template(const strict__crlf__mode_template& other_value);

public:
strict__crlf__mode_template();
strict__crlf__mode_template(template_sel other_value);
strict__crlf__mode_template(int other_value);
strict__crlf__mode_template(strict__crlf__mode::enum_type other_value);
strict__crlf__mode_template(const strict__crlf__mode& other_value);
strict__crlf__mode_template(const OPTIONAL<strict__crlf__mode>& other_value);
strict__crlf__mode_template(const strict__crlf__mode_template& other_value);
~strict__crlf__mode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
strict__crlf__mode_template& operator=(template_sel other_value);
strict__crlf__mode_template& operator=(int other_value);
strict__crlf__mode_template& operator=(strict__crlf__mode::enum_type other_value);
strict__crlf__mode_template& operator=(const strict__crlf__mode& other_value);
strict__crlf__mode_template& operator=(const OPTIONAL<strict__crlf__mode>& other_value);
strict__crlf__mode_template& operator=(const strict__crlf__mode_template& other_value);

boolean match(strict__crlf__mode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const strict__crlf__mode& other_value, boolean legacy = FALSE) const;
strict__crlf__mode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
strict__crlf__mode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const strict__crlf__mode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderLine {
  CHARSTRING field_header__name;
  CHARSTRING field_header__value;
public:
  HeaderLine();
  HeaderLine(const CHARSTRING& par_header__name,
    const CHARSTRING& par_header__value);
  HeaderLine(const HeaderLine& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HeaderLine& operator=(const HeaderLine& other_value);
  boolean operator==(const HeaderLine& other_value) const;
  inline boolean operator!=(const HeaderLine& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& header__name()
    {return field_header__name;}
  inline const CHARSTRING& header__name() const
    {return field_header__name;}
  inline CHARSTRING& header__value()
    {return field_header__value;}
  inline const CHARSTRING& header__value() const
    {return field_header__value;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HeaderLine_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HeaderLine_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HeaderLine& other_value);
void copy_template(const HeaderLine_template& other_value);

public:
HeaderLine_template();
HeaderLine_template(template_sel other_value);
HeaderLine_template(const HeaderLine& other_value);
HeaderLine_template(const OPTIONAL<HeaderLine>& other_value);
HeaderLine_template(const HeaderLine_template& other_value);
~HeaderLine_template();
HeaderLine_template& operator=(template_sel other_value);
HeaderLine_template& operator=(const HeaderLine& other_value);
HeaderLine_template& operator=(const OPTIONAL<HeaderLine>& other_value);
HeaderLine_template& operator=(const HeaderLine_template& other_value);
boolean match(const HeaderLine& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderLine valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderLine_template& list_item(unsigned int list_index) const;
CHARSTRING_template& header__name();
const CHARSTRING_template& header__name() const;
CHARSTRING_template& header__value();
const CHARSTRING_template& header__value() const;
int size_of() const;
void log() const;
void log_match(const HeaderLine& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderLines : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HeaderLine **value_elements;
} *val_ptr;

static const HeaderLine UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const HeaderLines& other_value);

public:
  typedef HeaderLine of_type;
HeaderLines();
HeaderLines(null_type other_value);
HeaderLines(const HeaderLines& other_value);
~HeaderLines();

void clean_up();
HeaderLines& operator=(null_type other_value);
HeaderLines& operator=(const HeaderLines& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const HeaderLines& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderLines& other_value) const { return !(*this == other_value); }

HeaderLine& operator[](int index_value);
HeaderLine& operator[](const INTEGER& index_value);
const HeaderLine& operator[](int index_value) const;
const HeaderLine& operator[](const INTEGER& index_value) const;

HeaderLines operator<<=(int rotate_count) const;
HeaderLines operator<<=(const INTEGER& rotate_count) const;
HeaderLines operator>>=(int rotate_count) const;
HeaderLines operator>>=(const INTEGER& rotate_count) const;

HeaderLines operator+(const HeaderLines& other_value) const;

HeaderLines substr(int index, int returncount) const;

HeaderLines replace(int index, int len, const HeaderLines& repl) const;

HeaderLines replace(int index, int len, const HeaderLines_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class HeaderLines_template : public Record_Of_Template {
union {
struct {
int n_elements;
HeaderLine_template **value_elements;
} single_value;
struct {
unsigned int n_values;
HeaderLines_template *list_value;
} value_list;
};
void copy_value(const HeaderLines& other_value);
void copy_template(const HeaderLines_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
HeaderLines_template();
HeaderLines_template(template_sel other_value);
HeaderLines_template(null_type other_value);
HeaderLines_template(const HeaderLines& other_value);
HeaderLines_template(const OPTIONAL<HeaderLines>& other_value);
HeaderLines_template(const HeaderLines_template& other_value);
~HeaderLines_template();

void clean_up();
HeaderLines_template& operator=(template_sel other_value);
HeaderLines_template& operator=(null_type other_value);
HeaderLines_template& operator=(const HeaderLines& other_value);
HeaderLines_template& operator=(const OPTIONAL<HeaderLines>& other_value);
HeaderLines_template& operator=(const HeaderLines_template& other_value);

HeaderLine_template& operator[](int index_value);
HeaderLine_template& operator[](const INTEGER& index_value);
const HeaderLine_template& operator[](int index_value) const;
const HeaderLine_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const HeaderLines& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
HeaderLines valueof() const;
HeaderLines substr(int index, int returncount) const;

HeaderLines replace(int index, int len, const HeaderLines_template& repl) const;

HeaderLines replace(int index, int len, const HeaderLines& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
HeaderLines_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderLines& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class HTTPResponse {
  OPTIONAL<INTEGER> field_client__id;
  INTEGER field_version__major;
  INTEGER field_version__minor;
  INTEGER field_statuscode;
  CHARSTRING field_statustext;
  HeaderLines field_header;
  CHARSTRING field_body;
public:
  HTTPResponse();
  HTTPResponse(const OPTIONAL<INTEGER>& par_client__id,
    const INTEGER& par_version__major,
    const INTEGER& par_version__minor,
    const INTEGER& par_statuscode,
    const CHARSTRING& par_statustext,
    const HeaderLines& par_header,
    const CHARSTRING& par_body);
  HTTPResponse(const HTTPResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HTTPResponse& operator=(const HTTPResponse& other_value);
  boolean operator==(const HTTPResponse& other_value) const;
  inline boolean operator!=(const HTTPResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  inline INTEGER& version__major()
    {return field_version__major;}
  inline const INTEGER& version__major() const
    {return field_version__major;}
  inline INTEGER& version__minor()
    {return field_version__minor;}
  inline const INTEGER& version__minor() const
    {return field_version__minor;}
  inline INTEGER& statuscode()
    {return field_statuscode;}
  inline const INTEGER& statuscode() const
    {return field_statuscode;}
  inline CHARSTRING& statustext()
    {return field_statustext;}
  inline const CHARSTRING& statustext() const
    {return field_statustext;}
  inline HeaderLines& header()
    {return field_header;}
  inline const HeaderLines& header() const
    {return field_header;}
  inline CHARSTRING& body()
    {return field_body;}
  inline const CHARSTRING& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HTTPResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HTTPResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HTTPResponse& other_value);
void copy_template(const HTTPResponse_template& other_value);

public:
HTTPResponse_template();
HTTPResponse_template(template_sel other_value);
HTTPResponse_template(const HTTPResponse& other_value);
HTTPResponse_template(const OPTIONAL<HTTPResponse>& other_value);
HTTPResponse_template(const HTTPResponse_template& other_value);
~HTTPResponse_template();
HTTPResponse_template& operator=(template_sel other_value);
HTTPResponse_template& operator=(const HTTPResponse& other_value);
HTTPResponse_template& operator=(const OPTIONAL<HTTPResponse>& other_value);
HTTPResponse_template& operator=(const HTTPResponse_template& other_value);
boolean match(const HTTPResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HTTPResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HTTPResponse_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
INTEGER_template& version__major();
const INTEGER_template& version__major() const;
INTEGER_template& version__minor();
const INTEGER_template& version__minor() const;
INTEGER_template& statuscode();
const INTEGER_template& statuscode() const;
CHARSTRING_template& statustext();
const CHARSTRING_template& statustext() const;
HeaderLines_template& header();
const HeaderLines_template& header() const;
CHARSTRING_template& body();
const CHARSTRING_template& body() const;
int size_of() const;
void log() const;
void log_match(const HTTPResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HTTPRequest {
  OPTIONAL<INTEGER> field_client__id;
  CHARSTRING field_method;
  CHARSTRING field_uri;
  INTEGER field_version__major;
  INTEGER field_version__minor;
  HeaderLines field_header;
  CHARSTRING field_body;
public:
  HTTPRequest();
  HTTPRequest(const OPTIONAL<INTEGER>& par_client__id,
    const CHARSTRING& par_method,
    const CHARSTRING& par_uri,
    const INTEGER& par_version__major,
    const INTEGER& par_version__minor,
    const HeaderLines& par_header,
    const CHARSTRING& par_body);
  HTTPRequest(const HTTPRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HTTPRequest& operator=(const HTTPRequest& other_value);
  boolean operator==(const HTTPRequest& other_value) const;
  inline boolean operator!=(const HTTPRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  inline CHARSTRING& method()
    {return field_method;}
  inline const CHARSTRING& method() const
    {return field_method;}
  inline CHARSTRING& uri()
    {return field_uri;}
  inline const CHARSTRING& uri() const
    {return field_uri;}
  inline INTEGER& version__major()
    {return field_version__major;}
  inline const INTEGER& version__major() const
    {return field_version__major;}
  inline INTEGER& version__minor()
    {return field_version__minor;}
  inline const INTEGER& version__minor() const
    {return field_version__minor;}
  inline HeaderLines& header()
    {return field_header;}
  inline const HeaderLines& header() const
    {return field_header;}
  inline CHARSTRING& body()
    {return field_body;}
  inline const CHARSTRING& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HTTPRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HTTPRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HTTPRequest& other_value);
void copy_template(const HTTPRequest_template& other_value);

public:
HTTPRequest_template();
HTTPRequest_template(template_sel other_value);
HTTPRequest_template(const HTTPRequest& other_value);
HTTPRequest_template(const OPTIONAL<HTTPRequest>& other_value);
HTTPRequest_template(const HTTPRequest_template& other_value);
~HTTPRequest_template();
HTTPRequest_template& operator=(template_sel other_value);
HTTPRequest_template& operator=(const HTTPRequest& other_value);
HTTPRequest_template& operator=(const OPTIONAL<HTTPRequest>& other_value);
HTTPRequest_template& operator=(const HTTPRequest_template& other_value);
boolean match(const HTTPRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HTTPRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HTTPRequest_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
CHARSTRING_template& method();
const CHARSTRING_template& method() const;
CHARSTRING_template& uri();
const CHARSTRING_template& uri() const;
INTEGER_template& version__major();
const INTEGER_template& version__major() const;
INTEGER_template& version__minor();
const INTEGER_template& version__minor() const;
HeaderLines_template& header();
const HeaderLines_template& header() const;
CHARSTRING_template& body();
const CHARSTRING_template& body() const;
int size_of() const;
void log() const;
void log_match(const HTTPRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HTTPResponse__binary__body {
  OPTIONAL<INTEGER> field_client__id;
  INTEGER field_version__major;
  INTEGER field_version__minor;
  INTEGER field_statuscode;
  CHARSTRING field_statustext;
  HeaderLines field_header;
  OCTETSTRING field_body;
public:
  HTTPResponse__binary__body();
  HTTPResponse__binary__body(const OPTIONAL<INTEGER>& par_client__id,
    const INTEGER& par_version__major,
    const INTEGER& par_version__minor,
    const INTEGER& par_statuscode,
    const CHARSTRING& par_statustext,
    const HeaderLines& par_header,
    const OCTETSTRING& par_body);
  HTTPResponse__binary__body(const HTTPResponse__binary__body& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HTTPResponse__binary__body& operator=(const HTTPResponse__binary__body& other_value);
  boolean operator==(const HTTPResponse__binary__body& other_value) const;
  inline boolean operator!=(const HTTPResponse__binary__body& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  inline INTEGER& version__major()
    {return field_version__major;}
  inline const INTEGER& version__major() const
    {return field_version__major;}
  inline INTEGER& version__minor()
    {return field_version__minor;}
  inline const INTEGER& version__minor() const
    {return field_version__minor;}
  inline INTEGER& statuscode()
    {return field_statuscode;}
  inline const INTEGER& statuscode() const
    {return field_statuscode;}
  inline CHARSTRING& statustext()
    {return field_statustext;}
  inline const CHARSTRING& statustext() const
    {return field_statustext;}
  inline HeaderLines& header()
    {return field_header;}
  inline const HeaderLines& header() const
    {return field_header;}
  inline OCTETSTRING& body()
    {return field_body;}
  inline const OCTETSTRING& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HTTPResponse__binary__body_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HTTPResponse__binary__body_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HTTPResponse__binary__body& other_value);
void copy_template(const HTTPResponse__binary__body_template& other_value);

public:
HTTPResponse__binary__body_template();
HTTPResponse__binary__body_template(template_sel other_value);
HTTPResponse__binary__body_template(const HTTPResponse__binary__body& other_value);
HTTPResponse__binary__body_template(const OPTIONAL<HTTPResponse__binary__body>& other_value);
HTTPResponse__binary__body_template(const HTTPResponse__binary__body_template& other_value);
~HTTPResponse__binary__body_template();
HTTPResponse__binary__body_template& operator=(template_sel other_value);
HTTPResponse__binary__body_template& operator=(const HTTPResponse__binary__body& other_value);
HTTPResponse__binary__body_template& operator=(const OPTIONAL<HTTPResponse__binary__body>& other_value);
HTTPResponse__binary__body_template& operator=(const HTTPResponse__binary__body_template& other_value);
boolean match(const HTTPResponse__binary__body& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HTTPResponse__binary__body valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HTTPResponse__binary__body_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
INTEGER_template& version__major();
const INTEGER_template& version__major() const;
INTEGER_template& version__minor();
const INTEGER_template& version__minor() const;
INTEGER_template& statuscode();
const INTEGER_template& statuscode() const;
CHARSTRING_template& statustext();
const CHARSTRING_template& statustext() const;
HeaderLines_template& header();
const HeaderLines_template& header() const;
OCTETSTRING_template& body();
const OCTETSTRING_template& body() const;
int size_of() const;
void log() const;
void log_match(const HTTPResponse__binary__body& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HTTPRequest__binary__body {
  OPTIONAL<INTEGER> field_client__id;
  CHARSTRING field_method;
  CHARSTRING field_uri;
  INTEGER field_version__major;
  INTEGER field_version__minor;
  HeaderLines field_header;
  OCTETSTRING field_body;
public:
  HTTPRequest__binary__body();
  HTTPRequest__binary__body(const OPTIONAL<INTEGER>& par_client__id,
    const CHARSTRING& par_method,
    const CHARSTRING& par_uri,
    const INTEGER& par_version__major,
    const INTEGER& par_version__minor,
    const HeaderLines& par_header,
    const OCTETSTRING& par_body);
  HTTPRequest__binary__body(const HTTPRequest__binary__body& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HTTPRequest__binary__body& operator=(const HTTPRequest__binary__body& other_value);
  boolean operator==(const HTTPRequest__binary__body& other_value) const;
  inline boolean operator!=(const HTTPRequest__binary__body& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  inline CHARSTRING& method()
    {return field_method;}
  inline const CHARSTRING& method() const
    {return field_method;}
  inline CHARSTRING& uri()
    {return field_uri;}
  inline const CHARSTRING& uri() const
    {return field_uri;}
  inline INTEGER& version__major()
    {return field_version__major;}
  inline const INTEGER& version__major() const
    {return field_version__major;}
  inline INTEGER& version__minor()
    {return field_version__minor;}
  inline const INTEGER& version__minor() const
    {return field_version__minor;}
  inline HeaderLines& header()
    {return field_header;}
  inline const HeaderLines& header() const
    {return field_header;}
  inline OCTETSTRING& body()
    {return field_body;}
  inline const OCTETSTRING& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HTTPRequest__binary__body_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HTTPRequest__binary__body_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HTTPRequest__binary__body& other_value);
void copy_template(const HTTPRequest__binary__body_template& other_value);

public:
HTTPRequest__binary__body_template();
HTTPRequest__binary__body_template(template_sel other_value);
HTTPRequest__binary__body_template(const HTTPRequest__binary__body& other_value);
HTTPRequest__binary__body_template(const OPTIONAL<HTTPRequest__binary__body>& other_value);
HTTPRequest__binary__body_template(const HTTPRequest__binary__body_template& other_value);
~HTTPRequest__binary__body_template();
HTTPRequest__binary__body_template& operator=(template_sel other_value);
HTTPRequest__binary__body_template& operator=(const HTTPRequest__binary__body& other_value);
HTTPRequest__binary__body_template& operator=(const OPTIONAL<HTTPRequest__binary__body>& other_value);
HTTPRequest__binary__body_template& operator=(const HTTPRequest__binary__body_template& other_value);
boolean match(const HTTPRequest__binary__body& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HTTPRequest__binary__body valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HTTPRequest__binary__body_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
CHARSTRING_template& method();
const CHARSTRING_template& method() const;
CHARSTRING_template& uri();
const CHARSTRING_template& uri() const;
INTEGER_template& version__major();
const INTEGER_template& version__major() const;
INTEGER_template& version__minor();
const INTEGER_template& version__minor() const;
HeaderLines_template& header();
const HeaderLines_template& header() const;
OCTETSTRING_template& body();
const OCTETSTRING_template& body() const;
int size_of() const;
void log() const;
void log_match(const HTTPRequest__binary__body& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HTTP__erronous__msg {
  OPTIONAL<INTEGER> field_client__id;
  CHARSTRING field_msg;
public:
  HTTP__erronous__msg();
  HTTP__erronous__msg(const OPTIONAL<INTEGER>& par_client__id,
    const CHARSTRING& par_msg);
  HTTP__erronous__msg(const HTTP__erronous__msg& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HTTP__erronous__msg& operator=(const HTTP__erronous__msg& other_value);
  boolean operator==(const HTTP__erronous__msg& other_value) const;
  inline boolean operator!=(const HTTP__erronous__msg& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  inline CHARSTRING& msg()
    {return field_msg;}
  inline const CHARSTRING& msg() const
    {return field_msg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class HTTP__erronous__msg_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HTTP__erronous__msg_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HTTP__erronous__msg& other_value);
void copy_template(const HTTP__erronous__msg_template& other_value);

public:
HTTP__erronous__msg_template();
HTTP__erronous__msg_template(template_sel other_value);
HTTP__erronous__msg_template(const HTTP__erronous__msg& other_value);
HTTP__erronous__msg_template(const OPTIONAL<HTTP__erronous__msg>& other_value);
HTTP__erronous__msg_template(const HTTP__erronous__msg_template& other_value);
~HTTP__erronous__msg_template();
HTTP__erronous__msg_template& operator=(template_sel other_value);
HTTP__erronous__msg_template& operator=(const HTTP__erronous__msg& other_value);
HTTP__erronous__msg_template& operator=(const OPTIONAL<HTTP__erronous__msg>& other_value);
HTTP__erronous__msg_template& operator=(const HTTP__erronous__msg_template& other_value);
boolean match(const HTTP__erronous__msg& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HTTP__erronous__msg valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HTTP__erronous__msg_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
CHARSTRING_template& msg();
const CHARSTRING_template& msg() const;
int size_of() const;
void log() const;
void log_match(const HTTP__erronous__msg& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HTTPMessage : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_response = 1, ALT_request = 2, ALT_response__binary = 3, ALT_request__binary = 4, ALT_erronous__msg = 5 };
private:
union_selection_type union_selection;
union {
HTTPResponse *field_response;
HTTPRequest *field_request;
HTTPResponse__binary__body *field_response__binary;
HTTPRequest__binary__body *field_request__binary;
HTTP__erronous__msg *field_erronous__msg;
};
void copy_value(const HTTPMessage& other_value);

public:
HTTPMessage();
HTTPMessage(const HTTPMessage& other_value);
~HTTPMessage();
HTTPMessage& operator=(const HTTPMessage& other_value);
boolean operator==(const HTTPMessage& other_value) const;
inline boolean operator!=(const HTTPMessage& other_value) const { return !(*this == other_value); }
HTTPResponse& response();
const HTTPResponse& response() const;
HTTPRequest& request();
const HTTPRequest& request() const;
HTTPResponse__binary__body& response__binary();
const HTTPResponse__binary__body& response__binary() const;
HTTPRequest__binary__body& request__binary();
const HTTPRequest__binary__body& request__binary() const;
HTTP__erronous__msg& erronous__msg();
const HTTP__erronous__msg& erronous__msg() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class HTTPMessage_template : public Base_Template {
union {
struct {
HTTPMessage::union_selection_type union_selection;
union {
HTTPResponse_template *field_response;
HTTPRequest_template *field_request;
HTTPResponse__binary__body_template *field_response__binary;
HTTPRequest__binary__body_template *field_request__binary;
HTTP__erronous__msg_template *field_erronous__msg;
};
} single_value;
struct {
unsigned int n_values;
HTTPMessage_template *list_value;
} value_list;
};
void copy_value(const HTTPMessage& other_value);

void copy_template(const HTTPMessage_template& other_value);

public:
HTTPMessage_template();
HTTPMessage_template(template_sel other_value);
HTTPMessage_template(const HTTPMessage& other_value);
HTTPMessage_template(const OPTIONAL<HTTPMessage>& other_value);
HTTPMessage_template(const HTTPMessage_template& other_value);
~HTTPMessage_template();
void clean_up();
HTTPMessage_template& operator=(template_sel other_value);
HTTPMessage_template& operator=(const HTTPMessage& other_value);
HTTPMessage_template& operator=(const OPTIONAL<HTTPMessage>& other_value);
HTTPMessage_template& operator=(const HTTPMessage_template& other_value);
boolean match(const HTTPMessage& other_value, boolean legacy = FALSE) const;
boolean is_value() const;HTTPMessage valueof() const;
HTTPMessage_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
HTTPResponse_template& response();
const HTTPResponse_template& response() const;
HTTPRequest_template& request();
const HTTPRequest_template& request() const;
HTTPResponse__binary__body_template& response__binary();
const HTTPResponse__binary__body_template& response__binary() const;
HTTPRequest__binary__body_template& request__binary();
const HTTPRequest__binary__body_template& request__binary() const;
HTTP__erronous__msg_template& erronous__msg();
const HTTP__erronous__msg_template& erronous__msg() const;
boolean ischosen(HTTPMessage::union_selection_type checked_selection) const;
void log() const;
void log_match(const HTTPMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Close {
  OPTIONAL<INTEGER> field_client__id;
public:
  Close();
  Close(const OPTIONAL<INTEGER>& par_client__id);
  Close(const Close& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Close& operator=(const Close& other_value);
  boolean operator==(const Close& other_value) const;
  inline boolean operator!=(const Close& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Close_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Close_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Close& other_value);
void copy_template(const Close_template& other_value);

public:
Close_template();
Close_template(template_sel other_value);
Close_template(const Close& other_value);
Close_template(const OPTIONAL<Close>& other_value);
Close_template(const Close_template& other_value);
~Close_template();
Close_template& operator=(template_sel other_value);
Close_template& operator=(const Close& other_value);
Close_template& operator=(const OPTIONAL<Close>& other_value);
Close_template& operator=(const Close_template& other_value);
boolean match(const Close& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Close valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Close_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
int size_of() const;
void log() const;
void log_match(const Close& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Connect {
  CHARSTRING field_hostname;
  INTEGER field_portnumber;
  BOOLEAN field_use__ssl;
public:
  Connect();
  Connect(const CHARSTRING& par_hostname,
    const INTEGER& par_portnumber,
    const BOOLEAN& par_use__ssl);
  Connect(const Connect& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Connect& operator=(const Connect& other_value);
  boolean operator==(const Connect& other_value) const;
  inline boolean operator!=(const Connect& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& hostname()
    {return field_hostname;}
  inline const CHARSTRING& hostname() const
    {return field_hostname;}
  inline INTEGER& portnumber()
    {return field_portnumber;}
  inline const INTEGER& portnumber() const
    {return field_portnumber;}
  inline BOOLEAN& use__ssl()
    {return field_use__ssl;}
  inline const BOOLEAN& use__ssl() const
    {return field_use__ssl;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Connect_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Connect_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Connect& other_value);
void copy_template(const Connect_template& other_value);

public:
Connect_template();
Connect_template(template_sel other_value);
Connect_template(const Connect& other_value);
Connect_template(const OPTIONAL<Connect>& other_value);
Connect_template(const Connect_template& other_value);
~Connect_template();
Connect_template& operator=(template_sel other_value);
Connect_template& operator=(const Connect& other_value);
Connect_template& operator=(const OPTIONAL<Connect>& other_value);
Connect_template& operator=(const Connect_template& other_value);
boolean match(const Connect& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Connect valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Connect_template& list_item(unsigned int list_index) const;
CHARSTRING_template& hostname();
const CHARSTRING_template& hostname() const;
INTEGER_template& portnumber();
const INTEGER_template& portnumber() const;
BOOLEAN_template& use__ssl();
const BOOLEAN_template& use__ssl() const;
int size_of() const;
void log() const;
void log_match(const Connect& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Connect__result {
  INTEGER field_client__id;
public:
  Connect__result();
  Connect__result(const INTEGER& par_client__id);
  Connect__result(const Connect__result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Connect__result& operator=(const Connect__result& other_value);
  boolean operator==(const Connect__result& other_value) const;
  inline boolean operator!=(const Connect__result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& client__id()
    {return field_client__id;}
  inline const INTEGER& client__id() const
    {return field_client__id;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Connect__result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Connect__result_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Connect__result& other_value);
void copy_template(const Connect__result_template& other_value);

public:
Connect__result_template();
Connect__result_template(template_sel other_value);
Connect__result_template(const Connect__result& other_value);
Connect__result_template(const OPTIONAL<Connect__result>& other_value);
Connect__result_template(const Connect__result_template& other_value);
~Connect__result_template();
Connect__result_template& operator=(template_sel other_value);
Connect__result_template& operator=(const Connect__result& other_value);
Connect__result_template& operator=(const OPTIONAL<Connect__result>& other_value);
Connect__result_template& operator=(const Connect__result_template& other_value);
boolean match(const Connect__result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Connect__result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Connect__result_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
int size_of() const;
void log() const;
void log_match(const Connect__result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Client__connected {
  CHARSTRING field_hostname;
  INTEGER field_portnumber;
  INTEGER field_client__id;
public:
  Client__connected();
  Client__connected(const CHARSTRING& par_hostname,
    const INTEGER& par_portnumber,
    const INTEGER& par_client__id);
  Client__connected(const Client__connected& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Client__connected& operator=(const Client__connected& other_value);
  boolean operator==(const Client__connected& other_value) const;
  inline boolean operator!=(const Client__connected& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& hostname()
    {return field_hostname;}
  inline const CHARSTRING& hostname() const
    {return field_hostname;}
  inline INTEGER& portnumber()
    {return field_portnumber;}
  inline const INTEGER& portnumber() const
    {return field_portnumber;}
  inline INTEGER& client__id()
    {return field_client__id;}
  inline const INTEGER& client__id() const
    {return field_client__id;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Client__connected_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Client__connected_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Client__connected& other_value);
void copy_template(const Client__connected_template& other_value);

public:
Client__connected_template();
Client__connected_template(template_sel other_value);
Client__connected_template(const Client__connected& other_value);
Client__connected_template(const OPTIONAL<Client__connected>& other_value);
Client__connected_template(const Client__connected_template& other_value);
~Client__connected_template();
Client__connected_template& operator=(template_sel other_value);
Client__connected_template& operator=(const Client__connected& other_value);
Client__connected_template& operator=(const OPTIONAL<Client__connected>& other_value);
Client__connected_template& operator=(const Client__connected_template& other_value);
boolean match(const Client__connected& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Client__connected valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Client__connected_template& list_item(unsigned int list_index) const;
CHARSTRING_template& hostname();
const CHARSTRING_template& hostname() const;
INTEGER_template& portnumber();
const INTEGER_template& portnumber() const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
int size_of() const;
void log() const;
void log_match(const Client__connected& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Half__close {
  OPTIONAL<INTEGER> field_client__id;
public:
  Half__close();
  Half__close(const OPTIONAL<INTEGER>& par_client__id);
  Half__close(const Half__close& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Half__close& operator=(const Half__close& other_value);
  boolean operator==(const Half__close& other_value) const;
  inline boolean operator!=(const Half__close& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& client__id()
    {return field_client__id;}
  inline const OPTIONAL<INTEGER>& client__id() const
    {return field_client__id;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Half__close_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Half__close_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Half__close& other_value);
void copy_template(const Half__close_template& other_value);

public:
Half__close_template();
Half__close_template(template_sel other_value);
Half__close_template(const Half__close& other_value);
Half__close_template(const OPTIONAL<Half__close>& other_value);
Half__close_template(const Half__close_template& other_value);
~Half__close_template();
Half__close_template& operator=(template_sel other_value);
Half__close_template& operator=(const Half__close& other_value);
Half__close_template& operator=(const OPTIONAL<Half__close>& other_value);
Half__close_template& operator=(const Half__close_template& other_value);
boolean match(const Half__close& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Half__close valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Half__close_template& list_item(unsigned int list_index) const;
INTEGER_template& client__id();
const INTEGER_template& client__id() const;
int size_of() const;
void log() const;
void log_match(const Half__close& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Listen {
  OPTIONAL<CHARSTRING> field_local__hostname;
  INTEGER field_portnumber;
  BOOLEAN field_use__ssl;
public:
  Listen();
  Listen(const OPTIONAL<CHARSTRING>& par_local__hostname,
    const INTEGER& par_portnumber,
    const BOOLEAN& par_use__ssl);
  Listen(const Listen& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Listen& operator=(const Listen& other_value);
  boolean operator==(const Listen& other_value) const;
  inline boolean operator!=(const Listen& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& local__hostname()
    {return field_local__hostname;}
  inline const OPTIONAL<CHARSTRING>& local__hostname() const
    {return field_local__hostname;}
  inline INTEGER& portnumber()
    {return field_portnumber;}
  inline const INTEGER& portnumber() const
    {return field_portnumber;}
  inline BOOLEAN& use__ssl()
    {return field_use__ssl;}
  inline const BOOLEAN& use__ssl() const
    {return field_use__ssl;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Listen_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Listen_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Listen& other_value);
void copy_template(const Listen_template& other_value);

public:
Listen_template();
Listen_template(template_sel other_value);
Listen_template(const Listen& other_value);
Listen_template(const OPTIONAL<Listen>& other_value);
Listen_template(const Listen_template& other_value);
~Listen_template();
Listen_template& operator=(template_sel other_value);
Listen_template& operator=(const Listen& other_value);
Listen_template& operator=(const OPTIONAL<Listen>& other_value);
Listen_template& operator=(const Listen_template& other_value);
boolean match(const Listen& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Listen valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Listen_template& list_item(unsigned int list_index) const;
CHARSTRING_template& local__hostname();
const CHARSTRING_template& local__hostname() const;
INTEGER_template& portnumber();
const INTEGER_template& portnumber() const;
BOOLEAN_template& use__ssl();
const BOOLEAN_template& use__ssl() const;
int size_of() const;
void log() const;
void log_match(const Listen& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Listen__result {
  INTEGER field_portnumber;
public:
  Listen__result();
  Listen__result(const INTEGER& par_portnumber);
  Listen__result(const Listen__result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Listen__result& operator=(const Listen__result& other_value);
  boolean operator==(const Listen__result& other_value) const;
  inline boolean operator!=(const Listen__result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& portnumber()
    {return field_portnumber;}
  inline const INTEGER& portnumber() const
    {return field_portnumber;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Listen__result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Listen__result_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Listen__result& other_value);
void copy_template(const Listen__result_template& other_value);

public:
Listen__result_template();
Listen__result_template(template_sel other_value);
Listen__result_template(const Listen__result& other_value);
Listen__result_template(const OPTIONAL<Listen__result>& other_value);
Listen__result_template(const Listen__result_template& other_value);
~Listen__result_template();
Listen__result_template& operator=(template_sel other_value);
Listen__result_template& operator=(const Listen__result& other_value);
Listen__result_template& operator=(const OPTIONAL<Listen__result>& other_value);
Listen__result_template& operator=(const Listen__result_template& other_value);
boolean match(const Listen__result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Listen__result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Listen__result_template& list_item(unsigned int list_index) const;
INTEGER_template& portnumber();
const INTEGER_template& portnumber() const;
int size_of() const;
void log() const;
void log_match(const Listen__result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Shutdown : public Base_Type {
boolean bound_flag;
public:
Shutdown();
Shutdown(null_type other_value);
Shutdown(const Shutdown& other_value);
Shutdown& operator=(null_type other_value);
Shutdown& operator=(const Shutdown& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Shutdown& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Shutdown& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class Shutdown_template : public Base_Template {
struct {
unsigned int n_values;
Shutdown_template *list_value;
} value_list;
void copy_template(const Shutdown_template& other_value);

public:
Shutdown_template();
Shutdown_template(template_sel other_value);
Shutdown_template(null_type other_value);
Shutdown_template(const Shutdown& other_value);
Shutdown_template(const OPTIONAL<Shutdown>& other_value);
Shutdown_template(const Shutdown_template& other_value);
~Shutdown_template();
void clean_up();
Shutdown_template& operator=(template_sel other_value);
Shutdown_template& operator=(null_type other_value);
Shutdown_template& operator=(const Shutdown& other_value);
Shutdown_template& operator=(const OPTIONAL<Shutdown>& other_value);
Shutdown_template& operator=(const Shutdown_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Shutdown& other_value, boolean legacy = FALSE) const;
Shutdown valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Shutdown_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Shutdown& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern OCTETSTRING enc__HTTPMessage(const HTTPMessage& msg);
extern INTEGER dec__HTTPMessage(const OCTETSTRING& stream, HTTPMessage& msg, const BOOLEAN& socket__debugging);
extern boolean operator==(null_type null_value, const HeaderLines& other_value);
inline boolean operator!=(null_type null_value, const HeaderLines& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Shutdown& other_value);
inline boolean operator!=(null_type null_value, const Shutdown& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const BOOLEAN& tsp__socket__debugging;
extern const TTCN_Typedescriptor_t strict__crlf__mode_descr_;
extern const strict__crlf__mode& crlf__mode;
extern const BOOLEAN& dec__HTTPMessage_socket__debugging_defval;
extern const XERdescriptor_t HeaderLine_header__name_xer_;
extern const TTCN_Typedescriptor_t HeaderLine_header__name_descr_;
extern const XERdescriptor_t HeaderLine_header__value_xer_;
extern const TTCN_Typedescriptor_t HeaderLine_header__value_descr_;
extern const TTCN_Typedescriptor_t HeaderLine_descr_;
extern const TTCN_Typedescriptor_t HeaderLines_descr_;
extern const XERdescriptor_t HTTPResponse_version__major_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_version__major_descr_;
extern const XERdescriptor_t HTTPResponse_version__minor_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_version__minor_descr_;
extern const XERdescriptor_t HTTPResponse_statuscode_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_statuscode_descr_;
extern const XERdescriptor_t HTTPResponse_statustext_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_statustext_descr_;
extern const XERdescriptor_t HTTPResponse_body_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_body_descr_;
extern const TTCN_Typedescriptor_t HTTPResponse_descr_;
extern const XERdescriptor_t HTTPResponse_client__id_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse_client__id_descr_;
extern const XERdescriptor_t HTTPRequest_method_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_method_descr_;
extern const XERdescriptor_t HTTPRequest_uri_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_uri_descr_;
extern const XERdescriptor_t HTTPRequest_version__major_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_version__major_descr_;
extern const XERdescriptor_t HTTPRequest_version__minor_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_version__minor_descr_;
extern const XERdescriptor_t HTTPRequest_body_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_body_descr_;
extern const TTCN_Typedescriptor_t HTTPRequest_descr_;
extern const XERdescriptor_t HTTPRequest_client__id_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest_client__id_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_version__major_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_version__major_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_version__minor_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_version__minor_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_statuscode_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_statuscode_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_statustext_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_statustext_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_body_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_body_descr_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_descr_;
extern const XERdescriptor_t HTTPResponse__binary__body_client__id_xer_;
extern const TTCN_Typedescriptor_t HTTPResponse__binary__body_client__id_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_method_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_method_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_uri_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_uri_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_version__major_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_version__major_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_version__minor_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_version__minor_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_body_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_body_descr_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_descr_;
extern const XERdescriptor_t HTTPRequest__binary__body_client__id_xer_;
extern const TTCN_Typedescriptor_t HTTPRequest__binary__body_client__id_descr_;
extern const XERdescriptor_t HTTP__erronous__msg_msg_xer_;
extern const TTCN_Typedescriptor_t HTTP__erronous__msg_msg_descr_;
extern const TTCN_Typedescriptor_t HTTP__erronous__msg_descr_;
extern const XERdescriptor_t HTTP__erronous__msg_client__id_xer_;
extern const TTCN_Typedescriptor_t HTTP__erronous__msg_client__id_descr_;
extern const TTCN_Typedescriptor_t HTTPMessage_descr_;
extern const TTCN_Typedescriptor_t Close_descr_;
extern const XERdescriptor_t Close_client__id_xer_;
extern const TTCN_Typedescriptor_t Close_client__id_descr_;
extern const XERdescriptor_t Connect_hostname_xer_;
extern const TTCN_Typedescriptor_t Connect_hostname_descr_;
extern const XERdescriptor_t Connect_portnumber_xer_;
extern const TTCN_Typedescriptor_t Connect_portnumber_descr_;
extern const XERdescriptor_t Connect_use__ssl_xer_;
extern const TTCN_Typedescriptor_t Connect_use__ssl_descr_;
extern const TTCN_Typedescriptor_t Connect_descr_;
extern const XERdescriptor_t Connect__result_client__id_xer_;
extern const TTCN_Typedescriptor_t Connect__result_client__id_descr_;
extern const TTCN_Typedescriptor_t Connect__result_descr_;
extern const XERdescriptor_t Client__connected_hostname_xer_;
extern const TTCN_Typedescriptor_t Client__connected_hostname_descr_;
extern const XERdescriptor_t Client__connected_portnumber_xer_;
extern const TTCN_Typedescriptor_t Client__connected_portnumber_descr_;
extern const XERdescriptor_t Client__connected_client__id_xer_;
extern const TTCN_Typedescriptor_t Client__connected_client__id_descr_;
extern const TTCN_Typedescriptor_t Client__connected_descr_;
extern const TTCN_Typedescriptor_t Half__close_descr_;
extern const XERdescriptor_t Half__close_client__id_xer_;
extern const TTCN_Typedescriptor_t Half__close_client__id_descr_;
extern const XERdescriptor_t Listen_portnumber_xer_;
extern const TTCN_Typedescriptor_t Listen_portnumber_descr_;
extern const XERdescriptor_t Listen_use__ssl_xer_;
extern const TTCN_Typedescriptor_t Listen_use__ssl_descr_;
extern const TTCN_Typedescriptor_t Listen_descr_;
extern const XERdescriptor_t Listen_local__hostname_xer_;
extern const TTCN_Typedescriptor_t Listen_local__hostname_descr_;
extern const XERdescriptor_t Listen__result_portnumber_xer_;
extern const TTCN_Typedescriptor_t Listen__result_portnumber_descr_;
extern const TTCN_Typedescriptor_t Listen__result_descr_;
extern const TTCN_Typedescriptor_t Shutdown_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
