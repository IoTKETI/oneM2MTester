// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef IPL4asp__Types_HH
#define IPL4asp__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "Socket_API_Definitions.hh"

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef IPL4asp__Types_HH
#endif

namespace IPL4asp__Types {

/* Forward declarations of classes */

class TcpKeepAlive;
class TcpKeepAlive_template;
class ReuseAddress;
class ReuseAddress_template;
class SctpEventHandle;
class SctpEventHandle_template;
class Linger__opt;
class Linger__opt_template;
class SSL__protocols;
class SSL__protocols_template;
class SSL__proto__support;
class SSL__proto__support_template;
class SSL__cert__options;
class SSL__cert__options_template;
class Option;
class Option_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING HostList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template HostList_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING Option_alpn__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template Option_alpn__list_template;
class OptionList;
class OptionList_template;
class ASP__Send;
class ASP__Send_template;
class ASP__SendTo;
class ASP__SendTo_template;
class ASP__RecvFrom;
class ASP__RecvFrom_template;
class IPL4__Param;
class IPL4__Param_template;
class IPL4__ParamResult;
class IPL4__ParamResult_template;
class IPL4__IPAddressType;
class IPL4__IPAddressType_template;
class IPL4__SrtpKeysAndSalts;
class IPL4__SrtpKeysAndSalts_template;
class IPL4__DigestMethods;
class IPL4__DigestMethods_template;

} /* end of namespace */

#ifndef IPL4asp__Types_HH
#define IPL4asp__Types_HH

namespace IPL4asp__Types {

/* Type definitions */

typedef INTEGER ConnectionId;
typedef INTEGER_template ConnectionId_template;
typedef Socket__API__Definitions::ro__ConnectionId ro__ConnectionId;
typedef Socket__API__Definitions::ro__ConnectionId_template ro__ConnectionId_template;
typedef INTEGER AssociationId;
typedef INTEGER_template AssociationId_template;
typedef Socket__API__Definitions::ro__AssociationId ro__AssociationId;
typedef Socket__API__Definitions::ro__AssociationId_template ro__AssociationId_template;
typedef CHARSTRING HostName;
typedef CHARSTRING_template HostName_template;
typedef INTEGER PortNumber;
typedef INTEGER_template PortNumber_template;
typedef Socket__API__Definitions::Socket Socket;
typedef Socket__API__Definitions::Socket_template Socket_template;
typedef Socket__API__Definitions::SocketList SocketList;
typedef Socket__API__Definitions::SocketList_template SocketList_template;
typedef Socket__API__Definitions::UdpTuple UdpTuple;
typedef Socket__API__Definitions::UdpTuple_template UdpTuple_template;
typedef Socket__API__Definitions::TcpTuple TcpTuple;
typedef Socket__API__Definitions::TcpTuple_template TcpTuple_template;
typedef Socket__API__Definitions::SctpTuple SctpTuple;
typedef Socket__API__Definitions::SctpTuple_template SctpTuple_template;
typedef Socket__API__Definitions::SslTuple SslTuple;
typedef Socket__API__Definitions::SslTuple_template SslTuple_template;
typedef Socket__API__Definitions::UnspecifiedTuple UnspecifiedTuple;
typedef Socket__API__Definitions::UnspecifiedTuple_template UnspecifiedTuple_template;
typedef Socket__API__Definitions::ProtoTuple ProtoTuple;
typedef Socket__API__Definitions::ProtoTuple_template ProtoTuple_template;
typedef Socket__API__Definitions::Result Result;
typedef Socket__API__Definitions::Result_template Result_template;
typedef Socket__API__Definitions::Extended__Result Extended__Result;
typedef Socket__API__Definitions::Extended__Result_template Extended__Result_template;
typedef INTEGER UserData;
typedef INTEGER_template UserData_template;
typedef Socket__API__Definitions::PortError PortError;
typedef Socket__API__Definitions::PortError_template PortError_template;
typedef Socket__API__Definitions::ConnectionOpenedEvent ConnectionOpenedEvent;
typedef Socket__API__Definitions::ConnectionOpenedEvent_template ConnectionOpenedEvent_template;
typedef Socket__API__Definitions::ConnectionOpenedEvent ConnectionClosedEvent;
typedef Socket__API__Definitions::ConnectionOpenedEvent_template ConnectionClosedEvent_template;
typedef Socket__API__Definitions::SctpEvent SctpEvent;
typedef Socket__API__Definitions::SctpEvent_template SctpEvent_template;
typedef Socket__API__Definitions::PortEvent PortEvent;
typedef Socket__API__Definitions::PortEvent_template PortEvent_template;
typedef Socket__API__Definitions::SAC__STATE SAC__STATE;
typedef Socket__API__Definitions::SAC__STATE_template SAC__STATE_template;
typedef Socket__API__Definitions::SctpAssocChange SctpAssocChange;
typedef Socket__API__Definitions::SctpAssocChange_template SctpAssocChange_template;
typedef Socket__API__Definitions::SPC__STATE SPC__STATE;
typedef Socket__API__Definitions::SPC__STATE_template SPC__STATE_template;
typedef Socket__API__Definitions::SctpPeerAddrChange SctpPeerAddrChange;
typedef Socket__API__Definitions::SctpPeerAddrChange_template SctpPeerAddrChange_template;
typedef Socket__API__Definitions::SctpSendFailed SctpSendFailed;
typedef Socket__API__Definitions::SctpSendFailed_template SctpSendFailed_template;
typedef Socket__API__Definitions::SctpRemoteError SctpRemoteError;
typedef Socket__API__Definitions::SctpRemoteError_template SctpRemoteError_template;
typedef Socket__API__Definitions::SctpShutDownEvent SctpShutDownEvent;
typedef Socket__API__Definitions::SctpShutDownEvent_template SctpShutDownEvent_template;
typedef Socket__API__Definitions::SctpPartialDeliveryEvent SctpPartialDeliveryEvent;
typedef Socket__API__Definitions::SctpPartialDeliveryEvent_template SctpPartialDeliveryEvent_template;
typedef Socket__API__Definitions::SctpAdaptationIndication SctpAdaptationIndication;
typedef Socket__API__Definitions::SctpAdaptationIndication_template SctpAdaptationIndication_template;
typedef Socket__API__Definitions::ro__integer ro__integer;
typedef Socket__API__Definitions::ro__integer_template ro__integer_template;
typedef Socket__API__Definitions::f__getMsgLen f__getMsgLen;
typedef Socket__API__Definitions::f__getMsgLen_template f__getMsgLen_template;
typedef Socket__API__Definitions::ro__charstring ro__charstring;
typedef Socket__API__Definitions::ro__charstring_template ro__charstring_template;
typedef Socket__API__Definitions::PortEvent ASP__Event;
typedef Socket__API__Definitions::PortEvent_template ASP__Event_template;
typedef Socket__API__Definitions::f__getMsgLen f__IPL4__getMsgLen;
typedef Socket__API__Definitions::f__getMsgLen_template f__IPL4__getMsgLen_template;

/* Class definitions */

class TcpKeepAlive {
  OPTIONAL<BOOLEAN> field_enable;
  OPTIONAL<INTEGER> field_count;
  OPTIONAL<INTEGER> field_idle;
  OPTIONAL<INTEGER> field_interval;
public:
  TcpKeepAlive();
  TcpKeepAlive(const OPTIONAL<BOOLEAN>& par_enable,
    const OPTIONAL<INTEGER>& par_count,
    const OPTIONAL<INTEGER>& par_idle,
    const OPTIONAL<INTEGER>& par_interval);
  TcpKeepAlive(const TcpKeepAlive& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TcpKeepAlive& operator=(const TcpKeepAlive& other_value);
  boolean operator==(const TcpKeepAlive& other_value) const;
  inline boolean operator!=(const TcpKeepAlive& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<BOOLEAN>& enable()
    {return field_enable;}
  inline const OPTIONAL<BOOLEAN>& enable() const
    {return field_enable;}
  inline OPTIONAL<INTEGER>& count()
    {return field_count;}
  inline const OPTIONAL<INTEGER>& count() const
    {return field_count;}
  inline OPTIONAL<INTEGER>& idle()
    {return field_idle;}
  inline const OPTIONAL<INTEGER>& idle() const
    {return field_idle;}
  inline OPTIONAL<INTEGER>& interval()
    {return field_interval;}
  inline const OPTIONAL<INTEGER>& interval() const
    {return field_interval;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class TcpKeepAlive_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TcpKeepAlive_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TcpKeepAlive& other_value);
void copy_template(const TcpKeepAlive_template& other_value);

public:
TcpKeepAlive_template();
TcpKeepAlive_template(template_sel other_value);
TcpKeepAlive_template(const TcpKeepAlive& other_value);
TcpKeepAlive_template(const OPTIONAL<TcpKeepAlive>& other_value);
TcpKeepAlive_template(const TcpKeepAlive_template& other_value);
~TcpKeepAlive_template();
TcpKeepAlive_template& operator=(template_sel other_value);
TcpKeepAlive_template& operator=(const TcpKeepAlive& other_value);
TcpKeepAlive_template& operator=(const OPTIONAL<TcpKeepAlive>& other_value);
TcpKeepAlive_template& operator=(const TcpKeepAlive_template& other_value);
boolean match(const TcpKeepAlive& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TcpKeepAlive valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TcpKeepAlive_template& list_item(unsigned int list_index) const;
BOOLEAN_template& enable();
const BOOLEAN_template& enable() const;
INTEGER_template& count();
const INTEGER_template& count() const;
INTEGER_template& idle();
const INTEGER_template& idle() const;
INTEGER_template& interval();
const INTEGER_template& interval() const;
int size_of() const;
void log() const;
void log_match(const TcpKeepAlive& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReuseAddress {
  OPTIONAL<BOOLEAN> field_enable;
public:
  ReuseAddress();
  ReuseAddress(const OPTIONAL<BOOLEAN>& par_enable);
  ReuseAddress(const ReuseAddress& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReuseAddress& operator=(const ReuseAddress& other_value);
  boolean operator==(const ReuseAddress& other_value) const;
  inline boolean operator!=(const ReuseAddress& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<BOOLEAN>& enable()
    {return field_enable;}
  inline const OPTIONAL<BOOLEAN>& enable() const
    {return field_enable;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ReuseAddress_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReuseAddress_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReuseAddress& other_value);
void copy_template(const ReuseAddress_template& other_value);

public:
ReuseAddress_template();
ReuseAddress_template(template_sel other_value);
ReuseAddress_template(const ReuseAddress& other_value);
ReuseAddress_template(const OPTIONAL<ReuseAddress>& other_value);
ReuseAddress_template(const ReuseAddress_template& other_value);
~ReuseAddress_template();
ReuseAddress_template& operator=(template_sel other_value);
ReuseAddress_template& operator=(const ReuseAddress& other_value);
ReuseAddress_template& operator=(const OPTIONAL<ReuseAddress>& other_value);
ReuseAddress_template& operator=(const ReuseAddress_template& other_value);
boolean match(const ReuseAddress& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReuseAddress valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReuseAddress_template& list_item(unsigned int list_index) const;
BOOLEAN_template& enable();
const BOOLEAN_template& enable() const;
int size_of() const;
void log() const;
void log_match(const ReuseAddress& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpEventHandle {
  OPTIONAL<BOOLEAN> field_sctp__data__io__event;
  OPTIONAL<BOOLEAN> field_sctp__association__event;
  OPTIONAL<BOOLEAN> field_sctp__address__event;
  OPTIONAL<BOOLEAN> field_sctp__send__failure__event;
  OPTIONAL<BOOLEAN> field_sctp__peer__error__event;
  OPTIONAL<BOOLEAN> field_sctp__shutdown__event;
  OPTIONAL<BOOLEAN> field_sctp__partial__delivery__event;
  OPTIONAL<BOOLEAN> field_sctp__adaptation__layer__event;
  OPTIONAL<BOOLEAN> field_sctp__authentication__event;
  OPTIONAL<BOOLEAN> field_sctp__sender__dry__event;
public:
  SctpEventHandle();
  SctpEventHandle(const OPTIONAL<BOOLEAN>& par_sctp__data__io__event,
    const OPTIONAL<BOOLEAN>& par_sctp__association__event,
    const OPTIONAL<BOOLEAN>& par_sctp__address__event,
    const OPTIONAL<BOOLEAN>& par_sctp__send__failure__event,
    const OPTIONAL<BOOLEAN>& par_sctp__peer__error__event,
    const OPTIONAL<BOOLEAN>& par_sctp__shutdown__event,
    const OPTIONAL<BOOLEAN>& par_sctp__partial__delivery__event,
    const OPTIONAL<BOOLEAN>& par_sctp__adaptation__layer__event,
    const OPTIONAL<BOOLEAN>& par_sctp__authentication__event,
    const OPTIONAL<BOOLEAN>& par_sctp__sender__dry__event);
  SctpEventHandle(const SctpEventHandle& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpEventHandle& operator=(const SctpEventHandle& other_value);
  boolean operator==(const SctpEventHandle& other_value) const;
  inline boolean operator!=(const SctpEventHandle& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<BOOLEAN>& sctp__data__io__event()
    {return field_sctp__data__io__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__data__io__event() const
    {return field_sctp__data__io__event;}
  inline OPTIONAL<BOOLEAN>& sctp__association__event()
    {return field_sctp__association__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__association__event() const
    {return field_sctp__association__event;}
  inline OPTIONAL<BOOLEAN>& sctp__address__event()
    {return field_sctp__address__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__address__event() const
    {return field_sctp__address__event;}
  inline OPTIONAL<BOOLEAN>& sctp__send__failure__event()
    {return field_sctp__send__failure__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__send__failure__event() const
    {return field_sctp__send__failure__event;}
  inline OPTIONAL<BOOLEAN>& sctp__peer__error__event()
    {return field_sctp__peer__error__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__peer__error__event() const
    {return field_sctp__peer__error__event;}
  inline OPTIONAL<BOOLEAN>& sctp__shutdown__event()
    {return field_sctp__shutdown__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__shutdown__event() const
    {return field_sctp__shutdown__event;}
  inline OPTIONAL<BOOLEAN>& sctp__partial__delivery__event()
    {return field_sctp__partial__delivery__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__partial__delivery__event() const
    {return field_sctp__partial__delivery__event;}
  inline OPTIONAL<BOOLEAN>& sctp__adaptation__layer__event()
    {return field_sctp__adaptation__layer__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__adaptation__layer__event() const
    {return field_sctp__adaptation__layer__event;}
  inline OPTIONAL<BOOLEAN>& sctp__authentication__event()
    {return field_sctp__authentication__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__authentication__event() const
    {return field_sctp__authentication__event;}
  inline OPTIONAL<BOOLEAN>& sctp__sender__dry__event()
    {return field_sctp__sender__dry__event;}
  inline const OPTIONAL<BOOLEAN>& sctp__sender__dry__event() const
    {return field_sctp__sender__dry__event;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpEventHandle_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpEventHandle_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpEventHandle& other_value);
void copy_template(const SctpEventHandle_template& other_value);

public:
SctpEventHandle_template();
SctpEventHandle_template(template_sel other_value);
SctpEventHandle_template(const SctpEventHandle& other_value);
SctpEventHandle_template(const OPTIONAL<SctpEventHandle>& other_value);
SctpEventHandle_template(const SctpEventHandle_template& other_value);
~SctpEventHandle_template();
SctpEventHandle_template& operator=(template_sel other_value);
SctpEventHandle_template& operator=(const SctpEventHandle& other_value);
SctpEventHandle_template& operator=(const OPTIONAL<SctpEventHandle>& other_value);
SctpEventHandle_template& operator=(const SctpEventHandle_template& other_value);
boolean match(const SctpEventHandle& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpEventHandle valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpEventHandle_template& list_item(unsigned int list_index) const;
BOOLEAN_template& sctp__data__io__event();
const BOOLEAN_template& sctp__data__io__event() const;
BOOLEAN_template& sctp__association__event();
const BOOLEAN_template& sctp__association__event() const;
BOOLEAN_template& sctp__address__event();
const BOOLEAN_template& sctp__address__event() const;
BOOLEAN_template& sctp__send__failure__event();
const BOOLEAN_template& sctp__send__failure__event() const;
BOOLEAN_template& sctp__peer__error__event();
const BOOLEAN_template& sctp__peer__error__event() const;
BOOLEAN_template& sctp__shutdown__event();
const BOOLEAN_template& sctp__shutdown__event() const;
BOOLEAN_template& sctp__partial__delivery__event();
const BOOLEAN_template& sctp__partial__delivery__event() const;
BOOLEAN_template& sctp__adaptation__layer__event();
const BOOLEAN_template& sctp__adaptation__layer__event() const;
BOOLEAN_template& sctp__authentication__event();
const BOOLEAN_template& sctp__authentication__event() const;
BOOLEAN_template& sctp__sender__dry__event();
const BOOLEAN_template& sctp__sender__dry__event() const;
int size_of() const;
void log() const;
void log_match(const SctpEventHandle& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Linger__opt {
  INTEGER field_l__onoff;
  INTEGER field_l__linger;
public:
  Linger__opt();
  Linger__opt(const INTEGER& par_l__onoff,
    const INTEGER& par_l__linger);
  Linger__opt(const Linger__opt& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Linger__opt& operator=(const Linger__opt& other_value);
  boolean operator==(const Linger__opt& other_value) const;
  inline boolean operator!=(const Linger__opt& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& l__onoff()
    {return field_l__onoff;}
  inline const INTEGER& l__onoff() const
    {return field_l__onoff;}
  inline INTEGER& l__linger()
    {return field_l__linger;}
  inline const INTEGER& l__linger() const
    {return field_l__linger;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Linger__opt_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Linger__opt_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Linger__opt& other_value);
void copy_template(const Linger__opt_template& other_value);

public:
Linger__opt_template();
Linger__opt_template(template_sel other_value);
Linger__opt_template(const Linger__opt& other_value);
Linger__opt_template(const OPTIONAL<Linger__opt>& other_value);
Linger__opt_template(const Linger__opt_template& other_value);
~Linger__opt_template();
Linger__opt_template& operator=(template_sel other_value);
Linger__opt_template& operator=(const Linger__opt& other_value);
Linger__opt_template& operator=(const OPTIONAL<Linger__opt>& other_value);
Linger__opt_template& operator=(const Linger__opt_template& other_value);
boolean match(const Linger__opt& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Linger__opt valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Linger__opt_template& list_item(unsigned int list_index) const;
INTEGER_template& l__onoff();
const INTEGER_template& l__onoff() const;
INTEGER_template& l__linger();
const INTEGER_template& l__linger() const;
int size_of() const;
void log() const;
void log_match(const Linger__opt& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SSL__protocols : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_SSLv2__supported = 1, ALT_SSLv3__supported = 2, ALT_TLSv1__supported = 3, ALT_TLSv1__1__supported = 4, ALT_TLSv1__2__supported = 5, ALT_DTLSv1__supported = 6, ALT_DTLSv1__2__supported = 7 };
private:
union_selection_type union_selection;
union {
BOOLEAN *field_SSLv2__supported;
BOOLEAN *field_SSLv3__supported;
BOOLEAN *field_TLSv1__supported;
BOOLEAN *field_TLSv1__1__supported;
BOOLEAN *field_TLSv1__2__supported;
BOOLEAN *field_DTLSv1__supported;
BOOLEAN *field_DTLSv1__2__supported;
};
void copy_value(const SSL__protocols& other_value);

public:
SSL__protocols();
SSL__protocols(const SSL__protocols& other_value);
~SSL__protocols();
SSL__protocols& operator=(const SSL__protocols& other_value);
boolean operator==(const SSL__protocols& other_value) const;
inline boolean operator!=(const SSL__protocols& other_value) const { return !(*this == other_value); }
BOOLEAN& SSLv2__supported();
const BOOLEAN& SSLv2__supported() const;
BOOLEAN& SSLv3__supported();
const BOOLEAN& SSLv3__supported() const;
BOOLEAN& TLSv1__supported();
const BOOLEAN& TLSv1__supported() const;
BOOLEAN& TLSv1__1__supported();
const BOOLEAN& TLSv1__1__supported() const;
BOOLEAN& TLSv1__2__supported();
const BOOLEAN& TLSv1__2__supported() const;
BOOLEAN& DTLSv1__supported();
const BOOLEAN& DTLSv1__supported() const;
BOOLEAN& DTLSv1__2__supported();
const BOOLEAN& DTLSv1__2__supported() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SSL__protocols_template : public Base_Template {
union {
struct {
SSL__protocols::union_selection_type union_selection;
union {
BOOLEAN_template *field_SSLv2__supported;
BOOLEAN_template *field_SSLv3__supported;
BOOLEAN_template *field_TLSv1__supported;
BOOLEAN_template *field_TLSv1__1__supported;
BOOLEAN_template *field_TLSv1__2__supported;
BOOLEAN_template *field_DTLSv1__supported;
BOOLEAN_template *field_DTLSv1__2__supported;
};
} single_value;
struct {
unsigned int n_values;
SSL__protocols_template *list_value;
} value_list;
};
void copy_value(const SSL__protocols& other_value);

void copy_template(const SSL__protocols_template& other_value);

public:
SSL__protocols_template();
SSL__protocols_template(template_sel other_value);
SSL__protocols_template(const SSL__protocols& other_value);
SSL__protocols_template(const OPTIONAL<SSL__protocols>& other_value);
SSL__protocols_template(const SSL__protocols_template& other_value);
~SSL__protocols_template();
void clean_up();
SSL__protocols_template& operator=(template_sel other_value);
SSL__protocols_template& operator=(const SSL__protocols& other_value);
SSL__protocols_template& operator=(const OPTIONAL<SSL__protocols>& other_value);
SSL__protocols_template& operator=(const SSL__protocols_template& other_value);
boolean match(const SSL__protocols& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SSL__protocols valueof() const;
SSL__protocols_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
BOOLEAN_template& SSLv2__supported();
const BOOLEAN_template& SSLv2__supported() const;
BOOLEAN_template& SSLv3__supported();
const BOOLEAN_template& SSLv3__supported() const;
BOOLEAN_template& TLSv1__supported();
const BOOLEAN_template& TLSv1__supported() const;
BOOLEAN_template& TLSv1__1__supported();
const BOOLEAN_template& TLSv1__1__supported() const;
BOOLEAN_template& TLSv1__2__supported();
const BOOLEAN_template& TLSv1__2__supported() const;
BOOLEAN_template& DTLSv1__supported();
const BOOLEAN_template& DTLSv1__supported() const;
BOOLEAN_template& DTLSv1__2__supported();
const BOOLEAN_template& DTLSv1__2__supported() const;
boolean ischosen(SSL__protocols::union_selection_type checked_selection) const;
void log() const;
void log_match(const SSL__protocols& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SSL__proto__support : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SSL__protocols **value_elements;
} *val_ptr;

static const SSL__protocols UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SSL__proto__support& other_value);

public:
  typedef SSL__protocols of_type;
SSL__proto__support();
SSL__proto__support(null_type other_value);
SSL__proto__support(const SSL__proto__support& other_value);
~SSL__proto__support();

void clean_up();
SSL__proto__support& operator=(null_type other_value);
SSL__proto__support& operator=(const SSL__proto__support& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SSL__proto__support& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SSL__proto__support& other_value) const { return !(*this == other_value); }

SSL__protocols& operator[](int index_value);
SSL__protocols& operator[](const INTEGER& index_value);
const SSL__protocols& operator[](int index_value) const;
const SSL__protocols& operator[](const INTEGER& index_value) const;

SSL__proto__support operator<<=(int rotate_count) const;
SSL__proto__support operator<<=(const INTEGER& rotate_count) const;
SSL__proto__support operator>>=(int rotate_count) const;
SSL__proto__support operator>>=(const INTEGER& rotate_count) const;

SSL__proto__support operator+(const SSL__proto__support& other_value) const;

SSL__proto__support substr(int index, int returncount) const;

SSL__proto__support replace(int index, int len, const SSL__proto__support& repl) const;

SSL__proto__support replace(int index, int len, const SSL__proto__support_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SSL__proto__support_template : public Record_Of_Template {
union {
struct {
int n_elements;
SSL__protocols_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SSL__proto__support_template *list_value;
} value_list;
};
void copy_value(const SSL__proto__support& other_value);
void copy_template(const SSL__proto__support_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SSL__proto__support_template();
SSL__proto__support_template(template_sel other_value);
SSL__proto__support_template(null_type other_value);
SSL__proto__support_template(const SSL__proto__support& other_value);
SSL__proto__support_template(const OPTIONAL<SSL__proto__support>& other_value);
SSL__proto__support_template(const SSL__proto__support_template& other_value);
~SSL__proto__support_template();

void clean_up();
SSL__proto__support_template& operator=(template_sel other_value);
SSL__proto__support_template& operator=(null_type other_value);
SSL__proto__support_template& operator=(const SSL__proto__support& other_value);
SSL__proto__support_template& operator=(const OPTIONAL<SSL__proto__support>& other_value);
SSL__proto__support_template& operator=(const SSL__proto__support_template& other_value);

SSL__protocols_template& operator[](int index_value);
SSL__protocols_template& operator[](const INTEGER& index_value);
const SSL__protocols_template& operator[](int index_value) const;
const SSL__protocols_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SSL__proto__support& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SSL__proto__support valueof() const;
SSL__proto__support substr(int index, int returncount) const;

SSL__proto__support replace(int index, int len, const SSL__proto__support_template& repl) const;

SSL__proto__support replace(int index, int len, const SSL__proto__support& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SSL__proto__support_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SSL__proto__support& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class SSL__cert__options {
  OPTIONAL<CHARSTRING> field_ssl__key__file;
  OPTIONAL<CHARSTRING> field_ssl__certificate__file;
  OPTIONAL<CHARSTRING> field_ssl__trustedCAlist__file;
  OPTIONAL<CHARSTRING> field_ssl__cipher__list;
  OPTIONAL<CHARSTRING> field_ssl__password;
public:
  SSL__cert__options();
  SSL__cert__options(const OPTIONAL<CHARSTRING>& par_ssl__key__file,
    const OPTIONAL<CHARSTRING>& par_ssl__certificate__file,
    const OPTIONAL<CHARSTRING>& par_ssl__trustedCAlist__file,
    const OPTIONAL<CHARSTRING>& par_ssl__cipher__list,
    const OPTIONAL<CHARSTRING>& par_ssl__password);
  SSL__cert__options(const SSL__cert__options& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SSL__cert__options& operator=(const SSL__cert__options& other_value);
  boolean operator==(const SSL__cert__options& other_value) const;
  inline boolean operator!=(const SSL__cert__options& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<CHARSTRING>& ssl__key__file()
    {return field_ssl__key__file;}
  inline const OPTIONAL<CHARSTRING>& ssl__key__file() const
    {return field_ssl__key__file;}
  inline OPTIONAL<CHARSTRING>& ssl__certificate__file()
    {return field_ssl__certificate__file;}
  inline const OPTIONAL<CHARSTRING>& ssl__certificate__file() const
    {return field_ssl__certificate__file;}
  inline OPTIONAL<CHARSTRING>& ssl__trustedCAlist__file()
    {return field_ssl__trustedCAlist__file;}
  inline const OPTIONAL<CHARSTRING>& ssl__trustedCAlist__file() const
    {return field_ssl__trustedCAlist__file;}
  inline OPTIONAL<CHARSTRING>& ssl__cipher__list()
    {return field_ssl__cipher__list;}
  inline const OPTIONAL<CHARSTRING>& ssl__cipher__list() const
    {return field_ssl__cipher__list;}
  inline OPTIONAL<CHARSTRING>& ssl__password()
    {return field_ssl__password;}
  inline const OPTIONAL<CHARSTRING>& ssl__password() const
    {return field_ssl__password;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SSL__cert__options_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SSL__cert__options_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SSL__cert__options& other_value);
void copy_template(const SSL__cert__options_template& other_value);

public:
SSL__cert__options_template();
SSL__cert__options_template(template_sel other_value);
SSL__cert__options_template(const SSL__cert__options& other_value);
SSL__cert__options_template(const OPTIONAL<SSL__cert__options>& other_value);
SSL__cert__options_template(const SSL__cert__options_template& other_value);
~SSL__cert__options_template();
SSL__cert__options_template& operator=(template_sel other_value);
SSL__cert__options_template& operator=(const SSL__cert__options& other_value);
SSL__cert__options_template& operator=(const OPTIONAL<SSL__cert__options>& other_value);
SSL__cert__options_template& operator=(const SSL__cert__options_template& other_value);
boolean match(const SSL__cert__options& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SSL__cert__options valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SSL__cert__options_template& list_item(unsigned int list_index) const;
CHARSTRING_template& ssl__key__file();
const CHARSTRING_template& ssl__key__file() const;
CHARSTRING_template& ssl__certificate__file();
const CHARSTRING_template& ssl__certificate__file() const;
CHARSTRING_template& ssl__trustedCAlist__file();
const CHARSTRING_template& ssl__trustedCAlist__file() const;
CHARSTRING_template& ssl__cipher__list();
const CHARSTRING_template& ssl__cipher__list() const;
CHARSTRING_template& ssl__password();
const CHARSTRING_template& ssl__password() const;
int size_of() const;
void log() const;
void log_match(const SSL__cert__options& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Option : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_reuseAddress = 1, ALT_tcpKeepAlive = 2, ALT_sctpEventHandle = 3, ALT_sslKeepAlive = 4, ALT_sctpAdditionalLocalAddresses = 5, ALT_sctpEINConfigGroup = 6, ALT_solinger = 7, ALT_ssl__support = 8, ALT_no__delay = 9, ALT_dtlsSrtpProfiles = 10, ALT_cert__options = 11, ALT_freebind = 12, ALT_alpn__list = 13, ALT_tls__hostname = 14 };
private:
union_selection_type union_selection;
union {
ReuseAddress *field_reuseAddress;
TcpKeepAlive *field_tcpKeepAlive;
SctpEventHandle *field_sctpEventHandle;
TcpKeepAlive *field_sslKeepAlive;
HostList *field_sctpAdditionalLocalAddresses;
INTEGER *field_sctpEINConfigGroup;
Linger__opt *field_solinger;
SSL__proto__support *field_ssl__support;
BOOLEAN *field_no__delay;
CHARSTRING *field_dtlsSrtpProfiles;
SSL__cert__options *field_cert__options;
BOOLEAN *field_freebind;
Option_alpn__list *field_alpn__list;
CHARSTRING *field_tls__hostname;
};
void copy_value(const Option& other_value);

public:
Option();
Option(const Option& other_value);
~Option();
Option& operator=(const Option& other_value);
boolean operator==(const Option& other_value) const;
inline boolean operator!=(const Option& other_value) const { return !(*this == other_value); }
ReuseAddress& reuseAddress();
const ReuseAddress& reuseAddress() const;
TcpKeepAlive& tcpKeepAlive();
const TcpKeepAlive& tcpKeepAlive() const;
SctpEventHandle& sctpEventHandle();
const SctpEventHandle& sctpEventHandle() const;
TcpKeepAlive& sslKeepAlive();
const TcpKeepAlive& sslKeepAlive() const;
HostList& sctpAdditionalLocalAddresses();
const HostList& sctpAdditionalLocalAddresses() const;
INTEGER& sctpEINConfigGroup();
const INTEGER& sctpEINConfigGroup() const;
Linger__opt& solinger();
const Linger__opt& solinger() const;
SSL__proto__support& ssl__support();
const SSL__proto__support& ssl__support() const;
BOOLEAN& no__delay();
const BOOLEAN& no__delay() const;
CHARSTRING& dtlsSrtpProfiles();
const CHARSTRING& dtlsSrtpProfiles() const;
SSL__cert__options& cert__options();
const SSL__cert__options& cert__options() const;
BOOLEAN& freebind();
const BOOLEAN& freebind() const;
Option_alpn__list& alpn__list();
const Option_alpn__list& alpn__list() const;
CHARSTRING& tls__hostname();
const CHARSTRING& tls__hostname() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class Option_template : public Base_Template {
union {
struct {
Option::union_selection_type union_selection;
union {
ReuseAddress_template *field_reuseAddress;
TcpKeepAlive_template *field_tcpKeepAlive;
SctpEventHandle_template *field_sctpEventHandle;
TcpKeepAlive_template *field_sslKeepAlive;
HostList_template *field_sctpAdditionalLocalAddresses;
INTEGER_template *field_sctpEINConfigGroup;
Linger__opt_template *field_solinger;
SSL__proto__support_template *field_ssl__support;
BOOLEAN_template *field_no__delay;
CHARSTRING_template *field_dtlsSrtpProfiles;
SSL__cert__options_template *field_cert__options;
BOOLEAN_template *field_freebind;
Option_alpn__list_template *field_alpn__list;
CHARSTRING_template *field_tls__hostname;
};
} single_value;
struct {
unsigned int n_values;
Option_template *list_value;
} value_list;
};
void copy_value(const Option& other_value);

void copy_template(const Option_template& other_value);

public:
Option_template();
Option_template(template_sel other_value);
Option_template(const Option& other_value);
Option_template(const OPTIONAL<Option>& other_value);
Option_template(const Option_template& other_value);
~Option_template();
void clean_up();
Option_template& operator=(template_sel other_value);
Option_template& operator=(const Option& other_value);
Option_template& operator=(const OPTIONAL<Option>& other_value);
Option_template& operator=(const Option_template& other_value);
boolean match(const Option& other_value, boolean legacy = FALSE) const;
boolean is_value() const;Option valueof() const;
Option_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ReuseAddress_template& reuseAddress();
const ReuseAddress_template& reuseAddress() const;
TcpKeepAlive_template& tcpKeepAlive();
const TcpKeepAlive_template& tcpKeepAlive() const;
SctpEventHandle_template& sctpEventHandle();
const SctpEventHandle_template& sctpEventHandle() const;
TcpKeepAlive_template& sslKeepAlive();
const TcpKeepAlive_template& sslKeepAlive() const;
HostList_template& sctpAdditionalLocalAddresses();
const HostList_template& sctpAdditionalLocalAddresses() const;
INTEGER_template& sctpEINConfigGroup();
const INTEGER_template& sctpEINConfigGroup() const;
Linger__opt_template& solinger();
const Linger__opt_template& solinger() const;
SSL__proto__support_template& ssl__support();
const SSL__proto__support_template& ssl__support() const;
BOOLEAN_template& no__delay();
const BOOLEAN_template& no__delay() const;
CHARSTRING_template& dtlsSrtpProfiles();
const CHARSTRING_template& dtlsSrtpProfiles() const;
SSL__cert__options_template& cert__options();
const SSL__cert__options_template& cert__options() const;
BOOLEAN_template& freebind();
const BOOLEAN_template& freebind() const;
Option_alpn__list_template& alpn__list();
const Option_alpn__list_template& alpn__list() const;
CHARSTRING_template& tls__hostname();
const CHARSTRING_template& tls__hostname() const;
boolean ischosen(Option::union_selection_type checked_selection) const;
void log() const;
void log_match(const Option& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class OptionList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Option **value_elements;
} *val_ptr;

static const Option UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const OptionList& other_value);

public:
  typedef Option of_type;
OptionList();
OptionList(null_type other_value);
OptionList(const OptionList& other_value);
~OptionList();

void clean_up();
OptionList& operator=(null_type other_value);
OptionList& operator=(const OptionList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const OptionList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const OptionList& other_value) const { return !(*this == other_value); }

Option& operator[](int index_value);
Option& operator[](const INTEGER& index_value);
const Option& operator[](int index_value) const;
const Option& operator[](const INTEGER& index_value) const;

OptionList operator<<=(int rotate_count) const;
OptionList operator<<=(const INTEGER& rotate_count) const;
OptionList operator>>=(int rotate_count) const;
OptionList operator>>=(const INTEGER& rotate_count) const;

OptionList operator+(const OptionList& other_value) const;

OptionList substr(int index, int returncount) const;

OptionList replace(int index, int len, const OptionList& repl) const;

OptionList replace(int index, int len, const OptionList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class OptionList_template : public Record_Of_Template {
union {
struct {
int n_elements;
Option_template **value_elements;
} single_value;
struct {
unsigned int n_values;
OptionList_template *list_value;
} value_list;
};
void copy_value(const OptionList& other_value);
void copy_template(const OptionList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
OptionList_template();
OptionList_template(template_sel other_value);
OptionList_template(null_type other_value);
OptionList_template(const OptionList& other_value);
OptionList_template(const OPTIONAL<OptionList>& other_value);
OptionList_template(const OptionList_template& other_value);
~OptionList_template();

void clean_up();
OptionList_template& operator=(template_sel other_value);
OptionList_template& operator=(null_type other_value);
OptionList_template& operator=(const OptionList& other_value);
OptionList_template& operator=(const OPTIONAL<OptionList>& other_value);
OptionList_template& operator=(const OptionList_template& other_value);

Option_template& operator[](int index_value);
Option_template& operator[](const INTEGER& index_value);
const Option_template& operator[](int index_value) const;
const Option_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const OptionList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
OptionList valueof() const;
OptionList substr(int index, int returncount) const;

OptionList replace(int index, int len, const OptionList_template& repl) const;

OptionList replace(int index, int len, const OptionList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
OptionList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const OptionList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ASP__Send {
  INTEGER field_connId;
  OPTIONAL<Socket__API__Definitions::ProtoTuple> field_proto;
  OCTETSTRING field_msg;
public:
  ASP__Send();
  ASP__Send(const INTEGER& par_connId,
    const OPTIONAL<Socket__API__Definitions::ProtoTuple>& par_proto,
    const OCTETSTRING& par_msg);
  ASP__Send(const ASP__Send& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ASP__Send& operator=(const ASP__Send& other_value);
  boolean operator==(const ASP__Send& other_value) const;
  inline boolean operator!=(const ASP__Send& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& connId()
    {return field_connId;}
  inline const INTEGER& connId() const
    {return field_connId;}
  inline OPTIONAL<Socket__API__Definitions::ProtoTuple>& proto()
    {return field_proto;}
  inline const OPTIONAL<Socket__API__Definitions::ProtoTuple>& proto() const
    {return field_proto;}
  inline OCTETSTRING& msg()
    {return field_msg;}
  inline const OCTETSTRING& msg() const
    {return field_msg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__Send_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__Send_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ASP__Send& other_value);
void copy_template(const ASP__Send_template& other_value);

public:
ASP__Send_template();
ASP__Send_template(template_sel other_value);
ASP__Send_template(const ASP__Send& other_value);
ASP__Send_template(const OPTIONAL<ASP__Send>& other_value);
ASP__Send_template(const ASP__Send_template& other_value);
~ASP__Send_template();
ASP__Send_template& operator=(template_sel other_value);
ASP__Send_template& operator=(const ASP__Send& other_value);
ASP__Send_template& operator=(const OPTIONAL<ASP__Send>& other_value);
ASP__Send_template& operator=(const ASP__Send_template& other_value);
boolean match(const ASP__Send& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__Send valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__Send_template& list_item(unsigned int list_index) const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
Socket__API__Definitions::ProtoTuple_template& proto();
const Socket__API__Definitions::ProtoTuple_template& proto() const;
OCTETSTRING_template& msg();
const OCTETSTRING_template& msg() const;
int size_of() const;
void log() const;
void log_match(const ASP__Send& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__SendTo {
  INTEGER field_connId;
  CHARSTRING field_remName;
  INTEGER field_remPort;
  OPTIONAL<Socket__API__Definitions::ProtoTuple> field_proto;
  OCTETSTRING field_msg;
public:
  ASP__SendTo();
  ASP__SendTo(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const OPTIONAL<Socket__API__Definitions::ProtoTuple>& par_proto,
    const OCTETSTRING& par_msg);
  ASP__SendTo(const ASP__SendTo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ASP__SendTo& operator=(const ASP__SendTo& other_value);
  boolean operator==(const ASP__SendTo& other_value) const;
  inline boolean operator!=(const ASP__SendTo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& connId()
    {return field_connId;}
  inline const INTEGER& connId() const
    {return field_connId;}
  inline CHARSTRING& remName()
    {return field_remName;}
  inline const CHARSTRING& remName() const
    {return field_remName;}
  inline INTEGER& remPort()
    {return field_remPort;}
  inline const INTEGER& remPort() const
    {return field_remPort;}
  inline OPTIONAL<Socket__API__Definitions::ProtoTuple>& proto()
    {return field_proto;}
  inline const OPTIONAL<Socket__API__Definitions::ProtoTuple>& proto() const
    {return field_proto;}
  inline OCTETSTRING& msg()
    {return field_msg;}
  inline const OCTETSTRING& msg() const
    {return field_msg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__SendTo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__SendTo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ASP__SendTo& other_value);
void copy_template(const ASP__SendTo_template& other_value);

public:
ASP__SendTo_template();
ASP__SendTo_template(template_sel other_value);
ASP__SendTo_template(const ASP__SendTo& other_value);
ASP__SendTo_template(const OPTIONAL<ASP__SendTo>& other_value);
ASP__SendTo_template(const ASP__SendTo_template& other_value);
~ASP__SendTo_template();
ASP__SendTo_template& operator=(template_sel other_value);
ASP__SendTo_template& operator=(const ASP__SendTo& other_value);
ASP__SendTo_template& operator=(const OPTIONAL<ASP__SendTo>& other_value);
ASP__SendTo_template& operator=(const ASP__SendTo_template& other_value);
boolean match(const ASP__SendTo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__SendTo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__SendTo_template& list_item(unsigned int list_index) const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
CHARSTRING_template& remName();
const CHARSTRING_template& remName() const;
INTEGER_template& remPort();
const INTEGER_template& remPort() const;
Socket__API__Definitions::ProtoTuple_template& proto();
const Socket__API__Definitions::ProtoTuple_template& proto() const;
OCTETSTRING_template& msg();
const OCTETSTRING_template& msg() const;
int size_of() const;
void log() const;
void log_match(const ASP__SendTo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ASP__RecvFrom {
  INTEGER field_connId;
  CHARSTRING field_remName;
  INTEGER field_remPort;
  CHARSTRING field_locName;
  INTEGER field_locPort;
  Socket__API__Definitions::ProtoTuple field_proto;
  INTEGER field_userData;
  OCTETSTRING field_msg;
public:
  ASP__RecvFrom();
  ASP__RecvFrom(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const CHARSTRING& par_locName,
    const INTEGER& par_locPort,
    const Socket__API__Definitions::ProtoTuple& par_proto,
    const INTEGER& par_userData,
    const OCTETSTRING& par_msg);
  ASP__RecvFrom(const ASP__RecvFrom& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ASP__RecvFrom& operator=(const ASP__RecvFrom& other_value);
  boolean operator==(const ASP__RecvFrom& other_value) const;
  inline boolean operator!=(const ASP__RecvFrom& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& connId()
    {return field_connId;}
  inline const INTEGER& connId() const
    {return field_connId;}
  inline CHARSTRING& remName()
    {return field_remName;}
  inline const CHARSTRING& remName() const
    {return field_remName;}
  inline INTEGER& remPort()
    {return field_remPort;}
  inline const INTEGER& remPort() const
    {return field_remPort;}
  inline CHARSTRING& locName()
    {return field_locName;}
  inline const CHARSTRING& locName() const
    {return field_locName;}
  inline INTEGER& locPort()
    {return field_locPort;}
  inline const INTEGER& locPort() const
    {return field_locPort;}
  inline Socket__API__Definitions::ProtoTuple& proto()
    {return field_proto;}
  inline const Socket__API__Definitions::ProtoTuple& proto() const
    {return field_proto;}
  inline INTEGER& userData()
    {return field_userData;}
  inline const INTEGER& userData() const
    {return field_userData;}
  inline OCTETSTRING& msg()
    {return field_msg;}
  inline const OCTETSTRING& msg() const
    {return field_msg;}
  inline int size_of() const
    {return 8;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ASP__RecvFrom_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ASP__RecvFrom_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ASP__RecvFrom& other_value);
void copy_template(const ASP__RecvFrom_template& other_value);

public:
ASP__RecvFrom_template();
ASP__RecvFrom_template(template_sel other_value);
ASP__RecvFrom_template(const ASP__RecvFrom& other_value);
ASP__RecvFrom_template(const OPTIONAL<ASP__RecvFrom>& other_value);
ASP__RecvFrom_template(const ASP__RecvFrom_template& other_value);
~ASP__RecvFrom_template();
ASP__RecvFrom_template& operator=(template_sel other_value);
ASP__RecvFrom_template& operator=(const ASP__RecvFrom& other_value);
ASP__RecvFrom_template& operator=(const OPTIONAL<ASP__RecvFrom>& other_value);
ASP__RecvFrom_template& operator=(const ASP__RecvFrom_template& other_value);
boolean match(const ASP__RecvFrom& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ASP__RecvFrom valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ASP__RecvFrom_template& list_item(unsigned int list_index) const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
CHARSTRING_template& remName();
const CHARSTRING_template& remName() const;
INTEGER_template& remPort();
const INTEGER_template& remPort() const;
CHARSTRING_template& locName();
const CHARSTRING_template& locName() const;
INTEGER_template& locPort();
const INTEGER_template& locPort() const;
Socket__API__Definitions::ProtoTuple_template& proto();
const Socket__API__Definitions::ProtoTuple_template& proto() const;
INTEGER_template& userData();
const INTEGER_template& userData() const;
OCTETSTRING_template& msg();
const OCTETSTRING_template& msg() const;
int size_of() const;
void log() const;
void log_match(const ASP__RecvFrom& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IPL4__Param : public Base_Type { // enum
friend class IPL4__Param_template;
public:
enum enum_type { IPL4__LOCALADDRESS = 0, IPL4__REMOTEADDRESS = 1, IPL4__PROTO = 2, IPL4__USERDATA = 3, IPL4__PARENTIDX = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
IPL4__Param();
IPL4__Param(int other_value);
IPL4__Param(enum_type other_value);
IPL4__Param(const IPL4__Param& other_value);

IPL4__Param& operator=(int other_value);
IPL4__Param& operator=(enum_type other_value);
IPL4__Param& operator=(const IPL4__Param& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const IPL4__Param& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IPL4__Param& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const IPL4__Param& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const IPL4__Param& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const IPL4__Param& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const IPL4__Param& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const IPL4__Param& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class IPL4__Param_template : public Base_Template {
union {
IPL4__Param::enum_type single_value;
struct {
unsigned int n_values;
IPL4__Param_template *list_value;
} value_list;
};

void copy_template(const IPL4__Param_template& other_value);

public:
IPL4__Param_template();
IPL4__Param_template(template_sel other_value);
IPL4__Param_template(int other_value);
IPL4__Param_template(IPL4__Param::enum_type other_value);
IPL4__Param_template(const IPL4__Param& other_value);
IPL4__Param_template(const OPTIONAL<IPL4__Param>& other_value);
IPL4__Param_template(const IPL4__Param_template& other_value);
~IPL4__Param_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPL4__Param_template& operator=(template_sel other_value);
IPL4__Param_template& operator=(int other_value);
IPL4__Param_template& operator=(IPL4__Param::enum_type other_value);
IPL4__Param_template& operator=(const IPL4__Param& other_value);
IPL4__Param_template& operator=(const OPTIONAL<IPL4__Param>& other_value);
IPL4__Param_template& operator=(const IPL4__Param_template& other_value);

boolean match(IPL4__Param::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const IPL4__Param& other_value, boolean legacy = FALSE) const;
IPL4__Param::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPL4__Param_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IPL4__Param& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IPL4__ParamResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_local = 1, ALT_remote = 2, ALT_proto = 3, ALT_userData = 4, ALT_parentIdx = 5 };
private:
union_selection_type union_selection;
union {
Socket__API__Definitions::Socket *field_local;
Socket__API__Definitions::Socket *field_remote;
Socket__API__Definitions::ProtoTuple *field_proto;
INTEGER *field_userData;
INTEGER *field_parentIdx;
};
void copy_value(const IPL4__ParamResult& other_value);

public:
IPL4__ParamResult();
IPL4__ParamResult(const IPL4__ParamResult& other_value);
~IPL4__ParamResult();
IPL4__ParamResult& operator=(const IPL4__ParamResult& other_value);
boolean operator==(const IPL4__ParamResult& other_value) const;
inline boolean operator!=(const IPL4__ParamResult& other_value) const { return !(*this == other_value); }
Socket__API__Definitions::Socket& local();
const Socket__API__Definitions::Socket& local() const;
Socket__API__Definitions::Socket& remote();
const Socket__API__Definitions::Socket& remote() const;
Socket__API__Definitions::ProtoTuple& proto();
const Socket__API__Definitions::ProtoTuple& proto() const;
INTEGER& userData();
const INTEGER& userData() const;
INTEGER& parentIdx();
const INTEGER& parentIdx() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class IPL4__ParamResult_template : public Base_Template {
union {
struct {
IPL4__ParamResult::union_selection_type union_selection;
union {
Socket__API__Definitions::Socket_template *field_local;
Socket__API__Definitions::Socket_template *field_remote;
Socket__API__Definitions::ProtoTuple_template *field_proto;
INTEGER_template *field_userData;
INTEGER_template *field_parentIdx;
};
} single_value;
struct {
unsigned int n_values;
IPL4__ParamResult_template *list_value;
} value_list;
};
void copy_value(const IPL4__ParamResult& other_value);

void copy_template(const IPL4__ParamResult_template& other_value);

public:
IPL4__ParamResult_template();
IPL4__ParamResult_template(template_sel other_value);
IPL4__ParamResult_template(const IPL4__ParamResult& other_value);
IPL4__ParamResult_template(const OPTIONAL<IPL4__ParamResult>& other_value);
IPL4__ParamResult_template(const IPL4__ParamResult_template& other_value);
~IPL4__ParamResult_template();
void clean_up();
IPL4__ParamResult_template& operator=(template_sel other_value);
IPL4__ParamResult_template& operator=(const IPL4__ParamResult& other_value);
IPL4__ParamResult_template& operator=(const OPTIONAL<IPL4__ParamResult>& other_value);
IPL4__ParamResult_template& operator=(const IPL4__ParamResult_template& other_value);
boolean match(const IPL4__ParamResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;IPL4__ParamResult valueof() const;
IPL4__ParamResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Socket__API__Definitions::Socket_template& local();
const Socket__API__Definitions::Socket_template& local() const;
Socket__API__Definitions::Socket_template& remote();
const Socket__API__Definitions::Socket_template& remote() const;
Socket__API__Definitions::ProtoTuple_template& proto();
const Socket__API__Definitions::ProtoTuple_template& proto() const;
INTEGER_template& userData();
const INTEGER_template& userData() const;
INTEGER_template& parentIdx();
const INTEGER_template& parentIdx() const;
boolean ischosen(IPL4__ParamResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const IPL4__ParamResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IPL4__IPAddressType : public Base_Type { // enum
friend class IPL4__IPAddressType_template;
public:
enum enum_type { IPv4 = 0, IPv6 = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
IPL4__IPAddressType();
IPL4__IPAddressType(int other_value);
IPL4__IPAddressType(enum_type other_value);
IPL4__IPAddressType(const IPL4__IPAddressType& other_value);

IPL4__IPAddressType& operator=(int other_value);
IPL4__IPAddressType& operator=(enum_type other_value);
IPL4__IPAddressType& operator=(const IPL4__IPAddressType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const IPL4__IPAddressType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IPL4__IPAddressType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const IPL4__IPAddressType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const IPL4__IPAddressType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const IPL4__IPAddressType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const IPL4__IPAddressType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const IPL4__IPAddressType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class IPL4__IPAddressType_template : public Base_Template {
union {
IPL4__IPAddressType::enum_type single_value;
struct {
unsigned int n_values;
IPL4__IPAddressType_template *list_value;
} value_list;
};

void copy_template(const IPL4__IPAddressType_template& other_value);

public:
IPL4__IPAddressType_template();
IPL4__IPAddressType_template(template_sel other_value);
IPL4__IPAddressType_template(int other_value);
IPL4__IPAddressType_template(IPL4__IPAddressType::enum_type other_value);
IPL4__IPAddressType_template(const IPL4__IPAddressType& other_value);
IPL4__IPAddressType_template(const OPTIONAL<IPL4__IPAddressType>& other_value);
IPL4__IPAddressType_template(const IPL4__IPAddressType_template& other_value);
~IPL4__IPAddressType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPL4__IPAddressType_template& operator=(template_sel other_value);
IPL4__IPAddressType_template& operator=(int other_value);
IPL4__IPAddressType_template& operator=(IPL4__IPAddressType::enum_type other_value);
IPL4__IPAddressType_template& operator=(const IPL4__IPAddressType& other_value);
IPL4__IPAddressType_template& operator=(const OPTIONAL<IPL4__IPAddressType>& other_value);
IPL4__IPAddressType_template& operator=(const IPL4__IPAddressType_template& other_value);

boolean match(IPL4__IPAddressType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const IPL4__IPAddressType& other_value, boolean legacy = FALSE) const;
IPL4__IPAddressType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPL4__IPAddressType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IPL4__IPAddressType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IPL4__SrtpKeysAndSalts {
  OCTETSTRING field_localKey;
  OCTETSTRING field_remoteKey;
  OCTETSTRING field_localSalt;
  OCTETSTRING field_remoteSalt;
public:
  IPL4__SrtpKeysAndSalts();
  IPL4__SrtpKeysAndSalts(const OCTETSTRING& par_localKey,
    const OCTETSTRING& par_remoteKey,
    const OCTETSTRING& par_localSalt,
    const OCTETSTRING& par_remoteSalt);
  IPL4__SrtpKeysAndSalts(const IPL4__SrtpKeysAndSalts& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IPL4__SrtpKeysAndSalts& operator=(const IPL4__SrtpKeysAndSalts& other_value);
  boolean operator==(const IPL4__SrtpKeysAndSalts& other_value) const;
  inline boolean operator!=(const IPL4__SrtpKeysAndSalts& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& localKey()
    {return field_localKey;}
  inline const OCTETSTRING& localKey() const
    {return field_localKey;}
  inline OCTETSTRING& remoteKey()
    {return field_remoteKey;}
  inline const OCTETSTRING& remoteKey() const
    {return field_remoteKey;}
  inline OCTETSTRING& localSalt()
    {return field_localSalt;}
  inline const OCTETSTRING& localSalt() const
    {return field_localSalt;}
  inline OCTETSTRING& remoteSalt()
    {return field_remoteSalt;}
  inline const OCTETSTRING& remoteSalt() const
    {return field_remoteSalt;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class IPL4__SrtpKeysAndSalts_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IPL4__SrtpKeysAndSalts_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IPL4__SrtpKeysAndSalts& other_value);
void copy_template(const IPL4__SrtpKeysAndSalts_template& other_value);

public:
IPL4__SrtpKeysAndSalts_template();
IPL4__SrtpKeysAndSalts_template(template_sel other_value);
IPL4__SrtpKeysAndSalts_template(const IPL4__SrtpKeysAndSalts& other_value);
IPL4__SrtpKeysAndSalts_template(const OPTIONAL<IPL4__SrtpKeysAndSalts>& other_value);
IPL4__SrtpKeysAndSalts_template(const IPL4__SrtpKeysAndSalts_template& other_value);
~IPL4__SrtpKeysAndSalts_template();
IPL4__SrtpKeysAndSalts_template& operator=(template_sel other_value);
IPL4__SrtpKeysAndSalts_template& operator=(const IPL4__SrtpKeysAndSalts& other_value);
IPL4__SrtpKeysAndSalts_template& operator=(const OPTIONAL<IPL4__SrtpKeysAndSalts>& other_value);
IPL4__SrtpKeysAndSalts_template& operator=(const IPL4__SrtpKeysAndSalts_template& other_value);
boolean match(const IPL4__SrtpKeysAndSalts& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPL4__SrtpKeysAndSalts valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPL4__SrtpKeysAndSalts_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& localKey();
const OCTETSTRING_template& localKey() const;
OCTETSTRING_template& remoteKey();
const OCTETSTRING_template& remoteKey() const;
OCTETSTRING_template& localSalt();
const OCTETSTRING_template& localSalt() const;
OCTETSTRING_template& remoteSalt();
const OCTETSTRING_template& remoteSalt() const;
int size_of() const;
void log() const;
void log_match(const IPL4__SrtpKeysAndSalts& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IPL4__DigestMethods : public Base_Type { // enum
friend class IPL4__DigestMethods_template;
public:
enum enum_type { NULL__method = 0, MD4 = 1, MD5 = 2, SHA = 3, SHA1 = 4, DSS = 5, DSS1 = 6, ECDSA = 7, SHA224 = 8, SHA256 = 9, SHA384 = 10, SHA512 = 11, MDC2 = 12, RIPEMD160 = 13, WHIRLPOOL = 14, UNKNOWN_VALUE = 15, UNBOUND_VALUE = 16 };
private:
enum_type enum_value;

public:
IPL4__DigestMethods();
IPL4__DigestMethods(int other_value);
IPL4__DigestMethods(enum_type other_value);
IPL4__DigestMethods(const IPL4__DigestMethods& other_value);

IPL4__DigestMethods& operator=(int other_value);
IPL4__DigestMethods& operator=(enum_type other_value);
IPL4__DigestMethods& operator=(const IPL4__DigestMethods& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const IPL4__DigestMethods& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IPL4__DigestMethods& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const IPL4__DigestMethods& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const IPL4__DigestMethods& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const IPL4__DigestMethods& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const IPL4__DigestMethods& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const IPL4__DigestMethods& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class IPL4__DigestMethods_template : public Base_Template {
union {
IPL4__DigestMethods::enum_type single_value;
struct {
unsigned int n_values;
IPL4__DigestMethods_template *list_value;
} value_list;
};

void copy_template(const IPL4__DigestMethods_template& other_value);

public:
IPL4__DigestMethods_template();
IPL4__DigestMethods_template(template_sel other_value);
IPL4__DigestMethods_template(int other_value);
IPL4__DigestMethods_template(IPL4__DigestMethods::enum_type other_value);
IPL4__DigestMethods_template(const IPL4__DigestMethods& other_value);
IPL4__DigestMethods_template(const OPTIONAL<IPL4__DigestMethods>& other_value);
IPL4__DigestMethods_template(const IPL4__DigestMethods_template& other_value);
~IPL4__DigestMethods_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
IPL4__DigestMethods_template& operator=(template_sel other_value);
IPL4__DigestMethods_template& operator=(int other_value);
IPL4__DigestMethods_template& operator=(IPL4__DigestMethods::enum_type other_value);
IPL4__DigestMethods_template& operator=(const IPL4__DigestMethods& other_value);
IPL4__DigestMethods_template& operator=(const OPTIONAL<IPL4__DigestMethods>& other_value);
IPL4__DigestMethods_template& operator=(const IPL4__DigestMethods_template& other_value);

boolean match(IPL4__DigestMethods::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const IPL4__DigestMethods& other_value, boolean legacy = FALSE) const;
IPL4__DigestMethods::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IPL4__DigestMethods_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IPL4__DigestMethods& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const SSL__proto__support& other_value);
inline boolean operator!=(null_type null_value, const SSL__proto__support& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const OptionList& other_value);
inline boolean operator!=(null_type null_value, const OptionList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t ConnectionId_xer_;
extern const TTCN_Typedescriptor_t ConnectionId_descr_;
extern const TTCN_Typedescriptor_t& ro__ConnectionId_descr_;
extern const XERdescriptor_t AssociationId_xer_;
extern const TTCN_Typedescriptor_t AssociationId_descr_;
extern const TTCN_Typedescriptor_t& ro__AssociationId_descr_;
extern const XERdescriptor_t HostName_xer_;
extern const TTCN_Typedescriptor_t HostName_descr_;
extern const XERdescriptor_t PortNumber_xer_;
extern const TTCN_Typedescriptor_t PortNumber_descr_;
extern const TTCN_Typedescriptor_t& Socket_descr_;
extern const TTCN_Typedescriptor_t& SocketList_descr_;
extern const TTCN_Typedescriptor_t& UdpTuple_descr_;
extern const TTCN_Typedescriptor_t& TcpTuple_descr_;
extern const TTCN_Typedescriptor_t& SctpTuple_descr_;
extern const TTCN_Typedescriptor_t& SslTuple_descr_;
extern const TTCN_Typedescriptor_t& UnspecifiedTuple_descr_;
extern const TTCN_Typedescriptor_t& ProtoTuple_descr_;
extern const TTCN_Typedescriptor_t& Result_descr_;
extern const TTCN_Typedescriptor_t& Extended__Result_descr_;
extern const XERdescriptor_t UserData_xer_;
extern const TTCN_Typedescriptor_t UserData_descr_;
extern const TTCN_Typedescriptor_t& PortError_descr_;
extern const TTCN_Typedescriptor_t& ConnectionOpenedEvent_descr_;
extern const TTCN_Typedescriptor_t& ConnectionClosedEvent_descr_;
extern const TTCN_Typedescriptor_t& SctpEvent_descr_;
extern const TTCN_Typedescriptor_t& PortEvent_descr_;
extern const TTCN_Typedescriptor_t& SAC__STATE_descr_;
extern const TTCN_Typedescriptor_t& SctpAssocChange_descr_;
extern const TTCN_Typedescriptor_t& SPC__STATE_descr_;
extern const TTCN_Typedescriptor_t& SctpPeerAddrChange_descr_;
extern const TTCN_Typedescriptor_t& SctpSendFailed_descr_;
extern const TTCN_Typedescriptor_t& SctpRemoteError_descr_;
extern const TTCN_Typedescriptor_t& SctpShutDownEvent_descr_;
extern const TTCN_Typedescriptor_t& SctpPartialDeliveryEvent_descr_;
extern const TTCN_Typedescriptor_t& SctpAdaptationIndication_descr_;
extern const TTCN_Typedescriptor_t& ro__integer_descr_;
extern const TTCN_Typedescriptor_t& f__getMsgLen_descr_;
extern const TTCN_Typedescriptor_t& ro__charstring_descr_;
extern const TTCN_Typedescriptor_t TcpKeepAlive_descr_;
extern const XERdescriptor_t TcpKeepAlive_enable_xer_;
extern const TTCN_Typedescriptor_t TcpKeepAlive_enable_descr_;
extern const XERdescriptor_t TcpKeepAlive_count_xer_;
extern const TTCN_Typedescriptor_t TcpKeepAlive_count_descr_;
extern const XERdescriptor_t TcpKeepAlive_idle_xer_;
extern const TTCN_Typedescriptor_t TcpKeepAlive_idle_descr_;
extern const XERdescriptor_t TcpKeepAlive_interval_xer_;
extern const TTCN_Typedescriptor_t TcpKeepAlive_interval_descr_;
extern const TTCN_Typedescriptor_t ReuseAddress_descr_;
extern const XERdescriptor_t ReuseAddress_enable_xer_;
extern const TTCN_Typedescriptor_t ReuseAddress_enable_descr_;
extern const TTCN_Typedescriptor_t SctpEventHandle_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__data__io__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__data__io__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__association__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__association__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__address__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__address__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__send__failure__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__send__failure__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__peer__error__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__peer__error__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__shutdown__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__shutdown__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__partial__delivery__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__partial__delivery__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__adaptation__layer__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__adaptation__layer__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__authentication__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__authentication__event_descr_;
extern const XERdescriptor_t SctpEventHandle_sctp__sender__dry__event_xer_;
extern const TTCN_Typedescriptor_t SctpEventHandle_sctp__sender__dry__event_descr_;
extern const XERdescriptor_t Linger__opt_l__onoff_xer_;
extern const TTCN_Typedescriptor_t Linger__opt_l__onoff_descr_;
extern const XERdescriptor_t Linger__opt_l__linger_xer_;
extern const TTCN_Typedescriptor_t Linger__opt_l__linger_descr_;
extern const TTCN_Typedescriptor_t Linger__opt_descr_;
extern const TTCN_Typedescriptor_t SSL__protocols_descr_;
extern const XERdescriptor_t SSL__protocols_SSLv2__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_SSLv2__supported_descr_;
extern const XERdescriptor_t SSL__protocols_SSLv3__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_SSLv3__supported_descr_;
extern const XERdescriptor_t SSL__protocols_TLSv1__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_TLSv1__supported_descr_;
extern const XERdescriptor_t SSL__protocols_TLSv1__1__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_TLSv1__1__supported_descr_;
extern const XERdescriptor_t SSL__protocols_TLSv1__2__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_TLSv1__2__supported_descr_;
extern const XERdescriptor_t SSL__protocols_DTLSv1__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_DTLSv1__supported_descr_;
extern const XERdescriptor_t SSL__protocols_DTLSv1__2__supported_xer_;
extern const TTCN_Typedescriptor_t SSL__protocols_DTLSv1__2__supported_descr_;
extern const TTCN_Typedescriptor_t SSL__proto__support_descr_;
extern const TTCN_Typedescriptor_t SSL__cert__options_descr_;
extern const XERdescriptor_t SSL__cert__options_ssl__key__file_xer_;
extern const TTCN_Typedescriptor_t SSL__cert__options_ssl__key__file_descr_;
extern const XERdescriptor_t SSL__cert__options_ssl__certificate__file_xer_;
extern const TTCN_Typedescriptor_t SSL__cert__options_ssl__certificate__file_descr_;
extern const XERdescriptor_t SSL__cert__options_ssl__trustedCAlist__file_xer_;
extern const TTCN_Typedescriptor_t SSL__cert__options_ssl__trustedCAlist__file_descr_;
extern const XERdescriptor_t SSL__cert__options_ssl__cipher__list_xer_;
extern const TTCN_Typedescriptor_t SSL__cert__options_ssl__cipher__list_descr_;
extern const XERdescriptor_t SSL__cert__options_ssl__password_xer_;
extern const TTCN_Typedescriptor_t SSL__cert__options_ssl__password_descr_;
extern const TTCN_Typedescriptor_t Option_descr_;
extern const TTCN_Typedescriptor_t HostList_descr_;
extern const XERdescriptor_t HostList_0_xer_;
extern const TTCN_Typedescriptor_t HostList_0_descr_;
extern const XERdescriptor_t Option_sctpEINConfigGroup_xer_;
extern const TTCN_Typedescriptor_t Option_sctpEINConfigGroup_descr_;
extern const XERdescriptor_t Option_no__delay_xer_;
extern const TTCN_Typedescriptor_t Option_no__delay_descr_;
extern const XERdescriptor_t Option_dtlsSrtpProfiles_xer_;
extern const TTCN_Typedescriptor_t Option_dtlsSrtpProfiles_descr_;
extern const XERdescriptor_t Option_freebind_xer_;
extern const TTCN_Typedescriptor_t Option_freebind_descr_;
extern const TTCN_Typedescriptor_t Option_alpn__list_descr_;
extern const XERdescriptor_t Option_alpn__list_0_xer_;
extern const TTCN_Typedescriptor_t Option_alpn__list_0_descr_;
extern const XERdescriptor_t Option_tls__hostname_xer_;
extern const TTCN_Typedescriptor_t Option_tls__hostname_descr_;
extern const TTCN_Typedescriptor_t OptionList_descr_;
extern const XERdescriptor_t ASP__Send_connId_xer_;
extern const TTCN_Typedescriptor_t ASP__Send_connId_descr_;
extern const XERdescriptor_t ASP__Send_msg_xer_;
extern const TTCN_Typedescriptor_t ASP__Send_msg_descr_;
extern const TTCN_Typedescriptor_t ASP__Send_descr_;
extern const XERdescriptor_t ASP__SendTo_connId_xer_;
extern const TTCN_Typedescriptor_t ASP__SendTo_connId_descr_;
extern const XERdescriptor_t ASP__SendTo_remName_xer_;
extern const TTCN_Typedescriptor_t ASP__SendTo_remName_descr_;
extern const XERdescriptor_t ASP__SendTo_remPort_xer_;
extern const TTCN_Typedescriptor_t ASP__SendTo_remPort_descr_;
extern const XERdescriptor_t ASP__SendTo_msg_xer_;
extern const TTCN_Typedescriptor_t ASP__SendTo_msg_descr_;
extern const TTCN_Typedescriptor_t ASP__SendTo_descr_;
extern const XERdescriptor_t ASP__RecvFrom_connId_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_connId_descr_;
extern const XERdescriptor_t ASP__RecvFrom_remName_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_remName_descr_;
extern const XERdescriptor_t ASP__RecvFrom_remPort_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_remPort_descr_;
extern const XERdescriptor_t ASP__RecvFrom_locName_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_locName_descr_;
extern const XERdescriptor_t ASP__RecvFrom_locPort_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_locPort_descr_;
extern const XERdescriptor_t ASP__RecvFrom_userData_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_userData_descr_;
extern const XERdescriptor_t ASP__RecvFrom_msg_xer_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_msg_descr_;
extern const TTCN_Typedescriptor_t ASP__RecvFrom_descr_;
extern const TTCN_Typedescriptor_t& ASP__Event_descr_;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__GENERAL;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__INSUFFICIENT__MEMORY;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__INVALID__INPUT__PARAMETER;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__UNSUPPORTED__TRANSPORT;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__SOCKET;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__HOSTNAME;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__INVALID__CONNECTION;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__TEMPORARILY__UNAVAILABLE;
extern const Socket__API__Definitions::PortError& IPL4__ERROR__AVAILABLE;
extern const TTCN_Typedescriptor_t& f__IPL4__getMsgLen_descr_;
extern const TTCN_Typedescriptor_t IPL4__Param_descr_;
extern const TTCN_Typedescriptor_t IPL4__ParamResult_descr_;
extern const XERdescriptor_t IPL4__ParamResult_userData_xer_;
extern const TTCN_Typedescriptor_t IPL4__ParamResult_userData_descr_;
extern const XERdescriptor_t IPL4__ParamResult_parentIdx_xer_;
extern const TTCN_Typedescriptor_t IPL4__ParamResult_parentIdx_descr_;
extern const TTCN_Typedescriptor_t IPL4__IPAddressType_descr_;
extern const XERdescriptor_t IPL4__SrtpKeysAndSalts_localKey_xer_;
extern const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_localKey_descr_;
extern const XERdescriptor_t IPL4__SrtpKeysAndSalts_remoteKey_xer_;
extern const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_remoteKey_descr_;
extern const XERdescriptor_t IPL4__SrtpKeysAndSalts_localSalt_xer_;
extern const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_localSalt_descr_;
extern const XERdescriptor_t IPL4__SrtpKeysAndSalts_remoteSalt_xer_;
extern const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_remoteSalt_descr_;
extern const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_descr_;
extern const TTCN_Typedescriptor_t IPL4__DigestMethods_descr_;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile;
extern const CHARSTRING& c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
