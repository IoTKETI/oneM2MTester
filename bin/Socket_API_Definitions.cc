// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "Socket_API_Definitions.hh"

namespace Socket__API__Definitions {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const CHARSTRING cs_2(0, NULL),
cs_0(7, "0.0.0.0"),
cs_1(2, "::");
static const unsigned char module_checksum[] = { 0xeb, 0x26, 0x77, 0x53, 0x71, 0x24, 0xe9, 0x7e, 0xe6, 0xd4, 0xf9, 0xed, 0xfb, 0xa6, 0xba, 0x7f };

/* Global variable definitions */

const XERdescriptor_t       ConnectionId_xer_ = { {"ConnectionId>\n", "ConnectionId>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionId_descr_ = { "@Socket_API_Definitions.ConnectionId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ro__ConnectionId
const TTCN_Typedescriptor_t ro__ConnectionId_descr_ = { "@Socket_API_Definitions.ro_ConnectionId", NULL, NULL, NULL, NULL, NULL, &ConnectionId_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ro__ConnectionId_0_xer_ = { {"ConnectionId>\n", "ConnectionId>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ro__ConnectionId_0_descr_ = { "@Socket_API_Definitions.ro_ConnectionId.<oftype>", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ro__ConnectionId_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AssociationId_xer_ = { {"AssociationId>\n", "AssociationId>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t AssociationId_descr_ = { "@Socket_API_Definitions.AssociationId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &AssociationId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ro__AssociationId
const TTCN_Typedescriptor_t ro__AssociationId_descr_ = { "@Socket_API_Definitions.ro_AssociationId", NULL, NULL, NULL, NULL, NULL, &AssociationId_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ro__AssociationId_0_xer_ = { {"AssociationId>\n", "AssociationId>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ro__AssociationId_0_descr_ = { "@Socket_API_Definitions.ro_AssociationId.<oftype>", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ro__AssociationId_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HostName_xer_ = { {"HostName>\n", "HostName>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t HostName_descr_ = { "@Socket_API_Definitions.HostName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &HostName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PortNumber_xer_ = { {"PortNumber>\n", "PortNumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PortNumber_descr_ = { "@Socket_API_Definitions.PortNumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &PortNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Socket_hostName_xer_ = { {"hostName>\n", "hostName>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Socket_hostName_descr_ = { "@Socket_API_Definitions.Socket.hostName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Socket_hostName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Socket_portNumber_xer_ = { {"portNumber>\n", "portNumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Socket_portNumber_descr_ = { "@Socket_API_Definitions.Socket.portNumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Socket_portNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Socket
const TTCN_Typedescriptor_t Socket_descr_ = { "@Socket_API_Definitions.Socket", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SocketList
const TTCN_Typedescriptor_t SocketList_descr_ = { "@Socket_API_Definitions.SocketList", NULL, NULL, NULL, NULL, NULL, &Socket_descr_, TTCN_Typedescriptor_t::DONTCARE };
static CHARSTRING const_c__ipv4AnyAddr;
const CHARSTRING& c__ipv4AnyAddr = const_c__ipv4AnyAddr;
static CHARSTRING const_c__ipv6AnyAddr;
const CHARSTRING& c__ipv6AnyAddr = const_c__ipv6AnyAddr;
static INTEGER const_c__anyPort;
const INTEGER& c__anyPort = const_c__anyPort;
static CHARSTRING const_c__defaultLocAddr;
const CHARSTRING& c__defaultLocAddr = const_c__defaultLocAddr;
static INTEGER const_c__defaultLocPort;
const INTEGER& c__defaultLocPort = const_c__defaultLocPort;
// No XER for UdpTuple
const TTCN_Typedescriptor_t UdpTuple_descr_ = { "@Socket_API_Definitions.UdpTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for UdpLightTuple
const TTCN_Typedescriptor_t UdpLightTuple_descr_ = { "@Socket_API_Definitions.UdpLightTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for TcpTuple
const TTCN_Typedescriptor_t TcpTuple_descr_ = { "@Socket_API_Definitions.TcpTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpTuple
const TTCN_Typedescriptor_t SctpTuple_descr_ = { "@Socket_API_Definitions.SctpTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpTuple_sinfo__stream_xer_ = { {"sinfo_stream>\n", "sinfo_stream>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpTuple_sinfo__stream_descr_ = { "@Socket_API_Definitions.SctpTuple.sinfo_stream", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpTuple_sinfo__stream_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpTuple_sinfo__ppid_xer_ = { {"sinfo_ppid>\n", "sinfo_ppid>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpTuple_sinfo__ppid_descr_ = { "@Socket_API_Definitions.SctpTuple.sinfo_ppid", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpTuple_sinfo__ppid_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpTuple_assocId_xer_ = { {"assocId>\n", "assocId>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpTuple_assocId_descr_ = { "@Socket_API_Definitions.SctpTuple.assocId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpTuple_assocId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SslTuple
const TTCN_Typedescriptor_t SslTuple_descr_ = { "@Socket_API_Definitions.SslTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DtlsTuple
const TTCN_Typedescriptor_t DtlsTuple_descr_ = { "@Socket_API_Definitions.DtlsTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for UnspecifiedTuple
const TTCN_Typedescriptor_t UnspecifiedTuple_descr_ = { "@Socket_API_Definitions.UnspecifiedTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ProtoTuple
const TTCN_Typedescriptor_t ProtoTuple_descr_ = { "@Socket_API_Definitions.ProtoTuple", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UserData_xer_ = { {"UserData>\n", "UserData>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UserData_descr_ = { "@Socket_API_Definitions.UserData", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &UserData_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PortError
const TTCN_Typedescriptor_t PortError_descr_ = { "@Socket_API_Definitions.PortError", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Result
const TTCN_Typedescriptor_t Result_descr_ = { "@Socket_API_Definitions.Result", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Result_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Result_connId_descr_ = { "@Socket_API_Definitions.Result.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Result_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Result_os__error__code_xer_ = { {"os_error_code>\n", "os_error_code>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Result_os__error__code_descr_ = { "@Socket_API_Definitions.Result.os_error_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Result_os__error__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Result_os__error__text_xer_ = { {"os_error_text>\n", "os_error_text>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Result_os__error__text_descr_ = { "@Socket_API_Definitions.Result.os_error_text", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Result_os__error__text_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Extended__Result
const TTCN_Typedescriptor_t Extended__Result_descr_ = { "@Socket_API_Definitions.Extended_Result", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Extended__Result_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Extended__Result_connId_descr_ = { "@Socket_API_Definitions.Extended_Result.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Extended__Result_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Extended__Result_os__error__code_xer_ = { {"os_error_code>\n", "os_error_code>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Extended__Result_os__error__code_descr_ = { "@Socket_API_Definitions.Extended_Result.os_error_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Extended__Result_os__error__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Extended__Result_os__error__text_xer_ = { {"os_error_text>\n", "os_error_text>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Extended__Result_os__error__text_descr_ = { "@Socket_API_Definitions.Extended_Result.os_error_text", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Extended__Result_os__error__text_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Extended__Result_msg_xer_ = { {"msg>\n", "msg>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Extended__Result_msg_descr_ = { "@Socket_API_Definitions.Extended_Result.msg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &Extended__Result_msg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_connId_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionOpenedEvent_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_remName_xer_ = { {"remName>\n", "remName>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_remName_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.remName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ConnectionOpenedEvent_remName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_remPort_xer_ = { {"remPort>\n", "remPort>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_remPort_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.remPort", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionOpenedEvent_remPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_locName_xer_ = { {"locName>\n", "locName>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_locName_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.locName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ConnectionOpenedEvent_locName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_locPort_xer_ = { {"locPort>\n", "locPort>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_locPort_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.locPort", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionOpenedEvent_locPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ConnectionOpenedEvent_userData_xer_ = { {"userData>\n", "userData>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionOpenedEvent_userData_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent.userData", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionOpenedEvent_userData_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ConnectionOpenedEvent
const TTCN_Typedescriptor_t ConnectionOpenedEvent_descr_ = { "@Socket_API_Definitions.ConnectionOpenedEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ConnectionClosedEvent_descr_ = ConnectionOpenedEvent_descr_;
// No XER for SctpEvent
const TTCN_Typedescriptor_t SctpEvent_descr_ = { "@Socket_API_Definitions.SctpEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpAssocChange_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpAssocChange_clientId_descr_ = { "@Socket_API_Definitions.SctpAssocChange.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpAssocChange_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SAC__STATE
const TTCN_Typedescriptor_t SAC__STATE_descr_ = { "@Socket_API_Definitions.SAC_STATE", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpAssocChange
const TTCN_Typedescriptor_t SctpAssocChange_descr_ = { "@Socket_API_Definitions.SctpAssocChange", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpPeerAddrChange_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpPeerAddrChange_clientId_descr_ = { "@Socket_API_Definitions.SctpPeerAddrChange.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpPeerAddrChange_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SPC__STATE
const TTCN_Typedescriptor_t SPC__STATE_descr_ = { "@Socket_API_Definitions.SPC_STATE", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpPeerAddrChange
const TTCN_Typedescriptor_t SctpPeerAddrChange_descr_ = { "@Socket_API_Definitions.SctpPeerAddrChange", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpSendFailed_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpSendFailed_clientId_descr_ = { "@Socket_API_Definitions.SctpSendFailed.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpSendFailed_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpSendFailed
const TTCN_Typedescriptor_t SctpSendFailed_descr_ = { "@Socket_API_Definitions.SctpSendFailed", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpRemoteError_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpRemoteError_clientId_descr_ = { "@Socket_API_Definitions.SctpRemoteError.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpRemoteError_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpRemoteError
const TTCN_Typedescriptor_t SctpRemoteError_descr_ = { "@Socket_API_Definitions.SctpRemoteError", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpShutDownEvent_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpShutDownEvent_clientId_descr_ = { "@Socket_API_Definitions.SctpShutDownEvent.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpShutDownEvent_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpShutDownEvent
const TTCN_Typedescriptor_t SctpShutDownEvent_descr_ = { "@Socket_API_Definitions.SctpShutDownEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpPartialDeliveryEvent_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpPartialDeliveryEvent_clientId_descr_ = { "@Socket_API_Definitions.SctpPartialDeliveryEvent.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpPartialDeliveryEvent_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpPartialDeliveryEvent
const TTCN_Typedescriptor_t SctpPartialDeliveryEvent_descr_ = { "@Socket_API_Definitions.SctpPartialDeliveryEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpAdaptationIndication_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpAdaptationIndication_clientId_descr_ = { "@Socket_API_Definitions.SctpAdaptationIndication.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpAdaptationIndication_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpAdaptationIndication
const TTCN_Typedescriptor_t SctpAdaptationIndication_descr_ = { "@Socket_API_Definitions.SctpAdaptationIndication", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpSenderDryEvent_clientId_xer_ = { {"clientId>\n", "clientId>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpSenderDryEvent_clientId_descr_ = { "@Socket_API_Definitions.SctpSenderDryEvent.clientId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &SctpSenderDryEvent_clientId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpSenderDryEvent
const TTCN_Typedescriptor_t SctpSenderDryEvent_descr_ = { "@Socket_API_Definitions.SctpSenderDryEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for PortEvent
const TTCN_Typedescriptor_t PortEvent_descr_ = { "@Socket_API_Definitions.PortEvent", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ro__integer
const TTCN_Typedescriptor_t ro__integer_descr_ = { "@Socket_API_Definitions.ro_integer", NULL, NULL, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ro__integer_0_xer_ = { {"INTEGER>\n", "INTEGER>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ro__integer_0_descr_ = { "@Socket_API_Definitions.ro_integer.INTEGER", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ro__integer_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for f__getMsgLen
const TTCN_Typedescriptor_t f__getMsgLen_descr_ = { "@Socket_API_Definitions.f_getMsgLen", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ro__charstring
const TTCN_Typedescriptor_t ro__charstring_descr_ = { "@Socket_API_Definitions.ro_charstring", NULL, NULL, NULL, NULL, NULL, &CHARSTRING_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ro__charstring_0_xer_ = { {"CHARSTRING>\n", "CHARSTRING>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ro__charstring_0_descr_ = { "@Socket_API_Definitions.ro_charstring.<oftype>", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ro__charstring_0_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("Socket_API_Definitions", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

Socket::Socket()
{
}

Socket::Socket(const CHARSTRING& par_hostName,
    const INTEGER& par_portNumber)
  :   field_hostName(par_hostName),
  field_portNumber(par_portNumber)
{
}

Socket::Socket(const Socket& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.Socket.");
if (other_value.hostName().is_bound()) field_hostName = other_value.hostName();
else field_hostName.clean_up();
if (other_value.portNumber().is_bound()) field_portNumber = other_value.portNumber();
else field_portNumber.clean_up();
}

void Socket::clean_up()
{
field_hostName.clean_up();
field_portNumber.clean_up();
}

Socket& Socket::operator=(const Socket& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.Socket.");
  if (other_value.hostName().is_bound()) field_hostName = other_value.hostName();
  else field_hostName.clean_up();
  if (other_value.portNumber().is_bound()) field_portNumber = other_value.portNumber();
  else field_portNumber.clean_up();
}
return *this;
}

boolean Socket::operator==(const Socket& other_value) const
{
return field_hostName==other_value.field_hostName
  && field_portNumber==other_value.field_portNumber;
}

boolean Socket::is_bound() const
{
if(field_hostName.is_bound()) return TRUE;
if(field_portNumber.is_bound()) return TRUE;
return FALSE;
}
boolean Socket::is_value() const
{
if(!field_hostName.is_value()) return FALSE;
if(!field_portNumber.is_value()) return FALSE;
return TRUE;
}
void Socket::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ hostName := ");
field_hostName.log();
TTCN_Logger::log_event_str(", portNumber := ");
field_portNumber.log();
TTCN_Logger::log_event_str(" }");
}

void Socket::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.Socket has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostName().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portNumber().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portNumber().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Socket: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.Socket");
  }
}

void Socket::set_implicit_omit()
{
if (hostName().is_bound()) hostName().set_implicit_omit();
if (portNumber().is_bound()) portNumber().set_implicit_omit();
}

void Socket::encode_text(Text_Buf& text_buf) const
{
field_hostName.encode_text(text_buf);
field_portNumber.encode_text(text_buf);
}

void Socket::decode_text(Text_Buf& text_buf)
{
field_hostName.decode_text(text_buf);
field_portNumber.decode_text(text_buf);
}

struct Socket_template::single_value_struct {
CHARSTRING_template field_hostName;
INTEGER_template field_portNumber;
};

void Socket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_hostName = ANY_VALUE;
single_value->field_portNumber = ANY_VALUE;
}
}
}

void Socket_template::copy_value(const Socket& other_value)
{
single_value = new single_value_struct;
if (other_value.hostName().is_bound()) {
  single_value->field_hostName = other_value.hostName();
} else {
  single_value->field_hostName.clean_up();
}
if (other_value.portNumber().is_bound()) {
  single_value->field_portNumber = other_value.portNumber();
} else {
  single_value->field_portNumber.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Socket_template::copy_template(const Socket_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.hostName().get_selection()) {
single_value->field_hostName = other_value.hostName();
} else {
single_value->field_hostName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.portNumber().get_selection()) {
single_value->field_portNumber = other_value.portNumber();
} else {
single_value->field_portNumber.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Socket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.Socket.");
break;
}
set_selection(other_value);
}

Socket_template::Socket_template()
{
}

Socket_template::Socket_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Socket_template::Socket_template(const Socket& other_value)
{
copy_value(other_value);
}

Socket_template::Socket_template(const OPTIONAL<Socket>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Socket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.Socket from an unbound optional field.");
}
}

Socket_template::Socket_template(const Socket_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Socket_template::~Socket_template()
{
clean_up();
}

Socket_template& Socket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Socket_template& Socket_template::operator=(const Socket& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Socket_template& Socket_template::operator=(const OPTIONAL<Socket>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Socket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.Socket.");
}
return *this;
}

Socket_template& Socket_template::operator=(const Socket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Socket_template::match(const Socket& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.hostName().is_bound()) return FALSE;
if(!single_value->field_hostName.match(other_value.hostName(), legacy))return FALSE;
if(!other_value.portNumber().is_bound()) return FALSE;
if(!single_value->field_portNumber.match(other_value.portNumber(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.Socket.");
}
return FALSE;
}

boolean Socket_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_hostName.is_bound()) return TRUE;
if (single_value->field_portNumber.is_bound()) return TRUE;
return FALSE;
}

boolean Socket_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_hostName.is_value()) return FALSE;
if (!single_value->field_portNumber.is_value()) return FALSE;
return TRUE;
}

void Socket_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Socket Socket_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.Socket.");
Socket ret_val;
if (single_value->field_hostName.is_bound()) {
ret_val.hostName() = single_value->field_hostName.valueof();
}
if (single_value->field_portNumber.is_bound()) {
ret_val.portNumber() = single_value->field_portNumber.valueof();
}
return ret_val;
}

void Socket_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.Socket.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Socket_template[list_length];
}

Socket_template& Socket_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.Socket.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.Socket.");
return value_list.list_value[list_index];
}

CHARSTRING_template& Socket_template::hostName()
{
set_specific();
return single_value->field_hostName;
}

const CHARSTRING_template& Socket_template::hostName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hostName of a non-specific template of type @Socket_API_Definitions.Socket.");
return single_value->field_hostName;
}

INTEGER_template& Socket_template::portNumber()
{
set_specific();
return single_value->field_portNumber;
}

const INTEGER_template& Socket_template::portNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field portNumber of a non-specific template of type @Socket_API_Definitions.Socket.");
return single_value->field_portNumber;
}

int Socket_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Socket containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.Socket.");
  }
  return 0;
}

void Socket_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ hostName := ");
single_value->field_hostName.log();
TTCN_Logger::log_event_str(", portNumber := ");
single_value->field_portNumber.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Socket_template::log_match(const Socket& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_hostName.match(match_value.hostName(), legacy)){
TTCN_Logger::log_logmatch_info(".hostName");
single_value->field_hostName.log_match(match_value.hostName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_portNumber.match(match_value.portNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".portNumber");
single_value->field_portNumber.log_match(match_value.portNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ hostName := ");
single_value->field_hostName.log_match(match_value.hostName(), legacy);
TTCN_Logger::log_event_str(", portNumber := ");
single_value->field_portNumber.log_match(match_value.portNumber(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Socket_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_hostName.encode_text(text_buf);
single_value->field_portNumber.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.Socket.");
}
}

void Socket_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_hostName.decode_text(text_buf);
single_value->field_portNumber.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Socket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.Socket.");
}
}

void Socket_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Socket_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.Socket has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) hostName().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) portNumber().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hostName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hostName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "portNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          portNumber().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Socket: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.Socket");
  }
  is_ifpresent = param.get_ifpresent();
}

void Socket_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_hostName.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Socket");
single_value->field_portNumber.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Socket");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.Socket");
}

boolean Socket_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Socket_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const Socket SocketList::UNBOUND_ELEM;
SocketList::SocketList()
{
val_ptr = NULL;
}

SocketList::SocketList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

SocketList::SocketList(const SocketList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SocketList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

SocketList::~SocketList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void SocketList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

SocketList& SocketList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

SocketList& SocketList::operator=(const SocketList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @Socket_API_Definitions.SocketList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean SocketList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @Socket_API_Definitions.SocketList.");
return val_ptr->n_elements == 0 ;
}

boolean SocketList::operator==(const SocketList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @Socket_API_Definitions.SocketList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @Socket_API_Definitions.SocketList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

Socket& SocketList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @Socket_API_Definitions.SocketList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (Socket**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Socket(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new Socket;
}
return *val_ptr->value_elements[index_value];
}

Socket& SocketList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @Socket_API_Definitions.SocketList.");
return (*this)[(int)index_value];
}

const Socket& SocketList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @Socket_API_Definitions.SocketList.");
if (index_value < 0) TTCN_error("Accessing an element of type @Socket_API_Definitions.SocketList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @Socket_API_Definitions.SocketList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const Socket& SocketList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @Socket_API_Definitions.SocketList.");
return (*this)[(int)index_value];
}

SocketList SocketList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

SocketList SocketList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

SocketList SocketList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

SocketList SocketList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @Socket_API_Definitions.SocketList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
SocketList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new Socket(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

SocketList SocketList::operator+(const SocketList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @Socket_API_Definitions.SocketList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
SocketList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Socket(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new Socket(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

SocketList SocketList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @Socket_API_Definitions.SocketList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@Socket_API_Definitions.SocketList","element");
SocketList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new Socket(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

SocketList SocketList::replace(int index, int len, const SocketList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @Socket_API_Definitions.SocketList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @Socket_API_Definitions.SocketList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@Socket_API_Definitions.SocketList","element");
SocketList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Socket(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new Socket(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new Socket(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

SocketList SocketList::replace(int index, int len, const SocketList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void SocketList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @Socket_API_Definitions.SocketList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (Socket**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Socket(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (Socket**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @Socket_API_Definitions.SocketList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (Socket**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean SocketList::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int SocketList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @Socket_API_Definitions.SocketList.");
return val_ptr->n_elements;
}

int SocketList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @Socket_API_Definitions.SocketList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void SocketList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void SocketList::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@Socket_API_Definitions.SocketList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@Socket_API_Definitions.SocketList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void SocketList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void SocketList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.SocketList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void SocketList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @Socket_API_Definitions.SocketList.");
val_ptr->value_elements = (Socket**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new Socket;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void SocketList_template::copy_value(const SocketList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @Socket_API_Definitions.SocketList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (Socket_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new Socket_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new Socket_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void SocketList_template::copy_template(const SocketList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (Socket_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new Socket_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new Socket_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SocketList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SocketList.");
break;
}
set_selection(other_value);
}

boolean SocketList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SocketList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const SocketList*)value_ptr)[value_index], legacy);
else return ((const SocketList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

SocketList_template::SocketList_template()
{
}

SocketList_template::SocketList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

SocketList_template::SocketList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

SocketList_template::SocketList_template(const SocketList& other_value)
{
copy_value(other_value);
}

SocketList_template::SocketList_template(const OPTIONAL<SocketList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SocketList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SocketList from an unbound optional field.");
}
}

SocketList_template::SocketList_template(const SocketList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

SocketList_template::~SocketList_template()
{
clean_up();
}

void SocketList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SocketList_template& SocketList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SocketList_template& SocketList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

SocketList_template& SocketList_template::operator=(const SocketList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SocketList_template& SocketList_template::operator=(const OPTIONAL<SocketList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SocketList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SocketList.");
}
return *this;
}

SocketList_template& SocketList_template::operator=(const SocketList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Socket_template& SocketList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @Socket_API_Definitions.SocketList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @Socket_API_Definitions.SocketList.");
    break;
}
return *single_value.value_elements[index_value];
}

Socket_template& SocketList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @Socket_API_Definitions.SocketList.");
return (*this)[(int)index_value];
}

const Socket_template& SocketList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @Socket_API_Definitions.SocketList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @Socket_API_Definitions.SocketList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @Socket_API_Definitions.SocketList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const Socket_template& SocketList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @Socket_API_Definitions.SocketList.");
return (*this)[(int)index_value];
}

void SocketList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @Socket_API_Definitions.SocketList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (Socket_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Socket_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Socket_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (Socket_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int SocketList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int SocketList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @Socket_API_Definitions.SocketList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SocketList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @Socket_API_Definitions.SocketList");
}

boolean SocketList_template::match(const SocketList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @Socket_API_Definitions.SocketList.");
}
return FALSE;
}

boolean SocketList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

SocketList SocketList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SocketList.");
SocketList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

SocketList SocketList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

SocketList SocketList_template::replace(int index, int len, const SocketList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

SocketList SocketList_template::replace(int index, int len, const SocketList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void SocketList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new SocketList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @Socket_API_Definitions.SocketList.");
}
set_selection(template_type);
}

SocketList_template& SocketList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @Socket_API_Definitions.SocketList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @Socket_API_Definitions.SocketList.");
return value_list.list_value[list_index];
}

void SocketList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void SocketList_template::log_match(const SocketList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SocketList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SocketList.");
}
}

void SocketList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @Socket_API_Definitions.SocketList.");
single_value.value_elements = (Socket_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new Socket_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SocketList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @Socket_API_Definitions.SocketList.");
}
}

boolean SocketList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SocketList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SocketList_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SocketList_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@Socket_API_Definitions.SocketList");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void SocketList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SocketList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SocketList");
}

boolean SocketList_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
UdpTuple::UdpTuple()
{
bound_flag = FALSE;
}

UdpTuple::UdpTuple(null_type)
{
bound_flag = TRUE;
}

UdpTuple::UdpTuple(const UdpTuple& other_value)
{
other_value.must_bound("Copying an unbound value of type @Socket_API_Definitions.UdpTuple.");
bound_flag = TRUE;
}

UdpTuple& UdpTuple::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

UdpTuple& UdpTuple::operator=(const UdpTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UdpTuple.");
bound_flag = TRUE;
return *this;
}

boolean UdpTuple::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpTuple.");
return TRUE;
}

boolean UdpTuple::operator==(const UdpTuple& other_value) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpTuple.");
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpTuple.");
return TRUE;
}

void UdpTuple::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void UdpTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@Socket_API_Definitions.UdpTuple");
  }
  bound_flag = TRUE;
}

void UdpTuple::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.UdpTuple.");
}

void UdpTuple::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void UdpTuple_template::copy_template(const UdpTuple_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UdpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.UdpTuple.");
break;
}
}

UdpTuple_template::UdpTuple_template()
{
}

UdpTuple_template::UdpTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UdpTuple_template::UdpTuple_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

UdpTuple_template::UdpTuple_template(const UdpTuple& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @Socket_API_Definitions.UdpTuple.");
}

UdpTuple_template::UdpTuple_template(const OPTIONAL<UdpTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.UdpTuple from an unbound optional field.");
}
}

UdpTuple_template::UdpTuple_template(const UdpTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UdpTuple_template::~UdpTuple_template()
{
clean_up();
}

void UdpTuple_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

UdpTuple_template& UdpTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UdpTuple_template& UdpTuple_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UdpTuple_template& UdpTuple_template::operator=(const UdpTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UdpTuple to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UdpTuple_template& UdpTuple_template::operator=(const OPTIONAL<UdpTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.UdpTuple.");
}
return *this;
}

UdpTuple_template& UdpTuple_template::operator=(const UdpTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean UdpTuple_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.UdpTuple.");
}
return FALSE;
}

boolean UdpTuple_template::match(const UdpTuple& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

UdpTuple UdpTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.UdpTuple.");
return NULL_VALUE;
}

void UdpTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.UdpTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UdpTuple_template[list_length];
}

UdpTuple_template& UdpTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.UdpTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.UdpTuple.");
return value_list.list_value[list_index];
}

void UdpTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UdpTuple_template::log_match(const UdpTuple& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void UdpTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.UdpTuple.");
}
}

void UdpTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UdpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.UdpTuple.");
}
}

void UdpTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UdpTuple_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@Socket_API_Definitions.UdpTuple");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@Socket_API_Definitions.UdpTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void UdpTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.UdpTuple");
}

boolean UdpTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UdpTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UdpLightTuple::UdpLightTuple()
{
bound_flag = FALSE;
}

UdpLightTuple::UdpLightTuple(null_type)
{
bound_flag = TRUE;
}

UdpLightTuple::UdpLightTuple(const UdpLightTuple& other_value)
{
other_value.must_bound("Copying an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
bound_flag = TRUE;
}

UdpLightTuple& UdpLightTuple::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

UdpLightTuple& UdpLightTuple::operator=(const UdpLightTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
bound_flag = TRUE;
return *this;
}

boolean UdpLightTuple::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
return TRUE;
}

boolean UdpLightTuple::operator==(const UdpLightTuple& other_value) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
return TRUE;
}

void UdpLightTuple::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void UdpLightTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@Socket_API_Definitions.UdpLightTuple");
  }
  bound_flag = TRUE;
}

void UdpLightTuple::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
}

void UdpLightTuple::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void UdpLightTuple_template::copy_template(const UdpLightTuple_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UdpLightTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.UdpLightTuple.");
break;
}
}

UdpLightTuple_template::UdpLightTuple_template()
{
}

UdpLightTuple_template::UdpLightTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UdpLightTuple_template::UdpLightTuple_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

UdpLightTuple_template::UdpLightTuple_template(const UdpLightTuple& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
}

UdpLightTuple_template::UdpLightTuple_template(const OPTIONAL<UdpLightTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.UdpLightTuple from an unbound optional field.");
}
}

UdpLightTuple_template::UdpLightTuple_template(const UdpLightTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UdpLightTuple_template::~UdpLightTuple_template()
{
clean_up();
}

void UdpLightTuple_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

UdpLightTuple_template& UdpLightTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UdpLightTuple_template& UdpLightTuple_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UdpLightTuple_template& UdpLightTuple_template::operator=(const UdpLightTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UdpLightTuple to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UdpLightTuple_template& UdpLightTuple_template::operator=(const OPTIONAL<UdpLightTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.UdpLightTuple.");
}
return *this;
}

UdpLightTuple_template& UdpLightTuple_template::operator=(const UdpLightTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean UdpLightTuple_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.UdpLightTuple.");
}
return FALSE;
}

boolean UdpLightTuple_template::match(const UdpLightTuple& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

UdpLightTuple UdpLightTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.UdpLightTuple.");
return NULL_VALUE;
}

void UdpLightTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.UdpLightTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UdpLightTuple_template[list_length];
}

UdpLightTuple_template& UdpLightTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.UdpLightTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.UdpLightTuple.");
return value_list.list_value[list_index];
}

void UdpLightTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UdpLightTuple_template::log_match(const UdpLightTuple& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void UdpLightTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.UdpLightTuple.");
}
}

void UdpLightTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UdpLightTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.UdpLightTuple.");
}
}

void UdpLightTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UdpLightTuple_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@Socket_API_Definitions.UdpLightTuple");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@Socket_API_Definitions.UdpLightTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void UdpLightTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.UdpLightTuple");
}

boolean UdpLightTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UdpLightTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TcpTuple::TcpTuple()
{
bound_flag = FALSE;
}

TcpTuple::TcpTuple(null_type)
{
bound_flag = TRUE;
}

TcpTuple::TcpTuple(const TcpTuple& other_value)
{
other_value.must_bound("Copying an unbound value of type @Socket_API_Definitions.TcpTuple.");
bound_flag = TRUE;
}

TcpTuple& TcpTuple::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

TcpTuple& TcpTuple::operator=(const TcpTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.TcpTuple.");
bound_flag = TRUE;
return *this;
}

boolean TcpTuple::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.TcpTuple.");
return TRUE;
}

boolean TcpTuple::operator==(const TcpTuple& other_value) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.TcpTuple.");
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.TcpTuple.");
return TRUE;
}

void TcpTuple::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void TcpTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@Socket_API_Definitions.TcpTuple");
  }
  bound_flag = TRUE;
}

void TcpTuple::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.TcpTuple.");
}

void TcpTuple::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void TcpTuple_template::copy_template(const TcpTuple_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TcpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.TcpTuple.");
break;
}
}

TcpTuple_template::TcpTuple_template()
{
}

TcpTuple_template::TcpTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TcpTuple_template::TcpTuple_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

TcpTuple_template::TcpTuple_template(const TcpTuple& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @Socket_API_Definitions.TcpTuple.");
}

TcpTuple_template::TcpTuple_template(const OPTIONAL<TcpTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.TcpTuple from an unbound optional field.");
}
}

TcpTuple_template::TcpTuple_template(const TcpTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

TcpTuple_template::~TcpTuple_template()
{
clean_up();
}

void TcpTuple_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TcpTuple_template& TcpTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TcpTuple_template& TcpTuple_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

TcpTuple_template& TcpTuple_template::operator=(const TcpTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.TcpTuple to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

TcpTuple_template& TcpTuple_template::operator=(const OPTIONAL<TcpTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.TcpTuple.");
}
return *this;
}

TcpTuple_template& TcpTuple_template::operator=(const TcpTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean TcpTuple_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.TcpTuple.");
}
return FALSE;
}

boolean TcpTuple_template::match(const TcpTuple& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

TcpTuple TcpTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.TcpTuple.");
return NULL_VALUE;
}

void TcpTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.TcpTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TcpTuple_template[list_length];
}

TcpTuple_template& TcpTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.TcpTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.TcpTuple.");
return value_list.list_value[list_index];
}

void TcpTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TcpTuple_template::log_match(const TcpTuple& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TcpTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.TcpTuple.");
}
}

void TcpTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TcpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.TcpTuple.");
}
}

void TcpTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TcpTuple_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@Socket_API_Definitions.TcpTuple");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@Socket_API_Definitions.TcpTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void TcpTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.TcpTuple");
}

boolean TcpTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TcpTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpTuple::SctpTuple()
{
}

SctpTuple::SctpTuple(const OPTIONAL<INTEGER>& par_sinfo__stream,
    const OPTIONAL<INTEGER>& par_sinfo__ppid,
    const OPTIONAL<SocketList>& par_remSocks,
    const OPTIONAL<INTEGER>& par_assocId)
  :   field_sinfo__stream(par_sinfo__stream),
  field_sinfo__ppid(par_sinfo__ppid),
  field_remSocks(par_remSocks),
  field_assocId(par_assocId)
{
}

SctpTuple::SctpTuple(const SctpTuple& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpTuple.");
if (other_value.sinfo__stream().is_bound()) field_sinfo__stream = other_value.sinfo__stream();
else field_sinfo__stream.clean_up();
if (other_value.sinfo__ppid().is_bound()) field_sinfo__ppid = other_value.sinfo__ppid();
else field_sinfo__ppid.clean_up();
if (other_value.remSocks().is_bound()) field_remSocks = other_value.remSocks();
else field_remSocks.clean_up();
if (other_value.assocId().is_bound()) field_assocId = other_value.assocId();
else field_assocId.clean_up();
}

void SctpTuple::clean_up()
{
field_sinfo__stream.clean_up();
field_sinfo__ppid.clean_up();
field_remSocks.clean_up();
field_assocId.clean_up();
}

SctpTuple& SctpTuple::operator=(const SctpTuple& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpTuple.");
  if (other_value.sinfo__stream().is_bound()) field_sinfo__stream = other_value.sinfo__stream();
  else field_sinfo__stream.clean_up();
  if (other_value.sinfo__ppid().is_bound()) field_sinfo__ppid = other_value.sinfo__ppid();
  else field_sinfo__ppid.clean_up();
  if (other_value.remSocks().is_bound()) field_remSocks = other_value.remSocks();
  else field_remSocks.clean_up();
  if (other_value.assocId().is_bound()) field_assocId = other_value.assocId();
  else field_assocId.clean_up();
}
return *this;
}

boolean SctpTuple::operator==(const SctpTuple& other_value) const
{
return field_sinfo__stream==other_value.field_sinfo__stream
  && field_sinfo__ppid==other_value.field_sinfo__ppid
  && field_remSocks==other_value.field_remSocks
  && field_assocId==other_value.field_assocId;
}

boolean SctpTuple::is_bound() const
{
if(OPTIONAL_OMIT == field_sinfo__stream.get_selection() || field_sinfo__stream.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sinfo__ppid.get_selection() || field_sinfo__ppid.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_remSocks.get_selection() || field_remSocks.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_assocId.get_selection() || field_assocId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpTuple::is_value() const
{
if(OPTIONAL_OMIT != field_sinfo__stream.get_selection() && !field_sinfo__stream.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sinfo__ppid.get_selection() && !field_sinfo__ppid.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_remSocks.get_selection() && !field_remSocks.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_assocId.get_selection() && !field_assocId.is_value()) return FALSE;
return TRUE;
}
int SctpTuple::size_of() const
{
  int ret_val = 0;
  if (field_sinfo__stream.ispresent()) ret_val++;
  if (field_sinfo__ppid.ispresent()) ret_val++;
  if (field_remSocks.ispresent()) ret_val++;
  if (field_assocId.ispresent()) ret_val++;
  return ret_val;
}

void SctpTuple::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sinfo_stream := ");
field_sinfo__stream.log();
TTCN_Logger::log_event_str(", sinfo_ppid := ");
field_sinfo__ppid.log();
TTCN_Logger::log_event_str(", remSocks := ");
field_remSocks.log();
TTCN_Logger::log_event_str(", assocId := ");
field_assocId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpTuple has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sinfo__stream().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sinfo__ppid().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remSocks().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) assocId().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sinfo_stream")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sinfo__stream().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sinfo_ppid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sinfo__ppid().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remSocks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remSocks().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "assocId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          assocId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpTuple: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpTuple");
  }
}

void SctpTuple::set_implicit_omit()
{
if (!sinfo__stream().is_bound()) sinfo__stream() = OMIT_VALUE;
else sinfo__stream().set_implicit_omit();
if (!sinfo__ppid().is_bound()) sinfo__ppid() = OMIT_VALUE;
else sinfo__ppid().set_implicit_omit();
if (!remSocks().is_bound()) remSocks() = OMIT_VALUE;
else remSocks().set_implicit_omit();
if (!assocId().is_bound()) assocId() = OMIT_VALUE;
else assocId().set_implicit_omit();
}

void SctpTuple::encode_text(Text_Buf& text_buf) const
{
field_sinfo__stream.encode_text(text_buf);
field_sinfo__ppid.encode_text(text_buf);
field_remSocks.encode_text(text_buf);
field_assocId.encode_text(text_buf);
}

void SctpTuple::decode_text(Text_Buf& text_buf)
{
field_sinfo__stream.decode_text(text_buf);
field_sinfo__ppid.decode_text(text_buf);
field_remSocks.decode_text(text_buf);
field_assocId.decode_text(text_buf);
}

struct SctpTuple_template::single_value_struct {
INTEGER_template field_sinfo__stream;
INTEGER_template field_sinfo__ppid;
SocketList_template field_remSocks;
INTEGER_template field_assocId;
};

void SctpTuple_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sinfo__stream = ANY_OR_OMIT;
single_value->field_sinfo__ppid = ANY_OR_OMIT;
single_value->field_remSocks = ANY_OR_OMIT;
single_value->field_assocId = ANY_OR_OMIT;
}
}
}

void SctpTuple_template::copy_value(const SctpTuple& other_value)
{
single_value = new single_value_struct;
if (other_value.sinfo__stream().is_bound()) {
  if (other_value.sinfo__stream().ispresent()) single_value->field_sinfo__stream = other_value.sinfo__stream()();
  else single_value->field_sinfo__stream = OMIT_VALUE;
} else {
  single_value->field_sinfo__stream.clean_up();
}
if (other_value.sinfo__ppid().is_bound()) {
  if (other_value.sinfo__ppid().ispresent()) single_value->field_sinfo__ppid = other_value.sinfo__ppid()();
  else single_value->field_sinfo__ppid = OMIT_VALUE;
} else {
  single_value->field_sinfo__ppid.clean_up();
}
if (other_value.remSocks().is_bound()) {
  if (other_value.remSocks().ispresent()) single_value->field_remSocks = other_value.remSocks()();
  else single_value->field_remSocks = OMIT_VALUE;
} else {
  single_value->field_remSocks.clean_up();
}
if (other_value.assocId().is_bound()) {
  if (other_value.assocId().ispresent()) single_value->field_assocId = other_value.assocId()();
  else single_value->field_assocId = OMIT_VALUE;
} else {
  single_value->field_assocId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpTuple_template::copy_template(const SctpTuple_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sinfo__stream().get_selection()) {
single_value->field_sinfo__stream = other_value.sinfo__stream();
} else {
single_value->field_sinfo__stream.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sinfo__ppid().get_selection()) {
single_value->field_sinfo__ppid = other_value.sinfo__ppid();
} else {
single_value->field_sinfo__ppid.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remSocks().get_selection()) {
single_value->field_remSocks = other_value.remSocks();
} else {
single_value->field_remSocks.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.assocId().get_selection()) {
single_value->field_assocId = other_value.assocId();
} else {
single_value->field_assocId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpTuple.");
break;
}
set_selection(other_value);
}

SctpTuple_template::SctpTuple_template()
{
}

SctpTuple_template::SctpTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpTuple_template::SctpTuple_template(const SctpTuple& other_value)
{
copy_value(other_value);
}

SctpTuple_template::SctpTuple_template(const OPTIONAL<SctpTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpTuple from an unbound optional field.");
}
}

SctpTuple_template::SctpTuple_template(const SctpTuple_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpTuple_template::~SctpTuple_template()
{
clean_up();
}

SctpTuple_template& SctpTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpTuple_template& SctpTuple_template::operator=(const SctpTuple& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpTuple_template& SctpTuple_template::operator=(const OPTIONAL<SctpTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpTuple.");
}
return *this;
}

SctpTuple_template& SctpTuple_template::operator=(const SctpTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpTuple_template::match(const SctpTuple& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sinfo__stream().is_bound()) return FALSE;
if((other_value.sinfo__stream().ispresent() ? !single_value->field_sinfo__stream.match((const INTEGER&)other_value.sinfo__stream(), legacy) : !single_value->field_sinfo__stream.match_omit(legacy)))return FALSE;
if(!other_value.sinfo__ppid().is_bound()) return FALSE;
if((other_value.sinfo__ppid().ispresent() ? !single_value->field_sinfo__ppid.match((const INTEGER&)other_value.sinfo__ppid(), legacy) : !single_value->field_sinfo__ppid.match_omit(legacy)))return FALSE;
if(!other_value.remSocks().is_bound()) return FALSE;
if((other_value.remSocks().ispresent() ? !single_value->field_remSocks.match((const SocketList&)other_value.remSocks(), legacy) : !single_value->field_remSocks.match_omit(legacy)))return FALSE;
if(!other_value.assocId().is_bound()) return FALSE;
if((other_value.assocId().ispresent() ? !single_value->field_assocId.match((const INTEGER&)other_value.assocId(), legacy) : !single_value->field_assocId.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpTuple.");
}
return FALSE;
}

boolean SctpTuple_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sinfo__stream.is_omit() || single_value->field_sinfo__stream.is_bound()) return TRUE;
if (single_value->field_sinfo__ppid.is_omit() || single_value->field_sinfo__ppid.is_bound()) return TRUE;
if (single_value->field_remSocks.is_omit() || single_value->field_remSocks.is_bound()) return TRUE;
if (single_value->field_assocId.is_omit() || single_value->field_assocId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpTuple_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sinfo__stream.is_omit() && !single_value->field_sinfo__stream.is_value()) return FALSE;
if (!single_value->field_sinfo__ppid.is_omit() && !single_value->field_sinfo__ppid.is_value()) return FALSE;
if (!single_value->field_remSocks.is_omit() && !single_value->field_remSocks.is_value()) return FALSE;
if (!single_value->field_assocId.is_omit() && !single_value->field_assocId.is_value()) return FALSE;
return TRUE;
}

void SctpTuple_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpTuple SctpTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpTuple.");
SctpTuple ret_val;
if (single_value->field_sinfo__stream.is_omit()) ret_val.sinfo__stream() = OMIT_VALUE;
else if (single_value->field_sinfo__stream.is_bound()) {
ret_val.sinfo__stream() = single_value->field_sinfo__stream.valueof();
}
if (single_value->field_sinfo__ppid.is_omit()) ret_val.sinfo__ppid() = OMIT_VALUE;
else if (single_value->field_sinfo__ppid.is_bound()) {
ret_val.sinfo__ppid() = single_value->field_sinfo__ppid.valueof();
}
if (single_value->field_remSocks.is_omit()) ret_val.remSocks() = OMIT_VALUE;
else if (single_value->field_remSocks.is_bound()) {
ret_val.remSocks() = single_value->field_remSocks.valueof();
}
if (single_value->field_assocId.is_omit()) ret_val.assocId() = OMIT_VALUE;
else if (single_value->field_assocId.is_bound()) {
ret_val.assocId() = single_value->field_assocId.valueof();
}
return ret_val;
}

void SctpTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpTuple_template[list_length];
}

SctpTuple_template& SctpTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpTuple.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpTuple_template::sinfo__stream()
{
set_specific();
return single_value->field_sinfo__stream;
}

const INTEGER_template& SctpTuple_template::sinfo__stream() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sinfo_stream of a non-specific template of type @Socket_API_Definitions.SctpTuple.");
return single_value->field_sinfo__stream;
}

INTEGER_template& SctpTuple_template::sinfo__ppid()
{
set_specific();
return single_value->field_sinfo__ppid;
}

const INTEGER_template& SctpTuple_template::sinfo__ppid() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sinfo_ppid of a non-specific template of type @Socket_API_Definitions.SctpTuple.");
return single_value->field_sinfo__ppid;
}

SocketList_template& SctpTuple_template::remSocks()
{
set_specific();
return single_value->field_remSocks;
}

const SocketList_template& SctpTuple_template::remSocks() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remSocks of a non-specific template of type @Socket_API_Definitions.SctpTuple.");
return single_value->field_remSocks;
}

INTEGER_template& SctpTuple_template::assocId()
{
set_specific();
return single_value->field_assocId;
}

const INTEGER_template& SctpTuple_template::assocId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field assocId of a non-specific template of type @Socket_API_Definitions.SctpTuple.");
return single_value->field_assocId;
}

int SctpTuple_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_sinfo__stream.is_present()) ret_val++;
      if (single_value->field_sinfo__ppid.is_present()) ret_val++;
      if (single_value->field_remSocks.is_present()) ret_val++;
      if (single_value->field_assocId.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpTuple containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpTuple.");
  }
  return 0;
}

void SctpTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sinfo_stream := ");
single_value->field_sinfo__stream.log();
TTCN_Logger::log_event_str(", sinfo_ppid := ");
single_value->field_sinfo__ppid.log();
TTCN_Logger::log_event_str(", remSocks := ");
single_value->field_remSocks.log();
TTCN_Logger::log_event_str(", assocId := ");
single_value->field_assocId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpTuple_template::log_match(const SctpTuple& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.sinfo__stream().ispresent()){
if(!single_value->field_sinfo__stream.match(match_value.sinfo__stream(), legacy)){
TTCN_Logger::log_logmatch_info(".sinfo_stream");
single_value->field_sinfo__stream.log_match(match_value.sinfo__stream(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sinfo__stream.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sinfo_stream := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sinfo__stream.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sinfo__ppid().ispresent()){
if(!single_value->field_sinfo__ppid.match(match_value.sinfo__ppid(), legacy)){
TTCN_Logger::log_logmatch_info(".sinfo_ppid");
single_value->field_sinfo__ppid.log_match(match_value.sinfo__ppid(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sinfo__ppid.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sinfo_ppid := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sinfo__ppid.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.remSocks().ispresent()){
if(!single_value->field_remSocks.match(match_value.remSocks(), legacy)){
TTCN_Logger::log_logmatch_info(".remSocks");
single_value->field_remSocks.log_match(match_value.remSocks(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_remSocks.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".remSocks := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_remSocks.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.assocId().ispresent()){
if(!single_value->field_assocId.match(match_value.assocId(), legacy)){
TTCN_Logger::log_logmatch_info(".assocId");
single_value->field_assocId.log_match(match_value.assocId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_assocId.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".assocId := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_assocId.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sinfo_stream := ");
if (match_value.sinfo__stream().ispresent()) single_value->field_sinfo__stream.log_match(match_value.sinfo__stream(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sinfo__stream.log();
if (single_value->field_sinfo__stream.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sinfo_ppid := ");
if (match_value.sinfo__ppid().ispresent()) single_value->field_sinfo__ppid.log_match(match_value.sinfo__ppid(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sinfo__ppid.log();
if (single_value->field_sinfo__ppid.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", remSocks := ");
if (match_value.remSocks().ispresent()) single_value->field_remSocks.log_match(match_value.remSocks(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_remSocks.log();
if (single_value->field_remSocks.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", assocId := ");
if (match_value.assocId().ispresent()) single_value->field_assocId.log_match(match_value.assocId(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_assocId.log();
if (single_value->field_assocId.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sinfo__stream.encode_text(text_buf);
single_value->field_sinfo__ppid.encode_text(text_buf);
single_value->field_remSocks.encode_text(text_buf);
single_value->field_assocId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpTuple.");
}
}

void SctpTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sinfo__stream.decode_text(text_buf);
single_value->field_sinfo__ppid.decode_text(text_buf);
single_value->field_remSocks.decode_text(text_buf);
single_value->field_assocId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpTuple.");
}
}

void SctpTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpTuple_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpTuple has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sinfo__stream().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sinfo__ppid().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remSocks().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) assocId().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sinfo_stream")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sinfo__stream().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sinfo_ppid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sinfo__ppid().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remSocks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remSocks().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "assocId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          assocId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpTuple: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sinfo__stream.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpTuple");
single_value->field_sinfo__ppid.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpTuple");
single_value->field_remSocks.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpTuple");
single_value->field_assocId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpTuple");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpTuple");
}

boolean SctpTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SslTuple::SslTuple()
{
bound_flag = FALSE;
}

SslTuple::SslTuple(null_type)
{
bound_flag = TRUE;
}

SslTuple::SslTuple(const SslTuple& other_value)
{
other_value.must_bound("Copying an unbound value of type @Socket_API_Definitions.SslTuple.");
bound_flag = TRUE;
}

SslTuple& SslTuple::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

SslTuple& SslTuple::operator=(const SslTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.SslTuple.");
bound_flag = TRUE;
return *this;
}

boolean SslTuple::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.SslTuple.");
return TRUE;
}

boolean SslTuple::operator==(const SslTuple& other_value) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.SslTuple.");
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.SslTuple.");
return TRUE;
}

void SslTuple::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void SslTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@Socket_API_Definitions.SslTuple");
  }
  bound_flag = TRUE;
}

void SslTuple::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.SslTuple.");
}

void SslTuple::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void SslTuple_template::copy_template(const SslTuple_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SslTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SslTuple.");
break;
}
}

SslTuple_template::SslTuple_template()
{
}

SslTuple_template::SslTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SslTuple_template::SslTuple_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

SslTuple_template::SslTuple_template(const SslTuple& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @Socket_API_Definitions.SslTuple.");
}

SslTuple_template::SslTuple_template(const OPTIONAL<SslTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SslTuple from an unbound optional field.");
}
}

SslTuple_template::SslTuple_template(const SslTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SslTuple_template::~SslTuple_template()
{
clean_up();
}

void SslTuple_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SslTuple_template& SslTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SslTuple_template& SslTuple_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

SslTuple_template& SslTuple_template::operator=(const SslTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.SslTuple to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

SslTuple_template& SslTuple_template::operator=(const OPTIONAL<SslTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SslTuple.");
}
return *this;
}

SslTuple_template& SslTuple_template::operator=(const SslTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean SslTuple_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SslTuple.");
}
return FALSE;
}

boolean SslTuple_template::match(const SslTuple& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

SslTuple SslTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SslTuple.");
return NULL_VALUE;
}

void SslTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SslTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SslTuple_template[list_length];
}

SslTuple_template& SslTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SslTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SslTuple.");
return value_list.list_value[list_index];
}

void SslTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SslTuple_template::log_match(const SslTuple& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SslTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SslTuple.");
}
}

void SslTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SslTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SslTuple.");
}
}

void SslTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SslTuple_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@Socket_API_Definitions.SslTuple");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@Socket_API_Definitions.SslTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void SslTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SslTuple");
}

boolean SslTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SslTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DtlsTuple::copy_value(const DtlsTuple& other_value)
{
switch (other_value.union_selection) {
case ALT_udp:
field_udp = new UdpTuple(*other_value.field_udp);
break;
case ALT_sctp:
field_sctp = new SctpTuple(*other_value.field_sctp);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Socket_API_Definitions.DtlsTuple.");
}
union_selection = other_value.union_selection;
}

DtlsTuple::DtlsTuple()
{
union_selection = UNBOUND_VALUE;
}

DtlsTuple::DtlsTuple(const DtlsTuple& other_value)
: Base_Type(){
copy_value(other_value);
}

DtlsTuple::~DtlsTuple()
{
clean_up();
}

DtlsTuple& DtlsTuple::operator=(const DtlsTuple& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean DtlsTuple::operator==(const DtlsTuple& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Socket_API_Definitions.DtlsTuple.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Socket_API_Definitions.DtlsTuple.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_udp:
return *field_udp == *other_value.field_udp;
case ALT_sctp:
return *field_sctp == *other_value.field_sctp;
default:
return FALSE;
}
}

UdpTuple& DtlsTuple::udp()
{
if (union_selection != ALT_udp) {
clean_up();
field_udp = new UdpTuple;
union_selection = ALT_udp;
}
return *field_udp;
}

const UdpTuple& DtlsTuple::udp() const
{
if (union_selection != ALT_udp) TTCN_error("Using non-selected field udp in a value of union type @Socket_API_Definitions.DtlsTuple.");
return *field_udp;
}

SctpTuple& DtlsTuple::sctp()
{
if (union_selection != ALT_sctp) {
clean_up();
field_sctp = new SctpTuple;
union_selection = ALT_sctp;
}
return *field_sctp;
}

const SctpTuple& DtlsTuple::sctp() const
{
if (union_selection != ALT_sctp) TTCN_error("Using non-selected field sctp in a value of union type @Socket_API_Definitions.DtlsTuple.");
return *field_sctp;
}

boolean DtlsTuple::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.DtlsTuple.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Socket_API_Definitions.DtlsTuple.");
return union_selection == checked_selection;
}

boolean DtlsTuple::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean DtlsTuple::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_udp: return field_udp->is_value();
case ALT_sctp: return field_sctp->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void DtlsTuple::clean_up()
{
switch (union_selection) {
case ALT_udp:
  delete field_udp;
  break;
case ALT_sctp:
  delete field_sctp;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void DtlsTuple::log() const
{
switch (union_selection) {
case ALT_udp:
TTCN_Logger::log_event_str("{ udp := ");
field_udp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctp:
TTCN_Logger::log_event_str("{ sctp := ");
field_sctp->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void DtlsTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "udp")) {
    udp().set_param(*mp_last);
    if (!udp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctp")) {
    sctp().set_param(*mp_last);
    if (!sctp().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Socket_API_Definitions.DtlsTuple.", mp_last->get_id()->get_name());
}

void DtlsTuple::set_implicit_omit()
{
switch (union_selection) {
case ALT_udp:
field_udp->set_implicit_omit(); break;
case ALT_sctp:
field_sctp->set_implicit_omit(); break;
default: break;
}
}

void DtlsTuple::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_udp:
field_udp->encode_text(text_buf);
break;
case ALT_sctp:
field_sctp->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Socket_API_Definitions.DtlsTuple.");
}
}

void DtlsTuple::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_udp:
udp().decode_text(text_buf);
break;
case ALT_sctp:
sctp().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Socket_API_Definitions.DtlsTuple.");
}
}

void DtlsTuple_template::copy_value(const DtlsTuple& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template(other_value.udp());
break;
case DtlsTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template(other_value.sctp());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Socket_API_Definitions.DtlsTuple.");
}
set_selection(SPECIFIC_VALUE);
}

void DtlsTuple_template::copy_template(const DtlsTuple_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template(*other_value.single_value.field_udp);
break;
case DtlsTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template(*other_value.single_value.field_sctp);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Socket_API_Definitions.DtlsTuple.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DtlsTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Socket_API_Definitions.DtlsTuple.");
}
set_selection(other_value);
}

DtlsTuple_template::DtlsTuple_template()
{
}

DtlsTuple_template::DtlsTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DtlsTuple_template::DtlsTuple_template(const DtlsTuple& other_value)
{
copy_value(other_value);
}

DtlsTuple_template::DtlsTuple_template(const OPTIONAL<DtlsTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DtlsTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Socket_API_Definitions.DtlsTuple from an unbound optional field.");
}
}

DtlsTuple_template::DtlsTuple_template(const DtlsTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

DtlsTuple_template::~DtlsTuple_template()
{
clean_up();
}

void DtlsTuple_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
delete single_value.field_udp;
break;
case DtlsTuple::ALT_sctp:
delete single_value.field_sctp;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DtlsTuple_template& DtlsTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DtlsTuple_template& DtlsTuple_template::operator=(const DtlsTuple& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DtlsTuple_template& DtlsTuple_template::operator=(const OPTIONAL<DtlsTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DtlsTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Socket_API_Definitions.DtlsTuple.");
}
return *this;
}

DtlsTuple_template& DtlsTuple_template::operator=(const DtlsTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DtlsTuple_template::match(const DtlsTuple& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
DtlsTuple::union_selection_type value_selection = other_value.get_selection();
if (value_selection == DtlsTuple::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case DtlsTuple::ALT_udp:
return single_value.field_udp->match(other_value.udp(), legacy);
case DtlsTuple::ALT_sctp:
return single_value.field_sctp->match(other_value.sctp(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Socket_API_Definitions.DtlsTuple.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Socket_API_Definitions.DtlsTuple.");
}
return FALSE;
}

boolean DtlsTuple_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
return single_value.field_udp->is_value();
case DtlsTuple::ALT_sctp:
return single_value.field_sctp->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Socket_API_Definitions.DtlsTuple.");
}
}

DtlsTuple DtlsTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Socket_API_Definitions.DtlsTuple.");
DtlsTuple ret_val;
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
ret_val.udp() = single_value.field_udp->valueof();
break;
case DtlsTuple::ALT_sctp:
ret_val.sctp() = single_value.field_sctp->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Socket_API_Definitions.DtlsTuple.");
}
return ret_val;
}

DtlsTuple_template& DtlsTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Socket_API_Definitions.DtlsTuple.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Socket_API_Definitions.DtlsTuple.");
return value_list.list_value[list_index];
}
void DtlsTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Socket_API_Definitions.DtlsTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DtlsTuple_template[list_length];
}

UdpTuple_template& DtlsTuple_template::udp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DtlsTuple::ALT_udp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_udp = new UdpTuple_template(ANY_VALUE);
else single_value.field_udp = new UdpTuple_template;
single_value.union_selection = DtlsTuple::ALT_udp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_udp;
}

const UdpTuple_template& DtlsTuple_template::udp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field udp in a non-specific template of union type @Socket_API_Definitions.DtlsTuple.");
if (single_value.union_selection != DtlsTuple::ALT_udp) TTCN_error("Accessing non-selected field udp in a template of union type @Socket_API_Definitions.DtlsTuple.");
return *single_value.field_udp;
}

SctpTuple_template& DtlsTuple_template::sctp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DtlsTuple::ALT_sctp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctp = new SctpTuple_template(ANY_VALUE);
else single_value.field_sctp = new SctpTuple_template;
single_value.union_selection = DtlsTuple::ALT_sctp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctp;
}

const SctpTuple_template& DtlsTuple_template::sctp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctp in a non-specific template of union type @Socket_API_Definitions.DtlsTuple.");
if (single_value.union_selection != DtlsTuple::ALT_sctp) TTCN_error("Accessing non-selected field sctp in a template of union type @Socket_API_Definitions.DtlsTuple.");
return *single_value.field_sctp;
}

boolean DtlsTuple_template::ischosen(DtlsTuple::union_selection_type checked_selection) const
{
if (checked_selection == DtlsTuple::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.DtlsTuple.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == DtlsTuple::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Socket_API_Definitions.DtlsTuple.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Socket_API_Definitions.DtlsTuple containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Socket_API_Definitions.DtlsTuple, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Socket_API_Definitions.DtlsTuple");
}
return FALSE;
}

void DtlsTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
TTCN_Logger::log_event_str("{ udp := ");
single_value.field_udp->log();
TTCN_Logger::log_event_str(" }");
break;
case DtlsTuple::ALT_sctp:
TTCN_Logger::log_event_str("{ sctp := ");
single_value.field_sctp->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DtlsTuple_template::log_match(const DtlsTuple& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".udp");
single_value.field_udp->log_match(match_value.udp(), legacy);
} else {
TTCN_Logger::log_event_str("{ udp := ");
single_value.field_udp->log_match(match_value.udp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DtlsTuple::ALT_sctp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctp");
single_value.field_sctp->log_match(match_value.sctp(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctp := ");
single_value.field_sctp->log_match(match_value.sctp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DtlsTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
single_value.field_udp->encode_text(text_buf);
break;
case DtlsTuple::ALT_sctp:
single_value.field_sctp->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Socket_API_Definitions.DtlsTuple.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Socket_API_Definitions.DtlsTuple.");
}
}

void DtlsTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = DtlsTuple::UNBOUND_VALUE;
DtlsTuple::union_selection_type new_selection = (DtlsTuple::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case DtlsTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template;
single_value.field_udp->decode_text(text_buf);
break;
case DtlsTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template;
single_value.field_sctp->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Socket_API_Definitions.DtlsTuple.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DtlsTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Socket_API_Definitions.DtlsTuple.");
}
}

boolean DtlsTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DtlsTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DtlsTuple_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Socket_API_Definitions.DtlsTuple'");
    }
    if (strcmp("udp", param_field) == 0) {
      udp().set_param(param);
      return;
    } else if (strcmp("sctp", param_field) == 0) {
      sctp().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Socket_API_Definitions.DtlsTuple'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DtlsTuple_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Socket_API_Definitions.DtlsTuple");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "udp")) {
      udp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctp")) {
      sctp().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Socket_API_Definitions.DtlsTuple.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Socket_API_Definitions.DtlsTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void DtlsTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case DtlsTuple::ALT_udp:
single_value.field_udp->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.DtlsTuple");
return;
case DtlsTuple::ALT_sctp:
single_value.field_sctp->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.DtlsTuple");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Socket_API_Definitions.DtlsTuple.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.DtlsTuple");
}

UnspecifiedTuple::UnspecifiedTuple()
{
bound_flag = FALSE;
}

UnspecifiedTuple::UnspecifiedTuple(null_type)
{
bound_flag = TRUE;
}

UnspecifiedTuple::UnspecifiedTuple(const UnspecifiedTuple& other_value)
{
other_value.must_bound("Copying an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
bound_flag = TRUE;
}

UnspecifiedTuple& UnspecifiedTuple::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

UnspecifiedTuple& UnspecifiedTuple::operator=(const UnspecifiedTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
bound_flag = TRUE;
return *this;
}

boolean UnspecifiedTuple::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
return TRUE;
}

boolean UnspecifiedTuple::operator==(const UnspecifiedTuple& other_value) const
{
must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
return TRUE;
}

void UnspecifiedTuple::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void UnspecifiedTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@Socket_API_Definitions.UnspecifiedTuple");
  }
  bound_flag = TRUE;
}

void UnspecifiedTuple::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
}

void UnspecifiedTuple::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void UnspecifiedTuple_template::copy_template(const UnspecifiedTuple_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UnspecifiedTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.UnspecifiedTuple.");
break;
}
}

UnspecifiedTuple_template::UnspecifiedTuple_template()
{
}

UnspecifiedTuple_template::UnspecifiedTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UnspecifiedTuple_template::UnspecifiedTuple_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

UnspecifiedTuple_template::UnspecifiedTuple_template(const UnspecifiedTuple& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
}

UnspecifiedTuple_template::UnspecifiedTuple_template(const OPTIONAL<UnspecifiedTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.UnspecifiedTuple from an unbound optional field.");
}
}

UnspecifiedTuple_template::UnspecifiedTuple_template(const UnspecifiedTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UnspecifiedTuple_template::~UnspecifiedTuple_template()
{
clean_up();
}

void UnspecifiedTuple_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

UnspecifiedTuple_template& UnspecifiedTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UnspecifiedTuple_template& UnspecifiedTuple_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UnspecifiedTuple_template& UnspecifiedTuple_template::operator=(const UnspecifiedTuple& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

UnspecifiedTuple_template& UnspecifiedTuple_template::operator=(const OPTIONAL<UnspecifiedTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.UnspecifiedTuple.");
}
return *this;
}

UnspecifiedTuple_template& UnspecifiedTuple_template::operator=(const UnspecifiedTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean UnspecifiedTuple_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.UnspecifiedTuple.");
}
return FALSE;
}

boolean UnspecifiedTuple_template::match(const UnspecifiedTuple& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

UnspecifiedTuple UnspecifiedTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.UnspecifiedTuple.");
return NULL_VALUE;
}

void UnspecifiedTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.UnspecifiedTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UnspecifiedTuple_template[list_length];
}

UnspecifiedTuple_template& UnspecifiedTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.UnspecifiedTuple.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.UnspecifiedTuple.");
return value_list.list_value[list_index];
}

void UnspecifiedTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UnspecifiedTuple_template::log_match(const UnspecifiedTuple& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void UnspecifiedTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.UnspecifiedTuple.");
}
}

void UnspecifiedTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UnspecifiedTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.UnspecifiedTuple.");
}
}

void UnspecifiedTuple_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UnspecifiedTuple_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@Socket_API_Definitions.UnspecifiedTuple");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@Socket_API_Definitions.UnspecifiedTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void UnspecifiedTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.UnspecifiedTuple");
}

boolean UnspecifiedTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UnspecifiedTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ProtoTuple::copy_value(const ProtoTuple& other_value)
{
switch (other_value.union_selection) {
case ALT_udp:
field_udp = new UdpTuple(*other_value.field_udp);
break;
case ALT_udpLight:
field_udpLight = new UdpLightTuple(*other_value.field_udpLight);
break;
case ALT_tcp:
field_tcp = new TcpTuple(*other_value.field_tcp);
break;
case ALT_sctp:
field_sctp = new SctpTuple(*other_value.field_sctp);
break;
case ALT_ssl:
field_ssl = new SslTuple(*other_value.field_ssl);
break;
case ALT_dtls:
field_dtls = new DtlsTuple(*other_value.field_dtls);
break;
case ALT_unspecified:
field_unspecified = new UnspecifiedTuple(*other_value.field_unspecified);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Socket_API_Definitions.ProtoTuple.");
}
union_selection = other_value.union_selection;
}

ProtoTuple::ProtoTuple()
{
union_selection = UNBOUND_VALUE;
}

ProtoTuple::ProtoTuple(const ProtoTuple& other_value)
: Base_Type(){
copy_value(other_value);
}

ProtoTuple::~ProtoTuple()
{
clean_up();
}

ProtoTuple& ProtoTuple::operator=(const ProtoTuple& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ProtoTuple::operator==(const ProtoTuple& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Socket_API_Definitions.ProtoTuple.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Socket_API_Definitions.ProtoTuple.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_udp:
return *field_udp == *other_value.field_udp;
case ALT_udpLight:
return *field_udpLight == *other_value.field_udpLight;
case ALT_tcp:
return *field_tcp == *other_value.field_tcp;
case ALT_sctp:
return *field_sctp == *other_value.field_sctp;
case ALT_ssl:
return *field_ssl == *other_value.field_ssl;
case ALT_dtls:
return *field_dtls == *other_value.field_dtls;
case ALT_unspecified:
return *field_unspecified == *other_value.field_unspecified;
default:
return FALSE;
}
}

UdpTuple& ProtoTuple::udp()
{
if (union_selection != ALT_udp) {
clean_up();
field_udp = new UdpTuple;
union_selection = ALT_udp;
}
return *field_udp;
}

const UdpTuple& ProtoTuple::udp() const
{
if (union_selection != ALT_udp) TTCN_error("Using non-selected field udp in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_udp;
}

UdpLightTuple& ProtoTuple::udpLight()
{
if (union_selection != ALT_udpLight) {
clean_up();
field_udpLight = new UdpLightTuple;
union_selection = ALT_udpLight;
}
return *field_udpLight;
}

const UdpLightTuple& ProtoTuple::udpLight() const
{
if (union_selection != ALT_udpLight) TTCN_error("Using non-selected field udpLight in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_udpLight;
}

TcpTuple& ProtoTuple::tcp()
{
if (union_selection != ALT_tcp) {
clean_up();
field_tcp = new TcpTuple;
union_selection = ALT_tcp;
}
return *field_tcp;
}

const TcpTuple& ProtoTuple::tcp() const
{
if (union_selection != ALT_tcp) TTCN_error("Using non-selected field tcp in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_tcp;
}

SctpTuple& ProtoTuple::sctp()
{
if (union_selection != ALT_sctp) {
clean_up();
field_sctp = new SctpTuple;
union_selection = ALT_sctp;
}
return *field_sctp;
}

const SctpTuple& ProtoTuple::sctp() const
{
if (union_selection != ALT_sctp) TTCN_error("Using non-selected field sctp in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_sctp;
}

SslTuple& ProtoTuple::ssl()
{
if (union_selection != ALT_ssl) {
clean_up();
field_ssl = new SslTuple;
union_selection = ALT_ssl;
}
return *field_ssl;
}

const SslTuple& ProtoTuple::ssl() const
{
if (union_selection != ALT_ssl) TTCN_error("Using non-selected field ssl in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_ssl;
}

DtlsTuple& ProtoTuple::dtls()
{
if (union_selection != ALT_dtls) {
clean_up();
field_dtls = new DtlsTuple;
union_selection = ALT_dtls;
}
return *field_dtls;
}

const DtlsTuple& ProtoTuple::dtls() const
{
if (union_selection != ALT_dtls) TTCN_error("Using non-selected field dtls in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_dtls;
}

UnspecifiedTuple& ProtoTuple::unspecified()
{
if (union_selection != ALT_unspecified) {
clean_up();
field_unspecified = new UnspecifiedTuple;
union_selection = ALT_unspecified;
}
return *field_unspecified;
}

const UnspecifiedTuple& ProtoTuple::unspecified() const
{
if (union_selection != ALT_unspecified) TTCN_error("Using non-selected field unspecified in a value of union type @Socket_API_Definitions.ProtoTuple.");
return *field_unspecified;
}

boolean ProtoTuple::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.ProtoTuple.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Socket_API_Definitions.ProtoTuple.");
return union_selection == checked_selection;
}

boolean ProtoTuple::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ProtoTuple::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_udp: return field_udp->is_value();
case ALT_udpLight: return field_udpLight->is_value();
case ALT_tcp: return field_tcp->is_value();
case ALT_sctp: return field_sctp->is_value();
case ALT_ssl: return field_ssl->is_value();
case ALT_dtls: return field_dtls->is_value();
case ALT_unspecified: return field_unspecified->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ProtoTuple::clean_up()
{
switch (union_selection) {
case ALT_udp:
  delete field_udp;
  break;
case ALT_udpLight:
  delete field_udpLight;
  break;
case ALT_tcp:
  delete field_tcp;
  break;
case ALT_sctp:
  delete field_sctp;
  break;
case ALT_ssl:
  delete field_ssl;
  break;
case ALT_dtls:
  delete field_dtls;
  break;
case ALT_unspecified:
  delete field_unspecified;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ProtoTuple::log() const
{
switch (union_selection) {
case ALT_udp:
TTCN_Logger::log_event_str("{ udp := ");
field_udp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_udpLight:
TTCN_Logger::log_event_str("{ udpLight := ");
field_udpLight->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tcp:
TTCN_Logger::log_event_str("{ tcp := ");
field_tcp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctp:
TTCN_Logger::log_event_str("{ sctp := ");
field_sctp->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_ssl:
TTCN_Logger::log_event_str("{ ssl := ");
field_ssl->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_dtls:
TTCN_Logger::log_event_str("{ dtls := ");
field_dtls->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unspecified:
TTCN_Logger::log_event_str("{ unspecified := ");
field_unspecified->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ProtoTuple::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "udp")) {
    udp().set_param(*mp_last);
    if (!udp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "udpLight")) {
    udpLight().set_param(*mp_last);
    if (!udpLight().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tcp")) {
    tcp().set_param(*mp_last);
    if (!tcp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctp")) {
    sctp().set_param(*mp_last);
    if (!sctp().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "ssl")) {
    ssl().set_param(*mp_last);
    if (!ssl().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "dtls")) {
    dtls().set_param(*mp_last);
    if (!dtls().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unspecified")) {
    unspecified().set_param(*mp_last);
    if (!unspecified().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Socket_API_Definitions.ProtoTuple.", mp_last->get_id()->get_name());
}

void ProtoTuple::set_implicit_omit()
{
switch (union_selection) {
case ALT_udp:
field_udp->set_implicit_omit(); break;
case ALT_udpLight:
field_udpLight->set_implicit_omit(); break;
case ALT_tcp:
field_tcp->set_implicit_omit(); break;
case ALT_sctp:
field_sctp->set_implicit_omit(); break;
case ALT_ssl:
field_ssl->set_implicit_omit(); break;
case ALT_dtls:
field_dtls->set_implicit_omit(); break;
case ALT_unspecified:
field_unspecified->set_implicit_omit(); break;
default: break;
}
}

void ProtoTuple::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_udp:
field_udp->encode_text(text_buf);
break;
case ALT_udpLight:
field_udpLight->encode_text(text_buf);
break;
case ALT_tcp:
field_tcp->encode_text(text_buf);
break;
case ALT_sctp:
field_sctp->encode_text(text_buf);
break;
case ALT_ssl:
field_ssl->encode_text(text_buf);
break;
case ALT_dtls:
field_dtls->encode_text(text_buf);
break;
case ALT_unspecified:
field_unspecified->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Socket_API_Definitions.ProtoTuple.");
}
}

void ProtoTuple::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_udp:
udp().decode_text(text_buf);
break;
case ALT_udpLight:
udpLight().decode_text(text_buf);
break;
case ALT_tcp:
tcp().decode_text(text_buf);
break;
case ALT_sctp:
sctp().decode_text(text_buf);
break;
case ALT_ssl:
ssl().decode_text(text_buf);
break;
case ALT_dtls:
dtls().decode_text(text_buf);
break;
case ALT_unspecified:
unspecified().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Socket_API_Definitions.ProtoTuple.");
}
}

void ProtoTuple_template::copy_value(const ProtoTuple& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template(other_value.udp());
break;
case ProtoTuple::ALT_udpLight:
single_value.field_udpLight = new UdpLightTuple_template(other_value.udpLight());
break;
case ProtoTuple::ALT_tcp:
single_value.field_tcp = new TcpTuple_template(other_value.tcp());
break;
case ProtoTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template(other_value.sctp());
break;
case ProtoTuple::ALT_ssl:
single_value.field_ssl = new SslTuple_template(other_value.ssl());
break;
case ProtoTuple::ALT_dtls:
single_value.field_dtls = new DtlsTuple_template(other_value.dtls());
break;
case ProtoTuple::ALT_unspecified:
single_value.field_unspecified = new UnspecifiedTuple_template(other_value.unspecified());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Socket_API_Definitions.ProtoTuple.");
}
set_selection(SPECIFIC_VALUE);
}

void ProtoTuple_template::copy_template(const ProtoTuple_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template(*other_value.single_value.field_udp);
break;
case ProtoTuple::ALT_udpLight:
single_value.field_udpLight = new UdpLightTuple_template(*other_value.single_value.field_udpLight);
break;
case ProtoTuple::ALT_tcp:
single_value.field_tcp = new TcpTuple_template(*other_value.single_value.field_tcp);
break;
case ProtoTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template(*other_value.single_value.field_sctp);
break;
case ProtoTuple::ALT_ssl:
single_value.field_ssl = new SslTuple_template(*other_value.single_value.field_ssl);
break;
case ProtoTuple::ALT_dtls:
single_value.field_dtls = new DtlsTuple_template(*other_value.single_value.field_dtls);
break;
case ProtoTuple::ALT_unspecified:
single_value.field_unspecified = new UnspecifiedTuple_template(*other_value.single_value.field_unspecified);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Socket_API_Definitions.ProtoTuple.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ProtoTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Socket_API_Definitions.ProtoTuple.");
}
set_selection(other_value);
}

ProtoTuple_template::ProtoTuple_template()
{
}

ProtoTuple_template::ProtoTuple_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ProtoTuple_template::ProtoTuple_template(const ProtoTuple& other_value)
{
copy_value(other_value);
}

ProtoTuple_template::ProtoTuple_template(const OPTIONAL<ProtoTuple>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtoTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Socket_API_Definitions.ProtoTuple from an unbound optional field.");
}
}

ProtoTuple_template::ProtoTuple_template(const ProtoTuple_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ProtoTuple_template::~ProtoTuple_template()
{
clean_up();
}

void ProtoTuple_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
delete single_value.field_udp;
break;
case ProtoTuple::ALT_udpLight:
delete single_value.field_udpLight;
break;
case ProtoTuple::ALT_tcp:
delete single_value.field_tcp;
break;
case ProtoTuple::ALT_sctp:
delete single_value.field_sctp;
break;
case ProtoTuple::ALT_ssl:
delete single_value.field_ssl;
break;
case ProtoTuple::ALT_dtls:
delete single_value.field_dtls;
break;
case ProtoTuple::ALT_unspecified:
delete single_value.field_unspecified;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ProtoTuple_template& ProtoTuple_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ProtoTuple_template& ProtoTuple_template::operator=(const ProtoTuple& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ProtoTuple_template& ProtoTuple_template::operator=(const OPTIONAL<ProtoTuple>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ProtoTuple&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Socket_API_Definitions.ProtoTuple.");
}
return *this;
}

ProtoTuple_template& ProtoTuple_template::operator=(const ProtoTuple_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ProtoTuple_template::match(const ProtoTuple& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ProtoTuple::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ProtoTuple::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ProtoTuple::ALT_udp:
return single_value.field_udp->match(other_value.udp(), legacy);
case ProtoTuple::ALT_udpLight:
return single_value.field_udpLight->match(other_value.udpLight(), legacy);
case ProtoTuple::ALT_tcp:
return single_value.field_tcp->match(other_value.tcp(), legacy);
case ProtoTuple::ALT_sctp:
return single_value.field_sctp->match(other_value.sctp(), legacy);
case ProtoTuple::ALT_ssl:
return single_value.field_ssl->match(other_value.ssl(), legacy);
case ProtoTuple::ALT_dtls:
return single_value.field_dtls->match(other_value.dtls(), legacy);
case ProtoTuple::ALT_unspecified:
return single_value.field_unspecified->match(other_value.unspecified(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Socket_API_Definitions.ProtoTuple.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Socket_API_Definitions.ProtoTuple.");
}
return FALSE;
}

boolean ProtoTuple_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
return single_value.field_udp->is_value();
case ProtoTuple::ALT_udpLight:
return single_value.field_udpLight->is_value();
case ProtoTuple::ALT_tcp:
return single_value.field_tcp->is_value();
case ProtoTuple::ALT_sctp:
return single_value.field_sctp->is_value();
case ProtoTuple::ALT_ssl:
return single_value.field_ssl->is_value();
case ProtoTuple::ALT_dtls:
return single_value.field_dtls->is_value();
case ProtoTuple::ALT_unspecified:
return single_value.field_unspecified->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Socket_API_Definitions.ProtoTuple.");
}
}

ProtoTuple ProtoTuple_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
ProtoTuple ret_val;
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
ret_val.udp() = single_value.field_udp->valueof();
break;
case ProtoTuple::ALT_udpLight:
ret_val.udpLight() = single_value.field_udpLight->valueof();
break;
case ProtoTuple::ALT_tcp:
ret_val.tcp() = single_value.field_tcp->valueof();
break;
case ProtoTuple::ALT_sctp:
ret_val.sctp() = single_value.field_sctp->valueof();
break;
case ProtoTuple::ALT_ssl:
ret_val.ssl() = single_value.field_ssl->valueof();
break;
case ProtoTuple::ALT_dtls:
ret_val.dtls() = single_value.field_dtls->valueof();
break;
case ProtoTuple::ALT_unspecified:
ret_val.unspecified() = single_value.field_unspecified->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Socket_API_Definitions.ProtoTuple.");
}
return ret_val;
}

ProtoTuple_template& ProtoTuple_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Socket_API_Definitions.ProtoTuple.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Socket_API_Definitions.ProtoTuple.");
return value_list.list_value[list_index];
}
void ProtoTuple_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Socket_API_Definitions.ProtoTuple.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ProtoTuple_template[list_length];
}

UdpTuple_template& ProtoTuple_template::udp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_udp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_udp = new UdpTuple_template(ANY_VALUE);
else single_value.field_udp = new UdpTuple_template;
single_value.union_selection = ProtoTuple::ALT_udp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_udp;
}

const UdpTuple_template& ProtoTuple_template::udp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field udp in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_udp) TTCN_error("Accessing non-selected field udp in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_udp;
}

UdpLightTuple_template& ProtoTuple_template::udpLight()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_udpLight) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_udpLight = new UdpLightTuple_template(ANY_VALUE);
else single_value.field_udpLight = new UdpLightTuple_template;
single_value.union_selection = ProtoTuple::ALT_udpLight;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_udpLight;
}

const UdpLightTuple_template& ProtoTuple_template::udpLight() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field udpLight in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_udpLight) TTCN_error("Accessing non-selected field udpLight in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_udpLight;
}

TcpTuple_template& ProtoTuple_template::tcp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_tcp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tcp = new TcpTuple_template(ANY_VALUE);
else single_value.field_tcp = new TcpTuple_template;
single_value.union_selection = ProtoTuple::ALT_tcp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tcp;
}

const TcpTuple_template& ProtoTuple_template::tcp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tcp in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_tcp) TTCN_error("Accessing non-selected field tcp in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_tcp;
}

SctpTuple_template& ProtoTuple_template::sctp()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_sctp) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctp = new SctpTuple_template(ANY_VALUE);
else single_value.field_sctp = new SctpTuple_template;
single_value.union_selection = ProtoTuple::ALT_sctp;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctp;
}

const SctpTuple_template& ProtoTuple_template::sctp() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctp in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_sctp) TTCN_error("Accessing non-selected field sctp in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_sctp;
}

SslTuple_template& ProtoTuple_template::ssl()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_ssl) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ssl = new SslTuple_template(ANY_VALUE);
else single_value.field_ssl = new SslTuple_template;
single_value.union_selection = ProtoTuple::ALT_ssl;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ssl;
}

const SslTuple_template& ProtoTuple_template::ssl() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ssl in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_ssl) TTCN_error("Accessing non-selected field ssl in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_ssl;
}

DtlsTuple_template& ProtoTuple_template::dtls()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_dtls) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_dtls = new DtlsTuple_template(ANY_VALUE);
else single_value.field_dtls = new DtlsTuple_template;
single_value.union_selection = ProtoTuple::ALT_dtls;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_dtls;
}

const DtlsTuple_template& ProtoTuple_template::dtls() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field dtls in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_dtls) TTCN_error("Accessing non-selected field dtls in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_dtls;
}

UnspecifiedTuple_template& ProtoTuple_template::unspecified()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ProtoTuple::ALT_unspecified) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unspecified = new UnspecifiedTuple_template(ANY_VALUE);
else single_value.field_unspecified = new UnspecifiedTuple_template;
single_value.union_selection = ProtoTuple::ALT_unspecified;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unspecified;
}

const UnspecifiedTuple_template& ProtoTuple_template::unspecified() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unspecified in a non-specific template of union type @Socket_API_Definitions.ProtoTuple.");
if (single_value.union_selection != ProtoTuple::ALT_unspecified) TTCN_error("Accessing non-selected field unspecified in a template of union type @Socket_API_Definitions.ProtoTuple.");
return *single_value.field_unspecified;
}

boolean ProtoTuple_template::ischosen(ProtoTuple::union_selection_type checked_selection) const
{
if (checked_selection == ProtoTuple::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.ProtoTuple.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ProtoTuple::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Socket_API_Definitions.ProtoTuple.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Socket_API_Definitions.ProtoTuple containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Socket_API_Definitions.ProtoTuple, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Socket_API_Definitions.ProtoTuple");
}
return FALSE;
}

void ProtoTuple_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
TTCN_Logger::log_event_str("{ udp := ");
single_value.field_udp->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_udpLight:
TTCN_Logger::log_event_str("{ udpLight := ");
single_value.field_udpLight->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_tcp:
TTCN_Logger::log_event_str("{ tcp := ");
single_value.field_tcp->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_sctp:
TTCN_Logger::log_event_str("{ sctp := ");
single_value.field_sctp->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_ssl:
TTCN_Logger::log_event_str("{ ssl := ");
single_value.field_ssl->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_dtls:
TTCN_Logger::log_event_str("{ dtls := ");
single_value.field_dtls->log();
TTCN_Logger::log_event_str(" }");
break;
case ProtoTuple::ALT_unspecified:
TTCN_Logger::log_event_str("{ unspecified := ");
single_value.field_unspecified->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ProtoTuple_template::log_match(const ProtoTuple& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".udp");
single_value.field_udp->log_match(match_value.udp(), legacy);
} else {
TTCN_Logger::log_event_str("{ udp := ");
single_value.field_udp->log_match(match_value.udp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_udpLight:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".udpLight");
single_value.field_udpLight->log_match(match_value.udpLight(), legacy);
} else {
TTCN_Logger::log_event_str("{ udpLight := ");
single_value.field_udpLight->log_match(match_value.udpLight(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_tcp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tcp");
single_value.field_tcp->log_match(match_value.tcp(), legacy);
} else {
TTCN_Logger::log_event_str("{ tcp := ");
single_value.field_tcp->log_match(match_value.tcp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_sctp:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctp");
single_value.field_sctp->log_match(match_value.sctp(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctp := ");
single_value.field_sctp->log_match(match_value.sctp(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_ssl:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ssl");
single_value.field_ssl->log_match(match_value.ssl(), legacy);
} else {
TTCN_Logger::log_event_str("{ ssl := ");
single_value.field_ssl->log_match(match_value.ssl(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_dtls:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".dtls");
single_value.field_dtls->log_match(match_value.dtls(), legacy);
} else {
TTCN_Logger::log_event_str("{ dtls := ");
single_value.field_dtls->log_match(match_value.dtls(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ProtoTuple::ALT_unspecified:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unspecified");
single_value.field_unspecified->log_match(match_value.unspecified(), legacy);
} else {
TTCN_Logger::log_event_str("{ unspecified := ");
single_value.field_unspecified->log_match(match_value.unspecified(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ProtoTuple_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
single_value.field_udp->encode_text(text_buf);
break;
case ProtoTuple::ALT_udpLight:
single_value.field_udpLight->encode_text(text_buf);
break;
case ProtoTuple::ALT_tcp:
single_value.field_tcp->encode_text(text_buf);
break;
case ProtoTuple::ALT_sctp:
single_value.field_sctp->encode_text(text_buf);
break;
case ProtoTuple::ALT_ssl:
single_value.field_ssl->encode_text(text_buf);
break;
case ProtoTuple::ALT_dtls:
single_value.field_dtls->encode_text(text_buf);
break;
case ProtoTuple::ALT_unspecified:
single_value.field_unspecified->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Socket_API_Definitions.ProtoTuple.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Socket_API_Definitions.ProtoTuple.");
}
}

void ProtoTuple_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ProtoTuple::UNBOUND_VALUE;
ProtoTuple::union_selection_type new_selection = (ProtoTuple::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ProtoTuple::ALT_udp:
single_value.field_udp = new UdpTuple_template;
single_value.field_udp->decode_text(text_buf);
break;
case ProtoTuple::ALT_udpLight:
single_value.field_udpLight = new UdpLightTuple_template;
single_value.field_udpLight->decode_text(text_buf);
break;
case ProtoTuple::ALT_tcp:
single_value.field_tcp = new TcpTuple_template;
single_value.field_tcp->decode_text(text_buf);
break;
case ProtoTuple::ALT_sctp:
single_value.field_sctp = new SctpTuple_template;
single_value.field_sctp->decode_text(text_buf);
break;
case ProtoTuple::ALT_ssl:
single_value.field_ssl = new SslTuple_template;
single_value.field_ssl->decode_text(text_buf);
break;
case ProtoTuple::ALT_dtls:
single_value.field_dtls = new DtlsTuple_template;
single_value.field_dtls->decode_text(text_buf);
break;
case ProtoTuple::ALT_unspecified:
single_value.field_unspecified = new UnspecifiedTuple_template;
single_value.field_unspecified->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Socket_API_Definitions.ProtoTuple.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ProtoTuple_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Socket_API_Definitions.ProtoTuple.");
}
}

boolean ProtoTuple_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ProtoTuple_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ProtoTuple_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Socket_API_Definitions.ProtoTuple'");
    }
    if (strcmp("udp", param_field) == 0) {
      udp().set_param(param);
      return;
    } else if (strcmp("udpLight", param_field) == 0) {
      udpLight().set_param(param);
      return;
    } else if (strcmp("tcp", param_field) == 0) {
      tcp().set_param(param);
      return;
    } else if (strcmp("sctp", param_field) == 0) {
      sctp().set_param(param);
      return;
    } else if (strcmp("ssl", param_field) == 0) {
      ssl().set_param(param);
      return;
    } else if (strcmp("dtls", param_field) == 0) {
      dtls().set_param(param);
      return;
    } else if (strcmp("unspecified", param_field) == 0) {
      unspecified().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Socket_API_Definitions.ProtoTuple'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ProtoTuple_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Socket_API_Definitions.ProtoTuple");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "udp")) {
      udp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "udpLight")) {
      udpLight().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tcp")) {
      tcp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctp")) {
      sctp().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "ssl")) {
      ssl().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "dtls")) {
      dtls().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unspecified")) {
      unspecified().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Socket_API_Definitions.ProtoTuple.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Socket_API_Definitions.ProtoTuple");
  }
  is_ifpresent = param.get_ifpresent();
}

void ProtoTuple_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ProtoTuple::ALT_udp:
single_value.field_udp->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_udpLight:
single_value.field_udpLight->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_tcp:
single_value.field_tcp->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_sctp:
single_value.field_sctp->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_ssl:
single_value.field_ssl->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_dtls:
single_value.field_dtls->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
case ProtoTuple::ALT_unspecified:
single_value.field_unspecified->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Socket_API_Definitions.ProtoTuple.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.ProtoTuple");
}

PortError::PortError()
{
enum_value = UNBOUND_VALUE;
}

PortError::PortError(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @Socket_API_Definitions.PortError with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PortError::PortError(enum_type other_value)
{
enum_value = other_value;
}

PortError::PortError(const PortError& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @Socket_API_Definitions.PortError.");
enum_value = other_value.enum_value;
}

PortError& PortError::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @Socket_API_Definitions.PortError.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PortError& PortError::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PortError& PortError::operator=(const PortError& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.PortError.");
enum_value = other_value.enum_value;
return *this;
}

boolean PortError::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value == other_value;
}

boolean PortError::operator==(const PortError& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value == other_value.enum_value;
}

boolean PortError::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value < other_value;
}

boolean PortError::operator<(const PortError& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value < other_value.enum_value;
}

boolean PortError::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value > other_value;
}

boolean PortError::operator>(const PortError& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.PortError.");
return enum_value > other_value.enum_value;
}

const char *PortError::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case ERROR__GENERAL: return "ERROR_GENERAL";
case ERROR__INSUFFICIENT__MEMORY: return "ERROR_INSUFFICIENT_MEMORY";
case ERROR__INVALID__INPUT__PARAMETER: return "ERROR_INVALID_INPUT_PARAMETER";
case ERROR__UNSUPPORTED__PROTOCOL: return "ERROR_UNSUPPORTED_PROTOCOL";
case ERROR__SOCKET: return "ERROR_SOCKET";
case ERROR__HOSTNAME: return "ERROR_HOSTNAME";
case ERROR__INVALID__CONNECTION: return "ERROR_INVALID_CONNECTION";
case ERROR__TEMPORARILY__UNAVAILABLE: return "ERROR_TEMPORARILY_UNAVAILABLE";
case ERROR__AVAILABLE: return "ERROR_AVAILABLE";
default: return "<unknown>";
}
}

PortError::enum_type PortError::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "ERROR_GENERAL")) return ERROR__GENERAL;
else if (!strcmp(str_par, "ERROR_INSUFFICIENT_MEMORY")) return ERROR__INSUFFICIENT__MEMORY;
else if (!strcmp(str_par, "ERROR_INVALID_INPUT_PARAMETER")) return ERROR__INVALID__INPUT__PARAMETER;
else if (!strcmp(str_par, "ERROR_UNSUPPORTED_PROTOCOL")) return ERROR__UNSUPPORTED__PROTOCOL;
else if (!strcmp(str_par, "ERROR_SOCKET")) return ERROR__SOCKET;
else if (!strcmp(str_par, "ERROR_HOSTNAME")) return ERROR__HOSTNAME;
else if (!strcmp(str_par, "ERROR_INVALID_CONNECTION")) return ERROR__INVALID__CONNECTION;
else if (!strcmp(str_par, "ERROR_TEMPORARILY_UNAVAILABLE")) return ERROR__TEMPORARILY__UNAVAILABLE;
else if (!strcmp(str_par, "ERROR_AVAILABLE")) return ERROR__AVAILABLE;
else return UNKNOWN_VALUE;
}

boolean PortError::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
return TRUE;
default:
return FALSE;
}
}

int PortError::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.PortError.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PortError::enum2int(const PortError& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.PortError.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PortError::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @Socket_API_Definitions.PortError.", int_val);
enum_value = (enum_type)int_val;
}

PortError::operator PortError::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @Socket_API_Definitions.PortError.");
return enum_value;
}

void PortError::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PortError::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@Socket_API_Definitions.PortError");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @Socket_API_Definitions.PortError.");
  }
}

void PortError::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @Socket_API_Definitions.PortError.");
text_buf.push_int(enum_value);
}

void PortError::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @Socket_API_Definitions.PortError.", enum_value);
}

void PortError_template::copy_template(const PortError_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PortError_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.PortError.");
}
}

PortError_template::PortError_template()
{
}

PortError_template::PortError_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PortError_template::PortError_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PortError::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @Socket_API_Definitions.PortError with unknown numeric value %d.", other_value);
single_value = (PortError::enum_type)other_value;
}

PortError_template::PortError_template(PortError::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PortError_template::PortError_template(const PortError& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PortError::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @Socket_API_Definitions.PortError.");
single_value = other_value.enum_value;
}

PortError_template::PortError_template(const OPTIONAL<PortError>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PortError::enum_type)(const PortError&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @Socket_API_Definitions.PortError from an unbound optional field.");
}
}

PortError_template::PortError_template(const PortError_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PortError_template::~PortError_template()
{
clean_up();
}

boolean PortError_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PortError_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PortError::UNBOUND_VALUE;
}

void PortError_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PortError_template& PortError_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PortError_template& PortError_template::operator=(int other_value)
{
if (!PortError::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @Socket_API_Definitions.PortError.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PortError::enum_type)other_value;
return *this;
}

PortError_template& PortError_template::operator=(PortError::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PortError_template& PortError_template::operator=(const PortError& other_value)
{
if (other_value.enum_value == PortError::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.PortError to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PortError_template& PortError_template::operator=(const OPTIONAL<PortError>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PortError::enum_type)(const PortError&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @Socket_API_Definitions.PortError.");
}
return *this;
}

PortError_template& PortError_template::operator=(const PortError_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PortError_template::match(PortError::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.PortError.");
}
return FALSE;
}

boolean PortError_template::match(const PortError& other_value, boolean) const
{
if (other_value.enum_value == PortError::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @Socket_API_Definitions.PortError with an unbound value.");
return match(other_value.enum_value);
}

PortError::enum_type PortError_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @Socket_API_Definitions.PortError.");
return single_value;
}

void PortError_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @Socket_API_Definitions.PortError.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PortError_template[list_length];
}

PortError_template& PortError_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @Socket_API_Definitions.PortError.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @Socket_API_Definitions.PortError.");
return value_list.list_value[list_index];
}

void PortError_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PortError::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PortError_template::log_match(const PortError& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PortError_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.PortError.");
}
}

void PortError_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PortError::enum_type)text_buf.pull_int().get_val();
if (!PortError::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @Socket_API_Definitions.PortError.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PortError_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @Socket_API_Definitions.PortError.");
}
}

boolean PortError_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PortError_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PortError_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PortError_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PortError::enum_type enum_val = PortError::str_to_enum(m_p->get_enumerated());
    if (!PortError::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @Socket_API_Definitions.PortError.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@Socket_API_Definitions.PortError");
  }
  is_ifpresent = param.get_ifpresent();
}

void PortError_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.PortError");
}

Result::Result()
{
}

Result::Result(const OPTIONAL<PortError>& par_errorCode,
    const OPTIONAL<INTEGER>& par_connId,
    const OPTIONAL<INTEGER>& par_os__error__code,
    const OPTIONAL<CHARSTRING>& par_os__error__text)
  :   field_errorCode(par_errorCode),
  field_connId(par_connId),
  field_os__error__code(par_os__error__code),
  field_os__error__text(par_os__error__text)
{
}

Result::Result(const Result& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.Result.");
if (other_value.errorCode().is_bound()) field_errorCode = other_value.errorCode();
else field_errorCode.clean_up();
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
else field_os__error__code.clean_up();
if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
else field_os__error__text.clean_up();
}

void Result::clean_up()
{
field_errorCode.clean_up();
field_connId.clean_up();
field_os__error__code.clean_up();
field_os__error__text.clean_up();
}

Result& Result::operator=(const Result& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.Result.");
  if (other_value.errorCode().is_bound()) field_errorCode = other_value.errorCode();
  else field_errorCode.clean_up();
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
  else field_os__error__code.clean_up();
  if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
  else field_os__error__text.clean_up();
}
return *this;
}

boolean Result::operator==(const Result& other_value) const
{
return field_errorCode==other_value.field_errorCode
  && field_connId==other_value.field_connId
  && field_os__error__code==other_value.field_os__error__code
  && field_os__error__text==other_value.field_os__error__text;
}

boolean Result::is_bound() const
{
if(OPTIONAL_OMIT == field_errorCode.get_selection() || field_errorCode.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_connId.get_selection() || field_connId.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_os__error__code.get_selection() || field_os__error__code.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_os__error__text.get_selection() || field_os__error__text.is_bound()) return TRUE;
return FALSE;
}
boolean Result::is_value() const
{
if(OPTIONAL_OMIT != field_errorCode.get_selection() && !field_errorCode.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_connId.get_selection() && !field_connId.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_os__error__code.get_selection() && !field_os__error__code.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_os__error__text.get_selection() && !field_os__error__text.is_value()) return FALSE;
return TRUE;
}
int Result::size_of() const
{
  int ret_val = 0;
  if (field_errorCode.ispresent()) ret_val++;
  if (field_connId.ispresent()) ret_val++;
  if (field_os__error__code.ispresent()) ret_val++;
  if (field_os__error__text.ispresent()) ret_val++;
  return ret_val;
}

void Result::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ errorCode := ");
field_errorCode.log();
TTCN_Logger::log_event_str(", connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", os_error_code := ");
field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
field_os__error__text.log();
TTCN_Logger::log_event_str(" }");
}

void Result::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.Result has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorCode().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.Result");
  }
}

void Result::set_implicit_omit()
{
if (!errorCode().is_bound()) errorCode() = OMIT_VALUE;
else errorCode().set_implicit_omit();
if (!connId().is_bound()) connId() = OMIT_VALUE;
else connId().set_implicit_omit();
if (!os__error__code().is_bound()) os__error__code() = OMIT_VALUE;
else os__error__code().set_implicit_omit();
if (!os__error__text().is_bound()) os__error__text() = OMIT_VALUE;
else os__error__text().set_implicit_omit();
}

void Result::encode_text(Text_Buf& text_buf) const
{
field_errorCode.encode_text(text_buf);
field_connId.encode_text(text_buf);
field_os__error__code.encode_text(text_buf);
field_os__error__text.encode_text(text_buf);
}

void Result::decode_text(Text_Buf& text_buf)
{
field_errorCode.decode_text(text_buf);
field_connId.decode_text(text_buf);
field_os__error__code.decode_text(text_buf);
field_os__error__text.decode_text(text_buf);
}

struct Result_template::single_value_struct {
PortError_template field_errorCode;
INTEGER_template field_connId;
INTEGER_template field_os__error__code;
CHARSTRING_template field_os__error__text;
};

void Result_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_errorCode = ANY_OR_OMIT;
single_value->field_connId = ANY_OR_OMIT;
single_value->field_os__error__code = ANY_OR_OMIT;
single_value->field_os__error__text = ANY_OR_OMIT;
}
}
}

void Result_template::copy_value(const Result& other_value)
{
single_value = new single_value_struct;
if (other_value.errorCode().is_bound()) {
  if (other_value.errorCode().ispresent()) single_value->field_errorCode = other_value.errorCode()();
  else single_value->field_errorCode = OMIT_VALUE;
} else {
  single_value->field_errorCode.clean_up();
}
if (other_value.connId().is_bound()) {
  if (other_value.connId().ispresent()) single_value->field_connId = other_value.connId()();
  else single_value->field_connId = OMIT_VALUE;
} else {
  single_value->field_connId.clean_up();
}
if (other_value.os__error__code().is_bound()) {
  if (other_value.os__error__code().ispresent()) single_value->field_os__error__code = other_value.os__error__code()();
  else single_value->field_os__error__code = OMIT_VALUE;
} else {
  single_value->field_os__error__code.clean_up();
}
if (other_value.os__error__text().is_bound()) {
  if (other_value.os__error__text().ispresent()) single_value->field_os__error__text = other_value.os__error__text()();
  else single_value->field_os__error__text = OMIT_VALUE;
} else {
  single_value->field_os__error__text.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Result_template::copy_template(const Result_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.errorCode().get_selection()) {
single_value->field_errorCode = other_value.errorCode();
} else {
single_value->field_errorCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__code().get_selection()) {
single_value->field_os__error__code = other_value.os__error__code();
} else {
single_value->field_os__error__code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__text().get_selection()) {
single_value->field_os__error__text = other_value.os__error__text();
} else {
single_value->field_os__error__text.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.Result.");
break;
}
set_selection(other_value);
}

Result_template::Result_template()
{
}

Result_template::Result_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Result_template::Result_template(const Result& other_value)
{
copy_value(other_value);
}

Result_template::Result_template(const OPTIONAL<Result>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.Result from an unbound optional field.");
}
}

Result_template::Result_template(const Result_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Result_template::~Result_template()
{
clean_up();
}

Result_template& Result_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Result_template& Result_template::operator=(const Result& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Result_template& Result_template::operator=(const OPTIONAL<Result>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.Result.");
}
return *this;
}

Result_template& Result_template::operator=(const Result_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Result_template::match(const Result& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.errorCode().is_bound()) return FALSE;
if((other_value.errorCode().ispresent() ? !single_value->field_errorCode.match((const PortError&)other_value.errorCode(), legacy) : !single_value->field_errorCode.match_omit(legacy)))return FALSE;
if(!other_value.connId().is_bound()) return FALSE;
if((other_value.connId().ispresent() ? !single_value->field_connId.match((const INTEGER&)other_value.connId(), legacy) : !single_value->field_connId.match_omit(legacy)))return FALSE;
if(!other_value.os__error__code().is_bound()) return FALSE;
if((other_value.os__error__code().ispresent() ? !single_value->field_os__error__code.match((const INTEGER&)other_value.os__error__code(), legacy) : !single_value->field_os__error__code.match_omit(legacy)))return FALSE;
if(!other_value.os__error__text().is_bound()) return FALSE;
if((other_value.os__error__text().ispresent() ? !single_value->field_os__error__text.match((const CHARSTRING&)other_value.os__error__text(), legacy) : !single_value->field_os__error__text.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.Result.");
}
return FALSE;
}

boolean Result_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_errorCode.is_omit() || single_value->field_errorCode.is_bound()) return TRUE;
if (single_value->field_connId.is_omit() || single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_os__error__code.is_omit() || single_value->field_os__error__code.is_bound()) return TRUE;
if (single_value->field_os__error__text.is_omit() || single_value->field_os__error__text.is_bound()) return TRUE;
return FALSE;
}

boolean Result_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_errorCode.is_omit() && !single_value->field_errorCode.is_value()) return FALSE;
if (!single_value->field_connId.is_omit() && !single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_os__error__code.is_omit() && !single_value->field_os__error__code.is_value()) return FALSE;
if (!single_value->field_os__error__text.is_omit() && !single_value->field_os__error__text.is_value()) return FALSE;
return TRUE;
}

void Result_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Result Result_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.Result.");
Result ret_val;
if (single_value->field_errorCode.is_omit()) ret_val.errorCode() = OMIT_VALUE;
else if (single_value->field_errorCode.is_bound()) {
ret_val.errorCode() = single_value->field_errorCode.valueof();
}
if (single_value->field_connId.is_omit()) ret_val.connId() = OMIT_VALUE;
else if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_os__error__code.is_omit()) ret_val.os__error__code() = OMIT_VALUE;
else if (single_value->field_os__error__code.is_bound()) {
ret_val.os__error__code() = single_value->field_os__error__code.valueof();
}
if (single_value->field_os__error__text.is_omit()) ret_val.os__error__text() = OMIT_VALUE;
else if (single_value->field_os__error__text.is_bound()) {
ret_val.os__error__text() = single_value->field_os__error__text.valueof();
}
return ret_val;
}

void Result_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.Result.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Result_template[list_length];
}

Result_template& Result_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.Result.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.Result.");
return value_list.list_value[list_index];
}

PortError_template& Result_template::errorCode()
{
set_specific();
return single_value->field_errorCode;
}

const PortError_template& Result_template::errorCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field errorCode of a non-specific template of type @Socket_API_Definitions.Result.");
return single_value->field_errorCode;
}

INTEGER_template& Result_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& Result_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @Socket_API_Definitions.Result.");
return single_value->field_connId;
}

INTEGER_template& Result_template::os__error__code()
{
set_specific();
return single_value->field_os__error__code;
}

const INTEGER_template& Result_template::os__error__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_code of a non-specific template of type @Socket_API_Definitions.Result.");
return single_value->field_os__error__code;
}

CHARSTRING_template& Result_template::os__error__text()
{
set_specific();
return single_value->field_os__error__text;
}

const CHARSTRING_template& Result_template::os__error__text() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_text of a non-specific template of type @Socket_API_Definitions.Result.");
return single_value->field_os__error__text;
}

int Result_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Result which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_errorCode.is_present()) ret_val++;
      if (single_value->field_connId.is_present()) ret_val++;
      if (single_value->field_os__error__code.is_present()) ret_val++;
      if (single_value->field_os__error__text.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.Result containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Result containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Result containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Result containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Result containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.Result.");
  }
  return 0;
}

void Result_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ errorCode := ");
single_value->field_errorCode.log();
TTCN_Logger::log_event_str(", connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", os_error_code := ");
single_value->field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
single_value->field_os__error__text.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Result_template::log_match(const Result& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.errorCode().ispresent()){
if(!single_value->field_errorCode.match(match_value.errorCode(), legacy)){
TTCN_Logger::log_logmatch_info(".errorCode");
single_value->field_errorCode.log_match(match_value.errorCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_errorCode.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".errorCode := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_errorCode.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.connId().ispresent()){
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_connId.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".connId := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_connId.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.os__error__code().ispresent()){
if(!single_value->field_os__error__code.match(match_value.os__error__code(), legacy)){
TTCN_Logger::log_logmatch_info(".os_error_code");
single_value->field_os__error__code.log_match(match_value.os__error__code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_os__error__code.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".os_error_code := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_os__error__code.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.os__error__text().ispresent()){
if(!single_value->field_os__error__text.match(match_value.os__error__text(), legacy)){
TTCN_Logger::log_logmatch_info(".os_error_text");
single_value->field_os__error__text.log_match(match_value.os__error__text(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_os__error__text.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".os_error_text := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_os__error__text.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ errorCode := ");
if (match_value.errorCode().ispresent()) single_value->field_errorCode.log_match(match_value.errorCode(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_errorCode.log();
if (single_value->field_errorCode.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", connId := ");
if (match_value.connId().ispresent()) single_value->field_connId.log_match(match_value.connId(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_connId.log();
if (single_value->field_connId.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", os_error_code := ");
if (match_value.os__error__code().ispresent()) single_value->field_os__error__code.log_match(match_value.os__error__code(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_os__error__code.log();
if (single_value->field_os__error__code.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", os_error_text := ");
if (match_value.os__error__text().ispresent()) single_value->field_os__error__text.log_match(match_value.os__error__text(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_os__error__text.log();
if (single_value->field_os__error__text.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Result_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_errorCode.encode_text(text_buf);
single_value->field_connId.encode_text(text_buf);
single_value->field_os__error__code.encode_text(text_buf);
single_value->field_os__error__text.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.Result.");
}
}

void Result_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_errorCode.decode_text(text_buf);
single_value->field_connId.decode_text(text_buf);
single_value->field_os__error__code.decode_text(text_buf);
single_value->field_os__error__text.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.Result.");
}
}

void Result_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Result_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.Result has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorCode().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.Result");
  }
  is_ifpresent = param.get_ifpresent();
}

void Result_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_errorCode.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Result");
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Result");
single_value->field_os__error__code.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Result");
single_value->field_os__error__text.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Result");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.Result");
}

boolean Result_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Result_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Extended__Result::Extended__Result()
{
}

Extended__Result::Extended__Result(const OPTIONAL<PortError>& par_errorCode,
    const OPTIONAL<INTEGER>& par_connId,
    const OPTIONAL<INTEGER>& par_os__error__code,
    const OPTIONAL<CHARSTRING>& par_os__error__text,
    const OPTIONAL<OCTETSTRING>& par_msg)
  :   field_errorCode(par_errorCode),
  field_connId(par_connId),
  field_os__error__code(par_os__error__code),
  field_os__error__text(par_os__error__text),
  field_msg(par_msg)
{
}

Extended__Result::Extended__Result(const Extended__Result& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.Extended_Result.");
if (other_value.errorCode().is_bound()) field_errorCode = other_value.errorCode();
else field_errorCode.clean_up();
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
else field_os__error__code.clean_up();
if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
else field_os__error__text.clean_up();
if (other_value.msg().is_bound()) field_msg = other_value.msg();
else field_msg.clean_up();
}

void Extended__Result::clean_up()
{
field_errorCode.clean_up();
field_connId.clean_up();
field_os__error__code.clean_up();
field_os__error__text.clean_up();
field_msg.clean_up();
}

Extended__Result& Extended__Result::operator=(const Extended__Result& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.Extended_Result.");
  if (other_value.errorCode().is_bound()) field_errorCode = other_value.errorCode();
  else field_errorCode.clean_up();
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.os__error__code().is_bound()) field_os__error__code = other_value.os__error__code();
  else field_os__error__code.clean_up();
  if (other_value.os__error__text().is_bound()) field_os__error__text = other_value.os__error__text();
  else field_os__error__text.clean_up();
  if (other_value.msg().is_bound()) field_msg = other_value.msg();
  else field_msg.clean_up();
}
return *this;
}

boolean Extended__Result::operator==(const Extended__Result& other_value) const
{
return field_errorCode==other_value.field_errorCode
  && field_connId==other_value.field_connId
  && field_os__error__code==other_value.field_os__error__code
  && field_os__error__text==other_value.field_os__error__text
  && field_msg==other_value.field_msg;
}

boolean Extended__Result::is_bound() const
{
if(OPTIONAL_OMIT == field_errorCode.get_selection() || field_errorCode.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_connId.get_selection() || field_connId.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_os__error__code.get_selection() || field_os__error__code.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_os__error__text.get_selection() || field_os__error__text.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_msg.get_selection() || field_msg.is_bound()) return TRUE;
return FALSE;
}
boolean Extended__Result::is_value() const
{
if(OPTIONAL_OMIT != field_errorCode.get_selection() && !field_errorCode.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_connId.get_selection() && !field_connId.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_os__error__code.get_selection() && !field_os__error__code.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_os__error__text.get_selection() && !field_os__error__text.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_msg.get_selection() && !field_msg.is_value()) return FALSE;
return TRUE;
}
int Extended__Result::size_of() const
{
  int ret_val = 0;
  if (field_errorCode.ispresent()) ret_val++;
  if (field_connId.ispresent()) ret_val++;
  if (field_os__error__code.ispresent()) ret_val++;
  if (field_os__error__text.ispresent()) ret_val++;
  if (field_msg.ispresent()) ret_val++;
  return ret_val;
}

void Extended__Result::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ errorCode := ");
field_errorCode.log();
TTCN_Logger::log_event_str(", connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", os_error_code := ");
field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
field_os__error__text.log();
TTCN_Logger::log_event_str(", msg := ");
field_msg.log();
TTCN_Logger::log_event_str(" }");
}

void Extended__Result::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.Extended_Result has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorCode().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Extended_Result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.Extended_Result");
  }
}

void Extended__Result::set_implicit_omit()
{
if (!errorCode().is_bound()) errorCode() = OMIT_VALUE;
else errorCode().set_implicit_omit();
if (!connId().is_bound()) connId() = OMIT_VALUE;
else connId().set_implicit_omit();
if (!os__error__code().is_bound()) os__error__code() = OMIT_VALUE;
else os__error__code().set_implicit_omit();
if (!os__error__text().is_bound()) os__error__text() = OMIT_VALUE;
else os__error__text().set_implicit_omit();
if (!msg().is_bound()) msg() = OMIT_VALUE;
else msg().set_implicit_omit();
}

void Extended__Result::encode_text(Text_Buf& text_buf) const
{
field_errorCode.encode_text(text_buf);
field_connId.encode_text(text_buf);
field_os__error__code.encode_text(text_buf);
field_os__error__text.encode_text(text_buf);
field_msg.encode_text(text_buf);
}

void Extended__Result::decode_text(Text_Buf& text_buf)
{
field_errorCode.decode_text(text_buf);
field_connId.decode_text(text_buf);
field_os__error__code.decode_text(text_buf);
field_os__error__text.decode_text(text_buf);
field_msg.decode_text(text_buf);
}

struct Extended__Result_template::single_value_struct {
PortError_template field_errorCode;
INTEGER_template field_connId;
INTEGER_template field_os__error__code;
CHARSTRING_template field_os__error__text;
OCTETSTRING_template field_msg;
};

void Extended__Result_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_errorCode = ANY_OR_OMIT;
single_value->field_connId = ANY_OR_OMIT;
single_value->field_os__error__code = ANY_OR_OMIT;
single_value->field_os__error__text = ANY_OR_OMIT;
single_value->field_msg = ANY_OR_OMIT;
}
}
}

void Extended__Result_template::copy_value(const Extended__Result& other_value)
{
single_value = new single_value_struct;
if (other_value.errorCode().is_bound()) {
  if (other_value.errorCode().ispresent()) single_value->field_errorCode = other_value.errorCode()();
  else single_value->field_errorCode = OMIT_VALUE;
} else {
  single_value->field_errorCode.clean_up();
}
if (other_value.connId().is_bound()) {
  if (other_value.connId().ispresent()) single_value->field_connId = other_value.connId()();
  else single_value->field_connId = OMIT_VALUE;
} else {
  single_value->field_connId.clean_up();
}
if (other_value.os__error__code().is_bound()) {
  if (other_value.os__error__code().ispresent()) single_value->field_os__error__code = other_value.os__error__code()();
  else single_value->field_os__error__code = OMIT_VALUE;
} else {
  single_value->field_os__error__code.clean_up();
}
if (other_value.os__error__text().is_bound()) {
  if (other_value.os__error__text().ispresent()) single_value->field_os__error__text = other_value.os__error__text()();
  else single_value->field_os__error__text = OMIT_VALUE;
} else {
  single_value->field_os__error__text.clean_up();
}
if (other_value.msg().is_bound()) {
  if (other_value.msg().ispresent()) single_value->field_msg = other_value.msg()();
  else single_value->field_msg = OMIT_VALUE;
} else {
  single_value->field_msg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Extended__Result_template::copy_template(const Extended__Result_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.errorCode().get_selection()) {
single_value->field_errorCode = other_value.errorCode();
} else {
single_value->field_errorCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__code().get_selection()) {
single_value->field_os__error__code = other_value.os__error__code();
} else {
single_value->field_os__error__code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.os__error__text().get_selection()) {
single_value->field_os__error__text = other_value.os__error__text();
} else {
single_value->field_os__error__text.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msg().get_selection()) {
single_value->field_msg = other_value.msg();
} else {
single_value->field_msg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Extended__Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.Extended_Result.");
break;
}
set_selection(other_value);
}

Extended__Result_template::Extended__Result_template()
{
}

Extended__Result_template::Extended__Result_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Extended__Result_template::Extended__Result_template(const Extended__Result& other_value)
{
copy_value(other_value);
}

Extended__Result_template::Extended__Result_template(const OPTIONAL<Extended__Result>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Extended__Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.Extended_Result from an unbound optional field.");
}
}

Extended__Result_template::Extended__Result_template(const Extended__Result_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Extended__Result_template::~Extended__Result_template()
{
clean_up();
}

Extended__Result_template& Extended__Result_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Extended__Result_template& Extended__Result_template::operator=(const Extended__Result& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Extended__Result_template& Extended__Result_template::operator=(const OPTIONAL<Extended__Result>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Extended__Result&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.Extended_Result.");
}
return *this;
}

Extended__Result_template& Extended__Result_template::operator=(const Extended__Result_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Extended__Result_template::match(const Extended__Result& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.errorCode().is_bound()) return FALSE;
if((other_value.errorCode().ispresent() ? !single_value->field_errorCode.match((const PortError&)other_value.errorCode(), legacy) : !single_value->field_errorCode.match_omit(legacy)))return FALSE;
if(!other_value.connId().is_bound()) return FALSE;
if((other_value.connId().ispresent() ? !single_value->field_connId.match((const INTEGER&)other_value.connId(), legacy) : !single_value->field_connId.match_omit(legacy)))return FALSE;
if(!other_value.os__error__code().is_bound()) return FALSE;
if((other_value.os__error__code().ispresent() ? !single_value->field_os__error__code.match((const INTEGER&)other_value.os__error__code(), legacy) : !single_value->field_os__error__code.match_omit(legacy)))return FALSE;
if(!other_value.os__error__text().is_bound()) return FALSE;
if((other_value.os__error__text().ispresent() ? !single_value->field_os__error__text.match((const CHARSTRING&)other_value.os__error__text(), legacy) : !single_value->field_os__error__text.match_omit(legacy)))return FALSE;
if(!other_value.msg().is_bound()) return FALSE;
if((other_value.msg().ispresent() ? !single_value->field_msg.match((const OCTETSTRING&)other_value.msg(), legacy) : !single_value->field_msg.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.Extended_Result.");
}
return FALSE;
}

boolean Extended__Result_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_errorCode.is_omit() || single_value->field_errorCode.is_bound()) return TRUE;
if (single_value->field_connId.is_omit() || single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_os__error__code.is_omit() || single_value->field_os__error__code.is_bound()) return TRUE;
if (single_value->field_os__error__text.is_omit() || single_value->field_os__error__text.is_bound()) return TRUE;
if (single_value->field_msg.is_omit() || single_value->field_msg.is_bound()) return TRUE;
return FALSE;
}

boolean Extended__Result_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_errorCode.is_omit() && !single_value->field_errorCode.is_value()) return FALSE;
if (!single_value->field_connId.is_omit() && !single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_os__error__code.is_omit() && !single_value->field_os__error__code.is_value()) return FALSE;
if (!single_value->field_os__error__text.is_omit() && !single_value->field_os__error__text.is_value()) return FALSE;
if (!single_value->field_msg.is_omit() && !single_value->field_msg.is_value()) return FALSE;
return TRUE;
}

void Extended__Result_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Extended__Result Extended__Result_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.Extended_Result.");
Extended__Result ret_val;
if (single_value->field_errorCode.is_omit()) ret_val.errorCode() = OMIT_VALUE;
else if (single_value->field_errorCode.is_bound()) {
ret_val.errorCode() = single_value->field_errorCode.valueof();
}
if (single_value->field_connId.is_omit()) ret_val.connId() = OMIT_VALUE;
else if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_os__error__code.is_omit()) ret_val.os__error__code() = OMIT_VALUE;
else if (single_value->field_os__error__code.is_bound()) {
ret_val.os__error__code() = single_value->field_os__error__code.valueof();
}
if (single_value->field_os__error__text.is_omit()) ret_val.os__error__text() = OMIT_VALUE;
else if (single_value->field_os__error__text.is_bound()) {
ret_val.os__error__text() = single_value->field_os__error__text.valueof();
}
if (single_value->field_msg.is_omit()) ret_val.msg() = OMIT_VALUE;
else if (single_value->field_msg.is_bound()) {
ret_val.msg() = single_value->field_msg.valueof();
}
return ret_val;
}

void Extended__Result_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.Extended_Result.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Extended__Result_template[list_length];
}

Extended__Result_template& Extended__Result_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.Extended_Result.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.Extended_Result.");
return value_list.list_value[list_index];
}

PortError_template& Extended__Result_template::errorCode()
{
set_specific();
return single_value->field_errorCode;
}

const PortError_template& Extended__Result_template::errorCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field errorCode of a non-specific template of type @Socket_API_Definitions.Extended_Result.");
return single_value->field_errorCode;
}

INTEGER_template& Extended__Result_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& Extended__Result_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @Socket_API_Definitions.Extended_Result.");
return single_value->field_connId;
}

INTEGER_template& Extended__Result_template::os__error__code()
{
set_specific();
return single_value->field_os__error__code;
}

const INTEGER_template& Extended__Result_template::os__error__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_code of a non-specific template of type @Socket_API_Definitions.Extended_Result.");
return single_value->field_os__error__code;
}

CHARSTRING_template& Extended__Result_template::os__error__text()
{
set_specific();
return single_value->field_os__error__text;
}

const CHARSTRING_template& Extended__Result_template::os__error__text() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field os_error_text of a non-specific template of type @Socket_API_Definitions.Extended_Result.");
return single_value->field_os__error__text;
}

OCTETSTRING_template& Extended__Result_template::msg()
{
set_specific();
return single_value->field_msg;
}

const OCTETSTRING_template& Extended__Result_template::msg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg of a non-specific template of type @Socket_API_Definitions.Extended_Result.");
return single_value->field_msg;
}

int Extended__Result_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_errorCode.is_present()) ret_val++;
      if (single_value->field_connId.is_present()) ret_val++;
      if (single_value->field_os__error__code.is_present()) ret_val++;
      if (single_value->field_os__error__text.is_present()) ret_val++;
      if (single_value->field_msg.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.Extended_Result containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.Extended_Result.");
  }
  return 0;
}

void Extended__Result_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ errorCode := ");
single_value->field_errorCode.log();
TTCN_Logger::log_event_str(", connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", os_error_code := ");
single_value->field_os__error__code.log();
TTCN_Logger::log_event_str(", os_error_text := ");
single_value->field_os__error__text.log();
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Extended__Result_template::log_match(const Extended__Result& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.errorCode().ispresent()){
if(!single_value->field_errorCode.match(match_value.errorCode(), legacy)){
TTCN_Logger::log_logmatch_info(".errorCode");
single_value->field_errorCode.log_match(match_value.errorCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_errorCode.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".errorCode := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_errorCode.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.connId().ispresent()){
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_connId.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".connId := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_connId.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.os__error__code().ispresent()){
if(!single_value->field_os__error__code.match(match_value.os__error__code(), legacy)){
TTCN_Logger::log_logmatch_info(".os_error_code");
single_value->field_os__error__code.log_match(match_value.os__error__code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_os__error__code.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".os_error_code := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_os__error__code.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.os__error__text().ispresent()){
if(!single_value->field_os__error__text.match(match_value.os__error__text(), legacy)){
TTCN_Logger::log_logmatch_info(".os_error_text");
single_value->field_os__error__text.log_match(match_value.os__error__text(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_os__error__text.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".os_error_text := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_os__error__text.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.msg().ispresent()){
if(!single_value->field_msg.match(match_value.msg(), legacy)){
TTCN_Logger::log_logmatch_info(".msg");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_msg.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".msg := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_msg.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ errorCode := ");
if (match_value.errorCode().ispresent()) single_value->field_errorCode.log_match(match_value.errorCode(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_errorCode.log();
if (single_value->field_errorCode.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", connId := ");
if (match_value.connId().ispresent()) single_value->field_connId.log_match(match_value.connId(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_connId.log();
if (single_value->field_connId.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", os_error_code := ");
if (match_value.os__error__code().ispresent()) single_value->field_os__error__code.log_match(match_value.os__error__code(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_os__error__code.log();
if (single_value->field_os__error__code.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", os_error_text := ");
if (match_value.os__error__text().ispresent()) single_value->field_os__error__text.log_match(match_value.os__error__text(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_os__error__text.log();
if (single_value->field_os__error__text.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", msg := ");
if (match_value.msg().ispresent()) single_value->field_msg.log_match(match_value.msg(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_msg.log();
if (single_value->field_msg.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Extended__Result_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_errorCode.encode_text(text_buf);
single_value->field_connId.encode_text(text_buf);
single_value->field_os__error__code.encode_text(text_buf);
single_value->field_os__error__text.encode_text(text_buf);
single_value->field_msg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.Extended_Result.");
}
}

void Extended__Result_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_errorCode.decode_text(text_buf);
single_value->field_connId.decode_text(text_buf);
single_value->field_os__error__code.decode_text(text_buf);
single_value->field_os__error__text.decode_text(text_buf);
single_value->field_msg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Extended__Result_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.Extended_Result.");
}
}

void Extended__Result_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Extended__Result_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.Extended_Result has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) errorCode().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) os__error__code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) os__error__text().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "errorCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          errorCode().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "os_error_text")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          os__error__text().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.Extended_Result: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.Extended_Result");
  }
  is_ifpresent = param.get_ifpresent();
}

void Extended__Result_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_errorCode.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
single_value->field_os__error__code.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
single_value->field_os__error__text.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
single_value->field_msg.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.Extended_Result");
}

boolean Extended__Result_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Extended__Result_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ConnectionOpenedEvent::ConnectionOpenedEvent()
{
}

ConnectionOpenedEvent::ConnectionOpenedEvent(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const CHARSTRING& par_locName,
    const INTEGER& par_locPort,
    const ProtoTuple& par_proto,
    const INTEGER& par_userData)
  :   field_connId(par_connId),
  field_remName(par_remName),
  field_remPort(par_remPort),
  field_locName(par_locName),
  field_locPort(par_locPort),
  field_proto(par_proto),
  field_userData(par_userData)
{
}

ConnectionOpenedEvent::ConnectionOpenedEvent(const ConnectionOpenedEvent& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.ConnectionOpenedEvent.");
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.remName().is_bound()) field_remName = other_value.remName();
else field_remName.clean_up();
if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
else field_remPort.clean_up();
if (other_value.locName().is_bound()) field_locName = other_value.locName();
else field_locName.clean_up();
if (other_value.locPort().is_bound()) field_locPort = other_value.locPort();
else field_locPort.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.userData().is_bound()) field_userData = other_value.userData();
else field_userData.clean_up();
}

void ConnectionOpenedEvent::clean_up()
{
field_connId.clean_up();
field_remName.clean_up();
field_remPort.clean_up();
field_locName.clean_up();
field_locPort.clean_up();
field_proto.clean_up();
field_userData.clean_up();
}

ConnectionOpenedEvent& ConnectionOpenedEvent::operator=(const ConnectionOpenedEvent& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.ConnectionOpenedEvent.");
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.remName().is_bound()) field_remName = other_value.remName();
  else field_remName.clean_up();
  if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
  else field_remPort.clean_up();
  if (other_value.locName().is_bound()) field_locName = other_value.locName();
  else field_locName.clean_up();
  if (other_value.locPort().is_bound()) field_locPort = other_value.locPort();
  else field_locPort.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.userData().is_bound()) field_userData = other_value.userData();
  else field_userData.clean_up();
}
return *this;
}

boolean ConnectionOpenedEvent::operator==(const ConnectionOpenedEvent& other_value) const
{
return field_connId==other_value.field_connId
  && field_remName==other_value.field_remName
  && field_remPort==other_value.field_remPort
  && field_locName==other_value.field_locName
  && field_locPort==other_value.field_locPort
  && field_proto==other_value.field_proto
  && field_userData==other_value.field_userData;
}

boolean ConnectionOpenedEvent::is_bound() const
{
if(field_connId.is_bound()) return TRUE;
if(field_remName.is_bound()) return TRUE;
if(field_remPort.is_bound()) return TRUE;
if(field_locName.is_bound()) return TRUE;
if(field_locPort.is_bound()) return TRUE;
if(field_proto.is_bound()) return TRUE;
if(field_userData.is_bound()) return TRUE;
return FALSE;
}
boolean ConnectionOpenedEvent::is_value() const
{
if(!field_connId.is_value()) return FALSE;
if(!field_remName.is_value()) return FALSE;
if(!field_remPort.is_value()) return FALSE;
if(!field_locName.is_value()) return FALSE;
if(!field_locPort.is_value()) return FALSE;
if(!field_proto.is_value()) return FALSE;
if(!field_userData.is_value()) return FALSE;
return TRUE;
}
void ConnectionOpenedEvent::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
field_remPort.log();
TTCN_Logger::log_event_str(", locName := ");
field_locName.log();
TTCN_Logger::log_event_str(", locPort := ");
field_locPort.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", userData := ");
field_userData.log();
TTCN_Logger::log_event_str(" }");
}

void ConnectionOpenedEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.ConnectionOpenedEvent has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) locName().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) locPort().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) userData().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userData().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.ConnectionOpenedEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.ConnectionOpenedEvent");
  }
}

void ConnectionOpenedEvent::set_implicit_omit()
{
if (connId().is_bound()) connId().set_implicit_omit();
if (remName().is_bound()) remName().set_implicit_omit();
if (remPort().is_bound()) remPort().set_implicit_omit();
if (locName().is_bound()) locName().set_implicit_omit();
if (locPort().is_bound()) locPort().set_implicit_omit();
if (proto().is_bound()) proto().set_implicit_omit();
if (userData().is_bound()) userData().set_implicit_omit();
}

void ConnectionOpenedEvent::encode_text(Text_Buf& text_buf) const
{
field_connId.encode_text(text_buf);
field_remName.encode_text(text_buf);
field_remPort.encode_text(text_buf);
field_locName.encode_text(text_buf);
field_locPort.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_userData.encode_text(text_buf);
}

void ConnectionOpenedEvent::decode_text(Text_Buf& text_buf)
{
field_connId.decode_text(text_buf);
field_remName.decode_text(text_buf);
field_remPort.decode_text(text_buf);
field_locName.decode_text(text_buf);
field_locPort.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_userData.decode_text(text_buf);
}

struct ConnectionOpenedEvent_template::single_value_struct {
INTEGER_template field_connId;
CHARSTRING_template field_remName;
INTEGER_template field_remPort;
CHARSTRING_template field_locName;
INTEGER_template field_locPort;
ProtoTuple_template field_proto;
INTEGER_template field_userData;
};

void ConnectionOpenedEvent_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connId = ANY_VALUE;
single_value->field_remName = ANY_VALUE;
single_value->field_remPort = ANY_VALUE;
single_value->field_locName = ANY_VALUE;
single_value->field_locPort = ANY_VALUE;
single_value->field_proto = ANY_VALUE;
single_value->field_userData = ANY_VALUE;
}
}
}

void ConnectionOpenedEvent_template::copy_value(const ConnectionOpenedEvent& other_value)
{
single_value = new single_value_struct;
if (other_value.connId().is_bound()) {
  single_value->field_connId = other_value.connId();
} else {
  single_value->field_connId.clean_up();
}
if (other_value.remName().is_bound()) {
  single_value->field_remName = other_value.remName();
} else {
  single_value->field_remName.clean_up();
}
if (other_value.remPort().is_bound()) {
  single_value->field_remPort = other_value.remPort();
} else {
  single_value->field_remPort.clean_up();
}
if (other_value.locName().is_bound()) {
  single_value->field_locName = other_value.locName();
} else {
  single_value->field_locName.clean_up();
}
if (other_value.locPort().is_bound()) {
  single_value->field_locPort = other_value.locPort();
} else {
  single_value->field_locPort.clean_up();
}
if (other_value.proto().is_bound()) {
  single_value->field_proto = other_value.proto();
} else {
  single_value->field_proto.clean_up();
}
if (other_value.userData().is_bound()) {
  single_value->field_userData = other_value.userData();
} else {
  single_value->field_userData.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ConnectionOpenedEvent_template::copy_template(const ConnectionOpenedEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remName().get_selection()) {
single_value->field_remName = other_value.remName();
} else {
single_value->field_remName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remPort().get_selection()) {
single_value->field_remPort = other_value.remPort();
} else {
single_value->field_remPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.locName().get_selection()) {
single_value->field_locName = other_value.locName();
} else {
single_value->field_locName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.locPort().get_selection()) {
single_value->field_locPort = other_value.locPort();
} else {
single_value->field_locPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.userData().get_selection()) {
single_value->field_userData = other_value.userData();
} else {
single_value->field_userData.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ConnectionOpenedEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
break;
}
set_selection(other_value);
}

ConnectionOpenedEvent_template::ConnectionOpenedEvent_template()
{
}

ConnectionOpenedEvent_template::ConnectionOpenedEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ConnectionOpenedEvent_template::ConnectionOpenedEvent_template(const ConnectionOpenedEvent& other_value)
{
copy_value(other_value);
}

ConnectionOpenedEvent_template::ConnectionOpenedEvent_template(const OPTIONAL<ConnectionOpenedEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectionOpenedEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.ConnectionOpenedEvent from an unbound optional field.");
}
}

ConnectionOpenedEvent_template::ConnectionOpenedEvent_template(const ConnectionOpenedEvent_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ConnectionOpenedEvent_template::~ConnectionOpenedEvent_template()
{
clean_up();
}

ConnectionOpenedEvent_template& ConnectionOpenedEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ConnectionOpenedEvent_template& ConnectionOpenedEvent_template::operator=(const ConnectionOpenedEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ConnectionOpenedEvent_template& ConnectionOpenedEvent_template::operator=(const OPTIONAL<ConnectionOpenedEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ConnectionOpenedEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
}
return *this;
}

ConnectionOpenedEvent_template& ConnectionOpenedEvent_template::operator=(const ConnectionOpenedEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ConnectionOpenedEvent_template::match(const ConnectionOpenedEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connId().is_bound()) return FALSE;
if(!single_value->field_connId.match(other_value.connId(), legacy))return FALSE;
if(!other_value.remName().is_bound()) return FALSE;
if(!single_value->field_remName.match(other_value.remName(), legacy))return FALSE;
if(!other_value.remPort().is_bound()) return FALSE;
if(!single_value->field_remPort.match(other_value.remPort(), legacy))return FALSE;
if(!other_value.locName().is_bound()) return FALSE;
if(!single_value->field_locName.match(other_value.locName(), legacy))return FALSE;
if(!other_value.locPort().is_bound()) return FALSE;
if(!single_value->field_locPort.match(other_value.locPort(), legacy))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if(!single_value->field_proto.match(other_value.proto(), legacy))return FALSE;
if(!other_value.userData().is_bound()) return FALSE;
if(!single_value->field_userData.match(other_value.userData(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
}
return FALSE;
}

boolean ConnectionOpenedEvent_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_remName.is_bound()) return TRUE;
if (single_value->field_remPort.is_bound()) return TRUE;
if (single_value->field_locName.is_bound()) return TRUE;
if (single_value->field_locPort.is_bound()) return TRUE;
if (single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_userData.is_bound()) return TRUE;
return FALSE;
}

boolean ConnectionOpenedEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_remName.is_value()) return FALSE;
if (!single_value->field_remPort.is_value()) return FALSE;
if (!single_value->field_locName.is_value()) return FALSE;
if (!single_value->field_locPort.is_value()) return FALSE;
if (!single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_userData.is_value()) return FALSE;
return TRUE;
}

void ConnectionOpenedEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ConnectionOpenedEvent ConnectionOpenedEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
ConnectionOpenedEvent ret_val;
if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_remName.is_bound()) {
ret_val.remName() = single_value->field_remName.valueof();
}
if (single_value->field_remPort.is_bound()) {
ret_val.remPort() = single_value->field_remPort.valueof();
}
if (single_value->field_locName.is_bound()) {
ret_val.locName() = single_value->field_locName.valueof();
}
if (single_value->field_locPort.is_bound()) {
ret_val.locPort() = single_value->field_locPort.valueof();
}
if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_userData.is_bound()) {
ret_val.userData() = single_value->field_userData.valueof();
}
return ret_val;
}

void ConnectionOpenedEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ConnectionOpenedEvent_template[list_length];
}

ConnectionOpenedEvent_template& ConnectionOpenedEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return value_list.list_value[list_index];
}

INTEGER_template& ConnectionOpenedEvent_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& ConnectionOpenedEvent_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_connId;
}

CHARSTRING_template& ConnectionOpenedEvent_template::remName()
{
set_specific();
return single_value->field_remName;
}

const CHARSTRING_template& ConnectionOpenedEvent_template::remName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remName of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_remName;
}

INTEGER_template& ConnectionOpenedEvent_template::remPort()
{
set_specific();
return single_value->field_remPort;
}

const INTEGER_template& ConnectionOpenedEvent_template::remPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remPort of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_remPort;
}

CHARSTRING_template& ConnectionOpenedEvent_template::locName()
{
set_specific();
return single_value->field_locName;
}

const CHARSTRING_template& ConnectionOpenedEvent_template::locName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field locName of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_locName;
}

INTEGER_template& ConnectionOpenedEvent_template::locPort()
{
set_specific();
return single_value->field_locPort;
}

const INTEGER_template& ConnectionOpenedEvent_template::locPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field locPort of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_locPort;
}

ProtoTuple_template& ConnectionOpenedEvent_template::proto()
{
set_specific();
return single_value->field_proto;
}

const ProtoTuple_template& ConnectionOpenedEvent_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_proto;
}

INTEGER_template& ConnectionOpenedEvent_template::userData()
{
set_specific();
return single_value->field_userData;
}

const INTEGER_template& ConnectionOpenedEvent_template::userData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field userData of a non-specific template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
return single_value->field_userData;
}

int ConnectionOpenedEvent_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.ConnectionOpenedEvent containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
  }
  return 0;
}

void ConnectionOpenedEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log();
TTCN_Logger::log_event_str(", locName := ");
single_value->field_locName.log();
TTCN_Logger::log_event_str(", locPort := ");
single_value->field_locPort.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", userData := ");
single_value->field_userData.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ConnectionOpenedEvent_template::log_match(const ConnectionOpenedEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remName.match(match_value.remName(), legacy)){
TTCN_Logger::log_logmatch_info(".remName");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remPort.match(match_value.remPort(), legacy)){
TTCN_Logger::log_logmatch_info(".remPort");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_locName.match(match_value.locName(), legacy)){
TTCN_Logger::log_logmatch_info(".locName");
single_value->field_locName.log_match(match_value.locName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_locPort.match(match_value.locPort(), legacy)){
TTCN_Logger::log_logmatch_info(".locPort");
single_value->field_locPort.log_match(match_value.locPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_userData.match(match_value.userData(), legacy)){
TTCN_Logger::log_logmatch_info(".userData");
single_value->field_userData.log_match(match_value.userData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::log_event_str(", locName := ");
single_value->field_locName.log_match(match_value.locName(), legacy);
TTCN_Logger::log_event_str(", locPort := ");
single_value->field_locPort.log_match(match_value.locPort(), legacy);
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::log_event_str(", userData := ");
single_value->field_userData.log_match(match_value.userData(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ConnectionOpenedEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connId.encode_text(text_buf);
single_value->field_remName.encode_text(text_buf);
single_value->field_remPort.encode_text(text_buf);
single_value->field_locName.encode_text(text_buf);
single_value->field_locPort.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_userData.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
}
}

void ConnectionOpenedEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connId.decode_text(text_buf);
single_value->field_remName.decode_text(text_buf);
single_value->field_remPort.decode_text(text_buf);
single_value->field_locName.decode_text(text_buf);
single_value->field_locPort.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_userData.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ConnectionOpenedEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.ConnectionOpenedEvent.");
}
}

void ConnectionOpenedEvent_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ConnectionOpenedEvent_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.ConnectionOpenedEvent has 7 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) locName().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) locPort().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) userData().set_param(*param.get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userData().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.ConnectionOpenedEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.ConnectionOpenedEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void ConnectionOpenedEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_remName.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_remPort.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_locName.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_locPort.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
single_value->field_userData.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.ConnectionOpenedEvent");
}

boolean ConnectionOpenedEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ConnectionOpenedEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SctpEvent::copy_value(const SctpEvent& other_value)
{
switch (other_value.union_selection) {
case ALT_sctpAssocChange:
field_sctpAssocChange = new SctpAssocChange(*other_value.field_sctpAssocChange);
break;
case ALT_sctpPeerAddrChange:
field_sctpPeerAddrChange = new SctpPeerAddrChange(*other_value.field_sctpPeerAddrChange);
break;
case ALT_sctpSendFailed:
field_sctpSendFailed = new SctpSendFailed(*other_value.field_sctpSendFailed);
break;
case ALT_sctpRemoteError:
field_sctpRemoteError = new SctpRemoteError(*other_value.field_sctpRemoteError);
break;
case ALT_sctpShutDownEvent:
field_sctpShutDownEvent = new SctpShutDownEvent(*other_value.field_sctpShutDownEvent);
break;
case ALT_sctpPartialDeliveryEvent:
field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent(*other_value.field_sctpPartialDeliveryEvent);
break;
case ALT_sctpAdaptationIndication:
field_sctpAdaptationIndication = new SctpAdaptationIndication(*other_value.field_sctpAdaptationIndication);
break;
case ALT_sctpSenderDryEvent:
field_sctpSenderDryEvent = new SctpSenderDryEvent(*other_value.field_sctpSenderDryEvent);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Socket_API_Definitions.SctpEvent.");
}
union_selection = other_value.union_selection;
}

SctpEvent::SctpEvent()
{
union_selection = UNBOUND_VALUE;
}

SctpEvent::SctpEvent(const SctpEvent& other_value)
: Base_Type(){
copy_value(other_value);
}

SctpEvent::~SctpEvent()
{
clean_up();
}

SctpEvent& SctpEvent::operator=(const SctpEvent& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SctpEvent::operator==(const SctpEvent& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Socket_API_Definitions.SctpEvent.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Socket_API_Definitions.SctpEvent.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_sctpAssocChange:
return *field_sctpAssocChange == *other_value.field_sctpAssocChange;
case ALT_sctpPeerAddrChange:
return *field_sctpPeerAddrChange == *other_value.field_sctpPeerAddrChange;
case ALT_sctpSendFailed:
return *field_sctpSendFailed == *other_value.field_sctpSendFailed;
case ALT_sctpRemoteError:
return *field_sctpRemoteError == *other_value.field_sctpRemoteError;
case ALT_sctpShutDownEvent:
return *field_sctpShutDownEvent == *other_value.field_sctpShutDownEvent;
case ALT_sctpPartialDeliveryEvent:
return *field_sctpPartialDeliveryEvent == *other_value.field_sctpPartialDeliveryEvent;
case ALT_sctpAdaptationIndication:
return *field_sctpAdaptationIndication == *other_value.field_sctpAdaptationIndication;
case ALT_sctpSenderDryEvent:
return *field_sctpSenderDryEvent == *other_value.field_sctpSenderDryEvent;
default:
return FALSE;
}
}

SctpAssocChange& SctpEvent::sctpAssocChange()
{
if (union_selection != ALT_sctpAssocChange) {
clean_up();
field_sctpAssocChange = new SctpAssocChange;
union_selection = ALT_sctpAssocChange;
}
return *field_sctpAssocChange;
}

const SctpAssocChange& SctpEvent::sctpAssocChange() const
{
if (union_selection != ALT_sctpAssocChange) TTCN_error("Using non-selected field sctpAssocChange in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpAssocChange;
}

SctpPeerAddrChange& SctpEvent::sctpPeerAddrChange()
{
if (union_selection != ALT_sctpPeerAddrChange) {
clean_up();
field_sctpPeerAddrChange = new SctpPeerAddrChange;
union_selection = ALT_sctpPeerAddrChange;
}
return *field_sctpPeerAddrChange;
}

const SctpPeerAddrChange& SctpEvent::sctpPeerAddrChange() const
{
if (union_selection != ALT_sctpPeerAddrChange) TTCN_error("Using non-selected field sctpPeerAddrChange in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpPeerAddrChange;
}

SctpSendFailed& SctpEvent::sctpSendFailed()
{
if (union_selection != ALT_sctpSendFailed) {
clean_up();
field_sctpSendFailed = new SctpSendFailed;
union_selection = ALT_sctpSendFailed;
}
return *field_sctpSendFailed;
}

const SctpSendFailed& SctpEvent::sctpSendFailed() const
{
if (union_selection != ALT_sctpSendFailed) TTCN_error("Using non-selected field sctpSendFailed in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpSendFailed;
}

SctpRemoteError& SctpEvent::sctpRemoteError()
{
if (union_selection != ALT_sctpRemoteError) {
clean_up();
field_sctpRemoteError = new SctpRemoteError;
union_selection = ALT_sctpRemoteError;
}
return *field_sctpRemoteError;
}

const SctpRemoteError& SctpEvent::sctpRemoteError() const
{
if (union_selection != ALT_sctpRemoteError) TTCN_error("Using non-selected field sctpRemoteError in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpRemoteError;
}

SctpShutDownEvent& SctpEvent::sctpShutDownEvent()
{
if (union_selection != ALT_sctpShutDownEvent) {
clean_up();
field_sctpShutDownEvent = new SctpShutDownEvent;
union_selection = ALT_sctpShutDownEvent;
}
return *field_sctpShutDownEvent;
}

const SctpShutDownEvent& SctpEvent::sctpShutDownEvent() const
{
if (union_selection != ALT_sctpShutDownEvent) TTCN_error("Using non-selected field sctpShutDownEvent in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpShutDownEvent;
}

SctpPartialDeliveryEvent& SctpEvent::sctpPartialDeliveryEvent()
{
if (union_selection != ALT_sctpPartialDeliveryEvent) {
clean_up();
field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent;
union_selection = ALT_sctpPartialDeliveryEvent;
}
return *field_sctpPartialDeliveryEvent;
}

const SctpPartialDeliveryEvent& SctpEvent::sctpPartialDeliveryEvent() const
{
if (union_selection != ALT_sctpPartialDeliveryEvent) TTCN_error("Using non-selected field sctpPartialDeliveryEvent in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpPartialDeliveryEvent;
}

SctpAdaptationIndication& SctpEvent::sctpAdaptationIndication()
{
if (union_selection != ALT_sctpAdaptationIndication) {
clean_up();
field_sctpAdaptationIndication = new SctpAdaptationIndication;
union_selection = ALT_sctpAdaptationIndication;
}
return *field_sctpAdaptationIndication;
}

const SctpAdaptationIndication& SctpEvent::sctpAdaptationIndication() const
{
if (union_selection != ALT_sctpAdaptationIndication) TTCN_error("Using non-selected field sctpAdaptationIndication in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpAdaptationIndication;
}

SctpSenderDryEvent& SctpEvent::sctpSenderDryEvent()
{
if (union_selection != ALT_sctpSenderDryEvent) {
clean_up();
field_sctpSenderDryEvent = new SctpSenderDryEvent;
union_selection = ALT_sctpSenderDryEvent;
}
return *field_sctpSenderDryEvent;
}

const SctpSenderDryEvent& SctpEvent::sctpSenderDryEvent() const
{
if (union_selection != ALT_sctpSenderDryEvent) TTCN_error("Using non-selected field sctpSenderDryEvent in a value of union type @Socket_API_Definitions.SctpEvent.");
return *field_sctpSenderDryEvent;
}

boolean SctpEvent::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.SctpEvent.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Socket_API_Definitions.SctpEvent.");
return union_selection == checked_selection;
}

boolean SctpEvent::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SctpEvent::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_sctpAssocChange: return field_sctpAssocChange->is_value();
case ALT_sctpPeerAddrChange: return field_sctpPeerAddrChange->is_value();
case ALT_sctpSendFailed: return field_sctpSendFailed->is_value();
case ALT_sctpRemoteError: return field_sctpRemoteError->is_value();
case ALT_sctpShutDownEvent: return field_sctpShutDownEvent->is_value();
case ALT_sctpPartialDeliveryEvent: return field_sctpPartialDeliveryEvent->is_value();
case ALT_sctpAdaptationIndication: return field_sctpAdaptationIndication->is_value();
case ALT_sctpSenderDryEvent: return field_sctpSenderDryEvent->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SctpEvent::clean_up()
{
switch (union_selection) {
case ALT_sctpAssocChange:
  delete field_sctpAssocChange;
  break;
case ALT_sctpPeerAddrChange:
  delete field_sctpPeerAddrChange;
  break;
case ALT_sctpSendFailed:
  delete field_sctpSendFailed;
  break;
case ALT_sctpRemoteError:
  delete field_sctpRemoteError;
  break;
case ALT_sctpShutDownEvent:
  delete field_sctpShutDownEvent;
  break;
case ALT_sctpPartialDeliveryEvent:
  delete field_sctpPartialDeliveryEvent;
  break;
case ALT_sctpAdaptationIndication:
  delete field_sctpAdaptationIndication;
  break;
case ALT_sctpSenderDryEvent:
  delete field_sctpSenderDryEvent;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SctpEvent::log() const
{
switch (union_selection) {
case ALT_sctpAssocChange:
TTCN_Logger::log_event_str("{ sctpAssocChange := ");
field_sctpAssocChange->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpPeerAddrChange:
TTCN_Logger::log_event_str("{ sctpPeerAddrChange := ");
field_sctpPeerAddrChange->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpSendFailed:
TTCN_Logger::log_event_str("{ sctpSendFailed := ");
field_sctpSendFailed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpRemoteError:
TTCN_Logger::log_event_str("{ sctpRemoteError := ");
field_sctpRemoteError->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpShutDownEvent:
TTCN_Logger::log_event_str("{ sctpShutDownEvent := ");
field_sctpShutDownEvent->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpPartialDeliveryEvent:
TTCN_Logger::log_event_str("{ sctpPartialDeliveryEvent := ");
field_sctpPartialDeliveryEvent->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpAdaptationIndication:
TTCN_Logger::log_event_str("{ sctpAdaptationIndication := ");
field_sctpAdaptationIndication->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpSenderDryEvent:
TTCN_Logger::log_event_str("{ sctpSenderDryEvent := ");
field_sctpSenderDryEvent->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SctpEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "sctpAssocChange")) {
    sctpAssocChange().set_param(*mp_last);
    if (!sctpAssocChange().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpPeerAddrChange")) {
    sctpPeerAddrChange().set_param(*mp_last);
    if (!sctpPeerAddrChange().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpSendFailed")) {
    sctpSendFailed().set_param(*mp_last);
    if (!sctpSendFailed().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpRemoteError")) {
    sctpRemoteError().set_param(*mp_last);
    if (!sctpRemoteError().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpShutDownEvent")) {
    sctpShutDownEvent().set_param(*mp_last);
    if (!sctpShutDownEvent().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpPartialDeliveryEvent")) {
    sctpPartialDeliveryEvent().set_param(*mp_last);
    if (!sctpPartialDeliveryEvent().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpAdaptationIndication")) {
    sctpAdaptationIndication().set_param(*mp_last);
    if (!sctpAdaptationIndication().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpSenderDryEvent")) {
    sctpSenderDryEvent().set_param(*mp_last);
    if (!sctpSenderDryEvent().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Socket_API_Definitions.SctpEvent.", mp_last->get_id()->get_name());
}

void SctpEvent::set_implicit_omit()
{
switch (union_selection) {
case ALT_sctpAssocChange:
field_sctpAssocChange->set_implicit_omit(); break;
case ALT_sctpPeerAddrChange:
field_sctpPeerAddrChange->set_implicit_omit(); break;
case ALT_sctpSendFailed:
field_sctpSendFailed->set_implicit_omit(); break;
case ALT_sctpRemoteError:
field_sctpRemoteError->set_implicit_omit(); break;
case ALT_sctpShutDownEvent:
field_sctpShutDownEvent->set_implicit_omit(); break;
case ALT_sctpPartialDeliveryEvent:
field_sctpPartialDeliveryEvent->set_implicit_omit(); break;
case ALT_sctpAdaptationIndication:
field_sctpAdaptationIndication->set_implicit_omit(); break;
case ALT_sctpSenderDryEvent:
field_sctpSenderDryEvent->set_implicit_omit(); break;
default: break;
}
}

void SctpEvent::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_sctpAssocChange:
field_sctpAssocChange->encode_text(text_buf);
break;
case ALT_sctpPeerAddrChange:
field_sctpPeerAddrChange->encode_text(text_buf);
break;
case ALT_sctpSendFailed:
field_sctpSendFailed->encode_text(text_buf);
break;
case ALT_sctpRemoteError:
field_sctpRemoteError->encode_text(text_buf);
break;
case ALT_sctpShutDownEvent:
field_sctpShutDownEvent->encode_text(text_buf);
break;
case ALT_sctpPartialDeliveryEvent:
field_sctpPartialDeliveryEvent->encode_text(text_buf);
break;
case ALT_sctpAdaptationIndication:
field_sctpAdaptationIndication->encode_text(text_buf);
break;
case ALT_sctpSenderDryEvent:
field_sctpSenderDryEvent->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Socket_API_Definitions.SctpEvent.");
}
}

void SctpEvent::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_sctpAssocChange:
sctpAssocChange().decode_text(text_buf);
break;
case ALT_sctpPeerAddrChange:
sctpPeerAddrChange().decode_text(text_buf);
break;
case ALT_sctpSendFailed:
sctpSendFailed().decode_text(text_buf);
break;
case ALT_sctpRemoteError:
sctpRemoteError().decode_text(text_buf);
break;
case ALT_sctpShutDownEvent:
sctpShutDownEvent().decode_text(text_buf);
break;
case ALT_sctpPartialDeliveryEvent:
sctpPartialDeliveryEvent().decode_text(text_buf);
break;
case ALT_sctpAdaptationIndication:
sctpAdaptationIndication().decode_text(text_buf);
break;
case ALT_sctpSenderDryEvent:
sctpSenderDryEvent().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Socket_API_Definitions.SctpEvent.");
}
}

void SctpEvent_template::copy_value(const SctpEvent& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
single_value.field_sctpAssocChange = new SctpAssocChange_template(other_value.sctpAssocChange());
break;
case SctpEvent::ALT_sctpPeerAddrChange:
single_value.field_sctpPeerAddrChange = new SctpPeerAddrChange_template(other_value.sctpPeerAddrChange());
break;
case SctpEvent::ALT_sctpSendFailed:
single_value.field_sctpSendFailed = new SctpSendFailed_template(other_value.sctpSendFailed());
break;
case SctpEvent::ALT_sctpRemoteError:
single_value.field_sctpRemoteError = new SctpRemoteError_template(other_value.sctpRemoteError());
break;
case SctpEvent::ALT_sctpShutDownEvent:
single_value.field_sctpShutDownEvent = new SctpShutDownEvent_template(other_value.sctpShutDownEvent());
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
single_value.field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent_template(other_value.sctpPartialDeliveryEvent());
break;
case SctpEvent::ALT_sctpAdaptationIndication:
single_value.field_sctpAdaptationIndication = new SctpAdaptationIndication_template(other_value.sctpAdaptationIndication());
break;
case SctpEvent::ALT_sctpSenderDryEvent:
single_value.field_sctpSenderDryEvent = new SctpSenderDryEvent_template(other_value.sctpSenderDryEvent());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Socket_API_Definitions.SctpEvent.");
}
set_selection(SPECIFIC_VALUE);
}

void SctpEvent_template::copy_template(const SctpEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
single_value.field_sctpAssocChange = new SctpAssocChange_template(*other_value.single_value.field_sctpAssocChange);
break;
case SctpEvent::ALT_sctpPeerAddrChange:
single_value.field_sctpPeerAddrChange = new SctpPeerAddrChange_template(*other_value.single_value.field_sctpPeerAddrChange);
break;
case SctpEvent::ALT_sctpSendFailed:
single_value.field_sctpSendFailed = new SctpSendFailed_template(*other_value.single_value.field_sctpSendFailed);
break;
case SctpEvent::ALT_sctpRemoteError:
single_value.field_sctpRemoteError = new SctpRemoteError_template(*other_value.single_value.field_sctpRemoteError);
break;
case SctpEvent::ALT_sctpShutDownEvent:
single_value.field_sctpShutDownEvent = new SctpShutDownEvent_template(*other_value.single_value.field_sctpShutDownEvent);
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
single_value.field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent_template(*other_value.single_value.field_sctpPartialDeliveryEvent);
break;
case SctpEvent::ALT_sctpAdaptationIndication:
single_value.field_sctpAdaptationIndication = new SctpAdaptationIndication_template(*other_value.single_value.field_sctpAdaptationIndication);
break;
case SctpEvent::ALT_sctpSenderDryEvent:
single_value.field_sctpSenderDryEvent = new SctpSenderDryEvent_template(*other_value.single_value.field_sctpSenderDryEvent);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Socket_API_Definitions.SctpEvent.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Socket_API_Definitions.SctpEvent.");
}
set_selection(other_value);
}

SctpEvent_template::SctpEvent_template()
{
}

SctpEvent_template::SctpEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpEvent_template::SctpEvent_template(const SctpEvent& other_value)
{
copy_value(other_value);
}

SctpEvent_template::SctpEvent_template(const OPTIONAL<SctpEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Socket_API_Definitions.SctpEvent from an unbound optional field.");
}
}

SctpEvent_template::SctpEvent_template(const SctpEvent_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SctpEvent_template::~SctpEvent_template()
{
clean_up();
}

void SctpEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
delete single_value.field_sctpAssocChange;
break;
case SctpEvent::ALT_sctpPeerAddrChange:
delete single_value.field_sctpPeerAddrChange;
break;
case SctpEvent::ALT_sctpSendFailed:
delete single_value.field_sctpSendFailed;
break;
case SctpEvent::ALT_sctpRemoteError:
delete single_value.field_sctpRemoteError;
break;
case SctpEvent::ALT_sctpShutDownEvent:
delete single_value.field_sctpShutDownEvent;
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
delete single_value.field_sctpPartialDeliveryEvent;
break;
case SctpEvent::ALT_sctpAdaptationIndication:
delete single_value.field_sctpAdaptationIndication;
break;
case SctpEvent::ALT_sctpSenderDryEvent:
delete single_value.field_sctpSenderDryEvent;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpEvent_template& SctpEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpEvent_template& SctpEvent_template::operator=(const SctpEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpEvent_template& SctpEvent_template::operator=(const OPTIONAL<SctpEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Socket_API_Definitions.SctpEvent.");
}
return *this;
}

SctpEvent_template& SctpEvent_template::operator=(const SctpEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpEvent_template::match(const SctpEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SctpEvent::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SctpEvent::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SctpEvent::ALT_sctpAssocChange:
return single_value.field_sctpAssocChange->match(other_value.sctpAssocChange(), legacy);
case SctpEvent::ALT_sctpPeerAddrChange:
return single_value.field_sctpPeerAddrChange->match(other_value.sctpPeerAddrChange(), legacy);
case SctpEvent::ALT_sctpSendFailed:
return single_value.field_sctpSendFailed->match(other_value.sctpSendFailed(), legacy);
case SctpEvent::ALT_sctpRemoteError:
return single_value.field_sctpRemoteError->match(other_value.sctpRemoteError(), legacy);
case SctpEvent::ALT_sctpShutDownEvent:
return single_value.field_sctpShutDownEvent->match(other_value.sctpShutDownEvent(), legacy);
case SctpEvent::ALT_sctpPartialDeliveryEvent:
return single_value.field_sctpPartialDeliveryEvent->match(other_value.sctpPartialDeliveryEvent(), legacy);
case SctpEvent::ALT_sctpAdaptationIndication:
return single_value.field_sctpAdaptationIndication->match(other_value.sctpAdaptationIndication(), legacy);
case SctpEvent::ALT_sctpSenderDryEvent:
return single_value.field_sctpSenderDryEvent->match(other_value.sctpSenderDryEvent(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Socket_API_Definitions.SctpEvent.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Socket_API_Definitions.SctpEvent.");
}
return FALSE;
}

boolean SctpEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
return single_value.field_sctpAssocChange->is_value();
case SctpEvent::ALT_sctpPeerAddrChange:
return single_value.field_sctpPeerAddrChange->is_value();
case SctpEvent::ALT_sctpSendFailed:
return single_value.field_sctpSendFailed->is_value();
case SctpEvent::ALT_sctpRemoteError:
return single_value.field_sctpRemoteError->is_value();
case SctpEvent::ALT_sctpShutDownEvent:
return single_value.field_sctpShutDownEvent->is_value();
case SctpEvent::ALT_sctpPartialDeliveryEvent:
return single_value.field_sctpPartialDeliveryEvent->is_value();
case SctpEvent::ALT_sctpAdaptationIndication:
return single_value.field_sctpAdaptationIndication->is_value();
case SctpEvent::ALT_sctpSenderDryEvent:
return single_value.field_sctpSenderDryEvent->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Socket_API_Definitions.SctpEvent.");
}
}

SctpEvent SctpEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
SctpEvent ret_val;
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
ret_val.sctpAssocChange() = single_value.field_sctpAssocChange->valueof();
break;
case SctpEvent::ALT_sctpPeerAddrChange:
ret_val.sctpPeerAddrChange() = single_value.field_sctpPeerAddrChange->valueof();
break;
case SctpEvent::ALT_sctpSendFailed:
ret_val.sctpSendFailed() = single_value.field_sctpSendFailed->valueof();
break;
case SctpEvent::ALT_sctpRemoteError:
ret_val.sctpRemoteError() = single_value.field_sctpRemoteError->valueof();
break;
case SctpEvent::ALT_sctpShutDownEvent:
ret_val.sctpShutDownEvent() = single_value.field_sctpShutDownEvent->valueof();
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
ret_val.sctpPartialDeliveryEvent() = single_value.field_sctpPartialDeliveryEvent->valueof();
break;
case SctpEvent::ALT_sctpAdaptationIndication:
ret_val.sctpAdaptationIndication() = single_value.field_sctpAdaptationIndication->valueof();
break;
case SctpEvent::ALT_sctpSenderDryEvent:
ret_val.sctpSenderDryEvent() = single_value.field_sctpSenderDryEvent->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Socket_API_Definitions.SctpEvent.");
}
return ret_val;
}

SctpEvent_template& SctpEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Socket_API_Definitions.SctpEvent.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Socket_API_Definitions.SctpEvent.");
return value_list.list_value[list_index];
}
void SctpEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Socket_API_Definitions.SctpEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpEvent_template[list_length];
}

SctpAssocChange_template& SctpEvent_template::sctpAssocChange()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpAssocChange) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpAssocChange = new SctpAssocChange_template(ANY_VALUE);
else single_value.field_sctpAssocChange = new SctpAssocChange_template;
single_value.union_selection = SctpEvent::ALT_sctpAssocChange;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpAssocChange;
}

const SctpAssocChange_template& SctpEvent_template::sctpAssocChange() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpAssocChange in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpAssocChange) TTCN_error("Accessing non-selected field sctpAssocChange in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpAssocChange;
}

SctpPeerAddrChange_template& SctpEvent_template::sctpPeerAddrChange()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpPeerAddrChange) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpPeerAddrChange = new SctpPeerAddrChange_template(ANY_VALUE);
else single_value.field_sctpPeerAddrChange = new SctpPeerAddrChange_template;
single_value.union_selection = SctpEvent::ALT_sctpPeerAddrChange;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpPeerAddrChange;
}

const SctpPeerAddrChange_template& SctpEvent_template::sctpPeerAddrChange() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpPeerAddrChange in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpPeerAddrChange) TTCN_error("Accessing non-selected field sctpPeerAddrChange in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpPeerAddrChange;
}

SctpSendFailed_template& SctpEvent_template::sctpSendFailed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpSendFailed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpSendFailed = new SctpSendFailed_template(ANY_VALUE);
else single_value.field_sctpSendFailed = new SctpSendFailed_template;
single_value.union_selection = SctpEvent::ALT_sctpSendFailed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpSendFailed;
}

const SctpSendFailed_template& SctpEvent_template::sctpSendFailed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpSendFailed in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpSendFailed) TTCN_error("Accessing non-selected field sctpSendFailed in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpSendFailed;
}

SctpRemoteError_template& SctpEvent_template::sctpRemoteError()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpRemoteError) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpRemoteError = new SctpRemoteError_template(ANY_VALUE);
else single_value.field_sctpRemoteError = new SctpRemoteError_template;
single_value.union_selection = SctpEvent::ALT_sctpRemoteError;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpRemoteError;
}

const SctpRemoteError_template& SctpEvent_template::sctpRemoteError() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpRemoteError in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpRemoteError) TTCN_error("Accessing non-selected field sctpRemoteError in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpRemoteError;
}

SctpShutDownEvent_template& SctpEvent_template::sctpShutDownEvent()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpShutDownEvent) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpShutDownEvent = new SctpShutDownEvent_template(ANY_VALUE);
else single_value.field_sctpShutDownEvent = new SctpShutDownEvent_template;
single_value.union_selection = SctpEvent::ALT_sctpShutDownEvent;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpShutDownEvent;
}

const SctpShutDownEvent_template& SctpEvent_template::sctpShutDownEvent() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpShutDownEvent in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpShutDownEvent) TTCN_error("Accessing non-selected field sctpShutDownEvent in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpShutDownEvent;
}

SctpPartialDeliveryEvent_template& SctpEvent_template::sctpPartialDeliveryEvent()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpPartialDeliveryEvent) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent_template(ANY_VALUE);
else single_value.field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent_template;
single_value.union_selection = SctpEvent::ALT_sctpPartialDeliveryEvent;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpPartialDeliveryEvent;
}

const SctpPartialDeliveryEvent_template& SctpEvent_template::sctpPartialDeliveryEvent() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpPartialDeliveryEvent in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpPartialDeliveryEvent) TTCN_error("Accessing non-selected field sctpPartialDeliveryEvent in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpPartialDeliveryEvent;
}

SctpAdaptationIndication_template& SctpEvent_template::sctpAdaptationIndication()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpAdaptationIndication) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpAdaptationIndication = new SctpAdaptationIndication_template(ANY_VALUE);
else single_value.field_sctpAdaptationIndication = new SctpAdaptationIndication_template;
single_value.union_selection = SctpEvent::ALT_sctpAdaptationIndication;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpAdaptationIndication;
}

const SctpAdaptationIndication_template& SctpEvent_template::sctpAdaptationIndication() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpAdaptationIndication in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpAdaptationIndication) TTCN_error("Accessing non-selected field sctpAdaptationIndication in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpAdaptationIndication;
}

SctpSenderDryEvent_template& SctpEvent_template::sctpSenderDryEvent()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SctpEvent::ALT_sctpSenderDryEvent) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpSenderDryEvent = new SctpSenderDryEvent_template(ANY_VALUE);
else single_value.field_sctpSenderDryEvent = new SctpSenderDryEvent_template;
single_value.union_selection = SctpEvent::ALT_sctpSenderDryEvent;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpSenderDryEvent;
}

const SctpSenderDryEvent_template& SctpEvent_template::sctpSenderDryEvent() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpSenderDryEvent in a non-specific template of union type @Socket_API_Definitions.SctpEvent.");
if (single_value.union_selection != SctpEvent::ALT_sctpSenderDryEvent) TTCN_error("Accessing non-selected field sctpSenderDryEvent in a template of union type @Socket_API_Definitions.SctpEvent.");
return *single_value.field_sctpSenderDryEvent;
}

boolean SctpEvent_template::ischosen(SctpEvent::union_selection_type checked_selection) const
{
if (checked_selection == SctpEvent::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.SctpEvent.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SctpEvent::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Socket_API_Definitions.SctpEvent.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Socket_API_Definitions.SctpEvent containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Socket_API_Definitions.SctpEvent, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Socket_API_Definitions.SctpEvent");
}
return FALSE;
}

void SctpEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
TTCN_Logger::log_event_str("{ sctpAssocChange := ");
single_value.field_sctpAssocChange->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpPeerAddrChange:
TTCN_Logger::log_event_str("{ sctpPeerAddrChange := ");
single_value.field_sctpPeerAddrChange->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpSendFailed:
TTCN_Logger::log_event_str("{ sctpSendFailed := ");
single_value.field_sctpSendFailed->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpRemoteError:
TTCN_Logger::log_event_str("{ sctpRemoteError := ");
single_value.field_sctpRemoteError->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpShutDownEvent:
TTCN_Logger::log_event_str("{ sctpShutDownEvent := ");
single_value.field_sctpShutDownEvent->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
TTCN_Logger::log_event_str("{ sctpPartialDeliveryEvent := ");
single_value.field_sctpPartialDeliveryEvent->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpAdaptationIndication:
TTCN_Logger::log_event_str("{ sctpAdaptationIndication := ");
single_value.field_sctpAdaptationIndication->log();
TTCN_Logger::log_event_str(" }");
break;
case SctpEvent::ALT_sctpSenderDryEvent:
TTCN_Logger::log_event_str("{ sctpSenderDryEvent := ");
single_value.field_sctpSenderDryEvent->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpEvent_template::log_match(const SctpEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpAssocChange");
single_value.field_sctpAssocChange->log_match(match_value.sctpAssocChange(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpAssocChange := ");
single_value.field_sctpAssocChange->log_match(match_value.sctpAssocChange(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpPeerAddrChange:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpPeerAddrChange");
single_value.field_sctpPeerAddrChange->log_match(match_value.sctpPeerAddrChange(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpPeerAddrChange := ");
single_value.field_sctpPeerAddrChange->log_match(match_value.sctpPeerAddrChange(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpSendFailed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpSendFailed");
single_value.field_sctpSendFailed->log_match(match_value.sctpSendFailed(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpSendFailed := ");
single_value.field_sctpSendFailed->log_match(match_value.sctpSendFailed(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpRemoteError:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpRemoteError");
single_value.field_sctpRemoteError->log_match(match_value.sctpRemoteError(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpRemoteError := ");
single_value.field_sctpRemoteError->log_match(match_value.sctpRemoteError(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpShutDownEvent:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpShutDownEvent");
single_value.field_sctpShutDownEvent->log_match(match_value.sctpShutDownEvent(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpShutDownEvent := ");
single_value.field_sctpShutDownEvent->log_match(match_value.sctpShutDownEvent(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpPartialDeliveryEvent");
single_value.field_sctpPartialDeliveryEvent->log_match(match_value.sctpPartialDeliveryEvent(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpPartialDeliveryEvent := ");
single_value.field_sctpPartialDeliveryEvent->log_match(match_value.sctpPartialDeliveryEvent(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpAdaptationIndication:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpAdaptationIndication");
single_value.field_sctpAdaptationIndication->log_match(match_value.sctpAdaptationIndication(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpAdaptationIndication := ");
single_value.field_sctpAdaptationIndication->log_match(match_value.sctpAdaptationIndication(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SctpEvent::ALT_sctpSenderDryEvent:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpSenderDryEvent");
single_value.field_sctpSenderDryEvent->log_match(match_value.sctpSenderDryEvent(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpSenderDryEvent := ");
single_value.field_sctpSenderDryEvent->log_match(match_value.sctpSenderDryEvent(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
single_value.field_sctpAssocChange->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpPeerAddrChange:
single_value.field_sctpPeerAddrChange->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpSendFailed:
single_value.field_sctpSendFailed->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpRemoteError:
single_value.field_sctpRemoteError->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpShutDownEvent:
single_value.field_sctpShutDownEvent->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
single_value.field_sctpPartialDeliveryEvent->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpAdaptationIndication:
single_value.field_sctpAdaptationIndication->encode_text(text_buf);
break;
case SctpEvent::ALT_sctpSenderDryEvent:
single_value.field_sctpSenderDryEvent->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Socket_API_Definitions.SctpEvent.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Socket_API_Definitions.SctpEvent.");
}
}

void SctpEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SctpEvent::UNBOUND_VALUE;
SctpEvent::union_selection_type new_selection = (SctpEvent::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SctpEvent::ALT_sctpAssocChange:
single_value.field_sctpAssocChange = new SctpAssocChange_template;
single_value.field_sctpAssocChange->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpPeerAddrChange:
single_value.field_sctpPeerAddrChange = new SctpPeerAddrChange_template;
single_value.field_sctpPeerAddrChange->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpSendFailed:
single_value.field_sctpSendFailed = new SctpSendFailed_template;
single_value.field_sctpSendFailed->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpRemoteError:
single_value.field_sctpRemoteError = new SctpRemoteError_template;
single_value.field_sctpRemoteError->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpShutDownEvent:
single_value.field_sctpShutDownEvent = new SctpShutDownEvent_template;
single_value.field_sctpShutDownEvent->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
single_value.field_sctpPartialDeliveryEvent = new SctpPartialDeliveryEvent_template;
single_value.field_sctpPartialDeliveryEvent->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpAdaptationIndication:
single_value.field_sctpAdaptationIndication = new SctpAdaptationIndication_template;
single_value.field_sctpAdaptationIndication->decode_text(text_buf);
break;
case SctpEvent::ALT_sctpSenderDryEvent:
single_value.field_sctpSenderDryEvent = new SctpSenderDryEvent_template;
single_value.field_sctpSenderDryEvent->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Socket_API_Definitions.SctpEvent.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Socket_API_Definitions.SctpEvent.");
}
}

boolean SctpEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SctpEvent_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Socket_API_Definitions.SctpEvent'");
    }
    if (strcmp("sctpAssocChange", param_field) == 0) {
      sctpAssocChange().set_param(param);
      return;
    } else if (strcmp("sctpPeerAddrChange", param_field) == 0) {
      sctpPeerAddrChange().set_param(param);
      return;
    } else if (strcmp("sctpSendFailed", param_field) == 0) {
      sctpSendFailed().set_param(param);
      return;
    } else if (strcmp("sctpRemoteError", param_field) == 0) {
      sctpRemoteError().set_param(param);
      return;
    } else if (strcmp("sctpShutDownEvent", param_field) == 0) {
      sctpShutDownEvent().set_param(param);
      return;
    } else if (strcmp("sctpPartialDeliveryEvent", param_field) == 0) {
      sctpPartialDeliveryEvent().set_param(param);
      return;
    } else if (strcmp("sctpAdaptationIndication", param_field) == 0) {
      sctpAdaptationIndication().set_param(param);
      return;
    } else if (strcmp("sctpSenderDryEvent", param_field) == 0) {
      sctpSenderDryEvent().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Socket_API_Definitions.SctpEvent'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpEvent_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Socket_API_Definitions.SctpEvent");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "sctpAssocChange")) {
      sctpAssocChange().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpPeerAddrChange")) {
      sctpPeerAddrChange().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpSendFailed")) {
      sctpSendFailed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpRemoteError")) {
      sctpRemoteError().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpShutDownEvent")) {
      sctpShutDownEvent().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpPartialDeliveryEvent")) {
      sctpPartialDeliveryEvent().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpAdaptationIndication")) {
      sctpAdaptationIndication().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpSenderDryEvent")) {
      sctpSenderDryEvent().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Socket_API_Definitions.SctpEvent.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Socket_API_Definitions.SctpEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SctpEvent::ALT_sctpAssocChange:
single_value.field_sctpAssocChange->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpPeerAddrChange:
single_value.field_sctpPeerAddrChange->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpSendFailed:
single_value.field_sctpSendFailed->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpRemoteError:
single_value.field_sctpRemoteError->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpShutDownEvent:
single_value.field_sctpShutDownEvent->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpPartialDeliveryEvent:
single_value.field_sctpPartialDeliveryEvent->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpAdaptationIndication:
single_value.field_sctpAdaptationIndication->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
case SctpEvent::ALT_sctpSenderDryEvent:
single_value.field_sctpSenderDryEvent->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Socket_API_Definitions.SctpEvent.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpEvent");
}

SAC__STATE::SAC__STATE()
{
enum_value = UNBOUND_VALUE;
}

SAC__STATE::SAC__STATE(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @Socket_API_Definitions.SAC_STATE with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SAC__STATE::SAC__STATE(enum_type other_value)
{
enum_value = other_value;
}

SAC__STATE::SAC__STATE(const SAC__STATE& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
enum_value = other_value.enum_value;
}

SAC__STATE& SAC__STATE::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @Socket_API_Definitions.SAC_STATE.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SAC__STATE& SAC__STATE::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SAC__STATE& SAC__STATE::operator=(const SAC__STATE& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
enum_value = other_value.enum_value;
return *this;
}

boolean SAC__STATE::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value == other_value;
}

boolean SAC__STATE::operator==(const SAC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value == other_value.enum_value;
}

boolean SAC__STATE::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value < other_value;
}

boolean SAC__STATE::operator<(const SAC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value < other_value.enum_value;
}

boolean SAC__STATE::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value > other_value;
}

boolean SAC__STATE::operator>(const SAC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value > other_value.enum_value;
}

const char *SAC__STATE::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case SCTP__COMM__UP: return "SCTP_COMM_UP";
case SCTP__COMM__LOST: return "SCTP_COMM_LOST";
case SCTP__RESTART: return "SCTP_RESTART";
case SCTP__SHUTDOWN__COMP: return "SCTP_SHUTDOWN_COMP";
case SCTP__CANT__STR__ASSOC: return "SCTP_CANT_STR_ASSOC";
case SCTP__UNKNOWN__SAC__STATE: return "SCTP_UNKNOWN_SAC_STATE";
default: return "<unknown>";
}
}

SAC__STATE::enum_type SAC__STATE::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "SCTP_COMM_UP")) return SCTP__COMM__UP;
else if (!strcmp(str_par, "SCTP_COMM_LOST")) return SCTP__COMM__LOST;
else if (!strcmp(str_par, "SCTP_RESTART")) return SCTP__RESTART;
else if (!strcmp(str_par, "SCTP_SHUTDOWN_COMP")) return SCTP__SHUTDOWN__COMP;
else if (!strcmp(str_par, "SCTP_CANT_STR_ASSOC")) return SCTP__CANT__STR__ASSOC;
else if (!strcmp(str_par, "SCTP_UNKNOWN_SAC_STATE")) return SCTP__UNKNOWN__SAC__STATE;
else return UNKNOWN_VALUE;
}

boolean SAC__STATE::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
return TRUE;
default:
return FALSE;
}
}

int SAC__STATE::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.SAC_STATE.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SAC__STATE::enum2int(const SAC__STATE& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.SAC_STATE.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SAC__STATE::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @Socket_API_Definitions.SAC_STATE.", int_val);
enum_value = (enum_type)int_val;
}

SAC__STATE::operator SAC__STATE::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @Socket_API_Definitions.SAC_STATE.");
return enum_value;
}

void SAC__STATE::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SAC__STATE::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@Socket_API_Definitions.SAC_STATE");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @Socket_API_Definitions.SAC_STATE.");
  }
}

void SAC__STATE::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
text_buf.push_int(enum_value);
}

void SAC__STATE::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @Socket_API_Definitions.SAC_STATE.", enum_value);
}

void SAC__STATE_template::copy_template(const SAC__STATE_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SAC__STATE_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SAC_STATE.");
}
}

SAC__STATE_template::SAC__STATE_template()
{
}

SAC__STATE_template::SAC__STATE_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SAC__STATE_template::SAC__STATE_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SAC__STATE::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @Socket_API_Definitions.SAC_STATE with unknown numeric value %d.", other_value);
single_value = (SAC__STATE::enum_type)other_value;
}

SAC__STATE_template::SAC__STATE_template(SAC__STATE::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SAC__STATE_template::SAC__STATE_template(const SAC__STATE& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SAC__STATE::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE.");
single_value = other_value.enum_value;
}

SAC__STATE_template::SAC__STATE_template(const OPTIONAL<SAC__STATE>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SAC__STATE::enum_type)(const SAC__STATE&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @Socket_API_Definitions.SAC_STATE from an unbound optional field.");
}
}

SAC__STATE_template::SAC__STATE_template(const SAC__STATE_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SAC__STATE_template::~SAC__STATE_template()
{
clean_up();
}

boolean SAC__STATE_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SAC__STATE_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SAC__STATE::UNBOUND_VALUE;
}

void SAC__STATE_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SAC__STATE_template& SAC__STATE_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SAC__STATE_template& SAC__STATE_template::operator=(int other_value)
{
if (!SAC__STATE::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @Socket_API_Definitions.SAC_STATE.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SAC__STATE::enum_type)other_value;
return *this;
}

SAC__STATE_template& SAC__STATE_template::operator=(SAC__STATE::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SAC__STATE_template& SAC__STATE_template::operator=(const SAC__STATE& other_value)
{
if (other_value.enum_value == SAC__STATE::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.SAC_STATE to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SAC__STATE_template& SAC__STATE_template::operator=(const OPTIONAL<SAC__STATE>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SAC__STATE::enum_type)(const SAC__STATE&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @Socket_API_Definitions.SAC_STATE.");
}
return *this;
}

SAC__STATE_template& SAC__STATE_template::operator=(const SAC__STATE_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SAC__STATE_template::match(SAC__STATE::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SAC_STATE.");
}
return FALSE;
}

boolean SAC__STATE_template::match(const SAC__STATE& other_value, boolean) const
{
if (other_value.enum_value == SAC__STATE::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @Socket_API_Definitions.SAC_STATE with an unbound value.");
return match(other_value.enum_value);
}

SAC__STATE::enum_type SAC__STATE_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @Socket_API_Definitions.SAC_STATE.");
return single_value;
}

void SAC__STATE_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @Socket_API_Definitions.SAC_STATE.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SAC__STATE_template[list_length];
}

SAC__STATE_template& SAC__STATE_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @Socket_API_Definitions.SAC_STATE.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @Socket_API_Definitions.SAC_STATE.");
return value_list.list_value[list_index];
}

void SAC__STATE_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SAC__STATE::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SAC__STATE_template::log_match(const SAC__STATE& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SAC__STATE_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SAC_STATE.");
}
}

void SAC__STATE_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SAC__STATE::enum_type)text_buf.pull_int().get_val();
if (!SAC__STATE::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @Socket_API_Definitions.SAC_STATE.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SAC__STATE_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @Socket_API_Definitions.SAC_STATE.");
}
}

boolean SAC__STATE_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SAC__STATE_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SAC__STATE_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SAC__STATE_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SAC__STATE::enum_type enum_val = SAC__STATE::str_to_enum(m_p->get_enumerated());
    if (!SAC__STATE::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @Socket_API_Definitions.SAC_STATE.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@Socket_API_Definitions.SAC_STATE");
  }
  is_ifpresent = param.get_ifpresent();
}

void SAC__STATE_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SAC_STATE");
}

SctpAssocChange::SctpAssocChange()
{
}

SctpAssocChange::SctpAssocChange(const INTEGER& par_clientId,
    const ProtoTuple& par_proto,
    const SAC__STATE& par_sac__state)
  :   field_clientId(par_clientId),
  field_proto(par_proto),
  field_sac__state(par_sac__state)
{
}

SctpAssocChange::SctpAssocChange(const SctpAssocChange& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpAssocChange.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.sac__state().is_bound()) field_sac__state = other_value.sac__state();
else field_sac__state.clean_up();
}

void SctpAssocChange::clean_up()
{
field_clientId.clean_up();
field_proto.clean_up();
field_sac__state.clean_up();
}

SctpAssocChange& SctpAssocChange::operator=(const SctpAssocChange& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpAssocChange.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.sac__state().is_bound()) field_sac__state = other_value.sac__state();
  else field_sac__state.clean_up();
}
return *this;
}

boolean SctpAssocChange::operator==(const SctpAssocChange& other_value) const
{
return field_clientId==other_value.field_clientId
  && field_proto==other_value.field_proto
  && field_sac__state==other_value.field_sac__state;
}

boolean SctpAssocChange::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
if(field_proto.is_bound()) return TRUE;
if(field_sac__state.is_bound()) return TRUE;
return FALSE;
}
boolean SctpAssocChange::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
if(!field_proto.is_value()) return FALSE;
if(!field_sac__state.is_value()) return FALSE;
return TRUE;
}
void SctpAssocChange::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", sac_state := ");
field_sac__state.log();
TTCN_Logger::log_event_str(" }");
}

void SctpAssocChange::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpAssocChange has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sac__state().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sac_state")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sac__state().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpAssocChange: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpAssocChange");
  }
}

void SctpAssocChange::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
if (proto().is_bound()) proto().set_implicit_omit();
if (sac__state().is_bound()) sac__state().set_implicit_omit();
}

void SctpAssocChange::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_sac__state.encode_text(text_buf);
}

void SctpAssocChange::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_sac__state.decode_text(text_buf);
}

struct SctpAssocChange_template::single_value_struct {
INTEGER_template field_clientId;
ProtoTuple_template field_proto;
SAC__STATE_template field_sac__state;
};

void SctpAssocChange_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
single_value->field_proto = ANY_VALUE;
single_value->field_sac__state = ANY_VALUE;
}
}
}

void SctpAssocChange_template::copy_value(const SctpAssocChange& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
if (other_value.proto().is_bound()) {
  single_value->field_proto = other_value.proto();
} else {
  single_value->field_proto.clean_up();
}
if (other_value.sac__state().is_bound()) {
  single_value->field_sac__state = other_value.sac__state();
} else {
  single_value->field_sac__state.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpAssocChange_template::copy_template(const SctpAssocChange_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sac__state().get_selection()) {
single_value->field_sac__state = other_value.sac__state();
} else {
single_value->field_sac__state.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpAssocChange_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAssocChange.");
break;
}
set_selection(other_value);
}

SctpAssocChange_template::SctpAssocChange_template()
{
}

SctpAssocChange_template::SctpAssocChange_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpAssocChange_template::SctpAssocChange_template(const SctpAssocChange& other_value)
{
copy_value(other_value);
}

SctpAssocChange_template::SctpAssocChange_template(const OPTIONAL<SctpAssocChange>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpAssocChange&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpAssocChange from an unbound optional field.");
}
}

SctpAssocChange_template::SctpAssocChange_template(const SctpAssocChange_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpAssocChange_template::~SctpAssocChange_template()
{
clean_up();
}

SctpAssocChange_template& SctpAssocChange_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpAssocChange_template& SctpAssocChange_template::operator=(const SctpAssocChange& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpAssocChange_template& SctpAssocChange_template::operator=(const OPTIONAL<SctpAssocChange>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpAssocChange&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpAssocChange.");
}
return *this;
}

SctpAssocChange_template& SctpAssocChange_template::operator=(const SctpAssocChange_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpAssocChange_template::match(const SctpAssocChange& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if(!single_value->field_proto.match(other_value.proto(), legacy))return FALSE;
if(!other_value.sac__state().is_bound()) return FALSE;
if(!single_value->field_sac__state.match(other_value.sac__state(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAssocChange.");
}
return FALSE;
}

boolean SctpAssocChange_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
if (single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_sac__state.is_bound()) return TRUE;
return FALSE;
}

boolean SctpAssocChange_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
if (!single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_sac__state.is_value()) return FALSE;
return TRUE;
}

void SctpAssocChange_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpAssocChange SctpAssocChange_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpAssocChange.");
SctpAssocChange ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_sac__state.is_bound()) {
ret_val.sac__state() = single_value->field_sac__state.valueof();
}
return ret_val;
}

void SctpAssocChange_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpAssocChange.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpAssocChange_template[list_length];
}

SctpAssocChange_template& SctpAssocChange_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpAssocChange.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpAssocChange.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpAssocChange_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpAssocChange_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpAssocChange.");
return single_value->field_clientId;
}

ProtoTuple_template& SctpAssocChange_template::proto()
{
set_specific();
return single_value->field_proto;
}

const ProtoTuple_template& SctpAssocChange_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @Socket_API_Definitions.SctpAssocChange.");
return single_value->field_proto;
}

SAC__STATE_template& SctpAssocChange_template::sac__state()
{
set_specific();
return single_value->field_sac__state;
}

const SAC__STATE_template& SctpAssocChange_template::sac__state() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sac_state of a non-specific template of type @Socket_API_Definitions.SctpAssocChange.");
return single_value->field_sac__state;
}

int SctpAssocChange_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAssocChange containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAssocChange.");
  }
  return 0;
}

void SctpAssocChange_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", sac_state := ");
single_value->field_sac__state.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpAssocChange_template::log_match(const SctpAssocChange& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sac__state.match(match_value.sac__state(), legacy)){
TTCN_Logger::log_logmatch_info(".sac_state");
single_value->field_sac__state.log_match(match_value.sac__state(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::log_event_str(", sac_state := ");
single_value->field_sac__state.log_match(match_value.sac__state(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpAssocChange_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_sac__state.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAssocChange.");
}
}

void SctpAssocChange_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_sac__state.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpAssocChange_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpAssocChange.");
}
}

void SctpAssocChange_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpAssocChange_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpAssocChange has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sac__state().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sac_state")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sac__state().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpAssocChange: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpAssocChange");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpAssocChange_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpAssocChange");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpAssocChange");
single_value->field_sac__state.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpAssocChange");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpAssocChange");
}

boolean SctpAssocChange_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpAssocChange_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SPC__STATE::SPC__STATE()
{
enum_value = UNBOUND_VALUE;
}

SPC__STATE::SPC__STATE(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @Socket_API_Definitions.SPC_STATE with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SPC__STATE::SPC__STATE(enum_type other_value)
{
enum_value = other_value;
}

SPC__STATE::SPC__STATE(const SPC__STATE& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
enum_value = other_value.enum_value;
}

SPC__STATE& SPC__STATE::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @Socket_API_Definitions.SPC_STATE.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SPC__STATE& SPC__STATE::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SPC__STATE& SPC__STATE::operator=(const SPC__STATE& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
enum_value = other_value.enum_value;
return *this;
}

boolean SPC__STATE::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value == other_value;
}

boolean SPC__STATE::operator==(const SPC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value == other_value.enum_value;
}

boolean SPC__STATE::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value < other_value;
}

boolean SPC__STATE::operator<(const SPC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value < other_value.enum_value;
}

boolean SPC__STATE::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value > other_value;
}

boolean SPC__STATE::operator>(const SPC__STATE& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value > other_value.enum_value;
}

const char *SPC__STATE::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case SCTP__ADDR__AVAILABLE: return "SCTP_ADDR_AVAILABLE";
case SCTP__ADDR__UNREACHABLE: return "SCTP_ADDR_UNREACHABLE";
case SCTP__ADDR__REMOVED: return "SCTP_ADDR_REMOVED";
case SCTP__ADDR__ADDED: return "SCTP_ADDR_ADDED";
case SCTP__ADDR__MADE__PRIM: return "SCTP_ADDR_MADE_PRIM";
case SCTP__ADDR__CONFIRMED: return "SCTP_ADDR_CONFIRMED";
case SCTP__UNKNOWN__SPC__STATE: return "SCTP_UNKNOWN_SPC_STATE";
default: return "<unknown>";
}
}

SPC__STATE::enum_type SPC__STATE::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "SCTP_ADDR_AVAILABLE")) return SCTP__ADDR__AVAILABLE;
else if (!strcmp(str_par, "SCTP_ADDR_UNREACHABLE")) return SCTP__ADDR__UNREACHABLE;
else if (!strcmp(str_par, "SCTP_ADDR_REMOVED")) return SCTP__ADDR__REMOVED;
else if (!strcmp(str_par, "SCTP_ADDR_ADDED")) return SCTP__ADDR__ADDED;
else if (!strcmp(str_par, "SCTP_ADDR_MADE_PRIM")) return SCTP__ADDR__MADE__PRIM;
else if (!strcmp(str_par, "SCTP_ADDR_CONFIRMED")) return SCTP__ADDR__CONFIRMED;
else if (!strcmp(str_par, "SCTP_UNKNOWN_SPC_STATE")) return SCTP__UNKNOWN__SPC__STATE;
else return UNKNOWN_VALUE;
}

boolean SPC__STATE::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
return TRUE;
default:
return FALSE;
}
}

int SPC__STATE::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.SPC_STATE.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SPC__STATE::enum2int(const SPC__STATE& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @Socket_API_Definitions.SPC_STATE.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SPC__STATE::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @Socket_API_Definitions.SPC_STATE.", int_val);
enum_value = (enum_type)int_val;
}

SPC__STATE::operator SPC__STATE::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @Socket_API_Definitions.SPC_STATE.");
return enum_value;
}

void SPC__STATE::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SPC__STATE::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@Socket_API_Definitions.SPC_STATE");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @Socket_API_Definitions.SPC_STATE.");
  }
}

void SPC__STATE::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
text_buf.push_int(enum_value);
}

void SPC__STATE::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @Socket_API_Definitions.SPC_STATE.", enum_value);
}

void SPC__STATE_template::copy_template(const SPC__STATE_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SPC__STATE_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SPC_STATE.");
}
}

SPC__STATE_template::SPC__STATE_template()
{
}

SPC__STATE_template::SPC__STATE_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SPC__STATE_template::SPC__STATE_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SPC__STATE::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @Socket_API_Definitions.SPC_STATE with unknown numeric value %d.", other_value);
single_value = (SPC__STATE::enum_type)other_value;
}

SPC__STATE_template::SPC__STATE_template(SPC__STATE::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SPC__STATE_template::SPC__STATE_template(const SPC__STATE& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SPC__STATE::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE.");
single_value = other_value.enum_value;
}

SPC__STATE_template::SPC__STATE_template(const OPTIONAL<SPC__STATE>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SPC__STATE::enum_type)(const SPC__STATE&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @Socket_API_Definitions.SPC_STATE from an unbound optional field.");
}
}

SPC__STATE_template::SPC__STATE_template(const SPC__STATE_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SPC__STATE_template::~SPC__STATE_template()
{
clean_up();
}

boolean SPC__STATE_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SPC__STATE_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SPC__STATE::UNBOUND_VALUE;
}

void SPC__STATE_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SPC__STATE_template& SPC__STATE_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SPC__STATE_template& SPC__STATE_template::operator=(int other_value)
{
if (!SPC__STATE::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @Socket_API_Definitions.SPC_STATE.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SPC__STATE::enum_type)other_value;
return *this;
}

SPC__STATE_template& SPC__STATE_template::operator=(SPC__STATE::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SPC__STATE_template& SPC__STATE_template::operator=(const SPC__STATE& other_value)
{
if (other_value.enum_value == SPC__STATE::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @Socket_API_Definitions.SPC_STATE to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SPC__STATE_template& SPC__STATE_template::operator=(const OPTIONAL<SPC__STATE>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SPC__STATE::enum_type)(const SPC__STATE&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @Socket_API_Definitions.SPC_STATE.");
}
return *this;
}

SPC__STATE_template& SPC__STATE_template::operator=(const SPC__STATE_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SPC__STATE_template::match(SPC__STATE::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SPC_STATE.");
}
return FALSE;
}

boolean SPC__STATE_template::match(const SPC__STATE& other_value, boolean) const
{
if (other_value.enum_value == SPC__STATE::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @Socket_API_Definitions.SPC_STATE with an unbound value.");
return match(other_value.enum_value);
}

SPC__STATE::enum_type SPC__STATE_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @Socket_API_Definitions.SPC_STATE.");
return single_value;
}

void SPC__STATE_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @Socket_API_Definitions.SPC_STATE.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SPC__STATE_template[list_length];
}

SPC__STATE_template& SPC__STATE_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @Socket_API_Definitions.SPC_STATE.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @Socket_API_Definitions.SPC_STATE.");
return value_list.list_value[list_index];
}

void SPC__STATE_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SPC__STATE::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SPC__STATE_template::log_match(const SPC__STATE& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SPC__STATE_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @Socket_API_Definitions.SPC_STATE.");
}
}

void SPC__STATE_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SPC__STATE::enum_type)text_buf.pull_int().get_val();
if (!SPC__STATE::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @Socket_API_Definitions.SPC_STATE.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SPC__STATE_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @Socket_API_Definitions.SPC_STATE.");
}
}

boolean SPC__STATE_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SPC__STATE_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SPC__STATE_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SPC__STATE_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SPC__STATE::enum_type enum_val = SPC__STATE::str_to_enum(m_p->get_enumerated());
    if (!SPC__STATE::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @Socket_API_Definitions.SPC_STATE.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@Socket_API_Definitions.SPC_STATE");
  }
  is_ifpresent = param.get_ifpresent();
}

void SPC__STATE_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SPC_STATE");
}

SctpPeerAddrChange::SctpPeerAddrChange()
{
}

SctpPeerAddrChange::SctpPeerAddrChange(const INTEGER& par_clientId,
    const SPC__STATE& par_spc__state)
  :   field_clientId(par_clientId),
  field_spc__state(par_spc__state)
{
}

SctpPeerAddrChange::SctpPeerAddrChange(const SctpPeerAddrChange& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpPeerAddrChange.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
if (other_value.spc__state().is_bound()) field_spc__state = other_value.spc__state();
else field_spc__state.clean_up();
}

void SctpPeerAddrChange::clean_up()
{
field_clientId.clean_up();
field_spc__state.clean_up();
}

SctpPeerAddrChange& SctpPeerAddrChange::operator=(const SctpPeerAddrChange& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpPeerAddrChange.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
  if (other_value.spc__state().is_bound()) field_spc__state = other_value.spc__state();
  else field_spc__state.clean_up();
}
return *this;
}

boolean SctpPeerAddrChange::operator==(const SctpPeerAddrChange& other_value) const
{
return field_clientId==other_value.field_clientId
  && field_spc__state==other_value.field_spc__state;
}

boolean SctpPeerAddrChange::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
if(field_spc__state.is_bound()) return TRUE;
return FALSE;
}
boolean SctpPeerAddrChange::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
if(!field_spc__state.is_value()) return FALSE;
return TRUE;
}
void SctpPeerAddrChange::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(", spc_state := ");
field_spc__state.log();
TTCN_Logger::log_event_str(" }");
}

void SctpPeerAddrChange::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpPeerAddrChange has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spc__state().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spc_state")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spc__state().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpPeerAddrChange: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpPeerAddrChange");
  }
}

void SctpPeerAddrChange::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
if (spc__state().is_bound()) spc__state().set_implicit_omit();
}

void SctpPeerAddrChange::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
field_spc__state.encode_text(text_buf);
}

void SctpPeerAddrChange::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
field_spc__state.decode_text(text_buf);
}

struct SctpPeerAddrChange_template::single_value_struct {
INTEGER_template field_clientId;
SPC__STATE_template field_spc__state;
};

void SctpPeerAddrChange_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
single_value->field_spc__state = ANY_VALUE;
}
}
}

void SctpPeerAddrChange_template::copy_value(const SctpPeerAddrChange& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
if (other_value.spc__state().is_bound()) {
  single_value->field_spc__state = other_value.spc__state();
} else {
  single_value->field_spc__state.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpPeerAddrChange_template::copy_template(const SctpPeerAddrChange_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.spc__state().get_selection()) {
single_value->field_spc__state = other_value.spc__state();
} else {
single_value->field_spc__state.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpPeerAddrChange_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPeerAddrChange.");
break;
}
set_selection(other_value);
}

SctpPeerAddrChange_template::SctpPeerAddrChange_template()
{
}

SctpPeerAddrChange_template::SctpPeerAddrChange_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpPeerAddrChange_template::SctpPeerAddrChange_template(const SctpPeerAddrChange& other_value)
{
copy_value(other_value);
}

SctpPeerAddrChange_template::SctpPeerAddrChange_template(const OPTIONAL<SctpPeerAddrChange>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpPeerAddrChange&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpPeerAddrChange from an unbound optional field.");
}
}

SctpPeerAddrChange_template::SctpPeerAddrChange_template(const SctpPeerAddrChange_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpPeerAddrChange_template::~SctpPeerAddrChange_template()
{
clean_up();
}

SctpPeerAddrChange_template& SctpPeerAddrChange_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpPeerAddrChange_template& SctpPeerAddrChange_template::operator=(const SctpPeerAddrChange& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpPeerAddrChange_template& SctpPeerAddrChange_template::operator=(const OPTIONAL<SctpPeerAddrChange>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpPeerAddrChange&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpPeerAddrChange.");
}
return *this;
}

SctpPeerAddrChange_template& SctpPeerAddrChange_template::operator=(const SctpPeerAddrChange_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpPeerAddrChange_template::match(const SctpPeerAddrChange& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
if(!other_value.spc__state().is_bound()) return FALSE;
if(!single_value->field_spc__state.match(other_value.spc__state(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPeerAddrChange.");
}
return FALSE;
}

boolean SctpPeerAddrChange_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
if (single_value->field_spc__state.is_bound()) return TRUE;
return FALSE;
}

boolean SctpPeerAddrChange_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
if (!single_value->field_spc__state.is_value()) return FALSE;
return TRUE;
}

void SctpPeerAddrChange_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpPeerAddrChange SctpPeerAddrChange_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpPeerAddrChange.");
SctpPeerAddrChange ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
if (single_value->field_spc__state.is_bound()) {
ret_val.spc__state() = single_value->field_spc__state.valueof();
}
return ret_val;
}

void SctpPeerAddrChange_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpPeerAddrChange.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpPeerAddrChange_template[list_length];
}

SctpPeerAddrChange_template& SctpPeerAddrChange_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpPeerAddrChange.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpPeerAddrChange.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpPeerAddrChange_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpPeerAddrChange_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpPeerAddrChange.");
return single_value->field_clientId;
}

SPC__STATE_template& SctpPeerAddrChange_template::spc__state()
{
set_specific();
return single_value->field_spc__state;
}

const SPC__STATE_template& SctpPeerAddrChange_template::spc__state() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field spc_state of a non-specific template of type @Socket_API_Definitions.SctpPeerAddrChange.");
return single_value->field_spc__state;
}

int SctpPeerAddrChange_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPeerAddrChange containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPeerAddrChange.");
  }
  return 0;
}

void SctpPeerAddrChange_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(", spc_state := ");
single_value->field_spc__state.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpPeerAddrChange_template::log_match(const SctpPeerAddrChange& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_spc__state.match(match_value.spc__state(), legacy)){
TTCN_Logger::log_logmatch_info(".spc_state");
single_value->field_spc__state.log_match(match_value.spc__state(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(", spc_state := ");
single_value->field_spc__state.log_match(match_value.spc__state(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpPeerAddrChange_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
single_value->field_spc__state.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPeerAddrChange.");
}
}

void SctpPeerAddrChange_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
single_value->field_spc__state.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpPeerAddrChange_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpPeerAddrChange.");
}
}

void SctpPeerAddrChange_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpPeerAddrChange_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpPeerAddrChange has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) spc__state().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "spc_state")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          spc__state().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpPeerAddrChange: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpPeerAddrChange");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpPeerAddrChange_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpPeerAddrChange");
single_value->field_spc__state.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpPeerAddrChange");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpPeerAddrChange");
}

boolean SctpPeerAddrChange_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpPeerAddrChange_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpSendFailed::SctpSendFailed()
{
}

SctpSendFailed::SctpSendFailed(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpSendFailed::SctpSendFailed(const SctpSendFailed& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpSendFailed.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpSendFailed::clean_up()
{
field_clientId.clean_up();
}

SctpSendFailed& SctpSendFailed::operator=(const SctpSendFailed& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpSendFailed.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpSendFailed::operator==(const SctpSendFailed& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpSendFailed::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpSendFailed::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpSendFailed::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpSendFailed::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpSendFailed has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpSendFailed: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpSendFailed");
  }
}

void SctpSendFailed::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpSendFailed::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpSendFailed::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpSendFailed_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpSendFailed_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpSendFailed_template::copy_value(const SctpSendFailed& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpSendFailed_template::copy_template(const SctpSendFailed_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpSendFailed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSendFailed.");
break;
}
set_selection(other_value);
}

SctpSendFailed_template::SctpSendFailed_template()
{
}

SctpSendFailed_template::SctpSendFailed_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpSendFailed_template::SctpSendFailed_template(const SctpSendFailed& other_value)
{
copy_value(other_value);
}

SctpSendFailed_template::SctpSendFailed_template(const OPTIONAL<SctpSendFailed>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpSendFailed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpSendFailed from an unbound optional field.");
}
}

SctpSendFailed_template::SctpSendFailed_template(const SctpSendFailed_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpSendFailed_template::~SctpSendFailed_template()
{
clean_up();
}

SctpSendFailed_template& SctpSendFailed_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpSendFailed_template& SctpSendFailed_template::operator=(const SctpSendFailed& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpSendFailed_template& SctpSendFailed_template::operator=(const OPTIONAL<SctpSendFailed>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpSendFailed&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpSendFailed.");
}
return *this;
}

SctpSendFailed_template& SctpSendFailed_template::operator=(const SctpSendFailed_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpSendFailed_template::match(const SctpSendFailed& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSendFailed.");
}
return FALSE;
}

boolean SctpSendFailed_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpSendFailed_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpSendFailed_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpSendFailed SctpSendFailed_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpSendFailed.");
SctpSendFailed ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpSendFailed_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpSendFailed.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpSendFailed_template[list_length];
}

SctpSendFailed_template& SctpSendFailed_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpSendFailed.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpSendFailed.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpSendFailed_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpSendFailed_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpSendFailed.");
return single_value->field_clientId;
}

int SctpSendFailed_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSendFailed containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSendFailed.");
  }
  return 0;
}

void SctpSendFailed_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpSendFailed_template::log_match(const SctpSendFailed& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpSendFailed_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSendFailed.");
}
}

void SctpSendFailed_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpSendFailed_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpSendFailed.");
}
}

void SctpSendFailed_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpSendFailed_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpSendFailed has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpSendFailed: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpSendFailed");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpSendFailed_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpSendFailed");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpSendFailed");
}

boolean SctpSendFailed_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpSendFailed_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpRemoteError::SctpRemoteError()
{
}

SctpRemoteError::SctpRemoteError(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpRemoteError::SctpRemoteError(const SctpRemoteError& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpRemoteError.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpRemoteError::clean_up()
{
field_clientId.clean_up();
}

SctpRemoteError& SctpRemoteError::operator=(const SctpRemoteError& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpRemoteError.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpRemoteError::operator==(const SctpRemoteError& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpRemoteError::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpRemoteError::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpRemoteError::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpRemoteError::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpRemoteError has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpRemoteError: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpRemoteError");
  }
}

void SctpRemoteError::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpRemoteError::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpRemoteError::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpRemoteError_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpRemoteError_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpRemoteError_template::copy_value(const SctpRemoteError& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpRemoteError_template::copy_template(const SctpRemoteError_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpRemoteError_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpRemoteError.");
break;
}
set_selection(other_value);
}

SctpRemoteError_template::SctpRemoteError_template()
{
}

SctpRemoteError_template::SctpRemoteError_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpRemoteError_template::SctpRemoteError_template(const SctpRemoteError& other_value)
{
copy_value(other_value);
}

SctpRemoteError_template::SctpRemoteError_template(const OPTIONAL<SctpRemoteError>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpRemoteError&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpRemoteError from an unbound optional field.");
}
}

SctpRemoteError_template::SctpRemoteError_template(const SctpRemoteError_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpRemoteError_template::~SctpRemoteError_template()
{
clean_up();
}

SctpRemoteError_template& SctpRemoteError_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpRemoteError_template& SctpRemoteError_template::operator=(const SctpRemoteError& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpRemoteError_template& SctpRemoteError_template::operator=(const OPTIONAL<SctpRemoteError>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpRemoteError&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpRemoteError.");
}
return *this;
}

SctpRemoteError_template& SctpRemoteError_template::operator=(const SctpRemoteError_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpRemoteError_template::match(const SctpRemoteError& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpRemoteError.");
}
return FALSE;
}

boolean SctpRemoteError_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpRemoteError_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpRemoteError_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpRemoteError SctpRemoteError_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpRemoteError.");
SctpRemoteError ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpRemoteError_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpRemoteError.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpRemoteError_template[list_length];
}

SctpRemoteError_template& SctpRemoteError_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpRemoteError.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpRemoteError.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpRemoteError_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpRemoteError_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpRemoteError.");
return single_value->field_clientId;
}

int SctpRemoteError_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpRemoteError containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpRemoteError.");
  }
  return 0;
}

void SctpRemoteError_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpRemoteError_template::log_match(const SctpRemoteError& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpRemoteError_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpRemoteError.");
}
}

void SctpRemoteError_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpRemoteError_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpRemoteError.");
}
}

void SctpRemoteError_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpRemoteError_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpRemoteError has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpRemoteError: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpRemoteError");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpRemoteError_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpRemoteError");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpRemoteError");
}

boolean SctpRemoteError_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpRemoteError_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpShutDownEvent::SctpShutDownEvent()
{
}

SctpShutDownEvent::SctpShutDownEvent(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpShutDownEvent::SctpShutDownEvent(const SctpShutDownEvent& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpShutDownEvent.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpShutDownEvent::clean_up()
{
field_clientId.clean_up();
}

SctpShutDownEvent& SctpShutDownEvent::operator=(const SctpShutDownEvent& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpShutDownEvent.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpShutDownEvent::operator==(const SctpShutDownEvent& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpShutDownEvent::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpShutDownEvent::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpShutDownEvent::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpShutDownEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpShutDownEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpShutDownEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpShutDownEvent");
  }
}

void SctpShutDownEvent::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpShutDownEvent::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpShutDownEvent::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpShutDownEvent_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpShutDownEvent_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpShutDownEvent_template::copy_value(const SctpShutDownEvent& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpShutDownEvent_template::copy_template(const SctpShutDownEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpShutDownEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpShutDownEvent.");
break;
}
set_selection(other_value);
}

SctpShutDownEvent_template::SctpShutDownEvent_template()
{
}

SctpShutDownEvent_template::SctpShutDownEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpShutDownEvent_template::SctpShutDownEvent_template(const SctpShutDownEvent& other_value)
{
copy_value(other_value);
}

SctpShutDownEvent_template::SctpShutDownEvent_template(const OPTIONAL<SctpShutDownEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpShutDownEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpShutDownEvent from an unbound optional field.");
}
}

SctpShutDownEvent_template::SctpShutDownEvent_template(const SctpShutDownEvent_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpShutDownEvent_template::~SctpShutDownEvent_template()
{
clean_up();
}

SctpShutDownEvent_template& SctpShutDownEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpShutDownEvent_template& SctpShutDownEvent_template::operator=(const SctpShutDownEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpShutDownEvent_template& SctpShutDownEvent_template::operator=(const OPTIONAL<SctpShutDownEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpShutDownEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpShutDownEvent.");
}
return *this;
}

SctpShutDownEvent_template& SctpShutDownEvent_template::operator=(const SctpShutDownEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpShutDownEvent_template::match(const SctpShutDownEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpShutDownEvent.");
}
return FALSE;
}

boolean SctpShutDownEvent_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpShutDownEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpShutDownEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpShutDownEvent SctpShutDownEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpShutDownEvent.");
SctpShutDownEvent ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpShutDownEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpShutDownEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpShutDownEvent_template[list_length];
}

SctpShutDownEvent_template& SctpShutDownEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpShutDownEvent.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpShutDownEvent.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpShutDownEvent_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpShutDownEvent_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpShutDownEvent.");
return single_value->field_clientId;
}

int SctpShutDownEvent_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpShutDownEvent containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpShutDownEvent.");
  }
  return 0;
}

void SctpShutDownEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpShutDownEvent_template::log_match(const SctpShutDownEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpShutDownEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpShutDownEvent.");
}
}

void SctpShutDownEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpShutDownEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpShutDownEvent.");
}
}

void SctpShutDownEvent_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpShutDownEvent_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpShutDownEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpShutDownEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpShutDownEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpShutDownEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpShutDownEvent");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpShutDownEvent");
}

boolean SctpShutDownEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpShutDownEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpPartialDeliveryEvent::SctpPartialDeliveryEvent()
{
}

SctpPartialDeliveryEvent::SctpPartialDeliveryEvent(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpPartialDeliveryEvent::SctpPartialDeliveryEvent(const SctpPartialDeliveryEvent& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpPartialDeliveryEvent::clean_up()
{
field_clientId.clean_up();
}

SctpPartialDeliveryEvent& SctpPartialDeliveryEvent::operator=(const SctpPartialDeliveryEvent& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpPartialDeliveryEvent::operator==(const SctpPartialDeliveryEvent& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpPartialDeliveryEvent::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpPartialDeliveryEvent::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpPartialDeliveryEvent::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpPartialDeliveryEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpPartialDeliveryEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpPartialDeliveryEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpPartialDeliveryEvent");
  }
}

void SctpPartialDeliveryEvent::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpPartialDeliveryEvent::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpPartialDeliveryEvent::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpPartialDeliveryEvent_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpPartialDeliveryEvent_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpPartialDeliveryEvent_template::copy_value(const SctpPartialDeliveryEvent& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpPartialDeliveryEvent_template::copy_template(const SctpPartialDeliveryEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpPartialDeliveryEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
break;
}
set_selection(other_value);
}

SctpPartialDeliveryEvent_template::SctpPartialDeliveryEvent_template()
{
}

SctpPartialDeliveryEvent_template::SctpPartialDeliveryEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpPartialDeliveryEvent_template::SctpPartialDeliveryEvent_template(const SctpPartialDeliveryEvent& other_value)
{
copy_value(other_value);
}

SctpPartialDeliveryEvent_template::SctpPartialDeliveryEvent_template(const OPTIONAL<SctpPartialDeliveryEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpPartialDeliveryEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent from an unbound optional field.");
}
}

SctpPartialDeliveryEvent_template::SctpPartialDeliveryEvent_template(const SctpPartialDeliveryEvent_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpPartialDeliveryEvent_template::~SctpPartialDeliveryEvent_template()
{
clean_up();
}

SctpPartialDeliveryEvent_template& SctpPartialDeliveryEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpPartialDeliveryEvent_template& SctpPartialDeliveryEvent_template::operator=(const SctpPartialDeliveryEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpPartialDeliveryEvent_template& SctpPartialDeliveryEvent_template::operator=(const OPTIONAL<SctpPartialDeliveryEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpPartialDeliveryEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
}
return *this;
}

SctpPartialDeliveryEvent_template& SctpPartialDeliveryEvent_template::operator=(const SctpPartialDeliveryEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpPartialDeliveryEvent_template::match(const SctpPartialDeliveryEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
}
return FALSE;
}

boolean SctpPartialDeliveryEvent_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpPartialDeliveryEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpPartialDeliveryEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpPartialDeliveryEvent SctpPartialDeliveryEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
SctpPartialDeliveryEvent ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpPartialDeliveryEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpPartialDeliveryEvent_template[list_length];
}

SctpPartialDeliveryEvent_template& SctpPartialDeliveryEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpPartialDeliveryEvent_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpPartialDeliveryEvent_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
return single_value->field_clientId;
}

int SctpPartialDeliveryEvent_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
  }
  return 0;
}

void SctpPartialDeliveryEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpPartialDeliveryEvent_template::log_match(const SctpPartialDeliveryEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpPartialDeliveryEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
}
}

void SctpPartialDeliveryEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpPartialDeliveryEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpPartialDeliveryEvent.");
}
}

void SctpPartialDeliveryEvent_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpPartialDeliveryEvent_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpPartialDeliveryEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpPartialDeliveryEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpPartialDeliveryEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpPartialDeliveryEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpPartialDeliveryEvent");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpPartialDeliveryEvent");
}

boolean SctpPartialDeliveryEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpPartialDeliveryEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpAdaptationIndication::SctpAdaptationIndication()
{
}

SctpAdaptationIndication::SctpAdaptationIndication(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpAdaptationIndication::SctpAdaptationIndication(const SctpAdaptationIndication& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpAdaptationIndication.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpAdaptationIndication::clean_up()
{
field_clientId.clean_up();
}

SctpAdaptationIndication& SctpAdaptationIndication::operator=(const SctpAdaptationIndication& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpAdaptationIndication.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpAdaptationIndication::operator==(const SctpAdaptationIndication& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpAdaptationIndication::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpAdaptationIndication::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpAdaptationIndication::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpAdaptationIndication::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpAdaptationIndication has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpAdaptationIndication: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpAdaptationIndication");
  }
}

void SctpAdaptationIndication::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpAdaptationIndication::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpAdaptationIndication::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpAdaptationIndication_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpAdaptationIndication_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpAdaptationIndication_template::copy_value(const SctpAdaptationIndication& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpAdaptationIndication_template::copy_template(const SctpAdaptationIndication_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpAdaptationIndication_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAdaptationIndication.");
break;
}
set_selection(other_value);
}

SctpAdaptationIndication_template::SctpAdaptationIndication_template()
{
}

SctpAdaptationIndication_template::SctpAdaptationIndication_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpAdaptationIndication_template::SctpAdaptationIndication_template(const SctpAdaptationIndication& other_value)
{
copy_value(other_value);
}

SctpAdaptationIndication_template::SctpAdaptationIndication_template(const OPTIONAL<SctpAdaptationIndication>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpAdaptationIndication&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpAdaptationIndication from an unbound optional field.");
}
}

SctpAdaptationIndication_template::SctpAdaptationIndication_template(const SctpAdaptationIndication_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpAdaptationIndication_template::~SctpAdaptationIndication_template()
{
clean_up();
}

SctpAdaptationIndication_template& SctpAdaptationIndication_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpAdaptationIndication_template& SctpAdaptationIndication_template::operator=(const SctpAdaptationIndication& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpAdaptationIndication_template& SctpAdaptationIndication_template::operator=(const OPTIONAL<SctpAdaptationIndication>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpAdaptationIndication&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpAdaptationIndication.");
}
return *this;
}

SctpAdaptationIndication_template& SctpAdaptationIndication_template::operator=(const SctpAdaptationIndication_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpAdaptationIndication_template::match(const SctpAdaptationIndication& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAdaptationIndication.");
}
return FALSE;
}

boolean SctpAdaptationIndication_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpAdaptationIndication_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpAdaptationIndication_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpAdaptationIndication SctpAdaptationIndication_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpAdaptationIndication.");
SctpAdaptationIndication ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpAdaptationIndication_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpAdaptationIndication.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpAdaptationIndication_template[list_length];
}

SctpAdaptationIndication_template& SctpAdaptationIndication_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpAdaptationIndication.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpAdaptationIndication.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpAdaptationIndication_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpAdaptationIndication_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpAdaptationIndication.");
return single_value->field_clientId;
}

int SctpAdaptationIndication_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpAdaptationIndication containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAdaptationIndication.");
  }
  return 0;
}

void SctpAdaptationIndication_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpAdaptationIndication_template::log_match(const SctpAdaptationIndication& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpAdaptationIndication_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpAdaptationIndication.");
}
}

void SctpAdaptationIndication_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpAdaptationIndication_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpAdaptationIndication.");
}
}

void SctpAdaptationIndication_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpAdaptationIndication_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpAdaptationIndication has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpAdaptationIndication: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpAdaptationIndication");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpAdaptationIndication_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpAdaptationIndication");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpAdaptationIndication");
}

boolean SctpAdaptationIndication_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpAdaptationIndication_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpSenderDryEvent::SctpSenderDryEvent()
{
}

SctpSenderDryEvent::SctpSenderDryEvent(const INTEGER& par_clientId)
  :   field_clientId(par_clientId)
{
}

SctpSenderDryEvent::SctpSenderDryEvent(const SctpSenderDryEvent& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @Socket_API_Definitions.SctpSenderDryEvent.");
if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
else field_clientId.clean_up();
}

void SctpSenderDryEvent::clean_up()
{
field_clientId.clean_up();
}

SctpSenderDryEvent& SctpSenderDryEvent::operator=(const SctpSenderDryEvent& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @Socket_API_Definitions.SctpSenderDryEvent.");
  if (other_value.clientId().is_bound()) field_clientId = other_value.clientId();
  else field_clientId.clean_up();
}
return *this;
}

boolean SctpSenderDryEvent::operator==(const SctpSenderDryEvent& other_value) const
{
return field_clientId==other_value.field_clientId;
}

boolean SctpSenderDryEvent::is_bound() const
{
if(field_clientId.is_bound()) return TRUE;
return FALSE;
}
boolean SctpSenderDryEvent::is_value() const
{
if(!field_clientId.is_value()) return FALSE;
return TRUE;
}
void SctpSenderDryEvent::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ clientId := ");
field_clientId.log();
TTCN_Logger::log_event_str(" }");
}

void SctpSenderDryEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @Socket_API_Definitions.SctpSenderDryEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpSenderDryEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@Socket_API_Definitions.SctpSenderDryEvent");
  }
}

void SctpSenderDryEvent::set_implicit_omit()
{
if (clientId().is_bound()) clientId().set_implicit_omit();
}

void SctpSenderDryEvent::encode_text(Text_Buf& text_buf) const
{
field_clientId.encode_text(text_buf);
}

void SctpSenderDryEvent::decode_text(Text_Buf& text_buf)
{
field_clientId.decode_text(text_buf);
}

struct SctpSenderDryEvent_template::single_value_struct {
INTEGER_template field_clientId;
};

void SctpSenderDryEvent_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_clientId = ANY_VALUE;
}
}
}

void SctpSenderDryEvent_template::copy_value(const SctpSenderDryEvent& other_value)
{
single_value = new single_value_struct;
if (other_value.clientId().is_bound()) {
  single_value->field_clientId = other_value.clientId();
} else {
  single_value->field_clientId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpSenderDryEvent_template::copy_template(const SctpSenderDryEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.clientId().get_selection()) {
single_value->field_clientId = other_value.clientId();
} else {
single_value->field_clientId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpSenderDryEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSenderDryEvent.");
break;
}
set_selection(other_value);
}

SctpSenderDryEvent_template::SctpSenderDryEvent_template()
{
}

SctpSenderDryEvent_template::SctpSenderDryEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpSenderDryEvent_template::SctpSenderDryEvent_template(const SctpSenderDryEvent& other_value)
{
copy_value(other_value);
}

SctpSenderDryEvent_template::SctpSenderDryEvent_template(const OPTIONAL<SctpSenderDryEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpSenderDryEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @Socket_API_Definitions.SctpSenderDryEvent from an unbound optional field.");
}
}

SctpSenderDryEvent_template::SctpSenderDryEvent_template(const SctpSenderDryEvent_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpSenderDryEvent_template::~SctpSenderDryEvent_template()
{
clean_up();
}

SctpSenderDryEvent_template& SctpSenderDryEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpSenderDryEvent_template& SctpSenderDryEvent_template::operator=(const SctpSenderDryEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpSenderDryEvent_template& SctpSenderDryEvent_template::operator=(const OPTIONAL<SctpSenderDryEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpSenderDryEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @Socket_API_Definitions.SctpSenderDryEvent.");
}
return *this;
}

SctpSenderDryEvent_template& SctpSenderDryEvent_template::operator=(const SctpSenderDryEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpSenderDryEvent_template::match(const SctpSenderDryEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.clientId().is_bound()) return FALSE;
if(!single_value->field_clientId.match(other_value.clientId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSenderDryEvent.");
}
return FALSE;
}

boolean SctpSenderDryEvent_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_clientId.is_bound()) return TRUE;
return FALSE;
}

boolean SctpSenderDryEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_clientId.is_value()) return FALSE;
return TRUE;
}

void SctpSenderDryEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpSenderDryEvent SctpSenderDryEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @Socket_API_Definitions.SctpSenderDryEvent.");
SctpSenderDryEvent ret_val;
if (single_value->field_clientId.is_bound()) {
ret_val.clientId() = single_value->field_clientId.valueof();
}
return ret_val;
}

void SctpSenderDryEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @Socket_API_Definitions.SctpSenderDryEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpSenderDryEvent_template[list_length];
}

SctpSenderDryEvent_template& SctpSenderDryEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.SctpSenderDryEvent.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.SctpSenderDryEvent.");
return value_list.list_value[list_index];
}

INTEGER_template& SctpSenderDryEvent_template::clientId()
{
set_specific();
return single_value->field_clientId;
}

const INTEGER_template& SctpSenderDryEvent_template::clientId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field clientId of a non-specific template of type @Socket_API_Definitions.SctpSenderDryEvent.");
return single_value->field_clientId;
}

int SctpSenderDryEvent_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @Socket_API_Definitions.SctpSenderDryEvent containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSenderDryEvent.");
  }
  return 0;
}

void SctpSenderDryEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpSenderDryEvent_template::log_match(const SctpSenderDryEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_clientId.match(match_value.clientId(), legacy)){
TTCN_Logger::log_logmatch_info(".clientId");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ clientId := ");
single_value->field_clientId.log_match(match_value.clientId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpSenderDryEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_clientId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @Socket_API_Definitions.SctpSenderDryEvent.");
}
}

void SctpSenderDryEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_clientId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpSenderDryEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @Socket_API_Definitions.SctpSenderDryEvent.");
}
}

void SctpSenderDryEvent_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpSenderDryEvent_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @Socket_API_Definitions.SctpSenderDryEvent has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) clientId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "clientId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          clientId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @Socket_API_Definitions.SctpSenderDryEvent: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@Socket_API_Definitions.SctpSenderDryEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpSenderDryEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_clientId.check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.SctpSenderDryEvent");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.SctpSenderDryEvent");
}

boolean SctpSenderDryEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpSenderDryEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PortEvent::copy_value(const PortEvent& other_value)
{
switch (other_value.union_selection) {
case ALT_connOpened:
field_connOpened = new ConnectionOpenedEvent(*other_value.field_connOpened);
break;
case ALT_connClosed:
field_connClosed = new ConnectionOpenedEvent(*other_value.field_connClosed);
break;
case ALT_result:
field_result = new Result(*other_value.field_result);
break;
case ALT_extended__result:
field_extended__result = new Extended__Result(*other_value.field_extended__result);
break;
case ALT_sctpEvent:
field_sctpEvent = new SctpEvent(*other_value.field_sctpEvent);
break;
default:
TTCN_error("Assignment of an unbound union value of type @Socket_API_Definitions.PortEvent.");
}
union_selection = other_value.union_selection;
}

PortEvent::PortEvent()
{
union_selection = UNBOUND_VALUE;
}

PortEvent::PortEvent(const PortEvent& other_value)
: Base_Type(){
copy_value(other_value);
}

PortEvent::~PortEvent()
{
clean_up();
}

PortEvent& PortEvent::operator=(const PortEvent& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean PortEvent::operator==(const PortEvent& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @Socket_API_Definitions.PortEvent.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @Socket_API_Definitions.PortEvent.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_connOpened:
return *field_connOpened == *other_value.field_connOpened;
case ALT_connClosed:
return *field_connClosed == *other_value.field_connClosed;
case ALT_result:
return *field_result == *other_value.field_result;
case ALT_extended__result:
return *field_extended__result == *other_value.field_extended__result;
case ALT_sctpEvent:
return *field_sctpEvent == *other_value.field_sctpEvent;
default:
return FALSE;
}
}

ConnectionOpenedEvent& PortEvent::connOpened()
{
if (union_selection != ALT_connOpened) {
clean_up();
field_connOpened = new ConnectionOpenedEvent;
union_selection = ALT_connOpened;
}
return *field_connOpened;
}

const ConnectionOpenedEvent& PortEvent::connOpened() const
{
if (union_selection != ALT_connOpened) TTCN_error("Using non-selected field connOpened in a value of union type @Socket_API_Definitions.PortEvent.");
return *field_connOpened;
}

ConnectionOpenedEvent& PortEvent::connClosed()
{
if (union_selection != ALT_connClosed) {
clean_up();
field_connClosed = new ConnectionOpenedEvent;
union_selection = ALT_connClosed;
}
return *field_connClosed;
}

const ConnectionOpenedEvent& PortEvent::connClosed() const
{
if (union_selection != ALT_connClosed) TTCN_error("Using non-selected field connClosed in a value of union type @Socket_API_Definitions.PortEvent.");
return *field_connClosed;
}

Result& PortEvent::result()
{
if (union_selection != ALT_result) {
clean_up();
field_result = new Result;
union_selection = ALT_result;
}
return *field_result;
}

const Result& PortEvent::result() const
{
if (union_selection != ALT_result) TTCN_error("Using non-selected field result in a value of union type @Socket_API_Definitions.PortEvent.");
return *field_result;
}

Extended__Result& PortEvent::extended__result()
{
if (union_selection != ALT_extended__result) {
clean_up();
field_extended__result = new Extended__Result;
union_selection = ALT_extended__result;
}
return *field_extended__result;
}

const Extended__Result& PortEvent::extended__result() const
{
if (union_selection != ALT_extended__result) TTCN_error("Using non-selected field extended_result in a value of union type @Socket_API_Definitions.PortEvent.");
return *field_extended__result;
}

SctpEvent& PortEvent::sctpEvent()
{
if (union_selection != ALT_sctpEvent) {
clean_up();
field_sctpEvent = new SctpEvent;
union_selection = ALT_sctpEvent;
}
return *field_sctpEvent;
}

const SctpEvent& PortEvent::sctpEvent() const
{
if (union_selection != ALT_sctpEvent) TTCN_error("Using non-selected field sctpEvent in a value of union type @Socket_API_Definitions.PortEvent.");
return *field_sctpEvent;
}

boolean PortEvent::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.PortEvent.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @Socket_API_Definitions.PortEvent.");
return union_selection == checked_selection;
}

boolean PortEvent::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean PortEvent::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_connOpened: return field_connOpened->is_value();
case ALT_connClosed: return field_connClosed->is_value();
case ALT_result: return field_result->is_value();
case ALT_extended__result: return field_extended__result->is_value();
case ALT_sctpEvent: return field_sctpEvent->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void PortEvent::clean_up()
{
switch (union_selection) {
case ALT_connOpened:
  delete field_connOpened;
  break;
case ALT_connClosed:
  delete field_connClosed;
  break;
case ALT_result:
  delete field_result;
  break;
case ALT_extended__result:
  delete field_extended__result;
  break;
case ALT_sctpEvent:
  delete field_sctpEvent;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void PortEvent::log() const
{
switch (union_selection) {
case ALT_connOpened:
TTCN_Logger::log_event_str("{ connOpened := ");
field_connOpened->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_connClosed:
TTCN_Logger::log_event_str("{ connClosed := ");
field_connClosed->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_result:
TTCN_Logger::log_event_str("{ result := ");
field_result->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_extended__result:
TTCN_Logger::log_event_str("{ extended_result := ");
field_extended__result->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpEvent:
TTCN_Logger::log_event_str("{ sctpEvent := ");
field_sctpEvent->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void PortEvent::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "connOpened")) {
    connOpened().set_param(*mp_last);
    if (!connOpened().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "connClosed")) {
    connClosed().set_param(*mp_last);
    if (!connClosed().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "result")) {
    result().set_param(*mp_last);
    if (!result().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "extended_result")) {
    extended__result().set_param(*mp_last);
    if (!extended__result().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpEvent")) {
    sctpEvent().set_param(*mp_last);
    if (!sctpEvent().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @Socket_API_Definitions.PortEvent.", mp_last->get_id()->get_name());
}

void PortEvent::set_implicit_omit()
{
switch (union_selection) {
case ALT_connOpened:
field_connOpened->set_implicit_omit(); break;
case ALT_connClosed:
field_connClosed->set_implicit_omit(); break;
case ALT_result:
field_result->set_implicit_omit(); break;
case ALT_extended__result:
field_extended__result->set_implicit_omit(); break;
case ALT_sctpEvent:
field_sctpEvent->set_implicit_omit(); break;
default: break;
}
}

void PortEvent::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_connOpened:
field_connOpened->encode_text(text_buf);
break;
case ALT_connClosed:
field_connClosed->encode_text(text_buf);
break;
case ALT_result:
field_result->encode_text(text_buf);
break;
case ALT_extended__result:
field_extended__result->encode_text(text_buf);
break;
case ALT_sctpEvent:
field_sctpEvent->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @Socket_API_Definitions.PortEvent.");
}
}

void PortEvent::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_connOpened:
connOpened().decode_text(text_buf);
break;
case ALT_connClosed:
connClosed().decode_text(text_buf);
break;
case ALT_result:
result().decode_text(text_buf);
break;
case ALT_extended__result:
extended__result().decode_text(text_buf);
break;
case ALT_sctpEvent:
sctpEvent().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @Socket_API_Definitions.PortEvent.");
}
}

void PortEvent_template::copy_value(const PortEvent& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
single_value.field_connOpened = new ConnectionOpenedEvent_template(other_value.connOpened());
break;
case PortEvent::ALT_connClosed:
single_value.field_connClosed = new ConnectionOpenedEvent_template(other_value.connClosed());
break;
case PortEvent::ALT_result:
single_value.field_result = new Result_template(other_value.result());
break;
case PortEvent::ALT_extended__result:
single_value.field_extended__result = new Extended__Result_template(other_value.extended__result());
break;
case PortEvent::ALT_sctpEvent:
single_value.field_sctpEvent = new SctpEvent_template(other_value.sctpEvent());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @Socket_API_Definitions.PortEvent.");
}
set_selection(SPECIFIC_VALUE);
}

void PortEvent_template::copy_template(const PortEvent_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
single_value.field_connOpened = new ConnectionOpenedEvent_template(*other_value.single_value.field_connOpened);
break;
case PortEvent::ALT_connClosed:
single_value.field_connClosed = new ConnectionOpenedEvent_template(*other_value.single_value.field_connClosed);
break;
case PortEvent::ALT_result:
single_value.field_result = new Result_template(*other_value.single_value.field_result);
break;
case PortEvent::ALT_extended__result:
single_value.field_extended__result = new Extended__Result_template(*other_value.single_value.field_extended__result);
break;
case PortEvent::ALT_sctpEvent:
single_value.field_sctpEvent = new SctpEvent_template(*other_value.single_value.field_sctpEvent);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @Socket_API_Definitions.PortEvent.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PortEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @Socket_API_Definitions.PortEvent.");
}
set_selection(other_value);
}

PortEvent_template::PortEvent_template()
{
}

PortEvent_template::PortEvent_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PortEvent_template::PortEvent_template(const PortEvent& other_value)
{
copy_value(other_value);
}

PortEvent_template::PortEvent_template(const OPTIONAL<PortEvent>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PortEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @Socket_API_Definitions.PortEvent from an unbound optional field.");
}
}

PortEvent_template::PortEvent_template(const PortEvent_template& other_value)
: Base_Template(){
copy_template(other_value);
}

PortEvent_template::~PortEvent_template()
{
clean_up();
}

void PortEvent_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
delete single_value.field_connOpened;
break;
case PortEvent::ALT_connClosed:
delete single_value.field_connClosed;
break;
case PortEvent::ALT_result:
delete single_value.field_result;
break;
case PortEvent::ALT_extended__result:
delete single_value.field_extended__result;
break;
case PortEvent::ALT_sctpEvent:
delete single_value.field_sctpEvent;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PortEvent_template& PortEvent_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PortEvent_template& PortEvent_template::operator=(const PortEvent& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PortEvent_template& PortEvent_template::operator=(const OPTIONAL<PortEvent>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PortEvent&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @Socket_API_Definitions.PortEvent.");
}
return *this;
}

PortEvent_template& PortEvent_template::operator=(const PortEvent_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PortEvent_template::match(const PortEvent& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
PortEvent::union_selection_type value_selection = other_value.get_selection();
if (value_selection == PortEvent::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case PortEvent::ALT_connOpened:
return single_value.field_connOpened->match(other_value.connOpened(), legacy);
case PortEvent::ALT_connClosed:
return single_value.field_connClosed->match(other_value.connClosed(), legacy);
case PortEvent::ALT_result:
return single_value.field_result->match(other_value.result(), legacy);
case PortEvent::ALT_extended__result:
return single_value.field_extended__result->match(other_value.extended__result(), legacy);
case PortEvent::ALT_sctpEvent:
return single_value.field_sctpEvent->match(other_value.sctpEvent(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @Socket_API_Definitions.PortEvent.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @Socket_API_Definitions.PortEvent.");
}
return FALSE;
}

boolean PortEvent_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
return single_value.field_connOpened->is_value();
case PortEvent::ALT_connClosed:
return single_value.field_connClosed->is_value();
case PortEvent::ALT_result:
return single_value.field_result->is_value();
case PortEvent::ALT_extended__result:
return single_value.field_extended__result->is_value();
case PortEvent::ALT_sctpEvent:
return single_value.field_sctpEvent->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @Socket_API_Definitions.PortEvent.");
}
}

PortEvent PortEvent_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @Socket_API_Definitions.PortEvent.");
PortEvent ret_val;
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
ret_val.connOpened() = single_value.field_connOpened->valueof();
break;
case PortEvent::ALT_connClosed:
ret_val.connClosed() = single_value.field_connClosed->valueof();
break;
case PortEvent::ALT_result:
ret_val.result() = single_value.field_result->valueof();
break;
case PortEvent::ALT_extended__result:
ret_val.extended__result() = single_value.field_extended__result->valueof();
break;
case PortEvent::ALT_sctpEvent:
ret_val.sctpEvent() = single_value.field_sctpEvent->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @Socket_API_Definitions.PortEvent.");
}
return ret_val;
}

PortEvent_template& PortEvent_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @Socket_API_Definitions.PortEvent.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @Socket_API_Definitions.PortEvent.");
return value_list.list_value[list_index];
}
void PortEvent_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @Socket_API_Definitions.PortEvent.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PortEvent_template[list_length];
}

ConnectionOpenedEvent_template& PortEvent_template::connOpened()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PortEvent::ALT_connOpened) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_connOpened = new ConnectionOpenedEvent_template(ANY_VALUE);
else single_value.field_connOpened = new ConnectionOpenedEvent_template;
single_value.union_selection = PortEvent::ALT_connOpened;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_connOpened;
}

const ConnectionOpenedEvent_template& PortEvent_template::connOpened() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field connOpened in a non-specific template of union type @Socket_API_Definitions.PortEvent.");
if (single_value.union_selection != PortEvent::ALT_connOpened) TTCN_error("Accessing non-selected field connOpened in a template of union type @Socket_API_Definitions.PortEvent.");
return *single_value.field_connOpened;
}

ConnectionOpenedEvent_template& PortEvent_template::connClosed()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PortEvent::ALT_connClosed) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_connClosed = new ConnectionOpenedEvent_template(ANY_VALUE);
else single_value.field_connClosed = new ConnectionOpenedEvent_template;
single_value.union_selection = PortEvent::ALT_connClosed;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_connClosed;
}

const ConnectionOpenedEvent_template& PortEvent_template::connClosed() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field connClosed in a non-specific template of union type @Socket_API_Definitions.PortEvent.");
if (single_value.union_selection != PortEvent::ALT_connClosed) TTCN_error("Accessing non-selected field connClosed in a template of union type @Socket_API_Definitions.PortEvent.");
return *single_value.field_connClosed;
}

Result_template& PortEvent_template::result()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PortEvent::ALT_result) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_result = new Result_template(ANY_VALUE);
else single_value.field_result = new Result_template;
single_value.union_selection = PortEvent::ALT_result;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_result;
}

const Result_template& PortEvent_template::result() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field result in a non-specific template of union type @Socket_API_Definitions.PortEvent.");
if (single_value.union_selection != PortEvent::ALT_result) TTCN_error("Accessing non-selected field result in a template of union type @Socket_API_Definitions.PortEvent.");
return *single_value.field_result;
}

Extended__Result_template& PortEvent_template::extended__result()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PortEvent::ALT_extended__result) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_extended__result = new Extended__Result_template(ANY_VALUE);
else single_value.field_extended__result = new Extended__Result_template;
single_value.union_selection = PortEvent::ALT_extended__result;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_extended__result;
}

const Extended__Result_template& PortEvent_template::extended__result() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field extended_result in a non-specific template of union type @Socket_API_Definitions.PortEvent.");
if (single_value.union_selection != PortEvent::ALT_extended__result) TTCN_error("Accessing non-selected field extended_result in a template of union type @Socket_API_Definitions.PortEvent.");
return *single_value.field_extended__result;
}

SctpEvent_template& PortEvent_template::sctpEvent()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PortEvent::ALT_sctpEvent) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpEvent = new SctpEvent_template(ANY_VALUE);
else single_value.field_sctpEvent = new SctpEvent_template;
single_value.union_selection = PortEvent::ALT_sctpEvent;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpEvent;
}

const SctpEvent_template& PortEvent_template::sctpEvent() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpEvent in a non-specific template of union type @Socket_API_Definitions.PortEvent.");
if (single_value.union_selection != PortEvent::ALT_sctpEvent) TTCN_error("Accessing non-selected field sctpEvent in a template of union type @Socket_API_Definitions.PortEvent.");
return *single_value.field_sctpEvent;
}

boolean PortEvent_template::ischosen(PortEvent::union_selection_type checked_selection) const
{
if (checked_selection == PortEvent::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @Socket_API_Definitions.PortEvent.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == PortEvent::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @Socket_API_Definitions.PortEvent.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @Socket_API_Definitions.PortEvent containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @Socket_API_Definitions.PortEvent, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @Socket_API_Definitions.PortEvent");
}
return FALSE;
}

void PortEvent_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
TTCN_Logger::log_event_str("{ connOpened := ");
single_value.field_connOpened->log();
TTCN_Logger::log_event_str(" }");
break;
case PortEvent::ALT_connClosed:
TTCN_Logger::log_event_str("{ connClosed := ");
single_value.field_connClosed->log();
TTCN_Logger::log_event_str(" }");
break;
case PortEvent::ALT_result:
TTCN_Logger::log_event_str("{ result := ");
single_value.field_result->log();
TTCN_Logger::log_event_str(" }");
break;
case PortEvent::ALT_extended__result:
TTCN_Logger::log_event_str("{ extended_result := ");
single_value.field_extended__result->log();
TTCN_Logger::log_event_str(" }");
break;
case PortEvent::ALT_sctpEvent:
TTCN_Logger::log_event_str("{ sctpEvent := ");
single_value.field_sctpEvent->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PortEvent_template::log_match(const PortEvent& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".connOpened");
single_value.field_connOpened->log_match(match_value.connOpened(), legacy);
} else {
TTCN_Logger::log_event_str("{ connOpened := ");
single_value.field_connOpened->log_match(match_value.connOpened(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PortEvent::ALT_connClosed:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".connClosed");
single_value.field_connClosed->log_match(match_value.connClosed(), legacy);
} else {
TTCN_Logger::log_event_str("{ connClosed := ");
single_value.field_connClosed->log_match(match_value.connClosed(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PortEvent::ALT_result:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".result");
single_value.field_result->log_match(match_value.result(), legacy);
} else {
TTCN_Logger::log_event_str("{ result := ");
single_value.field_result->log_match(match_value.result(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PortEvent::ALT_extended__result:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".extended_result");
single_value.field_extended__result->log_match(match_value.extended__result(), legacy);
} else {
TTCN_Logger::log_event_str("{ extended_result := ");
single_value.field_extended__result->log_match(match_value.extended__result(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PortEvent::ALT_sctpEvent:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpEvent");
single_value.field_sctpEvent->log_match(match_value.sctpEvent(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpEvent := ");
single_value.field_sctpEvent->log_match(match_value.sctpEvent(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PortEvent_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
single_value.field_connOpened->encode_text(text_buf);
break;
case PortEvent::ALT_connClosed:
single_value.field_connClosed->encode_text(text_buf);
break;
case PortEvent::ALT_result:
single_value.field_result->encode_text(text_buf);
break;
case PortEvent::ALT_extended__result:
single_value.field_extended__result->encode_text(text_buf);
break;
case PortEvent::ALT_sctpEvent:
single_value.field_sctpEvent->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @Socket_API_Definitions.PortEvent.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @Socket_API_Definitions.PortEvent.");
}
}

void PortEvent_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = PortEvent::UNBOUND_VALUE;
PortEvent::union_selection_type new_selection = (PortEvent::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case PortEvent::ALT_connOpened:
single_value.field_connOpened = new ConnectionOpenedEvent_template;
single_value.field_connOpened->decode_text(text_buf);
break;
case PortEvent::ALT_connClosed:
single_value.field_connClosed = new ConnectionOpenedEvent_template;
single_value.field_connClosed->decode_text(text_buf);
break;
case PortEvent::ALT_result:
single_value.field_result = new Result_template;
single_value.field_result->decode_text(text_buf);
break;
case PortEvent::ALT_extended__result:
single_value.field_extended__result = new Extended__Result_template;
single_value.field_extended__result->decode_text(text_buf);
break;
case PortEvent::ALT_sctpEvent:
single_value.field_sctpEvent = new SctpEvent_template;
single_value.field_sctpEvent->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @Socket_API_Definitions.PortEvent.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PortEvent_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @Socket_API_Definitions.PortEvent.");
}
}

boolean PortEvent_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PortEvent_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PortEvent_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@Socket_API_Definitions.PortEvent'");
    }
    if (strcmp("connOpened", param_field) == 0) {
      connOpened().set_param(param);
      return;
    } else if (strcmp("connClosed", param_field) == 0) {
      connClosed().set_param(param);
      return;
    } else if (strcmp("result", param_field) == 0) {
      result().set_param(param);
      return;
    } else if (strcmp("extended_result", param_field) == 0) {
      extended__result().set_param(param);
      return;
    } else if (strcmp("sctpEvent", param_field) == 0) {
      sctpEvent().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@Socket_API_Definitions.PortEvent'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PortEvent_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@Socket_API_Definitions.PortEvent");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "connOpened")) {
      connOpened().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "connClosed")) {
      connClosed().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "result")) {
      result().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "extended_result")) {
      extended__result().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpEvent")) {
      sctpEvent().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @Socket_API_Definitions.PortEvent.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@Socket_API_Definitions.PortEvent");
  }
  is_ifpresent = param.get_ifpresent();
}

void PortEvent_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case PortEvent::ALT_connOpened:
single_value.field_connOpened->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.PortEvent");
return;
case PortEvent::ALT_connClosed:
single_value.field_connClosed->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.PortEvent");
return;
case PortEvent::ALT_result:
single_value.field_result->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.PortEvent");
return;
case PortEvent::ALT_extended__result:
single_value.field_extended__result->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.PortEvent");
return;
case PortEvent::ALT_sctpEvent:
single_value.field_sctpEvent->check_restriction(t_res, t_name ? t_name : "@Socket_API_Definitions.PortEvent");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @Socket_API_Definitions.PortEvent.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.PortEvent");
}

f__getMsgLen::f__getMsgLen()
{
referred_function = NULL;
}

f__getMsgLen::f__getMsgLen(function_pointer other_value)
{
referred_function = other_value;
}

f__getMsgLen::f__getMsgLen(const f__getMsgLen& other_value)
: Base_Type(){
other_value.must_bound("Copying an unbound @Socket_API_Definitions.f_getMsgLen value.");
referred_function = other_value.referred_function;
}

f__getMsgLen& f__getMsgLen::operator=(function_pointer other_value)
{
referred_function = other_value;
return *this;
}

f__getMsgLen& f__getMsgLen::operator=(const f__getMsgLen& other_value)
{
other_value.must_bound("Assignment of an unbound value.");
referred_function = other_value.referred_function;
return *this;
}

boolean f__getMsgLen::operator==(function_pointer other_value) const
{
must_bound("Unbound left operand of @Socket_API_Definitions.f_getMsgLen comparison.");
return referred_function == other_value;
}

boolean f__getMsgLen::operator==(const f__getMsgLen& other_value) const
{
must_bound("Unbound left operand of @Socket_API_Definitions.f_getMsgLen comparison.");
other_value.must_bound("Unbound right operand of @Socket_API_Definitions.f_getMsgLen comparison.");
return referred_function == other_value.referred_function;
}

INTEGER f__getMsgLen::invoke(const OCTETSTRING& stream, ro__integer& args) const
{
must_bound("Call of unbound function.");
if(referred_function == (f__getMsgLen::function_pointer)Module_List::get_fat_null())
TTCN_error("null reference cannot be invoked.");
return referred_function(stream, args);
}

void f__getMsgLen::log() const
{
Module_List::log_function((genericfunc_t)referred_function);
}

void f__getMsgLen::set_param(Module_Param& param)
{
  param.error("Not supported.");
}

void f__getMsgLen::encode_text(Text_Buf&) const
{
TTCN_error("Values of type @Socket_API_Definitions.f_getMsgLen cannot be sent to other test components.");
}

void f__getMsgLen::decode_text(Text_Buf&)
{
TTCN_error("Values of type @Socket_API_Definitions.f_getMsgLen cannot be received from other test components.");
}

boolean operator==(f__getMsgLen::function_pointer value, const f__getMsgLen& other_value)
{
other_value.must_bound("Unbound right operand of @Socket_API_Definitions.f_getMsgLen comparison.");
return value == other_value.referred_function;
}

void f__getMsgLen_template::copy_template(const f__getMsgLen_template& other_value)
{
switch(other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new f__getMsgLen_template[value_list.n_values];
for(unsigned int i = 0; i < value_list.n_values; i++)
value_list.list_value[i] = other_value.value_list.list_value[i];
break;
default:
TTCN_error("Copying an unitialized/unsupported @Socket_API_Definitions.f_getMsgLen template.");
}
set_selection(other_value);
}

f__getMsgLen_template::f__getMsgLen_template()
{
}

f__getMsgLen_template::f__getMsgLen_template(template_sel other_value)
  : Base_Template(other_value)
{
check_single_selection(other_value);
}

f__getMsgLen_template::f__getMsgLen_template(f__getMsgLen::function_pointer other_value)
  : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

f__getMsgLen_template::f__getMsgLen_template(const f__getMsgLen& other_value)
  :Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound @Socket_API_Definitions.f_getMsgLen value.");
single_value = other_value.referred_function;
}

f__getMsgLen_template::f__getMsgLen_template(const OPTIONAL<f__getMsgLen>& other_value)
{
if(other_value.ispresent()) {
set_selection(SPECIFIC_VALUE);
single_value = ((const f__getMsgLen&)other_value()).referred_function;
} else set_selection(OMIT_VALUE);
}

f__getMsgLen_template::f__getMsgLen_template(const f__getMsgLen_template& other_value)
  :Base_Template()
{
copy_template(other_value);
}

f__getMsgLen_template::~f__getMsgLen_template()
{
  clean_up();
}

void f__getMsgLen_template::clean_up(){
if(template_selection == VALUE_LIST ||
template_selection == COMPLEMENTED_LIST)
delete[] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

f__getMsgLen_template& f__getMsgLen_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

f__getMsgLen_template& f__getMsgLen_template::operator=(f__getMsgLen::function_pointer other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;}

f__getMsgLen_template& f__getMsgLen_template::operator=(const f__getMsgLen& other_value)
{
other_value.must_bound("Assignment of an unbound @Socket_API_Definitions.f_getMsgLen value to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.referred_function;
return *this;
}

f__getMsgLen_template& f__getMsgLen_template::operator=(const OPTIONAL<f__getMsgLen>& other_value)
{
clean_up();
if(other_value.ispresent()) { 
set_selection(SPECIFIC_VALUE);
single_value = ((const f__getMsgLen&)other_value()).referred_function;
} else set_selection(OMIT_VALUE);
return *this;}

f__getMsgLen_template& f__getMsgLen_template::operator=(const f__getMsgLen_template& other_value)
{
if(&other_value != this) {
clean_up();copy_template(other_value);
}
return *this;
}

boolean f__getMsgLen_template::match(f__getMsgLen::function_pointer other_value, boolean) const
{
switch(template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for(unsigned int i = 0; i < value_list.n_values; i++)
if(value_list.list_value[i].match(other_value))
return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an unitialized/unsupported @Socket_API_Definitions.f_getMsgLen template.");
};
return FALSE;
}

boolean f__getMsgLen_template::match(const f__getMsgLen& other_value, boolean) const
{
  if (!other_value.is_bound()) return FALSE;
return match(other_value.referred_function);
}

f__getMsgLen f__getMsgLen_template::valueof() const
{
if(template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific @Socket_API_Definitions.f_getMsgLen template.");
return single_value;
}

void f__getMsgLen_template::set_type(template_sel template_type, unsigned int list_length)
{
if(template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid type for an @Socket_API_Definitions.f_getMsgLen template.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new f__getMsgLen_template[list_length];
}

f__getMsgLen_template& f__getMsgLen_template::list_item(unsigned int list_index) const
{
if(template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @Socket_API_Definitions.f_getMsgLen");
if(list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @Socket_API_Definitions.f_getMsgLen.");
return value_list.list_value[list_index];
}

void f__getMsgLen_template::log() const
{
switch(template_selection) {
case SPECIFIC_VALUE:
Module_List::log_function((genericfunc_t)single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for(unsigned int i = 0; i < value_list.n_values; i++) {
if(i > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[i].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void f__getMsgLen_template::log_match(const f__getMsgLen& match_value, boolean legacy) const
{
log();
TTCN_Logger::log_event_str(" with ");
match_value.log();
if(match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void f__getMsgLen_template::encode_text(Text_Buf&) const
{
TTCN_error("Templates of type @Socket_API_Definitions.f_getMsgLen cannot be sent to other test components.");
}

void f__getMsgLen_template::decode_text(Text_Buf&)
{
TTCN_error("Templates of type @Socket_API_Definitions.f_getMsgLen cannot be received from other test components.");
}

boolean f__getMsgLen_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean f__getMsgLen_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void f__getMsgLen_template::set_param(Module_Param& param)
{
  param.error("Not supported.");
}

void f__getMsgLen_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@Socket_API_Definitions.f_getMsgLen");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const SocketList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @Socket_API_Definitions.SocketList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const UdpTuple& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpTuple.");
return TRUE;
}

boolean operator==(null_type, const UdpLightTuple& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UdpLightTuple.");
return TRUE;
}

boolean operator==(null_type, const TcpTuple& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.TcpTuple.");
return TRUE;
}

boolean operator==(null_type, const SslTuple& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.SslTuple.");
return TRUE;
}

boolean operator==(null_type, const UnspecifiedTuple& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @Socket_API_Definitions.UnspecifiedTuple.");
return TRUE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "Socket_API_Definitions");
current_location.update_lineno(50);
#line 50 "../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn"
const_c__ipv4AnyAddr = cs_0;
current_location.update_lineno(51);
#line 51 "../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn"
const_c__ipv6AnyAddr = cs_1;
current_location.update_lineno(52);
#line 52 "../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn"
const_c__anyPort = 0;
current_location.update_lineno(53);
#line 53 "../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn"
const_c__defaultLocAddr = cs_2;
current_location.update_lineno(54);
#line 54 "../oneM2MTester/Lib/SocketAPI/Socket_API_Definitions.ttcn"
const_c__defaultLocPort = -1;
}


} /* end of namespace */
