// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "CoAP_Types.hh"

namespace CoAP__Types {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x56, 0xf9, 0x16, 0xfb, 0x69, 0x33, 0x71, 0x61, 0x6d, 0xbb, 0x84, 0xa8, 0x9f, 0x41, 0x86, 0x08 };

/* Global variable definitions */

const XERdescriptor_t       Code_class__xer_ = { {"class>\n", "class>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Code_class__descr_ = { "@CoAP_Types.Code.class", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Code_class__xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Code_detail_xer_ = { {"detail>\n", "detail>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Code_detail_descr_ = { "@CoAP_Types.Code.detail", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Code_detail_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Code
const TTCN_Typedescriptor_t Code_descr_ = { "@CoAP_Types.Code", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static Code const_EMPTY__MESSAGE;
const Code& EMPTY__MESSAGE = const_EMPTY__MESSAGE;
static Code const_METHOD__GET;
const Code& METHOD__GET = const_METHOD__GET;
static Code const_METHOD__POST;
const Code& METHOD__POST = const_METHOD__POST;
static Code const_METHOD__PUT;
const Code& METHOD__PUT = const_METHOD__PUT;
static Code const_METHOD__DELETE;
const Code& METHOD__DELETE = const_METHOD__DELETE;
static Code const_RESPONSE__CODE__Created;
const Code& RESPONSE__CODE__Created = const_RESPONSE__CODE__Created;
static Code const_RESPONSE__CODE__Deleted;
const Code& RESPONSE__CODE__Deleted = const_RESPONSE__CODE__Deleted;
static Code const_RESPONSE__CODE__Valid;
const Code& RESPONSE__CODE__Valid = const_RESPONSE__CODE__Valid;
static Code const_RESPONSE__CODE__Changed;
const Code& RESPONSE__CODE__Changed = const_RESPONSE__CODE__Changed;
static Code const_RESPONSE__CODE__Content;
const Code& RESPONSE__CODE__Content = const_RESPONSE__CODE__Content;
static Code const_RESPONSE__CODE__BadRequest;
const Code& RESPONSE__CODE__BadRequest = const_RESPONSE__CODE__BadRequest;
static Code const_RESPONSE__CODE__Unauthorized;
const Code& RESPONSE__CODE__Unauthorized = const_RESPONSE__CODE__Unauthorized;
static Code const_RESPONSE__CODE__BadOption;
const Code& RESPONSE__CODE__BadOption = const_RESPONSE__CODE__BadOption;
static Code const_RESPONSE__CODE__Forbidden;
const Code& RESPONSE__CODE__Forbidden = const_RESPONSE__CODE__Forbidden;
static Code const_RESPONSE__CODE__NotFound;
const Code& RESPONSE__CODE__NotFound = const_RESPONSE__CODE__NotFound;
static Code const_RESPONSE__CODE__MethodNotAllowed;
const Code& RESPONSE__CODE__MethodNotAllowed = const_RESPONSE__CODE__MethodNotAllowed;
static Code const_RESPONSE__CODE__NotAcceptable;
const Code& RESPONSE__CODE__NotAcceptable = const_RESPONSE__CODE__NotAcceptable;
static Code const_RESPONSE__CODE__PreconditionFailed;
const Code& RESPONSE__CODE__PreconditionFailed = const_RESPONSE__CODE__PreconditionFailed;
static Code const_RESPONSE__CODE__RequestEntityTooLarge;
const Code& RESPONSE__CODE__RequestEntityTooLarge = const_RESPONSE__CODE__RequestEntityTooLarge;
static Code const_RESPONSE__CODE__UnsupportedContentFormat;
const Code& RESPONSE__CODE__UnsupportedContentFormat = const_RESPONSE__CODE__UnsupportedContentFormat;
static Code const_RESPONSE__CODE__InternalServerError;
const Code& RESPONSE__CODE__InternalServerError = const_RESPONSE__CODE__InternalServerError;
static Code const_RESPONSE__CODE__NotImplemented;
const Code& RESPONSE__CODE__NotImplemented = const_RESPONSE__CODE__NotImplemented;
static Code const_RESPONSE__CODE__BadGateway;
const Code& RESPONSE__CODE__BadGateway = const_RESPONSE__CODE__BadGateway;
static Code const_RESPONSE__CODE__ServiceUnavailable;
const Code& RESPONSE__CODE__ServiceUnavailable = const_RESPONSE__CODE__ServiceUnavailable;
static Code const_RESPONSE__CODE__GatewayTimeout;
const Code& RESPONSE__CODE__GatewayTimeout = const_RESPONSE__CODE__GatewayTimeout;
static Code const_RESPONSE__CODE__ProxyingNotSupported;
const Code& RESPONSE__CODE__ProxyingNotSupported = const_RESPONSE__CODE__ProxyingNotSupported;
const TTCN_RAWdescriptor_t OCT0_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1,CharCoding::UNKNOWN};
const XERdescriptor_t       OCT0_xer_ = { {"OCT0>\n", "OCT0>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t OCT0_descr_ = { "@CoAP_Types.OCT0", &OCTETSTRING_ber_, &OCT0_raw_, &OCTETSTRING_text_, &OCT0_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       OCT0__8_xer_ = { {"OCT0_8>\n", "OCT0_8>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t OCT0__8_descr_ = { "@CoAP_Types.OCT0_8", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &OCT0__8_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       OCT1__8_xer_ = { {"OCT1_8>\n", "OCT1_8>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t OCT1__8_descr_ = { "@CoAP_Types.OCT1_8", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &OCT1__8_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR15_xer_ = { {"UCHAR15>\n", "UCHAR15>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR15_descr_ = { "@CoAP_Types.UCHAR15", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR15_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR0__255_xer_ = { {"UCHAR0_255>\n", "UCHAR0_255>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR0__255_descr_ = { "@CoAP_Types.UCHAR0_255", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR0__255_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR1__255_xer_ = { {"UCHAR1_255>\n", "UCHAR1_255>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR1__255_descr_ = { "@CoAP_Types.UCHAR1_255", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR1__255_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UCHAR1__1034_xer_ = { {"UCHAR1_1034>\n", "UCHAR1_1034>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UCHAR1__1034_descr_ = { "@CoAP_Types.UCHAR1_1034", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &UCHAR1__1034_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Type
const TTCN_Typedescriptor_t Type_descr_ = { "@CoAP_Types.Type", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Header_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Header_version_descr_ = { "@CoAP_Types.Header.version", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Header_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Header_message__id_xer_ = { {"message_id>\n", "message_id>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Header_message__id_descr_ = { "@CoAP_Types.Header.message_id", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Header_message__id_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Header
const TTCN_Typedescriptor_t Header_descr_ = { "@CoAP_Types.Header", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UnknownOption_option__code_xer_ = { {"option_code>\n", "option_code>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UnknownOption_option__code_descr_ = { "@CoAP_Types.UnknownOption.option_code", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &UnknownOption_option__code_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UnknownOption_option__value_xer_ = { {"option_value>\n", "option_value>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UnknownOption_option__value_descr_ = { "@CoAP_Types.UnknownOption.option_value", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &UnknownOption_option__value_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for UnknownOption
const TTCN_Typedescriptor_t UnknownOption_descr_ = { "@CoAP_Types.UnknownOption", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BlockOption_num_xer_ = { {"num>\n", "num>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BlockOption_num_descr_ = { "@CoAP_Types.BlockOption.num", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &BlockOption_num_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BlockOption_m_xer_ = { {"m>\n", "m>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BlockOption_m_descr_ = { "@CoAP_Types.BlockOption.m", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &BlockOption_m_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       BlockOption_szx_xer_ = { {"szx>\n", "szx>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t BlockOption_szx_descr_ = { "@CoAP_Types.BlockOption.szx", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &BlockOption_szx_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for BlockOption
const TTCN_Typedescriptor_t BlockOption_descr_ = { "@CoAP_Types.BlockOption", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CoAP__Options
const TTCN_Typedescriptor_t CoAP__Options_descr_ = { "@CoAP_Types.CoAP_Options", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_if__match_xer_ = { {"if_match>\n", "if_match>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_if__match_descr_ = { "@CoAP_Types.CoAP_Options.if_match", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &CoAP__Options_if__match_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_uri__host_xer_ = { {"uri_host>\n", "uri_host>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_uri__host_descr_ = { "@CoAP_Types.CoAP_Options.uri_host", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_uri__host_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_etag_xer_ = { {"etag>\n", "etag>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_etag_descr_ = { "@CoAP_Types.CoAP_Options.etag", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &CoAP__Options_etag_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_if__none__match_xer_ = { {"if_none_match>\n", "if_none_match>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_if__none__match_descr_ = { "@CoAP_Types.CoAP_Options.if_none_match", &OCTETSTRING_ber_, &OCT0_raw_, &OCTETSTRING_text_, &CoAP__Options_if__none__match_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_observe_xer_ = { {"observe>\n", "observe>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_observe_descr_ = { "@CoAP_Types.CoAP_Options.observe", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_observe_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_uri__port_xer_ = { {"uri_port>\n", "uri_port>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_uri__port_descr_ = { "@CoAP_Types.CoAP_Options.uri_port", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_uri__port_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_location__path_xer_ = { {"location_path>\n", "location_path>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_location__path_descr_ = { "@CoAP_Types.CoAP_Options.location_path", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_location__path_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_uri__path_xer_ = { {"uri_path>\n", "uri_path>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_uri__path_descr_ = { "@CoAP_Types.CoAP_Options.uri_path", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_uri__path_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_content__format_xer_ = { {"content_format>\n", "content_format>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_content__format_descr_ = { "@CoAP_Types.CoAP_Options.content_format", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_content__format_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_max__age_xer_ = { {"max_age>\n", "max_age>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_max__age_descr_ = { "@CoAP_Types.CoAP_Options.max_age", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_max__age_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_uri__query_xer_ = { {"uri_query>\n", "uri_query>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_uri__query_descr_ = { "@CoAP_Types.CoAP_Options.uri_query", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_uri__query_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_accept_xer_ = { {"accept>\n", "accept>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_accept_descr_ = { "@CoAP_Types.CoAP_Options.accept", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_accept_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_location__query_xer_ = { {"location_query>\n", "location_query>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_location__query_descr_ = { "@CoAP_Types.CoAP_Options.location_query", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_location__query_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_proxy__uri_xer_ = { {"proxy_uri>\n", "proxy_uri>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_proxy__uri_descr_ = { "@CoAP_Types.CoAP_Options.proxy_uri", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_proxy__uri_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_proxy__scheme_xer_ = { {"proxy_scheme>\n", "proxy_scheme>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_proxy__scheme_descr_ = { "@CoAP_Types.CoAP_Options.proxy_scheme", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_proxy__scheme_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_size1_xer_ = { {"size1>\n", "size1>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_size1_descr_ = { "@CoAP_Types.CoAP_Options.size1", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_size1_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__FR_xer_ = { {"oneM2M_FR>\n", "oneM2M_FR>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__FR_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_FR", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__FR_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__RQI_xer_ = { {"oneM2M_RQI>\n", "oneM2M_RQI>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RQI_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_RQI", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__RQI_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__OT_xer_ = { {"oneM2M_OT>\n", "oneM2M_OT>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__OT_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_OT", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__OT_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__RQET_xer_ = { {"oneM2M_RQET>\n", "oneM2M_RQET>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RQET_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_RQET", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__RQET_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__RSET_xer_ = { {"oneM2M_RSET>\n", "oneM2M_RSET>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RSET_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_RSET", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__RSET_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__OET_xer_ = { {"oneM2M_OET>\n", "oneM2M_OET>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__OET_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_OET", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__OET_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__RTURI_xer_ = { {"oneM2M_RTURI>\n", "oneM2M_RTURI>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RTURI_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_RTURI", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__RTURI_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__EC_xer_ = { {"oneM2M_EC>\n", "oneM2M_EC>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__EC_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_EC", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_oneM2M__EC_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__RSC_xer_ = { {"oneM2M_RSC>\n", "oneM2M_RSC>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RSC_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_RSC", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_oneM2M__RSC_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__GID_xer_ = { {"oneM2M_GID>\n", "oneM2M_GID>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__GID_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_GID", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__GID_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__TY_xer_ = { {"oneM2M_TY>\n", "oneM2M_TY>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__TY_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_TY", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_oneM2M__TY_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__CTO_xer_ = { {"oneM2M_CTO>\n", "oneM2M_CTO>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__CTO_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_CTO", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_oneM2M__CTO_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__CTS_xer_ = { {"oneM2M_CTS>\n", "oneM2M_CTS>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__CTS_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_CTS", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &CoAP__Options_oneM2M__CTS_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Options_oneM2M__ATI_xer_ = { {"oneM2M_ATI>\n", "oneM2M_ATI>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Options_oneM2M__ATI_descr_ = { "@CoAP_Types.CoAP_Options.oneM2M_ATI", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &CoAP__Options_oneM2M__ATI_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Charstring__List
const TTCN_Typedescriptor_t Charstring__List_descr_ = { "@CoAP_Types.Charstring_List", NULL, NULL, NULL, NULL, NULL, &UCHAR0__255_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Charstring__List_0_xer_ = { {"UCHAR0_255>\n", "UCHAR0_255>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Charstring__List_0_descr_ = { "@CoAP_Types.Charstring_List.<oftype>", NULL, &UNIVERSAL_CHARSTRING_raw_, &UNIVERSAL_CHARSTRING_text_, &Charstring__List_0_xer_, &UNIVERSAL_CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CoAP__OptionsList
const TTCN_Typedescriptor_t CoAP__OptionsList_descr_ = { "@CoAP_Types.CoAP_OptionsList", NULL, NULL, NULL, NULL, NULL, &CoAP__Options_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__ReqResp_token_xer_ = { {"token>\n", "token>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__ReqResp_token_descr_ = { "@CoAP_Types.CoAP_ReqResp.token", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &CoAP__ReqResp_token_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CoAP__ReqResp
const TTCN_Typedescriptor_t CoAP__ReqResp_descr_ = { "@CoAP_Types.CoAP_ReqResp", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__ReqResp_payload_xer_ = { {"payload>\n", "payload>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__ReqResp_payload_descr_ = { "@CoAP_Types.CoAP_ReqResp.payload", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &CoAP__ReqResp_payload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CoAP__Message
const TTCN_Typedescriptor_t CoAP__Message_descr_ = { "@CoAP_Types.CoAP_Message", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CoAP__Message_raw__message_xer_ = { {"raw_message>\n", "raw_message>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t CoAP__Message_raw__message_descr_ = { "@CoAP_Types.CoAP_Message.raw_message", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &CoAP__Message_raw__message_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("CoAP_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

Code::Code()
{
}

Code::Code(const INTEGER& par_class_,
    const INTEGER& par_detail)
  :   field_class_(par_class_),
  field_detail(par_detail)
{
}

Code::Code(const Code& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.Code.");
if (other_value.class_().is_bound()) field_class_ = other_value.class_();
else field_class_.clean_up();
if (other_value.detail().is_bound()) field_detail = other_value.detail();
else field_detail.clean_up();
}

void Code::clean_up()
{
field_class_.clean_up();
field_detail.clean_up();
}

Code& Code::operator=(const Code& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CoAP_Types.Code.");
  if (other_value.class_().is_bound()) field_class_ = other_value.class_();
  else field_class_.clean_up();
  if (other_value.detail().is_bound()) field_detail = other_value.detail();
  else field_detail.clean_up();
}
return *this;
}

boolean Code::operator==(const Code& other_value) const
{
return field_class_==other_value.field_class_
  && field_detail==other_value.field_detail;
}

boolean Code::is_bound() const
{
if(field_class_.is_bound()) return TRUE;
if(field_detail.is_bound()) return TRUE;
return FALSE;
}
boolean Code::is_value() const
{
if(!field_class_.is_value()) return FALSE;
if(!field_detail.is_value()) return FALSE;
return TRUE;
}
void Code::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ class := ");
field_class_.log();
TTCN_Logger::log_event_str(", detail := ");
field_detail.log();
TTCN_Logger::log_event_str(" }");
}

void Code::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @CoAP_Types.Code has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) class_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detail().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "class")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          class_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detail")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detail().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.Code: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CoAP_Types.Code");
  }
}

void Code::set_implicit_omit()
{
if (class_().is_bound()) class_().set_implicit_omit();
if (detail().is_bound()) detail().set_implicit_omit();
}

void Code::encode_text(Text_Buf& text_buf) const
{
field_class_.encode_text(text_buf);
field_detail.encode_text(text_buf);
}

void Code::decode_text(Text_Buf& text_buf)
{
field_class_.decode_text(text_buf);
field_detail.decode_text(text_buf);
}

struct Code_template::single_value_struct {
INTEGER_template field_class_;
INTEGER_template field_detail;
};

void Code_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_class_ = ANY_VALUE;
single_value->field_detail = ANY_VALUE;
}
}
}

void Code_template::copy_value(const Code& other_value)
{
single_value = new single_value_struct;
if (other_value.class_().is_bound()) {
  single_value->field_class_ = other_value.class_();
} else {
  single_value->field_class_.clean_up();
}
if (other_value.detail().is_bound()) {
  single_value->field_detail = other_value.detail();
} else {
  single_value->field_detail.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Code_template::copy_template(const Code_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.class_().get_selection()) {
single_value->field_class_ = other_value.class_();
} else {
single_value->field_class_.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.detail().get_selection()) {
single_value->field_detail = other_value.detail();
} else {
single_value->field_detail.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Code_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.Code.");
break;
}
set_selection(other_value);
}

Code_template::Code_template()
{
}

Code_template::Code_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Code_template::Code_template(const Code& other_value)
{
copy_value(other_value);
}

Code_template::Code_template(const OPTIONAL<Code>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Code&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.Code from an unbound optional field.");
}
}

Code_template::Code_template(const Code_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Code_template::~Code_template()
{
clean_up();
}

Code_template& Code_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Code_template& Code_template::operator=(const Code& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Code_template& Code_template::operator=(const OPTIONAL<Code>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Code&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.Code.");
}
return *this;
}

Code_template& Code_template::operator=(const Code_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Code_template::match(const Code& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.class_().is_bound()) return FALSE;
if(!single_value->field_class_.match(other_value.class_(), legacy))return FALSE;
if(!other_value.detail().is_bound()) return FALSE;
if(!single_value->field_detail.match(other_value.detail(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CoAP_Types.Code.");
}
return FALSE;
}

boolean Code_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_class_.is_bound()) return TRUE;
if (single_value->field_detail.is_bound()) return TRUE;
return FALSE;
}

boolean Code_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_class_.is_value()) return FALSE;
if (!single_value->field_detail.is_value()) return FALSE;
return TRUE;
}

void Code_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Code Code_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.Code.");
Code ret_val;
if (single_value->field_class_.is_bound()) {
ret_val.class_() = single_value->field_class_.valueof();
}
if (single_value->field_detail.is_bound()) {
ret_val.detail() = single_value->field_detail.valueof();
}
return ret_val;
}

void Code_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CoAP_Types.Code.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Code_template[list_length];
}

Code_template& Code_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CoAP_Types.Code.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CoAP_Types.Code.");
return value_list.list_value[list_index];
}

INTEGER_template& Code_template::class_()
{
set_specific();
return single_value->field_class_;
}

const INTEGER_template& Code_template::class_() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field class of a non-specific template of type @CoAP_Types.Code.");
return single_value->field_class_;
}

INTEGER_template& Code_template::detail()
{
set_specific();
return single_value->field_detail;
}

const INTEGER_template& Code_template::detail() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field detail of a non-specific template of type @CoAP_Types.Code.");
return single_value->field_detail;
}

int Code_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Code which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CoAP_Types.Code containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Code containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Code containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Code containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Code containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CoAP_Types.Code.");
  }
  return 0;
}

void Code_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ class := ");
single_value->field_class_.log();
TTCN_Logger::log_event_str(", detail := ");
single_value->field_detail.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Code_template::log_match(const Code& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_class_.match(match_value.class_(), legacy)){
TTCN_Logger::log_logmatch_info(".class");
single_value->field_class_.log_match(match_value.class_(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_detail.match(match_value.detail(), legacy)){
TTCN_Logger::log_logmatch_info(".detail");
single_value->field_detail.log_match(match_value.detail(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ class := ");
single_value->field_class_.log_match(match_value.class_(), legacy);
TTCN_Logger::log_event_str(", detail := ");
single_value->field_detail.log_match(match_value.detail(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Code_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_class_.encode_text(text_buf);
single_value->field_detail.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.Code.");
}
}

void Code_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_class_.decode_text(text_buf);
single_value->field_detail.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Code_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CoAP_Types.Code.");
}
}

void Code_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Code_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @CoAP_Types.Code has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) class_().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detail().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "class")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          class_().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detail")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detail().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.Code: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CoAP_Types.Code");
  }
  is_ifpresent = param.get_ifpresent();
}

void Code_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_class_.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Code");
single_value->field_detail.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Code");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.Code");
}

boolean Code_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Code_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Type::Type()
{
enum_value = UNBOUND_VALUE;
}

Type::Type(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @CoAP_Types.Type with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

Type::Type(enum_type other_value)
{
enum_value = other_value;
}

Type::Type(const Type& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @CoAP_Types.Type.");
enum_value = other_value.enum_value;
}

Type& Type::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @CoAP_Types.Type.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

Type& Type::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

Type& Type::operator=(const Type& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @CoAP_Types.Type.");
enum_value = other_value.enum_value;
return *this;
}

boolean Type::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value == other_value;
}

boolean Type::operator==(const Type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value == other_value.enum_value;
}

boolean Type::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value < other_value;
}

boolean Type::operator<(const Type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value < other_value.enum_value;
}

boolean Type::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value > other_value;
}

boolean Type::operator>(const Type& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @CoAP_Types.Type.");
return enum_value > other_value.enum_value;
}

const char *Type::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case CONFIRMABLE: return "CONFIRMABLE";
case NON__CONFIRMABLE: return "NON_CONFIRMABLE";
case ACKNOWLEDGEMENT: return "ACKNOWLEDGEMENT";
case RESET: return "RESET";
default: return "<unknown>";
}
}

Type::enum_type Type::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "CONFIRMABLE")) return CONFIRMABLE;
else if (!strcmp(str_par, "NON_CONFIRMABLE")) return NON__CONFIRMABLE;
else if (!strcmp(str_par, "ACKNOWLEDGEMENT")) return ACKNOWLEDGEMENT;
else if (!strcmp(str_par, "RESET")) return RESET;
else return UNKNOWN_VALUE;
}

boolean Type::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int Type::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @CoAP_Types.Type.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int Type::enum2int(const Type& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @CoAP_Types.Type.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void Type::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @CoAP_Types.Type.", int_val);
enum_value = (enum_type)int_val;
}

Type::operator Type::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @CoAP_Types.Type.");
return enum_value;
}

void Type::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void Type::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@CoAP_Types.Type");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @CoAP_Types.Type.");
  }
}

void Type::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @CoAP_Types.Type.");
text_buf.push_int(enum_value);
}

void Type::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @CoAP_Types.Type.", enum_value);
}

void Type_template::copy_template(const Type_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Type_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @CoAP_Types.Type.");
}
}

Type_template::Type_template()
{
}

Type_template::Type_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Type_template::Type_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!Type::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @CoAP_Types.Type with unknown numeric value %d.", other_value);
single_value = (Type::enum_type)other_value;
}

Type_template::Type_template(Type::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

Type_template::Type_template(const Type& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == Type::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @CoAP_Types.Type.");
single_value = other_value.enum_value;
}

Type_template::Type_template(const OPTIONAL<Type>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Type::enum_type)(const Type&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @CoAP_Types.Type from an unbound optional field.");
}
}

Type_template::Type_template(const Type_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

Type_template::~Type_template()
{
clean_up();
}

boolean Type_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean Type_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != Type::UNBOUND_VALUE;
}

void Type_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

Type_template& Type_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Type_template& Type_template::operator=(int other_value)
{
if (!Type::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @CoAP_Types.Type.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (Type::enum_type)other_value;
return *this;
}

Type_template& Type_template::operator=(Type::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

Type_template& Type_template::operator=(const Type& other_value)
{
if (other_value.enum_value == Type::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @CoAP_Types.Type to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

Type_template& Type_template::operator=(const OPTIONAL<Type>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Type::enum_type)(const Type&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @CoAP_Types.Type.");
}
return *this;
}

Type_template& Type_template::operator=(const Type_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Type_template::match(Type::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @CoAP_Types.Type.");
}
return FALSE;
}

boolean Type_template::match(const Type& other_value, boolean) const
{
if (other_value.enum_value == Type::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @CoAP_Types.Type with an unbound value.");
return match(other_value.enum_value);
}

Type::enum_type Type_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @CoAP_Types.Type.");
return single_value;
}

void Type_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @CoAP_Types.Type.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Type_template[list_length];
}

Type_template& Type_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @CoAP_Types.Type.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @CoAP_Types.Type.");
return value_list.list_value[list_index];
}

void Type_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(Type::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Type_template::log_match(const Type& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void Type_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @CoAP_Types.Type.");
}
}

void Type_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (Type::enum_type)text_buf.pull_int().get_val();
if (!Type::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @CoAP_Types.Type.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Type_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @CoAP_Types.Type.");
}
}

boolean Type_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Type_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Type_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Type_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    Type::enum_type enum_val = Type::str_to_enum(m_p->get_enumerated());
    if (!Type::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @CoAP_Types.Type.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@CoAP_Types.Type");
  }
  is_ifpresent = param.get_ifpresent();
}

void Type_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.Type");
}

Header::Header()
{
}

Header::Header(const INTEGER& par_version,
    const Type& par_msg__type,
    const Code& par_code,
    const INTEGER& par_message__id)
  :   field_version(par_version),
  field_msg__type(par_msg__type),
  field_code(par_code),
  field_message__id(par_message__id)
{
}

Header::Header(const Header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.Header.");
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
else field_msg__type.clean_up();
if (other_value.code().is_bound()) field_code = other_value.code();
else field_code.clean_up();
if (other_value.message__id().is_bound()) field_message__id = other_value.message__id();
else field_message__id.clean_up();
}

void Header::clean_up()
{
field_version.clean_up();
field_msg__type.clean_up();
field_code.clean_up();
field_message__id.clean_up();
}

Header& Header::operator=(const Header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CoAP_Types.Header.");
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.msg__type().is_bound()) field_msg__type = other_value.msg__type();
  else field_msg__type.clean_up();
  if (other_value.code().is_bound()) field_code = other_value.code();
  else field_code.clean_up();
  if (other_value.message__id().is_bound()) field_message__id = other_value.message__id();
  else field_message__id.clean_up();
}
return *this;
}

boolean Header::operator==(const Header& other_value) const
{
return field_version==other_value.field_version
  && field_msg__type==other_value.field_msg__type
  && field_code==other_value.field_code
  && field_message__id==other_value.field_message__id;
}

boolean Header::is_bound() const
{
if(field_version.is_bound()) return TRUE;
if(field_msg__type.is_bound()) return TRUE;
if(field_code.is_bound()) return TRUE;
if(field_message__id.is_bound()) return TRUE;
return FALSE;
}
boolean Header::is_value() const
{
if(!field_version.is_value()) return FALSE;
if(!field_msg__type.is_value()) return FALSE;
if(!field_code.is_value()) return FALSE;
if(!field_message__id.is_value()) return FALSE;
return TRUE;
}
void Header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", msg_type := ");
field_msg__type.log();
TTCN_Logger::log_event_str(", code := ");
field_code.log();
TTCN_Logger::log_event_str(", message_id := ");
field_message__id.log();
TTCN_Logger::log_event_str(" }");
}

void Header::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @CoAP_Types.Header has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) message__id().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "message_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          message__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.Header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CoAP_Types.Header");
  }
}

void Header::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (msg__type().is_bound()) msg__type().set_implicit_omit();
if (code().is_bound()) code().set_implicit_omit();
if (message__id().is_bound()) message__id().set_implicit_omit();
}

void Header::encode_text(Text_Buf& text_buf) const
{
field_version.encode_text(text_buf);
field_msg__type.encode_text(text_buf);
field_code.encode_text(text_buf);
field_message__id.encode_text(text_buf);
}

void Header::decode_text(Text_Buf& text_buf)
{
field_version.decode_text(text_buf);
field_msg__type.decode_text(text_buf);
field_code.decode_text(text_buf);
field_message__id.decode_text(text_buf);
}

struct Header_template::single_value_struct {
INTEGER_template field_version;
Type_template field_msg__type;
Code_template field_code;
INTEGER_template field_message__id;
};

void Header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_msg__type = ANY_VALUE;
single_value->field_code = ANY_VALUE;
single_value->field_message__id = ANY_VALUE;
}
}
}

void Header_template::copy_value(const Header& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.msg__type().is_bound()) {
  single_value->field_msg__type = other_value.msg__type();
} else {
  single_value->field_msg__type.clean_up();
}
if (other_value.code().is_bound()) {
  single_value->field_code = other_value.code();
} else {
  single_value->field_code.clean_up();
}
if (other_value.message__id().is_bound()) {
  single_value->field_message__id = other_value.message__id();
} else {
  single_value->field_message__id.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Header_template::copy_template(const Header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msg__type().get_selection()) {
single_value->field_msg__type = other_value.msg__type();
} else {
single_value->field_msg__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.code().get_selection()) {
single_value->field_code = other_value.code();
} else {
single_value->field_code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.message__id().get_selection()) {
single_value->field_message__id = other_value.message__id();
} else {
single_value->field_message__id.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.Header.");
break;
}
set_selection(other_value);
}

Header_template::Header_template()
{
}

Header_template::Header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Header_template::Header_template(const Header& other_value)
{
copy_value(other_value);
}

Header_template::Header_template(const OPTIONAL<Header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.Header from an unbound optional field.");
}
}

Header_template::Header_template(const Header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Header_template::~Header_template()
{
clean_up();
}

Header_template& Header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Header_template& Header_template::operator=(const Header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Header_template& Header_template::operator=(const OPTIONAL<Header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.Header.");
}
return *this;
}

Header_template& Header_template::operator=(const Header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Header_template::match(const Header& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.msg__type().is_bound()) return FALSE;
if(!single_value->field_msg__type.match(other_value.msg__type(), legacy))return FALSE;
if(!other_value.code().is_bound()) return FALSE;
if(!single_value->field_code.match(other_value.code(), legacy))return FALSE;
if(!other_value.message__id().is_bound()) return FALSE;
if(!single_value->field_message__id.match(other_value.message__id(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CoAP_Types.Header.");
}
return FALSE;
}

boolean Header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_msg__type.is_bound()) return TRUE;
if (single_value->field_code.is_bound()) return TRUE;
if (single_value->field_message__id.is_bound()) return TRUE;
return FALSE;
}

boolean Header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_msg__type.is_value()) return FALSE;
if (!single_value->field_code.is_value()) return FALSE;
if (!single_value->field_message__id.is_value()) return FALSE;
return TRUE;
}

void Header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Header Header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.Header.");
Header ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_msg__type.is_bound()) {
ret_val.msg__type() = single_value->field_msg__type.valueof();
}
if (single_value->field_code.is_bound()) {
ret_val.code() = single_value->field_code.valueof();
}
if (single_value->field_message__id.is_bound()) {
ret_val.message__id() = single_value->field_message__id.valueof();
}
return ret_val;
}

void Header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CoAP_Types.Header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Header_template[list_length];
}

Header_template& Header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CoAP_Types.Header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CoAP_Types.Header.");
return value_list.list_value[list_index];
}

INTEGER_template& Header_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& Header_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @CoAP_Types.Header.");
return single_value->field_version;
}

Type_template& Header_template::msg__type()
{
set_specific();
return single_value->field_msg__type;
}

const Type_template& Header_template::msg__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg_type of a non-specific template of type @CoAP_Types.Header.");
return single_value->field_msg__type;
}

Code_template& Header_template::code()
{
set_specific();
return single_value->field_code;
}

const Code_template& Header_template::code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field code of a non-specific template of type @CoAP_Types.Header.");
return single_value->field_code;
}

INTEGER_template& Header_template::message__id()
{
set_specific();
return single_value->field_message__id;
}

const INTEGER_template& Header_template::message__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field message_id of a non-specific template of type @CoAP_Types.Header.");
return single_value->field_message__id;
}

int Header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CoAP_Types.Header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.Header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CoAP_Types.Header.");
  }
  return 0;
}

void Header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", msg_type := ");
single_value->field_msg__type.log();
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log();
TTCN_Logger::log_event_str(", message_id := ");
single_value->field_message__id.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Header_template::log_match(const Header& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_msg__type.match(match_value.msg__type(), legacy)){
TTCN_Logger::log_logmatch_info(".msg_type");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_code.match(match_value.code(), legacy)){
TTCN_Logger::log_logmatch_info(".code");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_message__id.match(match_value.message__id(), legacy)){
TTCN_Logger::log_logmatch_info(".message_id");
single_value->field_message__id.log_match(match_value.message__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", msg_type := ");
single_value->field_msg__type.log_match(match_value.msg__type(), legacy);
TTCN_Logger::log_event_str(", code := ");
single_value->field_code.log_match(match_value.code(), legacy);
TTCN_Logger::log_event_str(", message_id := ");
single_value->field_message__id.log_match(match_value.message__id(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_msg__type.encode_text(text_buf);
single_value->field_code.encode_text(text_buf);
single_value->field_message__id.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.Header.");
}
}

void Header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_msg__type.decode_text(text_buf);
single_value->field_code.decode_text(text_buf);
single_value->field_message__id.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CoAP_Types.Header.");
}
}

void Header_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Header_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @CoAP_Types.Header has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) msg__type().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) code().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) message__id().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg__type().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "message_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          message__id().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.Header: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CoAP_Types.Header");
  }
  is_ifpresent = param.get_ifpresent();
}

void Header_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Header");
single_value->field_msg__type.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Header");
single_value->field_code.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Header");
single_value->field_message__id.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.Header");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.Header");
}

boolean Header_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Header_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UnknownOption::UnknownOption()
{
}

UnknownOption::UnknownOption(const INTEGER& par_option__code,
    const OCTETSTRING& par_option__value)
  :   field_option__code(par_option__code),
  field_option__value(par_option__value)
{
}

UnknownOption::UnknownOption(const UnknownOption& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.UnknownOption.");
if (other_value.option__code().is_bound()) field_option__code = other_value.option__code();
else field_option__code.clean_up();
if (other_value.option__value().is_bound()) field_option__value = other_value.option__value();
else field_option__value.clean_up();
}

void UnknownOption::clean_up()
{
field_option__code.clean_up();
field_option__value.clean_up();
}

UnknownOption& UnknownOption::operator=(const UnknownOption& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CoAP_Types.UnknownOption.");
  if (other_value.option__code().is_bound()) field_option__code = other_value.option__code();
  else field_option__code.clean_up();
  if (other_value.option__value().is_bound()) field_option__value = other_value.option__value();
  else field_option__value.clean_up();
}
return *this;
}

boolean UnknownOption::operator==(const UnknownOption& other_value) const
{
return field_option__code==other_value.field_option__code
  && field_option__value==other_value.field_option__value;
}

boolean UnknownOption::is_bound() const
{
if(field_option__code.is_bound()) return TRUE;
if(field_option__value.is_bound()) return TRUE;
return FALSE;
}
boolean UnknownOption::is_value() const
{
if(!field_option__code.is_value()) return FALSE;
if(!field_option__value.is_value()) return FALSE;
return TRUE;
}
void UnknownOption::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ option_code := ");
field_option__code.log();
TTCN_Logger::log_event_str(", option_value := ");
field_option__value.log();
TTCN_Logger::log_event_str(" }");
}

void UnknownOption::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @CoAP_Types.UnknownOption has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) option__code().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) option__value().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "option_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          option__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "option_value")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          option__value().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.UnknownOption: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CoAP_Types.UnknownOption");
  }
}

void UnknownOption::set_implicit_omit()
{
if (option__code().is_bound()) option__code().set_implicit_omit();
if (option__value().is_bound()) option__value().set_implicit_omit();
}

void UnknownOption::encode_text(Text_Buf& text_buf) const
{
field_option__code.encode_text(text_buf);
field_option__value.encode_text(text_buf);
}

void UnknownOption::decode_text(Text_Buf& text_buf)
{
field_option__code.decode_text(text_buf);
field_option__value.decode_text(text_buf);
}

struct UnknownOption_template::single_value_struct {
INTEGER_template field_option__code;
OCTETSTRING_template field_option__value;
};

void UnknownOption_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_option__code = ANY_VALUE;
single_value->field_option__value = ANY_VALUE;
}
}
}

void UnknownOption_template::copy_value(const UnknownOption& other_value)
{
single_value = new single_value_struct;
if (other_value.option__code().is_bound()) {
  single_value->field_option__code = other_value.option__code();
} else {
  single_value->field_option__code.clean_up();
}
if (other_value.option__value().is_bound()) {
  single_value->field_option__value = other_value.option__value();
} else {
  single_value->field_option__value.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UnknownOption_template::copy_template(const UnknownOption_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.option__code().get_selection()) {
single_value->field_option__code = other_value.option__code();
} else {
single_value->field_option__code.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.option__value().get_selection()) {
single_value->field_option__value = other_value.option__value();
} else {
single_value->field_option__value.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UnknownOption_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.UnknownOption.");
break;
}
set_selection(other_value);
}

UnknownOption_template::UnknownOption_template()
{
}

UnknownOption_template::UnknownOption_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UnknownOption_template::UnknownOption_template(const UnknownOption& other_value)
{
copy_value(other_value);
}

UnknownOption_template::UnknownOption_template(const OPTIONAL<UnknownOption>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UnknownOption&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.UnknownOption from an unbound optional field.");
}
}

UnknownOption_template::UnknownOption_template(const UnknownOption_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UnknownOption_template::~UnknownOption_template()
{
clean_up();
}

UnknownOption_template& UnknownOption_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UnknownOption_template& UnknownOption_template::operator=(const UnknownOption& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UnknownOption_template& UnknownOption_template::operator=(const OPTIONAL<UnknownOption>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UnknownOption&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.UnknownOption.");
}
return *this;
}

UnknownOption_template& UnknownOption_template::operator=(const UnknownOption_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UnknownOption_template::match(const UnknownOption& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.option__code().is_bound()) return FALSE;
if(!single_value->field_option__code.match(other_value.option__code(), legacy))return FALSE;
if(!other_value.option__value().is_bound()) return FALSE;
if(!single_value->field_option__value.match(other_value.option__value(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CoAP_Types.UnknownOption.");
}
return FALSE;
}

boolean UnknownOption_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_option__code.is_bound()) return TRUE;
if (single_value->field_option__value.is_bound()) return TRUE;
return FALSE;
}

boolean UnknownOption_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_option__code.is_value()) return FALSE;
if (!single_value->field_option__value.is_value()) return FALSE;
return TRUE;
}

void UnknownOption_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UnknownOption UnknownOption_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.UnknownOption.");
UnknownOption ret_val;
if (single_value->field_option__code.is_bound()) {
ret_val.option__code() = single_value->field_option__code.valueof();
}
if (single_value->field_option__value.is_bound()) {
ret_val.option__value() = single_value->field_option__value.valueof();
}
return ret_val;
}

void UnknownOption_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CoAP_Types.UnknownOption.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UnknownOption_template[list_length];
}

UnknownOption_template& UnknownOption_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CoAP_Types.UnknownOption.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CoAP_Types.UnknownOption.");
return value_list.list_value[list_index];
}

INTEGER_template& UnknownOption_template::option__code()
{
set_specific();
return single_value->field_option__code;
}

const INTEGER_template& UnknownOption_template::option__code() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field option_code of a non-specific template of type @CoAP_Types.UnknownOption.");
return single_value->field_option__code;
}

OCTETSTRING_template& UnknownOption_template::option__value()
{
set_specific();
return single_value->field_option__value;
}

const OCTETSTRING_template& UnknownOption_template::option__value() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field option_value of a non-specific template of type @CoAP_Types.UnknownOption.");
return single_value->field_option__value;
}

int UnknownOption_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.UnknownOption containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CoAP_Types.UnknownOption.");
  }
  return 0;
}

void UnknownOption_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ option_code := ");
single_value->field_option__code.log();
TTCN_Logger::log_event_str(", option_value := ");
single_value->field_option__value.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UnknownOption_template::log_match(const UnknownOption& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_option__code.match(match_value.option__code(), legacy)){
TTCN_Logger::log_logmatch_info(".option_code");
single_value->field_option__code.log_match(match_value.option__code(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_option__value.match(match_value.option__value(), legacy)){
TTCN_Logger::log_logmatch_info(".option_value");
single_value->field_option__value.log_match(match_value.option__value(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ option_code := ");
single_value->field_option__code.log_match(match_value.option__code(), legacy);
TTCN_Logger::log_event_str(", option_value := ");
single_value->field_option__value.log_match(match_value.option__value(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UnknownOption_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_option__code.encode_text(text_buf);
single_value->field_option__value.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.UnknownOption.");
}
}

void UnknownOption_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_option__code.decode_text(text_buf);
single_value->field_option__value.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UnknownOption_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CoAP_Types.UnknownOption.");
}
}

void UnknownOption_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UnknownOption_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @CoAP_Types.UnknownOption has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) option__code().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) option__value().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "option_code")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          option__code().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "option_value")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          option__value().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.UnknownOption: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CoAP_Types.UnknownOption");
  }
  is_ifpresent = param.get_ifpresent();
}

void UnknownOption_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_option__code.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.UnknownOption");
single_value->field_option__value.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.UnknownOption");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.UnknownOption");
}

boolean UnknownOption_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UnknownOption_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BlockOption::BlockOption()
{
}

BlockOption::BlockOption(const INTEGER& par_num,
    const BOOLEAN& par_m,
    const INTEGER& par_szx)
  :   field_num(par_num),
  field_m(par_m),
  field_szx(par_szx)
{
}

BlockOption::BlockOption(const BlockOption& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.BlockOption.");
if (other_value.num().is_bound()) field_num = other_value.num();
else field_num.clean_up();
if (other_value.m().is_bound()) field_m = other_value.m();
else field_m.clean_up();
if (other_value.szx().is_bound()) field_szx = other_value.szx();
else field_szx.clean_up();
}

void BlockOption::clean_up()
{
field_num.clean_up();
field_m.clean_up();
field_szx.clean_up();
}

BlockOption& BlockOption::operator=(const BlockOption& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CoAP_Types.BlockOption.");
  if (other_value.num().is_bound()) field_num = other_value.num();
  else field_num.clean_up();
  if (other_value.m().is_bound()) field_m = other_value.m();
  else field_m.clean_up();
  if (other_value.szx().is_bound()) field_szx = other_value.szx();
  else field_szx.clean_up();
}
return *this;
}

boolean BlockOption::operator==(const BlockOption& other_value) const
{
return field_num==other_value.field_num
  && field_m==other_value.field_m
  && field_szx==other_value.field_szx;
}

boolean BlockOption::is_bound() const
{
if(field_num.is_bound()) return TRUE;
if(field_m.is_bound()) return TRUE;
if(field_szx.is_bound()) return TRUE;
return FALSE;
}
boolean BlockOption::is_value() const
{
if(!field_num.is_value()) return FALSE;
if(!field_m.is_value()) return FALSE;
if(!field_szx.is_value()) return FALSE;
return TRUE;
}
void BlockOption::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ num := ");
field_num.log();
TTCN_Logger::log_event_str(", m := ");
field_m.log();
TTCN_Logger::log_event_str(", szx := ");
field_szx.log();
TTCN_Logger::log_event_str(" }");
}

void BlockOption::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @CoAP_Types.BlockOption has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) num().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) m().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) szx().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "num")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          num().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "m")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          m().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "szx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          szx().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.BlockOption: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CoAP_Types.BlockOption");
  }
}

void BlockOption::set_implicit_omit()
{
if (num().is_bound()) num().set_implicit_omit();
if (m().is_bound()) m().set_implicit_omit();
if (szx().is_bound()) szx().set_implicit_omit();
}

void BlockOption::encode_text(Text_Buf& text_buf) const
{
field_num.encode_text(text_buf);
field_m.encode_text(text_buf);
field_szx.encode_text(text_buf);
}

void BlockOption::decode_text(Text_Buf& text_buf)
{
field_num.decode_text(text_buf);
field_m.decode_text(text_buf);
field_szx.decode_text(text_buf);
}

struct BlockOption_template::single_value_struct {
INTEGER_template field_num;
BOOLEAN_template field_m;
INTEGER_template field_szx;
};

void BlockOption_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_num = ANY_VALUE;
single_value->field_m = ANY_VALUE;
single_value->field_szx = ANY_VALUE;
}
}
}

void BlockOption_template::copy_value(const BlockOption& other_value)
{
single_value = new single_value_struct;
if (other_value.num().is_bound()) {
  single_value->field_num = other_value.num();
} else {
  single_value->field_num.clean_up();
}
if (other_value.m().is_bound()) {
  single_value->field_m = other_value.m();
} else {
  single_value->field_m.clean_up();
}
if (other_value.szx().is_bound()) {
  single_value->field_szx = other_value.szx();
} else {
  single_value->field_szx.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BlockOption_template::copy_template(const BlockOption_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.num().get_selection()) {
single_value->field_num = other_value.num();
} else {
single_value->field_num.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.m().get_selection()) {
single_value->field_m = other_value.m();
} else {
single_value->field_m.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.szx().get_selection()) {
single_value->field_szx = other_value.szx();
} else {
single_value->field_szx.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BlockOption_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.BlockOption.");
break;
}
set_selection(other_value);
}

BlockOption_template::BlockOption_template()
{
}

BlockOption_template::BlockOption_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BlockOption_template::BlockOption_template(const BlockOption& other_value)
{
copy_value(other_value);
}

BlockOption_template::BlockOption_template(const OPTIONAL<BlockOption>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BlockOption&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.BlockOption from an unbound optional field.");
}
}

BlockOption_template::BlockOption_template(const BlockOption_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BlockOption_template::~BlockOption_template()
{
clean_up();
}

BlockOption_template& BlockOption_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BlockOption_template& BlockOption_template::operator=(const BlockOption& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BlockOption_template& BlockOption_template::operator=(const OPTIONAL<BlockOption>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BlockOption&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.BlockOption.");
}
return *this;
}

BlockOption_template& BlockOption_template::operator=(const BlockOption_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BlockOption_template::match(const BlockOption& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.num().is_bound()) return FALSE;
if(!single_value->field_num.match(other_value.num(), legacy))return FALSE;
if(!other_value.m().is_bound()) return FALSE;
if(!single_value->field_m.match(other_value.m(), legacy))return FALSE;
if(!other_value.szx().is_bound()) return FALSE;
if(!single_value->field_szx.match(other_value.szx(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CoAP_Types.BlockOption.");
}
return FALSE;
}

boolean BlockOption_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_num.is_bound()) return TRUE;
if (single_value->field_m.is_bound()) return TRUE;
if (single_value->field_szx.is_bound()) return TRUE;
return FALSE;
}

boolean BlockOption_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_num.is_value()) return FALSE;
if (!single_value->field_m.is_value()) return FALSE;
if (!single_value->field_szx.is_value()) return FALSE;
return TRUE;
}

void BlockOption_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BlockOption BlockOption_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.BlockOption.");
BlockOption ret_val;
if (single_value->field_num.is_bound()) {
ret_val.num() = single_value->field_num.valueof();
}
if (single_value->field_m.is_bound()) {
ret_val.m() = single_value->field_m.valueof();
}
if (single_value->field_szx.is_bound()) {
ret_val.szx() = single_value->field_szx.valueof();
}
return ret_val;
}

void BlockOption_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CoAP_Types.BlockOption.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BlockOption_template[list_length];
}

BlockOption_template& BlockOption_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CoAP_Types.BlockOption.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CoAP_Types.BlockOption.");
return value_list.list_value[list_index];
}

INTEGER_template& BlockOption_template::num()
{
set_specific();
return single_value->field_num;
}

const INTEGER_template& BlockOption_template::num() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field num of a non-specific template of type @CoAP_Types.BlockOption.");
return single_value->field_num;
}

BOOLEAN_template& BlockOption_template::m()
{
set_specific();
return single_value->field_m;
}

const BOOLEAN_template& BlockOption_template::m() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field m of a non-specific template of type @CoAP_Types.BlockOption.");
return single_value->field_m;
}

INTEGER_template& BlockOption_template::szx()
{
set_specific();
return single_value->field_szx;
}

const INTEGER_template& BlockOption_template::szx() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field szx of a non-specific template of type @CoAP_Types.BlockOption.");
return single_value->field_szx;
}

int BlockOption_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.BlockOption which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CoAP_Types.BlockOption containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.BlockOption containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.BlockOption containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.BlockOption containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.BlockOption containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CoAP_Types.BlockOption.");
  }
  return 0;
}

void BlockOption_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ num := ");
single_value->field_num.log();
TTCN_Logger::log_event_str(", m := ");
single_value->field_m.log();
TTCN_Logger::log_event_str(", szx := ");
single_value->field_szx.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BlockOption_template::log_match(const BlockOption& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_num.match(match_value.num(), legacy)){
TTCN_Logger::log_logmatch_info(".num");
single_value->field_num.log_match(match_value.num(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_m.match(match_value.m(), legacy)){
TTCN_Logger::log_logmatch_info(".m");
single_value->field_m.log_match(match_value.m(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_szx.match(match_value.szx(), legacy)){
TTCN_Logger::log_logmatch_info(".szx");
single_value->field_szx.log_match(match_value.szx(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ num := ");
single_value->field_num.log_match(match_value.num(), legacy);
TTCN_Logger::log_event_str(", m := ");
single_value->field_m.log_match(match_value.m(), legacy);
TTCN_Logger::log_event_str(", szx := ");
single_value->field_szx.log_match(match_value.szx(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BlockOption_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_num.encode_text(text_buf);
single_value->field_m.encode_text(text_buf);
single_value->field_szx.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.BlockOption.");
}
}

void BlockOption_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_num.decode_text(text_buf);
single_value->field_m.decode_text(text_buf);
single_value->field_szx.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BlockOption_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CoAP_Types.BlockOption.");
}
}

void BlockOption_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BlockOption_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @CoAP_Types.BlockOption has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) num().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) m().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) szx().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "num")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          num().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "m")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          m().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "szx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          szx().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.BlockOption: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CoAP_Types.BlockOption");
  }
  is_ifpresent = param.get_ifpresent();
}

void BlockOption_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_num.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.BlockOption");
single_value->field_m.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.BlockOption");
single_value->field_szx.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.BlockOption");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.BlockOption");
}

boolean BlockOption_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BlockOption_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CoAP__Options::copy_value(const CoAP__Options& other_value)
{
switch (other_value.union_selection) {
case ALT_if__match:
field_if__match = new OCTETSTRING(*other_value.field_if__match);
break;
case ALT_uri__host:
field_uri__host = new UNIVERSAL_CHARSTRING(*other_value.field_uri__host);
break;
case ALT_etag:
field_etag = new OCTETSTRING(*other_value.field_etag);
break;
case ALT_if__none__match:
field_if__none__match = new OCTETSTRING(*other_value.field_if__none__match);
break;
case ALT_observe:
field_observe = new INTEGER(*other_value.field_observe);
break;
case ALT_uri__port:
field_uri__port = new INTEGER(*other_value.field_uri__port);
break;
case ALT_location__path:
field_location__path = new UNIVERSAL_CHARSTRING(*other_value.field_location__path);
break;
case ALT_uri__path:
field_uri__path = new UNIVERSAL_CHARSTRING(*other_value.field_uri__path);
break;
case ALT_content__format:
field_content__format = new INTEGER(*other_value.field_content__format);
break;
case ALT_max__age:
field_max__age = new INTEGER(*other_value.field_max__age);
break;
case ALT_uri__query:
field_uri__query = new UNIVERSAL_CHARSTRING(*other_value.field_uri__query);
break;
case ALT_accept:
field_accept = new INTEGER(*other_value.field_accept);
break;
case ALT_location__query:
field_location__query = new UNIVERSAL_CHARSTRING(*other_value.field_location__query);
break;
case ALT_block1:
field_block1 = new BlockOption(*other_value.field_block1);
break;
case ALT_block2:
field_block2 = new BlockOption(*other_value.field_block2);
break;
case ALT_proxy__uri:
field_proxy__uri = new UNIVERSAL_CHARSTRING(*other_value.field_proxy__uri);
break;
case ALT_proxy__scheme:
field_proxy__scheme = new UNIVERSAL_CHARSTRING(*other_value.field_proxy__scheme);
break;
case ALT_size1:
field_size1 = new INTEGER(*other_value.field_size1);
break;
case ALT_unknown__option:
field_unknown__option = new UnknownOption(*other_value.field_unknown__option);
break;
case ALT_oneM2M__FR:
field_oneM2M__FR = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__FR);
break;
case ALT_oneM2M__RQI:
field_oneM2M__RQI = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__RQI);
break;
case ALT_oneM2M__OT:
field_oneM2M__OT = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__OT);
break;
case ALT_oneM2M__RQET:
field_oneM2M__RQET = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__RQET);
break;
case ALT_oneM2M__RSET:
field_oneM2M__RSET = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__RSET);
break;
case ALT_oneM2M__OET:
field_oneM2M__OET = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__OET);
break;
case ALT_oneM2M__RTURI:
field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__RTURI);
break;
case ALT_oneM2M__EC:
field_oneM2M__EC = new INTEGER(*other_value.field_oneM2M__EC);
break;
case ALT_oneM2M__RSC:
field_oneM2M__RSC = new INTEGER(*other_value.field_oneM2M__RSC);
break;
case ALT_oneM2M__GID:
field_oneM2M__GID = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__GID);
break;
case ALT_oneM2M__TY:
field_oneM2M__TY = new INTEGER(*other_value.field_oneM2M__TY);
break;
case ALT_oneM2M__CTO:
field_oneM2M__CTO = new INTEGER(*other_value.field_oneM2M__CTO);
break;
case ALT_oneM2M__CTS:
field_oneM2M__CTS = new INTEGER(*other_value.field_oneM2M__CTS);
break;
case ALT_oneM2M__ATI:
field_oneM2M__ATI = new UNIVERSAL_CHARSTRING(*other_value.field_oneM2M__ATI);
break;
default:
TTCN_error("Assignment of an unbound union value of type @CoAP_Types.CoAP_Options.");
}
union_selection = other_value.union_selection;
}

CoAP__Options::CoAP__Options()
{
union_selection = UNBOUND_VALUE;
}

CoAP__Options::CoAP__Options(const CoAP__Options& other_value)
: Base_Type(){
copy_value(other_value);
}

CoAP__Options::~CoAP__Options()
{
clean_up();
}

CoAP__Options& CoAP__Options::operator=(const CoAP__Options& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean CoAP__Options::operator==(const CoAP__Options& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @CoAP_Types.CoAP_Options.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @CoAP_Types.CoAP_Options.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_if__match:
return *field_if__match == *other_value.field_if__match;
case ALT_uri__host:
return *field_uri__host == *other_value.field_uri__host;
case ALT_etag:
return *field_etag == *other_value.field_etag;
case ALT_if__none__match:
return *field_if__none__match == *other_value.field_if__none__match;
case ALT_observe:
return *field_observe == *other_value.field_observe;
case ALT_uri__port:
return *field_uri__port == *other_value.field_uri__port;
case ALT_location__path:
return *field_location__path == *other_value.field_location__path;
case ALT_uri__path:
return *field_uri__path == *other_value.field_uri__path;
case ALT_content__format:
return *field_content__format == *other_value.field_content__format;
case ALT_max__age:
return *field_max__age == *other_value.field_max__age;
case ALT_uri__query:
return *field_uri__query == *other_value.field_uri__query;
case ALT_accept:
return *field_accept == *other_value.field_accept;
case ALT_location__query:
return *field_location__query == *other_value.field_location__query;
case ALT_block1:
return *field_block1 == *other_value.field_block1;
case ALT_block2:
return *field_block2 == *other_value.field_block2;
case ALT_proxy__uri:
return *field_proxy__uri == *other_value.field_proxy__uri;
case ALT_proxy__scheme:
return *field_proxy__scheme == *other_value.field_proxy__scheme;
case ALT_size1:
return *field_size1 == *other_value.field_size1;
case ALT_unknown__option:
return *field_unknown__option == *other_value.field_unknown__option;
case ALT_oneM2M__FR:
return *field_oneM2M__FR == *other_value.field_oneM2M__FR;
case ALT_oneM2M__RQI:
return *field_oneM2M__RQI == *other_value.field_oneM2M__RQI;
case ALT_oneM2M__OT:
return *field_oneM2M__OT == *other_value.field_oneM2M__OT;
case ALT_oneM2M__RQET:
return *field_oneM2M__RQET == *other_value.field_oneM2M__RQET;
case ALT_oneM2M__RSET:
return *field_oneM2M__RSET == *other_value.field_oneM2M__RSET;
case ALT_oneM2M__OET:
return *field_oneM2M__OET == *other_value.field_oneM2M__OET;
case ALT_oneM2M__RTURI:
return *field_oneM2M__RTURI == *other_value.field_oneM2M__RTURI;
case ALT_oneM2M__EC:
return *field_oneM2M__EC == *other_value.field_oneM2M__EC;
case ALT_oneM2M__RSC:
return *field_oneM2M__RSC == *other_value.field_oneM2M__RSC;
case ALT_oneM2M__GID:
return *field_oneM2M__GID == *other_value.field_oneM2M__GID;
case ALT_oneM2M__TY:
return *field_oneM2M__TY == *other_value.field_oneM2M__TY;
case ALT_oneM2M__CTO:
return *field_oneM2M__CTO == *other_value.field_oneM2M__CTO;
case ALT_oneM2M__CTS:
return *field_oneM2M__CTS == *other_value.field_oneM2M__CTS;
case ALT_oneM2M__ATI:
return *field_oneM2M__ATI == *other_value.field_oneM2M__ATI;
default:
return FALSE;
}
}

OCTETSTRING& CoAP__Options::if__match()
{
if (union_selection != ALT_if__match) {
clean_up();
field_if__match = new OCTETSTRING;
union_selection = ALT_if__match;
}
return *field_if__match;
}

const OCTETSTRING& CoAP__Options::if__match() const
{
if (union_selection != ALT_if__match) TTCN_error("Using non-selected field if_match in a value of union type @CoAP_Types.CoAP_Options.");
return *field_if__match;
}

UNIVERSAL_CHARSTRING& CoAP__Options::uri__host()
{
if (union_selection != ALT_uri__host) {
clean_up();
field_uri__host = new UNIVERSAL_CHARSTRING;
union_selection = ALT_uri__host;
}
return *field_uri__host;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::uri__host() const
{
if (union_selection != ALT_uri__host) TTCN_error("Using non-selected field uri_host in a value of union type @CoAP_Types.CoAP_Options.");
return *field_uri__host;
}

OCTETSTRING& CoAP__Options::etag()
{
if (union_selection != ALT_etag) {
clean_up();
field_etag = new OCTETSTRING;
union_selection = ALT_etag;
}
return *field_etag;
}

const OCTETSTRING& CoAP__Options::etag() const
{
if (union_selection != ALT_etag) TTCN_error("Using non-selected field etag in a value of union type @CoAP_Types.CoAP_Options.");
return *field_etag;
}

OCTETSTRING& CoAP__Options::if__none__match()
{
if (union_selection != ALT_if__none__match) {
clean_up();
field_if__none__match = new OCTETSTRING;
union_selection = ALT_if__none__match;
}
return *field_if__none__match;
}

const OCTETSTRING& CoAP__Options::if__none__match() const
{
if (union_selection != ALT_if__none__match) TTCN_error("Using non-selected field if_none_match in a value of union type @CoAP_Types.CoAP_Options.");
return *field_if__none__match;
}

INTEGER& CoAP__Options::observe()
{
if (union_selection != ALT_observe) {
clean_up();
field_observe = new INTEGER;
union_selection = ALT_observe;
}
return *field_observe;
}

const INTEGER& CoAP__Options::observe() const
{
if (union_selection != ALT_observe) TTCN_error("Using non-selected field observe in a value of union type @CoAP_Types.CoAP_Options.");
return *field_observe;
}

INTEGER& CoAP__Options::uri__port()
{
if (union_selection != ALT_uri__port) {
clean_up();
field_uri__port = new INTEGER;
union_selection = ALT_uri__port;
}
return *field_uri__port;
}

const INTEGER& CoAP__Options::uri__port() const
{
if (union_selection != ALT_uri__port) TTCN_error("Using non-selected field uri_port in a value of union type @CoAP_Types.CoAP_Options.");
return *field_uri__port;
}

UNIVERSAL_CHARSTRING& CoAP__Options::location__path()
{
if (union_selection != ALT_location__path) {
clean_up();
field_location__path = new UNIVERSAL_CHARSTRING;
union_selection = ALT_location__path;
}
return *field_location__path;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::location__path() const
{
if (union_selection != ALT_location__path) TTCN_error("Using non-selected field location_path in a value of union type @CoAP_Types.CoAP_Options.");
return *field_location__path;
}

UNIVERSAL_CHARSTRING& CoAP__Options::uri__path()
{
if (union_selection != ALT_uri__path) {
clean_up();
field_uri__path = new UNIVERSAL_CHARSTRING;
union_selection = ALT_uri__path;
}
return *field_uri__path;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::uri__path() const
{
if (union_selection != ALT_uri__path) TTCN_error("Using non-selected field uri_path in a value of union type @CoAP_Types.CoAP_Options.");
return *field_uri__path;
}

INTEGER& CoAP__Options::content__format()
{
if (union_selection != ALT_content__format) {
clean_up();
field_content__format = new INTEGER;
union_selection = ALT_content__format;
}
return *field_content__format;
}

const INTEGER& CoAP__Options::content__format() const
{
if (union_selection != ALT_content__format) TTCN_error("Using non-selected field content_format in a value of union type @CoAP_Types.CoAP_Options.");
return *field_content__format;
}

INTEGER& CoAP__Options::max__age()
{
if (union_selection != ALT_max__age) {
clean_up();
field_max__age = new INTEGER;
union_selection = ALT_max__age;
}
return *field_max__age;
}

const INTEGER& CoAP__Options::max__age() const
{
if (union_selection != ALT_max__age) TTCN_error("Using non-selected field max_age in a value of union type @CoAP_Types.CoAP_Options.");
return *field_max__age;
}

UNIVERSAL_CHARSTRING& CoAP__Options::uri__query()
{
if (union_selection != ALT_uri__query) {
clean_up();
field_uri__query = new UNIVERSAL_CHARSTRING;
union_selection = ALT_uri__query;
}
return *field_uri__query;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::uri__query() const
{
if (union_selection != ALT_uri__query) TTCN_error("Using non-selected field uri_query in a value of union type @CoAP_Types.CoAP_Options.");
return *field_uri__query;
}

INTEGER& CoAP__Options::accept()
{
if (union_selection != ALT_accept) {
clean_up();
field_accept = new INTEGER;
union_selection = ALT_accept;
}
return *field_accept;
}

const INTEGER& CoAP__Options::accept() const
{
if (union_selection != ALT_accept) TTCN_error("Using non-selected field accept in a value of union type @CoAP_Types.CoAP_Options.");
return *field_accept;
}

UNIVERSAL_CHARSTRING& CoAP__Options::location__query()
{
if (union_selection != ALT_location__query) {
clean_up();
field_location__query = new UNIVERSAL_CHARSTRING;
union_selection = ALT_location__query;
}
return *field_location__query;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::location__query() const
{
if (union_selection != ALT_location__query) TTCN_error("Using non-selected field location_query in a value of union type @CoAP_Types.CoAP_Options.");
return *field_location__query;
}

BlockOption& CoAP__Options::block1()
{
if (union_selection != ALT_block1) {
clean_up();
field_block1 = new BlockOption;
union_selection = ALT_block1;
}
return *field_block1;
}

const BlockOption& CoAP__Options::block1() const
{
if (union_selection != ALT_block1) TTCN_error("Using non-selected field block1 in a value of union type @CoAP_Types.CoAP_Options.");
return *field_block1;
}

BlockOption& CoAP__Options::block2()
{
if (union_selection != ALT_block2) {
clean_up();
field_block2 = new BlockOption;
union_selection = ALT_block2;
}
return *field_block2;
}

const BlockOption& CoAP__Options::block2() const
{
if (union_selection != ALT_block2) TTCN_error("Using non-selected field block2 in a value of union type @CoAP_Types.CoAP_Options.");
return *field_block2;
}

UNIVERSAL_CHARSTRING& CoAP__Options::proxy__uri()
{
if (union_selection != ALT_proxy__uri) {
clean_up();
field_proxy__uri = new UNIVERSAL_CHARSTRING;
union_selection = ALT_proxy__uri;
}
return *field_proxy__uri;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::proxy__uri() const
{
if (union_selection != ALT_proxy__uri) TTCN_error("Using non-selected field proxy_uri in a value of union type @CoAP_Types.CoAP_Options.");
return *field_proxy__uri;
}

UNIVERSAL_CHARSTRING& CoAP__Options::proxy__scheme()
{
if (union_selection != ALT_proxy__scheme) {
clean_up();
field_proxy__scheme = new UNIVERSAL_CHARSTRING;
union_selection = ALT_proxy__scheme;
}
return *field_proxy__scheme;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::proxy__scheme() const
{
if (union_selection != ALT_proxy__scheme) TTCN_error("Using non-selected field proxy_scheme in a value of union type @CoAP_Types.CoAP_Options.");
return *field_proxy__scheme;
}

INTEGER& CoAP__Options::size1()
{
if (union_selection != ALT_size1) {
clean_up();
field_size1 = new INTEGER;
union_selection = ALT_size1;
}
return *field_size1;
}

const INTEGER& CoAP__Options::size1() const
{
if (union_selection != ALT_size1) TTCN_error("Using non-selected field size1 in a value of union type @CoAP_Types.CoAP_Options.");
return *field_size1;
}

UnknownOption& CoAP__Options::unknown__option()
{
if (union_selection != ALT_unknown__option) {
clean_up();
field_unknown__option = new UnknownOption;
union_selection = ALT_unknown__option;
}
return *field_unknown__option;
}

const UnknownOption& CoAP__Options::unknown__option() const
{
if (union_selection != ALT_unknown__option) TTCN_error("Using non-selected field unknown_option in a value of union type @CoAP_Types.CoAP_Options.");
return *field_unknown__option;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__FR()
{
if (union_selection != ALT_oneM2M__FR) {
clean_up();
field_oneM2M__FR = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__FR;
}
return *field_oneM2M__FR;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__FR() const
{
if (union_selection != ALT_oneM2M__FR) TTCN_error("Using non-selected field oneM2M_FR in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__FR;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RQI()
{
if (union_selection != ALT_oneM2M__RQI) {
clean_up();
field_oneM2M__RQI = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__RQI;
}
return *field_oneM2M__RQI;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RQI() const
{
if (union_selection != ALT_oneM2M__RQI) TTCN_error("Using non-selected field oneM2M_RQI in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__RQI;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__OT()
{
if (union_selection != ALT_oneM2M__OT) {
clean_up();
field_oneM2M__OT = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__OT;
}
return *field_oneM2M__OT;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__OT() const
{
if (union_selection != ALT_oneM2M__OT) TTCN_error("Using non-selected field oneM2M_OT in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__OT;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RQET()
{
if (union_selection != ALT_oneM2M__RQET) {
clean_up();
field_oneM2M__RQET = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__RQET;
}
return *field_oneM2M__RQET;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RQET() const
{
if (union_selection != ALT_oneM2M__RQET) TTCN_error("Using non-selected field oneM2M_RQET in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__RQET;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RSET()
{
if (union_selection != ALT_oneM2M__RSET) {
clean_up();
field_oneM2M__RSET = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__RSET;
}
return *field_oneM2M__RSET;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RSET() const
{
if (union_selection != ALT_oneM2M__RSET) TTCN_error("Using non-selected field oneM2M_RSET in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__RSET;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__OET()
{
if (union_selection != ALT_oneM2M__OET) {
clean_up();
field_oneM2M__OET = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__OET;
}
return *field_oneM2M__OET;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__OET() const
{
if (union_selection != ALT_oneM2M__OET) TTCN_error("Using non-selected field oneM2M_OET in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__OET;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RTURI()
{
if (union_selection != ALT_oneM2M__RTURI) {
clean_up();
field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__RTURI;
}
return *field_oneM2M__RTURI;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__RTURI() const
{
if (union_selection != ALT_oneM2M__RTURI) TTCN_error("Using non-selected field oneM2M_RTURI in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__RTURI;
}

INTEGER& CoAP__Options::oneM2M__EC()
{
if (union_selection != ALT_oneM2M__EC) {
clean_up();
field_oneM2M__EC = new INTEGER;
union_selection = ALT_oneM2M__EC;
}
return *field_oneM2M__EC;
}

const INTEGER& CoAP__Options::oneM2M__EC() const
{
if (union_selection != ALT_oneM2M__EC) TTCN_error("Using non-selected field oneM2M_EC in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__EC;
}

INTEGER& CoAP__Options::oneM2M__RSC()
{
if (union_selection != ALT_oneM2M__RSC) {
clean_up();
field_oneM2M__RSC = new INTEGER;
union_selection = ALT_oneM2M__RSC;
}
return *field_oneM2M__RSC;
}

const INTEGER& CoAP__Options::oneM2M__RSC() const
{
if (union_selection != ALT_oneM2M__RSC) TTCN_error("Using non-selected field oneM2M_RSC in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__RSC;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__GID()
{
if (union_selection != ALT_oneM2M__GID) {
clean_up();
field_oneM2M__GID = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__GID;
}
return *field_oneM2M__GID;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__GID() const
{
if (union_selection != ALT_oneM2M__GID) TTCN_error("Using non-selected field oneM2M_GID in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__GID;
}

INTEGER& CoAP__Options::oneM2M__TY()
{
if (union_selection != ALT_oneM2M__TY) {
clean_up();
field_oneM2M__TY = new INTEGER;
union_selection = ALT_oneM2M__TY;
}
return *field_oneM2M__TY;
}

const INTEGER& CoAP__Options::oneM2M__TY() const
{
if (union_selection != ALT_oneM2M__TY) TTCN_error("Using non-selected field oneM2M_TY in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__TY;
}

INTEGER& CoAP__Options::oneM2M__CTO()
{
if (union_selection != ALT_oneM2M__CTO) {
clean_up();
field_oneM2M__CTO = new INTEGER;
union_selection = ALT_oneM2M__CTO;
}
return *field_oneM2M__CTO;
}

const INTEGER& CoAP__Options::oneM2M__CTO() const
{
if (union_selection != ALT_oneM2M__CTO) TTCN_error("Using non-selected field oneM2M_CTO in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__CTO;
}

INTEGER& CoAP__Options::oneM2M__CTS()
{
if (union_selection != ALT_oneM2M__CTS) {
clean_up();
field_oneM2M__CTS = new INTEGER;
union_selection = ALT_oneM2M__CTS;
}
return *field_oneM2M__CTS;
}

const INTEGER& CoAP__Options::oneM2M__CTS() const
{
if (union_selection != ALT_oneM2M__CTS) TTCN_error("Using non-selected field oneM2M_CTS in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__CTS;
}

UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__ATI()
{
if (union_selection != ALT_oneM2M__ATI) {
clean_up();
field_oneM2M__ATI = new UNIVERSAL_CHARSTRING;
union_selection = ALT_oneM2M__ATI;
}
return *field_oneM2M__ATI;
}

const UNIVERSAL_CHARSTRING& CoAP__Options::oneM2M__ATI() const
{
if (union_selection != ALT_oneM2M__ATI) TTCN_error("Using non-selected field oneM2M_ATI in a value of union type @CoAP_Types.CoAP_Options.");
return *field_oneM2M__ATI;
}

boolean CoAP__Options::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CoAP_Types.CoAP_Options.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @CoAP_Types.CoAP_Options.");
return union_selection == checked_selection;
}

boolean CoAP__Options::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean CoAP__Options::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_if__match: return field_if__match->is_value();
case ALT_uri__host: return field_uri__host->is_value();
case ALT_etag: return field_etag->is_value();
case ALT_if__none__match: return field_if__none__match->is_value();
case ALT_observe: return field_observe->is_value();
case ALT_uri__port: return field_uri__port->is_value();
case ALT_location__path: return field_location__path->is_value();
case ALT_uri__path: return field_uri__path->is_value();
case ALT_content__format: return field_content__format->is_value();
case ALT_max__age: return field_max__age->is_value();
case ALT_uri__query: return field_uri__query->is_value();
case ALT_accept: return field_accept->is_value();
case ALT_location__query: return field_location__query->is_value();
case ALT_block1: return field_block1->is_value();
case ALT_block2: return field_block2->is_value();
case ALT_proxy__uri: return field_proxy__uri->is_value();
case ALT_proxy__scheme: return field_proxy__scheme->is_value();
case ALT_size1: return field_size1->is_value();
case ALT_unknown__option: return field_unknown__option->is_value();
case ALT_oneM2M__FR: return field_oneM2M__FR->is_value();
case ALT_oneM2M__RQI: return field_oneM2M__RQI->is_value();
case ALT_oneM2M__OT: return field_oneM2M__OT->is_value();
case ALT_oneM2M__RQET: return field_oneM2M__RQET->is_value();
case ALT_oneM2M__RSET: return field_oneM2M__RSET->is_value();
case ALT_oneM2M__OET: return field_oneM2M__OET->is_value();
case ALT_oneM2M__RTURI: return field_oneM2M__RTURI->is_value();
case ALT_oneM2M__EC: return field_oneM2M__EC->is_value();
case ALT_oneM2M__RSC: return field_oneM2M__RSC->is_value();
case ALT_oneM2M__GID: return field_oneM2M__GID->is_value();
case ALT_oneM2M__TY: return field_oneM2M__TY->is_value();
case ALT_oneM2M__CTO: return field_oneM2M__CTO->is_value();
case ALT_oneM2M__CTS: return field_oneM2M__CTS->is_value();
case ALT_oneM2M__ATI: return field_oneM2M__ATI->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void CoAP__Options::clean_up()
{
switch (union_selection) {
case ALT_if__match:
  delete field_if__match;
  break;
case ALT_uri__host:
  delete field_uri__host;
  break;
case ALT_etag:
  delete field_etag;
  break;
case ALT_if__none__match:
  delete field_if__none__match;
  break;
case ALT_observe:
  delete field_observe;
  break;
case ALT_uri__port:
  delete field_uri__port;
  break;
case ALT_location__path:
  delete field_location__path;
  break;
case ALT_uri__path:
  delete field_uri__path;
  break;
case ALT_content__format:
  delete field_content__format;
  break;
case ALT_max__age:
  delete field_max__age;
  break;
case ALT_uri__query:
  delete field_uri__query;
  break;
case ALT_accept:
  delete field_accept;
  break;
case ALT_location__query:
  delete field_location__query;
  break;
case ALT_block1:
  delete field_block1;
  break;
case ALT_block2:
  delete field_block2;
  break;
case ALT_proxy__uri:
  delete field_proxy__uri;
  break;
case ALT_proxy__scheme:
  delete field_proxy__scheme;
  break;
case ALT_size1:
  delete field_size1;
  break;
case ALT_unknown__option:
  delete field_unknown__option;
  break;
case ALT_oneM2M__FR:
  delete field_oneM2M__FR;
  break;
case ALT_oneM2M__RQI:
  delete field_oneM2M__RQI;
  break;
case ALT_oneM2M__OT:
  delete field_oneM2M__OT;
  break;
case ALT_oneM2M__RQET:
  delete field_oneM2M__RQET;
  break;
case ALT_oneM2M__RSET:
  delete field_oneM2M__RSET;
  break;
case ALT_oneM2M__OET:
  delete field_oneM2M__OET;
  break;
case ALT_oneM2M__RTURI:
  delete field_oneM2M__RTURI;
  break;
case ALT_oneM2M__EC:
  delete field_oneM2M__EC;
  break;
case ALT_oneM2M__RSC:
  delete field_oneM2M__RSC;
  break;
case ALT_oneM2M__GID:
  delete field_oneM2M__GID;
  break;
case ALT_oneM2M__TY:
  delete field_oneM2M__TY;
  break;
case ALT_oneM2M__CTO:
  delete field_oneM2M__CTO;
  break;
case ALT_oneM2M__CTS:
  delete field_oneM2M__CTS;
  break;
case ALT_oneM2M__ATI:
  delete field_oneM2M__ATI;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void CoAP__Options::log() const
{
switch (union_selection) {
case ALT_if__match:
TTCN_Logger::log_event_str("{ if_match := ");
field_if__match->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_uri__host:
TTCN_Logger::log_event_str("{ uri_host := ");
field_uri__host->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_etag:
TTCN_Logger::log_event_str("{ etag := ");
field_etag->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_if__none__match:
TTCN_Logger::log_event_str("{ if_none_match := ");
field_if__none__match->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_observe:
TTCN_Logger::log_event_str("{ observe := ");
field_observe->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_uri__port:
TTCN_Logger::log_event_str("{ uri_port := ");
field_uri__port->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_location__path:
TTCN_Logger::log_event_str("{ location_path := ");
field_location__path->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_uri__path:
TTCN_Logger::log_event_str("{ uri_path := ");
field_uri__path->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_content__format:
TTCN_Logger::log_event_str("{ content_format := ");
field_content__format->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_max__age:
TTCN_Logger::log_event_str("{ max_age := ");
field_max__age->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_uri__query:
TTCN_Logger::log_event_str("{ uri_query := ");
field_uri__query->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_accept:
TTCN_Logger::log_event_str("{ accept := ");
field_accept->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_location__query:
TTCN_Logger::log_event_str("{ location_query := ");
field_location__query->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_block1:
TTCN_Logger::log_event_str("{ block1 := ");
field_block1->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_block2:
TTCN_Logger::log_event_str("{ block2 := ");
field_block2->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_proxy__uri:
TTCN_Logger::log_event_str("{ proxy_uri := ");
field_proxy__uri->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_proxy__scheme:
TTCN_Logger::log_event_str("{ proxy_scheme := ");
field_proxy__scheme->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_size1:
TTCN_Logger::log_event_str("{ size1 := ");
field_size1->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_unknown__option:
TTCN_Logger::log_event_str("{ unknown_option := ");
field_unknown__option->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__FR:
TTCN_Logger::log_event_str("{ oneM2M_FR := ");
field_oneM2M__FR->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__RQI:
TTCN_Logger::log_event_str("{ oneM2M_RQI := ");
field_oneM2M__RQI->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__OT:
TTCN_Logger::log_event_str("{ oneM2M_OT := ");
field_oneM2M__OT->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__RQET:
TTCN_Logger::log_event_str("{ oneM2M_RQET := ");
field_oneM2M__RQET->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__RSET:
TTCN_Logger::log_event_str("{ oneM2M_RSET := ");
field_oneM2M__RSET->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__OET:
TTCN_Logger::log_event_str("{ oneM2M_OET := ");
field_oneM2M__OET->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__RTURI:
TTCN_Logger::log_event_str("{ oneM2M_RTURI := ");
field_oneM2M__RTURI->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__EC:
TTCN_Logger::log_event_str("{ oneM2M_EC := ");
field_oneM2M__EC->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__RSC:
TTCN_Logger::log_event_str("{ oneM2M_RSC := ");
field_oneM2M__RSC->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__GID:
TTCN_Logger::log_event_str("{ oneM2M_GID := ");
field_oneM2M__GID->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__TY:
TTCN_Logger::log_event_str("{ oneM2M_TY := ");
field_oneM2M__TY->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__CTO:
TTCN_Logger::log_event_str("{ oneM2M_CTO := ");
field_oneM2M__CTO->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__CTS:
TTCN_Logger::log_event_str("{ oneM2M_CTS := ");
field_oneM2M__CTS->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_oneM2M__ATI:
TTCN_Logger::log_event_str("{ oneM2M_ATI := ");
field_oneM2M__ATI->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void CoAP__Options::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "if_match")) {
    if__match().set_param(*mp_last);
    if (!if__match().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "uri_host")) {
    uri__host().set_param(*mp_last);
    if (!uri__host().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "etag")) {
    etag().set_param(*mp_last);
    if (!etag().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "if_none_match")) {
    if__none__match().set_param(*mp_last);
    if (!if__none__match().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "observe")) {
    observe().set_param(*mp_last);
    if (!observe().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "uri_port")) {
    uri__port().set_param(*mp_last);
    if (!uri__port().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "location_path")) {
    location__path().set_param(*mp_last);
    if (!location__path().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "uri_path")) {
    uri__path().set_param(*mp_last);
    if (!uri__path().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "content_format")) {
    content__format().set_param(*mp_last);
    if (!content__format().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "max_age")) {
    max__age().set_param(*mp_last);
    if (!max__age().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "uri_query")) {
    uri__query().set_param(*mp_last);
    if (!uri__query().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "accept")) {
    accept().set_param(*mp_last);
    if (!accept().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "location_query")) {
    location__query().set_param(*mp_last);
    if (!location__query().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "block1")) {
    block1().set_param(*mp_last);
    if (!block1().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "block2")) {
    block2().set_param(*mp_last);
    if (!block2().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "proxy_uri")) {
    proxy__uri().set_param(*mp_last);
    if (!proxy__uri().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "proxy_scheme")) {
    proxy__scheme().set_param(*mp_last);
    if (!proxy__scheme().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "size1")) {
    size1().set_param(*mp_last);
    if (!size1().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "unknown_option")) {
    unknown__option().set_param(*mp_last);
    if (!unknown__option().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_FR")) {
    oneM2M__FR().set_param(*mp_last);
    if (!oneM2M__FR().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RQI")) {
    oneM2M__RQI().set_param(*mp_last);
    if (!oneM2M__RQI().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_OT")) {
    oneM2M__OT().set_param(*mp_last);
    if (!oneM2M__OT().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RQET")) {
    oneM2M__RQET().set_param(*mp_last);
    if (!oneM2M__RQET().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RSET")) {
    oneM2M__RSET().set_param(*mp_last);
    if (!oneM2M__RSET().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_OET")) {
    oneM2M__OET().set_param(*mp_last);
    if (!oneM2M__OET().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RTURI")) {
    oneM2M__RTURI().set_param(*mp_last);
    if (!oneM2M__RTURI().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_EC")) {
    oneM2M__EC().set_param(*mp_last);
    if (!oneM2M__EC().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RSC")) {
    oneM2M__RSC().set_param(*mp_last);
    if (!oneM2M__RSC().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_GID")) {
    oneM2M__GID().set_param(*mp_last);
    if (!oneM2M__GID().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_TY")) {
    oneM2M__TY().set_param(*mp_last);
    if (!oneM2M__TY().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_CTO")) {
    oneM2M__CTO().set_param(*mp_last);
    if (!oneM2M__CTO().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_CTS")) {
    oneM2M__CTS().set_param(*mp_last);
    if (!oneM2M__CTS().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_ATI")) {
    oneM2M__ATI().set_param(*mp_last);
    if (!oneM2M__ATI().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @CoAP_Types.CoAP_Options.", mp_last->get_id()->get_name());
}

void CoAP__Options::set_implicit_omit()
{
switch (union_selection) {
case ALT_if__match:
field_if__match->set_implicit_omit(); break;
case ALT_uri__host:
field_uri__host->set_implicit_omit(); break;
case ALT_etag:
field_etag->set_implicit_omit(); break;
case ALT_if__none__match:
field_if__none__match->set_implicit_omit(); break;
case ALT_observe:
field_observe->set_implicit_omit(); break;
case ALT_uri__port:
field_uri__port->set_implicit_omit(); break;
case ALT_location__path:
field_location__path->set_implicit_omit(); break;
case ALT_uri__path:
field_uri__path->set_implicit_omit(); break;
case ALT_content__format:
field_content__format->set_implicit_omit(); break;
case ALT_max__age:
field_max__age->set_implicit_omit(); break;
case ALT_uri__query:
field_uri__query->set_implicit_omit(); break;
case ALT_accept:
field_accept->set_implicit_omit(); break;
case ALT_location__query:
field_location__query->set_implicit_omit(); break;
case ALT_block1:
field_block1->set_implicit_omit(); break;
case ALT_block2:
field_block2->set_implicit_omit(); break;
case ALT_proxy__uri:
field_proxy__uri->set_implicit_omit(); break;
case ALT_proxy__scheme:
field_proxy__scheme->set_implicit_omit(); break;
case ALT_size1:
field_size1->set_implicit_omit(); break;
case ALT_unknown__option:
field_unknown__option->set_implicit_omit(); break;
case ALT_oneM2M__FR:
field_oneM2M__FR->set_implicit_omit(); break;
case ALT_oneM2M__RQI:
field_oneM2M__RQI->set_implicit_omit(); break;
case ALT_oneM2M__OT:
field_oneM2M__OT->set_implicit_omit(); break;
case ALT_oneM2M__RQET:
field_oneM2M__RQET->set_implicit_omit(); break;
case ALT_oneM2M__RSET:
field_oneM2M__RSET->set_implicit_omit(); break;
case ALT_oneM2M__OET:
field_oneM2M__OET->set_implicit_omit(); break;
case ALT_oneM2M__RTURI:
field_oneM2M__RTURI->set_implicit_omit(); break;
case ALT_oneM2M__EC:
field_oneM2M__EC->set_implicit_omit(); break;
case ALT_oneM2M__RSC:
field_oneM2M__RSC->set_implicit_omit(); break;
case ALT_oneM2M__GID:
field_oneM2M__GID->set_implicit_omit(); break;
case ALT_oneM2M__TY:
field_oneM2M__TY->set_implicit_omit(); break;
case ALT_oneM2M__CTO:
field_oneM2M__CTO->set_implicit_omit(); break;
case ALT_oneM2M__CTS:
field_oneM2M__CTS->set_implicit_omit(); break;
case ALT_oneM2M__ATI:
field_oneM2M__ATI->set_implicit_omit(); break;
default: break;
}
}

void CoAP__Options::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_if__match:
field_if__match->encode_text(text_buf);
break;
case ALT_uri__host:
field_uri__host->encode_text(text_buf);
break;
case ALT_etag:
field_etag->encode_text(text_buf);
break;
case ALT_if__none__match:
field_if__none__match->encode_text(text_buf);
break;
case ALT_observe:
field_observe->encode_text(text_buf);
break;
case ALT_uri__port:
field_uri__port->encode_text(text_buf);
break;
case ALT_location__path:
field_location__path->encode_text(text_buf);
break;
case ALT_uri__path:
field_uri__path->encode_text(text_buf);
break;
case ALT_content__format:
field_content__format->encode_text(text_buf);
break;
case ALT_max__age:
field_max__age->encode_text(text_buf);
break;
case ALT_uri__query:
field_uri__query->encode_text(text_buf);
break;
case ALT_accept:
field_accept->encode_text(text_buf);
break;
case ALT_location__query:
field_location__query->encode_text(text_buf);
break;
case ALT_block1:
field_block1->encode_text(text_buf);
break;
case ALT_block2:
field_block2->encode_text(text_buf);
break;
case ALT_proxy__uri:
field_proxy__uri->encode_text(text_buf);
break;
case ALT_proxy__scheme:
field_proxy__scheme->encode_text(text_buf);
break;
case ALT_size1:
field_size1->encode_text(text_buf);
break;
case ALT_unknown__option:
field_unknown__option->encode_text(text_buf);
break;
case ALT_oneM2M__FR:
field_oneM2M__FR->encode_text(text_buf);
break;
case ALT_oneM2M__RQI:
field_oneM2M__RQI->encode_text(text_buf);
break;
case ALT_oneM2M__OT:
field_oneM2M__OT->encode_text(text_buf);
break;
case ALT_oneM2M__RQET:
field_oneM2M__RQET->encode_text(text_buf);
break;
case ALT_oneM2M__RSET:
field_oneM2M__RSET->encode_text(text_buf);
break;
case ALT_oneM2M__OET:
field_oneM2M__OET->encode_text(text_buf);
break;
case ALT_oneM2M__RTURI:
field_oneM2M__RTURI->encode_text(text_buf);
break;
case ALT_oneM2M__EC:
field_oneM2M__EC->encode_text(text_buf);
break;
case ALT_oneM2M__RSC:
field_oneM2M__RSC->encode_text(text_buf);
break;
case ALT_oneM2M__GID:
field_oneM2M__GID->encode_text(text_buf);
break;
case ALT_oneM2M__TY:
field_oneM2M__TY->encode_text(text_buf);
break;
case ALT_oneM2M__CTO:
field_oneM2M__CTO->encode_text(text_buf);
break;
case ALT_oneM2M__CTS:
field_oneM2M__CTS->encode_text(text_buf);
break;
case ALT_oneM2M__ATI:
field_oneM2M__ATI->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @CoAP_Types.CoAP_Options.");
}
}

void CoAP__Options::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_if__match:
if__match().decode_text(text_buf);
break;
case ALT_uri__host:
uri__host().decode_text(text_buf);
break;
case ALT_etag:
etag().decode_text(text_buf);
break;
case ALT_if__none__match:
if__none__match().decode_text(text_buf);
break;
case ALT_observe:
observe().decode_text(text_buf);
break;
case ALT_uri__port:
uri__port().decode_text(text_buf);
break;
case ALT_location__path:
location__path().decode_text(text_buf);
break;
case ALT_uri__path:
uri__path().decode_text(text_buf);
break;
case ALT_content__format:
content__format().decode_text(text_buf);
break;
case ALT_max__age:
max__age().decode_text(text_buf);
break;
case ALT_uri__query:
uri__query().decode_text(text_buf);
break;
case ALT_accept:
accept().decode_text(text_buf);
break;
case ALT_location__query:
location__query().decode_text(text_buf);
break;
case ALT_block1:
block1().decode_text(text_buf);
break;
case ALT_block2:
block2().decode_text(text_buf);
break;
case ALT_proxy__uri:
proxy__uri().decode_text(text_buf);
break;
case ALT_proxy__scheme:
proxy__scheme().decode_text(text_buf);
break;
case ALT_size1:
size1().decode_text(text_buf);
break;
case ALT_unknown__option:
unknown__option().decode_text(text_buf);
break;
case ALT_oneM2M__FR:
oneM2M__FR().decode_text(text_buf);
break;
case ALT_oneM2M__RQI:
oneM2M__RQI().decode_text(text_buf);
break;
case ALT_oneM2M__OT:
oneM2M__OT().decode_text(text_buf);
break;
case ALT_oneM2M__RQET:
oneM2M__RQET().decode_text(text_buf);
break;
case ALT_oneM2M__RSET:
oneM2M__RSET().decode_text(text_buf);
break;
case ALT_oneM2M__OET:
oneM2M__OET().decode_text(text_buf);
break;
case ALT_oneM2M__RTURI:
oneM2M__RTURI().decode_text(text_buf);
break;
case ALT_oneM2M__EC:
oneM2M__EC().decode_text(text_buf);
break;
case ALT_oneM2M__RSC:
oneM2M__RSC().decode_text(text_buf);
break;
case ALT_oneM2M__GID:
oneM2M__GID().decode_text(text_buf);
break;
case ALT_oneM2M__TY:
oneM2M__TY().decode_text(text_buf);
break;
case ALT_oneM2M__CTO:
oneM2M__CTO().decode_text(text_buf);
break;
case ALT_oneM2M__CTS:
oneM2M__CTS().decode_text(text_buf);
break;
case ALT_oneM2M__ATI:
oneM2M__ATI().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @CoAP_Types.CoAP_Options.");
}
}

void CoAP__Options_template::copy_value(const CoAP__Options& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
single_value.field_if__match = new OCTETSTRING_template(other_value.if__match());
break;
case CoAP__Options::ALT_uri__host:
single_value.field_uri__host = new UNIVERSAL_CHARSTRING_template(other_value.uri__host());
break;
case CoAP__Options::ALT_etag:
single_value.field_etag = new OCTETSTRING_template(other_value.etag());
break;
case CoAP__Options::ALT_if__none__match:
single_value.field_if__none__match = new OCTETSTRING_template(other_value.if__none__match());
break;
case CoAP__Options::ALT_observe:
single_value.field_observe = new INTEGER_template(other_value.observe());
break;
case CoAP__Options::ALT_uri__port:
single_value.field_uri__port = new INTEGER_template(other_value.uri__port());
break;
case CoAP__Options::ALT_location__path:
single_value.field_location__path = new UNIVERSAL_CHARSTRING_template(other_value.location__path());
break;
case CoAP__Options::ALT_uri__path:
single_value.field_uri__path = new UNIVERSAL_CHARSTRING_template(other_value.uri__path());
break;
case CoAP__Options::ALT_content__format:
single_value.field_content__format = new INTEGER_template(other_value.content__format());
break;
case CoAP__Options::ALT_max__age:
single_value.field_max__age = new INTEGER_template(other_value.max__age());
break;
case CoAP__Options::ALT_uri__query:
single_value.field_uri__query = new UNIVERSAL_CHARSTRING_template(other_value.uri__query());
break;
case CoAP__Options::ALT_accept:
single_value.field_accept = new INTEGER_template(other_value.accept());
break;
case CoAP__Options::ALT_location__query:
single_value.field_location__query = new UNIVERSAL_CHARSTRING_template(other_value.location__query());
break;
case CoAP__Options::ALT_block1:
single_value.field_block1 = new BlockOption_template(other_value.block1());
break;
case CoAP__Options::ALT_block2:
single_value.field_block2 = new BlockOption_template(other_value.block2());
break;
case CoAP__Options::ALT_proxy__uri:
single_value.field_proxy__uri = new UNIVERSAL_CHARSTRING_template(other_value.proxy__uri());
break;
case CoAP__Options::ALT_proxy__scheme:
single_value.field_proxy__scheme = new UNIVERSAL_CHARSTRING_template(other_value.proxy__scheme());
break;
case CoAP__Options::ALT_size1:
single_value.field_size1 = new INTEGER_template(other_value.size1());
break;
case CoAP__Options::ALT_unknown__option:
single_value.field_unknown__option = new UnknownOption_template(other_value.unknown__option());
break;
case CoAP__Options::ALT_oneM2M__FR:
single_value.field_oneM2M__FR = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__FR());
break;
case CoAP__Options::ALT_oneM2M__RQI:
single_value.field_oneM2M__RQI = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__RQI());
break;
case CoAP__Options::ALT_oneM2M__OT:
single_value.field_oneM2M__OT = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__OT());
break;
case CoAP__Options::ALT_oneM2M__RQET:
single_value.field_oneM2M__RQET = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__RQET());
break;
case CoAP__Options::ALT_oneM2M__RSET:
single_value.field_oneM2M__RSET = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__RSET());
break;
case CoAP__Options::ALT_oneM2M__OET:
single_value.field_oneM2M__OET = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__OET());
break;
case CoAP__Options::ALT_oneM2M__RTURI:
single_value.field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__RTURI());
break;
case CoAP__Options::ALT_oneM2M__EC:
single_value.field_oneM2M__EC = new INTEGER_template(other_value.oneM2M__EC());
break;
case CoAP__Options::ALT_oneM2M__RSC:
single_value.field_oneM2M__RSC = new INTEGER_template(other_value.oneM2M__RSC());
break;
case CoAP__Options::ALT_oneM2M__GID:
single_value.field_oneM2M__GID = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__GID());
break;
case CoAP__Options::ALT_oneM2M__TY:
single_value.field_oneM2M__TY = new INTEGER_template(other_value.oneM2M__TY());
break;
case CoAP__Options::ALT_oneM2M__CTO:
single_value.field_oneM2M__CTO = new INTEGER_template(other_value.oneM2M__CTO());
break;
case CoAP__Options::ALT_oneM2M__CTS:
single_value.field_oneM2M__CTS = new INTEGER_template(other_value.oneM2M__CTS());
break;
case CoAP__Options::ALT_oneM2M__ATI:
single_value.field_oneM2M__ATI = new UNIVERSAL_CHARSTRING_template(other_value.oneM2M__ATI());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @CoAP_Types.CoAP_Options.");
}
set_selection(SPECIFIC_VALUE);
}

void CoAP__Options_template::copy_template(const CoAP__Options_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
single_value.field_if__match = new OCTETSTRING_template(*other_value.single_value.field_if__match);
break;
case CoAP__Options::ALT_uri__host:
single_value.field_uri__host = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_uri__host);
break;
case CoAP__Options::ALT_etag:
single_value.field_etag = new OCTETSTRING_template(*other_value.single_value.field_etag);
break;
case CoAP__Options::ALT_if__none__match:
single_value.field_if__none__match = new OCTETSTRING_template(*other_value.single_value.field_if__none__match);
break;
case CoAP__Options::ALT_observe:
single_value.field_observe = new INTEGER_template(*other_value.single_value.field_observe);
break;
case CoAP__Options::ALT_uri__port:
single_value.field_uri__port = new INTEGER_template(*other_value.single_value.field_uri__port);
break;
case CoAP__Options::ALT_location__path:
single_value.field_location__path = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_location__path);
break;
case CoAP__Options::ALT_uri__path:
single_value.field_uri__path = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_uri__path);
break;
case CoAP__Options::ALT_content__format:
single_value.field_content__format = new INTEGER_template(*other_value.single_value.field_content__format);
break;
case CoAP__Options::ALT_max__age:
single_value.field_max__age = new INTEGER_template(*other_value.single_value.field_max__age);
break;
case CoAP__Options::ALT_uri__query:
single_value.field_uri__query = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_uri__query);
break;
case CoAP__Options::ALT_accept:
single_value.field_accept = new INTEGER_template(*other_value.single_value.field_accept);
break;
case CoAP__Options::ALT_location__query:
single_value.field_location__query = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_location__query);
break;
case CoAP__Options::ALT_block1:
single_value.field_block1 = new BlockOption_template(*other_value.single_value.field_block1);
break;
case CoAP__Options::ALT_block2:
single_value.field_block2 = new BlockOption_template(*other_value.single_value.field_block2);
break;
case CoAP__Options::ALT_proxy__uri:
single_value.field_proxy__uri = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_proxy__uri);
break;
case CoAP__Options::ALT_proxy__scheme:
single_value.field_proxy__scheme = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_proxy__scheme);
break;
case CoAP__Options::ALT_size1:
single_value.field_size1 = new INTEGER_template(*other_value.single_value.field_size1);
break;
case CoAP__Options::ALT_unknown__option:
single_value.field_unknown__option = new UnknownOption_template(*other_value.single_value.field_unknown__option);
break;
case CoAP__Options::ALT_oneM2M__FR:
single_value.field_oneM2M__FR = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__FR);
break;
case CoAP__Options::ALT_oneM2M__RQI:
single_value.field_oneM2M__RQI = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__RQI);
break;
case CoAP__Options::ALT_oneM2M__OT:
single_value.field_oneM2M__OT = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__OT);
break;
case CoAP__Options::ALT_oneM2M__RQET:
single_value.field_oneM2M__RQET = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__RQET);
break;
case CoAP__Options::ALT_oneM2M__RSET:
single_value.field_oneM2M__RSET = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__RSET);
break;
case CoAP__Options::ALT_oneM2M__OET:
single_value.field_oneM2M__OET = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__OET);
break;
case CoAP__Options::ALT_oneM2M__RTURI:
single_value.field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__RTURI);
break;
case CoAP__Options::ALT_oneM2M__EC:
single_value.field_oneM2M__EC = new INTEGER_template(*other_value.single_value.field_oneM2M__EC);
break;
case CoAP__Options::ALT_oneM2M__RSC:
single_value.field_oneM2M__RSC = new INTEGER_template(*other_value.single_value.field_oneM2M__RSC);
break;
case CoAP__Options::ALT_oneM2M__GID:
single_value.field_oneM2M__GID = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__GID);
break;
case CoAP__Options::ALT_oneM2M__TY:
single_value.field_oneM2M__TY = new INTEGER_template(*other_value.single_value.field_oneM2M__TY);
break;
case CoAP__Options::ALT_oneM2M__CTO:
single_value.field_oneM2M__CTO = new INTEGER_template(*other_value.single_value.field_oneM2M__CTO);
break;
case CoAP__Options::ALT_oneM2M__CTS:
single_value.field_oneM2M__CTS = new INTEGER_template(*other_value.single_value.field_oneM2M__CTS);
break;
case CoAP__Options::ALT_oneM2M__ATI:
single_value.field_oneM2M__ATI = new UNIVERSAL_CHARSTRING_template(*other_value.single_value.field_oneM2M__ATI);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @CoAP_Types.CoAP_Options.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CoAP__Options_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @CoAP_Types.CoAP_Options.");
}
set_selection(other_value);
}

CoAP__Options_template::CoAP__Options_template()
{
}

CoAP__Options_template::CoAP__Options_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CoAP__Options_template::CoAP__Options_template(const CoAP__Options& other_value)
{
copy_value(other_value);
}

CoAP__Options_template::CoAP__Options_template(const OPTIONAL<CoAP__Options>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__Options&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @CoAP_Types.CoAP_Options from an unbound optional field.");
}
}

CoAP__Options_template::CoAP__Options_template(const CoAP__Options_template& other_value)
: Base_Template(){
copy_template(other_value);
}

CoAP__Options_template::~CoAP__Options_template()
{
clean_up();
}

void CoAP__Options_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
delete single_value.field_if__match;
break;
case CoAP__Options::ALT_uri__host:
delete single_value.field_uri__host;
break;
case CoAP__Options::ALT_etag:
delete single_value.field_etag;
break;
case CoAP__Options::ALT_if__none__match:
delete single_value.field_if__none__match;
break;
case CoAP__Options::ALT_observe:
delete single_value.field_observe;
break;
case CoAP__Options::ALT_uri__port:
delete single_value.field_uri__port;
break;
case CoAP__Options::ALT_location__path:
delete single_value.field_location__path;
break;
case CoAP__Options::ALT_uri__path:
delete single_value.field_uri__path;
break;
case CoAP__Options::ALT_content__format:
delete single_value.field_content__format;
break;
case CoAP__Options::ALT_max__age:
delete single_value.field_max__age;
break;
case CoAP__Options::ALT_uri__query:
delete single_value.field_uri__query;
break;
case CoAP__Options::ALT_accept:
delete single_value.field_accept;
break;
case CoAP__Options::ALT_location__query:
delete single_value.field_location__query;
break;
case CoAP__Options::ALT_block1:
delete single_value.field_block1;
break;
case CoAP__Options::ALT_block2:
delete single_value.field_block2;
break;
case CoAP__Options::ALT_proxy__uri:
delete single_value.field_proxy__uri;
break;
case CoAP__Options::ALT_proxy__scheme:
delete single_value.field_proxy__scheme;
break;
case CoAP__Options::ALT_size1:
delete single_value.field_size1;
break;
case CoAP__Options::ALT_unknown__option:
delete single_value.field_unknown__option;
break;
case CoAP__Options::ALT_oneM2M__FR:
delete single_value.field_oneM2M__FR;
break;
case CoAP__Options::ALT_oneM2M__RQI:
delete single_value.field_oneM2M__RQI;
break;
case CoAP__Options::ALT_oneM2M__OT:
delete single_value.field_oneM2M__OT;
break;
case CoAP__Options::ALT_oneM2M__RQET:
delete single_value.field_oneM2M__RQET;
break;
case CoAP__Options::ALT_oneM2M__RSET:
delete single_value.field_oneM2M__RSET;
break;
case CoAP__Options::ALT_oneM2M__OET:
delete single_value.field_oneM2M__OET;
break;
case CoAP__Options::ALT_oneM2M__RTURI:
delete single_value.field_oneM2M__RTURI;
break;
case CoAP__Options::ALT_oneM2M__EC:
delete single_value.field_oneM2M__EC;
break;
case CoAP__Options::ALT_oneM2M__RSC:
delete single_value.field_oneM2M__RSC;
break;
case CoAP__Options::ALT_oneM2M__GID:
delete single_value.field_oneM2M__GID;
break;
case CoAP__Options::ALT_oneM2M__TY:
delete single_value.field_oneM2M__TY;
break;
case CoAP__Options::ALT_oneM2M__CTO:
delete single_value.field_oneM2M__CTO;
break;
case CoAP__Options::ALT_oneM2M__CTS:
delete single_value.field_oneM2M__CTS;
break;
case CoAP__Options::ALT_oneM2M__ATI:
delete single_value.field_oneM2M__ATI;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CoAP__Options_template& CoAP__Options_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CoAP__Options_template& CoAP__Options_template::operator=(const CoAP__Options& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CoAP__Options_template& CoAP__Options_template::operator=(const OPTIONAL<CoAP__Options>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__Options&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @CoAP_Types.CoAP_Options.");
}
return *this;
}

CoAP__Options_template& CoAP__Options_template::operator=(const CoAP__Options_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CoAP__Options_template::match(const CoAP__Options& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
CoAP__Options::union_selection_type value_selection = other_value.get_selection();
if (value_selection == CoAP__Options::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case CoAP__Options::ALT_if__match:
return single_value.field_if__match->match(other_value.if__match(), legacy);
case CoAP__Options::ALT_uri__host:
return single_value.field_uri__host->match(other_value.uri__host(), legacy);
case CoAP__Options::ALT_etag:
return single_value.field_etag->match(other_value.etag(), legacy);
case CoAP__Options::ALT_if__none__match:
return single_value.field_if__none__match->match(other_value.if__none__match(), legacy);
case CoAP__Options::ALT_observe:
return single_value.field_observe->match(other_value.observe(), legacy);
case CoAP__Options::ALT_uri__port:
return single_value.field_uri__port->match(other_value.uri__port(), legacy);
case CoAP__Options::ALT_location__path:
return single_value.field_location__path->match(other_value.location__path(), legacy);
case CoAP__Options::ALT_uri__path:
return single_value.field_uri__path->match(other_value.uri__path(), legacy);
case CoAP__Options::ALT_content__format:
return single_value.field_content__format->match(other_value.content__format(), legacy);
case CoAP__Options::ALT_max__age:
return single_value.field_max__age->match(other_value.max__age(), legacy);
case CoAP__Options::ALT_uri__query:
return single_value.field_uri__query->match(other_value.uri__query(), legacy);
case CoAP__Options::ALT_accept:
return single_value.field_accept->match(other_value.accept(), legacy);
case CoAP__Options::ALT_location__query:
return single_value.field_location__query->match(other_value.location__query(), legacy);
case CoAP__Options::ALT_block1:
return single_value.field_block1->match(other_value.block1(), legacy);
case CoAP__Options::ALT_block2:
return single_value.field_block2->match(other_value.block2(), legacy);
case CoAP__Options::ALT_proxy__uri:
return single_value.field_proxy__uri->match(other_value.proxy__uri(), legacy);
case CoAP__Options::ALT_proxy__scheme:
return single_value.field_proxy__scheme->match(other_value.proxy__scheme(), legacy);
case CoAP__Options::ALT_size1:
return single_value.field_size1->match(other_value.size1(), legacy);
case CoAP__Options::ALT_unknown__option:
return single_value.field_unknown__option->match(other_value.unknown__option(), legacy);
case CoAP__Options::ALT_oneM2M__FR:
return single_value.field_oneM2M__FR->match(other_value.oneM2M__FR(), legacy);
case CoAP__Options::ALT_oneM2M__RQI:
return single_value.field_oneM2M__RQI->match(other_value.oneM2M__RQI(), legacy);
case CoAP__Options::ALT_oneM2M__OT:
return single_value.field_oneM2M__OT->match(other_value.oneM2M__OT(), legacy);
case CoAP__Options::ALT_oneM2M__RQET:
return single_value.field_oneM2M__RQET->match(other_value.oneM2M__RQET(), legacy);
case CoAP__Options::ALT_oneM2M__RSET:
return single_value.field_oneM2M__RSET->match(other_value.oneM2M__RSET(), legacy);
case CoAP__Options::ALT_oneM2M__OET:
return single_value.field_oneM2M__OET->match(other_value.oneM2M__OET(), legacy);
case CoAP__Options::ALT_oneM2M__RTURI:
return single_value.field_oneM2M__RTURI->match(other_value.oneM2M__RTURI(), legacy);
case CoAP__Options::ALT_oneM2M__EC:
return single_value.field_oneM2M__EC->match(other_value.oneM2M__EC(), legacy);
case CoAP__Options::ALT_oneM2M__RSC:
return single_value.field_oneM2M__RSC->match(other_value.oneM2M__RSC(), legacy);
case CoAP__Options::ALT_oneM2M__GID:
return single_value.field_oneM2M__GID->match(other_value.oneM2M__GID(), legacy);
case CoAP__Options::ALT_oneM2M__TY:
return single_value.field_oneM2M__TY->match(other_value.oneM2M__TY(), legacy);
case CoAP__Options::ALT_oneM2M__CTO:
return single_value.field_oneM2M__CTO->match(other_value.oneM2M__CTO(), legacy);
case CoAP__Options::ALT_oneM2M__CTS:
return single_value.field_oneM2M__CTS->match(other_value.oneM2M__CTS(), legacy);
case CoAP__Options::ALT_oneM2M__ATI:
return single_value.field_oneM2M__ATI->match(other_value.oneM2M__ATI(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @CoAP_Types.CoAP_Options.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @CoAP_Types.CoAP_Options.");
}
return FALSE;
}

boolean CoAP__Options_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
return single_value.field_if__match->is_value();
case CoAP__Options::ALT_uri__host:
return single_value.field_uri__host->is_value();
case CoAP__Options::ALT_etag:
return single_value.field_etag->is_value();
case CoAP__Options::ALT_if__none__match:
return single_value.field_if__none__match->is_value();
case CoAP__Options::ALT_observe:
return single_value.field_observe->is_value();
case CoAP__Options::ALT_uri__port:
return single_value.field_uri__port->is_value();
case CoAP__Options::ALT_location__path:
return single_value.field_location__path->is_value();
case CoAP__Options::ALT_uri__path:
return single_value.field_uri__path->is_value();
case CoAP__Options::ALT_content__format:
return single_value.field_content__format->is_value();
case CoAP__Options::ALT_max__age:
return single_value.field_max__age->is_value();
case CoAP__Options::ALT_uri__query:
return single_value.field_uri__query->is_value();
case CoAP__Options::ALT_accept:
return single_value.field_accept->is_value();
case CoAP__Options::ALT_location__query:
return single_value.field_location__query->is_value();
case CoAP__Options::ALT_block1:
return single_value.field_block1->is_value();
case CoAP__Options::ALT_block2:
return single_value.field_block2->is_value();
case CoAP__Options::ALT_proxy__uri:
return single_value.field_proxy__uri->is_value();
case CoAP__Options::ALT_proxy__scheme:
return single_value.field_proxy__scheme->is_value();
case CoAP__Options::ALT_size1:
return single_value.field_size1->is_value();
case CoAP__Options::ALT_unknown__option:
return single_value.field_unknown__option->is_value();
case CoAP__Options::ALT_oneM2M__FR:
return single_value.field_oneM2M__FR->is_value();
case CoAP__Options::ALT_oneM2M__RQI:
return single_value.field_oneM2M__RQI->is_value();
case CoAP__Options::ALT_oneM2M__OT:
return single_value.field_oneM2M__OT->is_value();
case CoAP__Options::ALT_oneM2M__RQET:
return single_value.field_oneM2M__RQET->is_value();
case CoAP__Options::ALT_oneM2M__RSET:
return single_value.field_oneM2M__RSET->is_value();
case CoAP__Options::ALT_oneM2M__OET:
return single_value.field_oneM2M__OET->is_value();
case CoAP__Options::ALT_oneM2M__RTURI:
return single_value.field_oneM2M__RTURI->is_value();
case CoAP__Options::ALT_oneM2M__EC:
return single_value.field_oneM2M__EC->is_value();
case CoAP__Options::ALT_oneM2M__RSC:
return single_value.field_oneM2M__RSC->is_value();
case CoAP__Options::ALT_oneM2M__GID:
return single_value.field_oneM2M__GID->is_value();
case CoAP__Options::ALT_oneM2M__TY:
return single_value.field_oneM2M__TY->is_value();
case CoAP__Options::ALT_oneM2M__CTO:
return single_value.field_oneM2M__CTO->is_value();
case CoAP__Options::ALT_oneM2M__CTS:
return single_value.field_oneM2M__CTS->is_value();
case CoAP__Options::ALT_oneM2M__ATI:
return single_value.field_oneM2M__ATI->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @CoAP_Types.CoAP_Options.");
}
}

CoAP__Options CoAP__Options_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @CoAP_Types.CoAP_Options.");
CoAP__Options ret_val;
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
ret_val.if__match() = single_value.field_if__match->valueof();
break;
case CoAP__Options::ALT_uri__host:
ret_val.uri__host() = single_value.field_uri__host->valueof();
break;
case CoAP__Options::ALT_etag:
ret_val.etag() = single_value.field_etag->valueof();
break;
case CoAP__Options::ALT_if__none__match:
ret_val.if__none__match() = single_value.field_if__none__match->valueof();
break;
case CoAP__Options::ALT_observe:
ret_val.observe() = single_value.field_observe->valueof();
break;
case CoAP__Options::ALT_uri__port:
ret_val.uri__port() = single_value.field_uri__port->valueof();
break;
case CoAP__Options::ALT_location__path:
ret_val.location__path() = single_value.field_location__path->valueof();
break;
case CoAP__Options::ALT_uri__path:
ret_val.uri__path() = single_value.field_uri__path->valueof();
break;
case CoAP__Options::ALT_content__format:
ret_val.content__format() = single_value.field_content__format->valueof();
break;
case CoAP__Options::ALT_max__age:
ret_val.max__age() = single_value.field_max__age->valueof();
break;
case CoAP__Options::ALT_uri__query:
ret_val.uri__query() = single_value.field_uri__query->valueof();
break;
case CoAP__Options::ALT_accept:
ret_val.accept() = single_value.field_accept->valueof();
break;
case CoAP__Options::ALT_location__query:
ret_val.location__query() = single_value.field_location__query->valueof();
break;
case CoAP__Options::ALT_block1:
ret_val.block1() = single_value.field_block1->valueof();
break;
case CoAP__Options::ALT_block2:
ret_val.block2() = single_value.field_block2->valueof();
break;
case CoAP__Options::ALT_proxy__uri:
ret_val.proxy__uri() = single_value.field_proxy__uri->valueof();
break;
case CoAP__Options::ALT_proxy__scheme:
ret_val.proxy__scheme() = single_value.field_proxy__scheme->valueof();
break;
case CoAP__Options::ALT_size1:
ret_val.size1() = single_value.field_size1->valueof();
break;
case CoAP__Options::ALT_unknown__option:
ret_val.unknown__option() = single_value.field_unknown__option->valueof();
break;
case CoAP__Options::ALT_oneM2M__FR:
ret_val.oneM2M__FR() = single_value.field_oneM2M__FR->valueof();
break;
case CoAP__Options::ALT_oneM2M__RQI:
ret_val.oneM2M__RQI() = single_value.field_oneM2M__RQI->valueof();
break;
case CoAP__Options::ALT_oneM2M__OT:
ret_val.oneM2M__OT() = single_value.field_oneM2M__OT->valueof();
break;
case CoAP__Options::ALT_oneM2M__RQET:
ret_val.oneM2M__RQET() = single_value.field_oneM2M__RQET->valueof();
break;
case CoAP__Options::ALT_oneM2M__RSET:
ret_val.oneM2M__RSET() = single_value.field_oneM2M__RSET->valueof();
break;
case CoAP__Options::ALT_oneM2M__OET:
ret_val.oneM2M__OET() = single_value.field_oneM2M__OET->valueof();
break;
case CoAP__Options::ALT_oneM2M__RTURI:
ret_val.oneM2M__RTURI() = single_value.field_oneM2M__RTURI->valueof();
break;
case CoAP__Options::ALT_oneM2M__EC:
ret_val.oneM2M__EC() = single_value.field_oneM2M__EC->valueof();
break;
case CoAP__Options::ALT_oneM2M__RSC:
ret_val.oneM2M__RSC() = single_value.field_oneM2M__RSC->valueof();
break;
case CoAP__Options::ALT_oneM2M__GID:
ret_val.oneM2M__GID() = single_value.field_oneM2M__GID->valueof();
break;
case CoAP__Options::ALT_oneM2M__TY:
ret_val.oneM2M__TY() = single_value.field_oneM2M__TY->valueof();
break;
case CoAP__Options::ALT_oneM2M__CTO:
ret_val.oneM2M__CTO() = single_value.field_oneM2M__CTO->valueof();
break;
case CoAP__Options::ALT_oneM2M__CTS:
ret_val.oneM2M__CTS() = single_value.field_oneM2M__CTS->valueof();
break;
case CoAP__Options::ALT_oneM2M__ATI:
ret_val.oneM2M__ATI() = single_value.field_oneM2M__ATI->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @CoAP_Types.CoAP_Options.");
}
return ret_val;
}

CoAP__Options_template& CoAP__Options_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @CoAP_Types.CoAP_Options.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @CoAP_Types.CoAP_Options.");
return value_list.list_value[list_index];
}
void CoAP__Options_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @CoAP_Types.CoAP_Options.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CoAP__Options_template[list_length];
}

OCTETSTRING_template& CoAP__Options_template::if__match()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_if__match) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_if__match = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_if__match = new OCTETSTRING_template;
single_value.union_selection = CoAP__Options::ALT_if__match;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_if__match;
}

const OCTETSTRING_template& CoAP__Options_template::if__match() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field if_match in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_if__match) TTCN_error("Accessing non-selected field if_match in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_if__match;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__host()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_uri__host) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_uri__host = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_uri__host = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_uri__host;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_uri__host;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__host() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field uri_host in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_uri__host) TTCN_error("Accessing non-selected field uri_host in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_uri__host;
}

OCTETSTRING_template& CoAP__Options_template::etag()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_etag) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_etag = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_etag = new OCTETSTRING_template;
single_value.union_selection = CoAP__Options::ALT_etag;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_etag;
}

const OCTETSTRING_template& CoAP__Options_template::etag() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field etag in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_etag) TTCN_error("Accessing non-selected field etag in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_etag;
}

OCTETSTRING_template& CoAP__Options_template::if__none__match()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_if__none__match) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_if__none__match = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_if__none__match = new OCTETSTRING_template;
single_value.union_selection = CoAP__Options::ALT_if__none__match;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_if__none__match;
}

const OCTETSTRING_template& CoAP__Options_template::if__none__match() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field if_none_match in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_if__none__match) TTCN_error("Accessing non-selected field if_none_match in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_if__none__match;
}

INTEGER_template& CoAP__Options_template::observe()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_observe) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_observe = new INTEGER_template(ANY_VALUE);
else single_value.field_observe = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_observe;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_observe;
}

const INTEGER_template& CoAP__Options_template::observe() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field observe in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_observe) TTCN_error("Accessing non-selected field observe in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_observe;
}

INTEGER_template& CoAP__Options_template::uri__port()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_uri__port) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_uri__port = new INTEGER_template(ANY_VALUE);
else single_value.field_uri__port = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_uri__port;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_uri__port;
}

const INTEGER_template& CoAP__Options_template::uri__port() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field uri_port in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_uri__port) TTCN_error("Accessing non-selected field uri_port in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_uri__port;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::location__path()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_location__path) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_location__path = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_location__path = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_location__path;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_location__path;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::location__path() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field location_path in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_location__path) TTCN_error("Accessing non-selected field location_path in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_location__path;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__path()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_uri__path) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_uri__path = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_uri__path = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_uri__path;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_uri__path;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__path() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field uri_path in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_uri__path) TTCN_error("Accessing non-selected field uri_path in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_uri__path;
}

INTEGER_template& CoAP__Options_template::content__format()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_content__format) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_content__format = new INTEGER_template(ANY_VALUE);
else single_value.field_content__format = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_content__format;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_content__format;
}

const INTEGER_template& CoAP__Options_template::content__format() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field content_format in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_content__format) TTCN_error("Accessing non-selected field content_format in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_content__format;
}

INTEGER_template& CoAP__Options_template::max__age()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_max__age) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_max__age = new INTEGER_template(ANY_VALUE);
else single_value.field_max__age = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_max__age;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_max__age;
}

const INTEGER_template& CoAP__Options_template::max__age() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field max_age in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_max__age) TTCN_error("Accessing non-selected field max_age in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_max__age;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__query()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_uri__query) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_uri__query = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_uri__query = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_uri__query;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_uri__query;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::uri__query() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field uri_query in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_uri__query) TTCN_error("Accessing non-selected field uri_query in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_uri__query;
}

INTEGER_template& CoAP__Options_template::accept()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_accept) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_accept = new INTEGER_template(ANY_VALUE);
else single_value.field_accept = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_accept;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_accept;
}

const INTEGER_template& CoAP__Options_template::accept() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field accept in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_accept) TTCN_error("Accessing non-selected field accept in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_accept;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::location__query()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_location__query) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_location__query = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_location__query = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_location__query;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_location__query;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::location__query() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field location_query in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_location__query) TTCN_error("Accessing non-selected field location_query in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_location__query;
}

BlockOption_template& CoAP__Options_template::block1()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_block1) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_block1 = new BlockOption_template(ANY_VALUE);
else single_value.field_block1 = new BlockOption_template;
single_value.union_selection = CoAP__Options::ALT_block1;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_block1;
}

const BlockOption_template& CoAP__Options_template::block1() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field block1 in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_block1) TTCN_error("Accessing non-selected field block1 in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_block1;
}

BlockOption_template& CoAP__Options_template::block2()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_block2) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_block2 = new BlockOption_template(ANY_VALUE);
else single_value.field_block2 = new BlockOption_template;
single_value.union_selection = CoAP__Options::ALT_block2;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_block2;
}

const BlockOption_template& CoAP__Options_template::block2() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field block2 in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_block2) TTCN_error("Accessing non-selected field block2 in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_block2;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::proxy__uri()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_proxy__uri) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_proxy__uri = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_proxy__uri = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_proxy__uri;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_proxy__uri;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::proxy__uri() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field proxy_uri in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_proxy__uri) TTCN_error("Accessing non-selected field proxy_uri in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_proxy__uri;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::proxy__scheme()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_proxy__scheme) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_proxy__scheme = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_proxy__scheme = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_proxy__scheme;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_proxy__scheme;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::proxy__scheme() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field proxy_scheme in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_proxy__scheme) TTCN_error("Accessing non-selected field proxy_scheme in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_proxy__scheme;
}

INTEGER_template& CoAP__Options_template::size1()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_size1) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_size1 = new INTEGER_template(ANY_VALUE);
else single_value.field_size1 = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_size1;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_size1;
}

const INTEGER_template& CoAP__Options_template::size1() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field size1 in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_size1) TTCN_error("Accessing non-selected field size1 in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_size1;
}

UnknownOption_template& CoAP__Options_template::unknown__option()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_unknown__option) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_unknown__option = new UnknownOption_template(ANY_VALUE);
else single_value.field_unknown__option = new UnknownOption_template;
single_value.union_selection = CoAP__Options::ALT_unknown__option;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_unknown__option;
}

const UnknownOption_template& CoAP__Options_template::unknown__option() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field unknown_option in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_unknown__option) TTCN_error("Accessing non-selected field unknown_option in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_unknown__option;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__FR()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__FR) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__FR = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__FR = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__FR;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__FR;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__FR() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_FR in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__FR) TTCN_error("Accessing non-selected field oneM2M_FR in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__FR;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RQI()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__RQI) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__RQI = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__RQI = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__RQI;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__RQI;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RQI() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_RQI in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__RQI) TTCN_error("Accessing non-selected field oneM2M_RQI in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__RQI;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__OT()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__OT) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__OT = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__OT = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__OT;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__OT;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__OT() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_OT in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__OT) TTCN_error("Accessing non-selected field oneM2M_OT in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__OT;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RQET()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__RQET) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__RQET = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__RQET = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__RQET;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__RQET;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RQET() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_RQET in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__RQET) TTCN_error("Accessing non-selected field oneM2M_RQET in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__RQET;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RSET()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__RSET) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__RSET = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__RSET = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__RSET;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__RSET;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RSET() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_RSET in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__RSET) TTCN_error("Accessing non-selected field oneM2M_RSET in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__RSET;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__OET()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__OET) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__OET = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__OET = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__OET;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__OET;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__OET() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_OET in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__OET) TTCN_error("Accessing non-selected field oneM2M_OET in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__OET;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RTURI()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__RTURI) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__RTURI;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__RTURI;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__RTURI() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_RTURI in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__RTURI) TTCN_error("Accessing non-selected field oneM2M_RTURI in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__RTURI;
}

INTEGER_template& CoAP__Options_template::oneM2M__EC()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__EC) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__EC = new INTEGER_template(ANY_VALUE);
else single_value.field_oneM2M__EC = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__EC;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__EC;
}

const INTEGER_template& CoAP__Options_template::oneM2M__EC() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_EC in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__EC) TTCN_error("Accessing non-selected field oneM2M_EC in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__EC;
}

INTEGER_template& CoAP__Options_template::oneM2M__RSC()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__RSC) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__RSC = new INTEGER_template(ANY_VALUE);
else single_value.field_oneM2M__RSC = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__RSC;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__RSC;
}

const INTEGER_template& CoAP__Options_template::oneM2M__RSC() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_RSC in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__RSC) TTCN_error("Accessing non-selected field oneM2M_RSC in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__RSC;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__GID()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__GID) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__GID = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__GID = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__GID;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__GID;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__GID() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_GID in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__GID) TTCN_error("Accessing non-selected field oneM2M_GID in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__GID;
}

INTEGER_template& CoAP__Options_template::oneM2M__TY()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__TY) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__TY = new INTEGER_template(ANY_VALUE);
else single_value.field_oneM2M__TY = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__TY;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__TY;
}

const INTEGER_template& CoAP__Options_template::oneM2M__TY() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_TY in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__TY) TTCN_error("Accessing non-selected field oneM2M_TY in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__TY;
}

INTEGER_template& CoAP__Options_template::oneM2M__CTO()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__CTO) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__CTO = new INTEGER_template(ANY_VALUE);
else single_value.field_oneM2M__CTO = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__CTO;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__CTO;
}

const INTEGER_template& CoAP__Options_template::oneM2M__CTO() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_CTO in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__CTO) TTCN_error("Accessing non-selected field oneM2M_CTO in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__CTO;
}

INTEGER_template& CoAP__Options_template::oneM2M__CTS()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__CTS) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__CTS = new INTEGER_template(ANY_VALUE);
else single_value.field_oneM2M__CTS = new INTEGER_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__CTS;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__CTS;
}

const INTEGER_template& CoAP__Options_template::oneM2M__CTS() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_CTS in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__CTS) TTCN_error("Accessing non-selected field oneM2M_CTS in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__CTS;
}

UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__ATI()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Options::ALT_oneM2M__ATI) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_oneM2M__ATI = new UNIVERSAL_CHARSTRING_template(ANY_VALUE);
else single_value.field_oneM2M__ATI = new UNIVERSAL_CHARSTRING_template;
single_value.union_selection = CoAP__Options::ALT_oneM2M__ATI;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_oneM2M__ATI;
}

const UNIVERSAL_CHARSTRING_template& CoAP__Options_template::oneM2M__ATI() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field oneM2M_ATI in a non-specific template of union type @CoAP_Types.CoAP_Options.");
if (single_value.union_selection != CoAP__Options::ALT_oneM2M__ATI) TTCN_error("Accessing non-selected field oneM2M_ATI in a template of union type @CoAP_Types.CoAP_Options.");
return *single_value.field_oneM2M__ATI;
}

boolean CoAP__Options_template::ischosen(CoAP__Options::union_selection_type checked_selection) const
{
if (checked_selection == CoAP__Options::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CoAP_Types.CoAP_Options.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == CoAP__Options::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Options.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Options containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Options, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @CoAP_Types.CoAP_Options");
}
return FALSE;
}

void CoAP__Options_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
TTCN_Logger::log_event_str("{ if_match := ");
single_value.field_if__match->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_uri__host:
TTCN_Logger::log_event_str("{ uri_host := ");
single_value.field_uri__host->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_etag:
TTCN_Logger::log_event_str("{ etag := ");
single_value.field_etag->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_if__none__match:
TTCN_Logger::log_event_str("{ if_none_match := ");
single_value.field_if__none__match->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_observe:
TTCN_Logger::log_event_str("{ observe := ");
single_value.field_observe->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_uri__port:
TTCN_Logger::log_event_str("{ uri_port := ");
single_value.field_uri__port->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_location__path:
TTCN_Logger::log_event_str("{ location_path := ");
single_value.field_location__path->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_uri__path:
TTCN_Logger::log_event_str("{ uri_path := ");
single_value.field_uri__path->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_content__format:
TTCN_Logger::log_event_str("{ content_format := ");
single_value.field_content__format->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_max__age:
TTCN_Logger::log_event_str("{ max_age := ");
single_value.field_max__age->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_uri__query:
TTCN_Logger::log_event_str("{ uri_query := ");
single_value.field_uri__query->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_accept:
TTCN_Logger::log_event_str("{ accept := ");
single_value.field_accept->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_location__query:
TTCN_Logger::log_event_str("{ location_query := ");
single_value.field_location__query->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_block1:
TTCN_Logger::log_event_str("{ block1 := ");
single_value.field_block1->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_block2:
TTCN_Logger::log_event_str("{ block2 := ");
single_value.field_block2->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_proxy__uri:
TTCN_Logger::log_event_str("{ proxy_uri := ");
single_value.field_proxy__uri->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_proxy__scheme:
TTCN_Logger::log_event_str("{ proxy_scheme := ");
single_value.field_proxy__scheme->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_size1:
TTCN_Logger::log_event_str("{ size1 := ");
single_value.field_size1->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_unknown__option:
TTCN_Logger::log_event_str("{ unknown_option := ");
single_value.field_unknown__option->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__FR:
TTCN_Logger::log_event_str("{ oneM2M_FR := ");
single_value.field_oneM2M__FR->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__RQI:
TTCN_Logger::log_event_str("{ oneM2M_RQI := ");
single_value.field_oneM2M__RQI->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__OT:
TTCN_Logger::log_event_str("{ oneM2M_OT := ");
single_value.field_oneM2M__OT->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__RQET:
TTCN_Logger::log_event_str("{ oneM2M_RQET := ");
single_value.field_oneM2M__RQET->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__RSET:
TTCN_Logger::log_event_str("{ oneM2M_RSET := ");
single_value.field_oneM2M__RSET->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__OET:
TTCN_Logger::log_event_str("{ oneM2M_OET := ");
single_value.field_oneM2M__OET->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__RTURI:
TTCN_Logger::log_event_str("{ oneM2M_RTURI := ");
single_value.field_oneM2M__RTURI->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__EC:
TTCN_Logger::log_event_str("{ oneM2M_EC := ");
single_value.field_oneM2M__EC->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__RSC:
TTCN_Logger::log_event_str("{ oneM2M_RSC := ");
single_value.field_oneM2M__RSC->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__GID:
TTCN_Logger::log_event_str("{ oneM2M_GID := ");
single_value.field_oneM2M__GID->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__TY:
TTCN_Logger::log_event_str("{ oneM2M_TY := ");
single_value.field_oneM2M__TY->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__CTO:
TTCN_Logger::log_event_str("{ oneM2M_CTO := ");
single_value.field_oneM2M__CTO->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__CTS:
TTCN_Logger::log_event_str("{ oneM2M_CTS := ");
single_value.field_oneM2M__CTS->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Options::ALT_oneM2M__ATI:
TTCN_Logger::log_event_str("{ oneM2M_ATI := ");
single_value.field_oneM2M__ATI->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CoAP__Options_template::log_match(const CoAP__Options& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".if_match");
single_value.field_if__match->log_match(match_value.if__match(), legacy);
} else {
TTCN_Logger::log_event_str("{ if_match := ");
single_value.field_if__match->log_match(match_value.if__match(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_uri__host:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".uri_host");
single_value.field_uri__host->log_match(match_value.uri__host(), legacy);
} else {
TTCN_Logger::log_event_str("{ uri_host := ");
single_value.field_uri__host->log_match(match_value.uri__host(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_etag:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".etag");
single_value.field_etag->log_match(match_value.etag(), legacy);
} else {
TTCN_Logger::log_event_str("{ etag := ");
single_value.field_etag->log_match(match_value.etag(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_if__none__match:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".if_none_match");
single_value.field_if__none__match->log_match(match_value.if__none__match(), legacy);
} else {
TTCN_Logger::log_event_str("{ if_none_match := ");
single_value.field_if__none__match->log_match(match_value.if__none__match(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_observe:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".observe");
single_value.field_observe->log_match(match_value.observe(), legacy);
} else {
TTCN_Logger::log_event_str("{ observe := ");
single_value.field_observe->log_match(match_value.observe(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_uri__port:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".uri_port");
single_value.field_uri__port->log_match(match_value.uri__port(), legacy);
} else {
TTCN_Logger::log_event_str("{ uri_port := ");
single_value.field_uri__port->log_match(match_value.uri__port(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_location__path:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".location_path");
single_value.field_location__path->log_match(match_value.location__path(), legacy);
} else {
TTCN_Logger::log_event_str("{ location_path := ");
single_value.field_location__path->log_match(match_value.location__path(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_uri__path:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".uri_path");
single_value.field_uri__path->log_match(match_value.uri__path(), legacy);
} else {
TTCN_Logger::log_event_str("{ uri_path := ");
single_value.field_uri__path->log_match(match_value.uri__path(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_content__format:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".content_format");
single_value.field_content__format->log_match(match_value.content__format(), legacy);
} else {
TTCN_Logger::log_event_str("{ content_format := ");
single_value.field_content__format->log_match(match_value.content__format(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_max__age:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".max_age");
single_value.field_max__age->log_match(match_value.max__age(), legacy);
} else {
TTCN_Logger::log_event_str("{ max_age := ");
single_value.field_max__age->log_match(match_value.max__age(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_uri__query:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".uri_query");
single_value.field_uri__query->log_match(match_value.uri__query(), legacy);
} else {
TTCN_Logger::log_event_str("{ uri_query := ");
single_value.field_uri__query->log_match(match_value.uri__query(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_accept:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".accept");
single_value.field_accept->log_match(match_value.accept(), legacy);
} else {
TTCN_Logger::log_event_str("{ accept := ");
single_value.field_accept->log_match(match_value.accept(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_location__query:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".location_query");
single_value.field_location__query->log_match(match_value.location__query(), legacy);
} else {
TTCN_Logger::log_event_str("{ location_query := ");
single_value.field_location__query->log_match(match_value.location__query(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_block1:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".block1");
single_value.field_block1->log_match(match_value.block1(), legacy);
} else {
TTCN_Logger::log_event_str("{ block1 := ");
single_value.field_block1->log_match(match_value.block1(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_block2:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".block2");
single_value.field_block2->log_match(match_value.block2(), legacy);
} else {
TTCN_Logger::log_event_str("{ block2 := ");
single_value.field_block2->log_match(match_value.block2(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_proxy__uri:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".proxy_uri");
single_value.field_proxy__uri->log_match(match_value.proxy__uri(), legacy);
} else {
TTCN_Logger::log_event_str("{ proxy_uri := ");
single_value.field_proxy__uri->log_match(match_value.proxy__uri(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_proxy__scheme:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".proxy_scheme");
single_value.field_proxy__scheme->log_match(match_value.proxy__scheme(), legacy);
} else {
TTCN_Logger::log_event_str("{ proxy_scheme := ");
single_value.field_proxy__scheme->log_match(match_value.proxy__scheme(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_size1:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".size1");
single_value.field_size1->log_match(match_value.size1(), legacy);
} else {
TTCN_Logger::log_event_str("{ size1 := ");
single_value.field_size1->log_match(match_value.size1(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_unknown__option:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".unknown_option");
single_value.field_unknown__option->log_match(match_value.unknown__option(), legacy);
} else {
TTCN_Logger::log_event_str("{ unknown_option := ");
single_value.field_unknown__option->log_match(match_value.unknown__option(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__FR:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_FR");
single_value.field_oneM2M__FR->log_match(match_value.oneM2M__FR(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_FR := ");
single_value.field_oneM2M__FR->log_match(match_value.oneM2M__FR(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__RQI:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_RQI");
single_value.field_oneM2M__RQI->log_match(match_value.oneM2M__RQI(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_RQI := ");
single_value.field_oneM2M__RQI->log_match(match_value.oneM2M__RQI(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__OT:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_OT");
single_value.field_oneM2M__OT->log_match(match_value.oneM2M__OT(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_OT := ");
single_value.field_oneM2M__OT->log_match(match_value.oneM2M__OT(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__RQET:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_RQET");
single_value.field_oneM2M__RQET->log_match(match_value.oneM2M__RQET(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_RQET := ");
single_value.field_oneM2M__RQET->log_match(match_value.oneM2M__RQET(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__RSET:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_RSET");
single_value.field_oneM2M__RSET->log_match(match_value.oneM2M__RSET(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_RSET := ");
single_value.field_oneM2M__RSET->log_match(match_value.oneM2M__RSET(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__OET:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_OET");
single_value.field_oneM2M__OET->log_match(match_value.oneM2M__OET(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_OET := ");
single_value.field_oneM2M__OET->log_match(match_value.oneM2M__OET(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__RTURI:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_RTURI");
single_value.field_oneM2M__RTURI->log_match(match_value.oneM2M__RTURI(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_RTURI := ");
single_value.field_oneM2M__RTURI->log_match(match_value.oneM2M__RTURI(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__EC:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_EC");
single_value.field_oneM2M__EC->log_match(match_value.oneM2M__EC(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_EC := ");
single_value.field_oneM2M__EC->log_match(match_value.oneM2M__EC(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__RSC:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_RSC");
single_value.field_oneM2M__RSC->log_match(match_value.oneM2M__RSC(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_RSC := ");
single_value.field_oneM2M__RSC->log_match(match_value.oneM2M__RSC(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__GID:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_GID");
single_value.field_oneM2M__GID->log_match(match_value.oneM2M__GID(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_GID := ");
single_value.field_oneM2M__GID->log_match(match_value.oneM2M__GID(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__TY:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_TY");
single_value.field_oneM2M__TY->log_match(match_value.oneM2M__TY(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_TY := ");
single_value.field_oneM2M__TY->log_match(match_value.oneM2M__TY(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__CTO:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_CTO");
single_value.field_oneM2M__CTO->log_match(match_value.oneM2M__CTO(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_CTO := ");
single_value.field_oneM2M__CTO->log_match(match_value.oneM2M__CTO(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__CTS:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_CTS");
single_value.field_oneM2M__CTS->log_match(match_value.oneM2M__CTS(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_CTS := ");
single_value.field_oneM2M__CTS->log_match(match_value.oneM2M__CTS(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Options::ALT_oneM2M__ATI:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".oneM2M_ATI");
single_value.field_oneM2M__ATI->log_match(match_value.oneM2M__ATI(), legacy);
} else {
TTCN_Logger::log_event_str("{ oneM2M_ATI := ");
single_value.field_oneM2M__ATI->log_match(match_value.oneM2M__ATI(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CoAP__Options_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
single_value.field_if__match->encode_text(text_buf);
break;
case CoAP__Options::ALT_uri__host:
single_value.field_uri__host->encode_text(text_buf);
break;
case CoAP__Options::ALT_etag:
single_value.field_etag->encode_text(text_buf);
break;
case CoAP__Options::ALT_if__none__match:
single_value.field_if__none__match->encode_text(text_buf);
break;
case CoAP__Options::ALT_observe:
single_value.field_observe->encode_text(text_buf);
break;
case CoAP__Options::ALT_uri__port:
single_value.field_uri__port->encode_text(text_buf);
break;
case CoAP__Options::ALT_location__path:
single_value.field_location__path->encode_text(text_buf);
break;
case CoAP__Options::ALT_uri__path:
single_value.field_uri__path->encode_text(text_buf);
break;
case CoAP__Options::ALT_content__format:
single_value.field_content__format->encode_text(text_buf);
break;
case CoAP__Options::ALT_max__age:
single_value.field_max__age->encode_text(text_buf);
break;
case CoAP__Options::ALT_uri__query:
single_value.field_uri__query->encode_text(text_buf);
break;
case CoAP__Options::ALT_accept:
single_value.field_accept->encode_text(text_buf);
break;
case CoAP__Options::ALT_location__query:
single_value.field_location__query->encode_text(text_buf);
break;
case CoAP__Options::ALT_block1:
single_value.field_block1->encode_text(text_buf);
break;
case CoAP__Options::ALT_block2:
single_value.field_block2->encode_text(text_buf);
break;
case CoAP__Options::ALT_proxy__uri:
single_value.field_proxy__uri->encode_text(text_buf);
break;
case CoAP__Options::ALT_proxy__scheme:
single_value.field_proxy__scheme->encode_text(text_buf);
break;
case CoAP__Options::ALT_size1:
single_value.field_size1->encode_text(text_buf);
break;
case CoAP__Options::ALT_unknown__option:
single_value.field_unknown__option->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__FR:
single_value.field_oneM2M__FR->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RQI:
single_value.field_oneM2M__RQI->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__OT:
single_value.field_oneM2M__OT->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RQET:
single_value.field_oneM2M__RQET->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RSET:
single_value.field_oneM2M__RSET->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__OET:
single_value.field_oneM2M__OET->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RTURI:
single_value.field_oneM2M__RTURI->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__EC:
single_value.field_oneM2M__EC->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RSC:
single_value.field_oneM2M__RSC->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__GID:
single_value.field_oneM2M__GID->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__TY:
single_value.field_oneM2M__TY->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__CTO:
single_value.field_oneM2M__CTO->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__CTS:
single_value.field_oneM2M__CTS->encode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__ATI:
single_value.field_oneM2M__ATI->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @CoAP_Types.CoAP_Options.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @CoAP_Types.CoAP_Options.");
}
}

void CoAP__Options_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = CoAP__Options::UNBOUND_VALUE;
CoAP__Options::union_selection_type new_selection = (CoAP__Options::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case CoAP__Options::ALT_if__match:
single_value.field_if__match = new OCTETSTRING_template;
single_value.field_if__match->decode_text(text_buf);
break;
case CoAP__Options::ALT_uri__host:
single_value.field_uri__host = new UNIVERSAL_CHARSTRING_template;
single_value.field_uri__host->decode_text(text_buf);
break;
case CoAP__Options::ALT_etag:
single_value.field_etag = new OCTETSTRING_template;
single_value.field_etag->decode_text(text_buf);
break;
case CoAP__Options::ALT_if__none__match:
single_value.field_if__none__match = new OCTETSTRING_template;
single_value.field_if__none__match->decode_text(text_buf);
break;
case CoAP__Options::ALT_observe:
single_value.field_observe = new INTEGER_template;
single_value.field_observe->decode_text(text_buf);
break;
case CoAP__Options::ALT_uri__port:
single_value.field_uri__port = new INTEGER_template;
single_value.field_uri__port->decode_text(text_buf);
break;
case CoAP__Options::ALT_location__path:
single_value.field_location__path = new UNIVERSAL_CHARSTRING_template;
single_value.field_location__path->decode_text(text_buf);
break;
case CoAP__Options::ALT_uri__path:
single_value.field_uri__path = new UNIVERSAL_CHARSTRING_template;
single_value.field_uri__path->decode_text(text_buf);
break;
case CoAP__Options::ALT_content__format:
single_value.field_content__format = new INTEGER_template;
single_value.field_content__format->decode_text(text_buf);
break;
case CoAP__Options::ALT_max__age:
single_value.field_max__age = new INTEGER_template;
single_value.field_max__age->decode_text(text_buf);
break;
case CoAP__Options::ALT_uri__query:
single_value.field_uri__query = new UNIVERSAL_CHARSTRING_template;
single_value.field_uri__query->decode_text(text_buf);
break;
case CoAP__Options::ALT_accept:
single_value.field_accept = new INTEGER_template;
single_value.field_accept->decode_text(text_buf);
break;
case CoAP__Options::ALT_location__query:
single_value.field_location__query = new UNIVERSAL_CHARSTRING_template;
single_value.field_location__query->decode_text(text_buf);
break;
case CoAP__Options::ALT_block1:
single_value.field_block1 = new BlockOption_template;
single_value.field_block1->decode_text(text_buf);
break;
case CoAP__Options::ALT_block2:
single_value.field_block2 = new BlockOption_template;
single_value.field_block2->decode_text(text_buf);
break;
case CoAP__Options::ALT_proxy__uri:
single_value.field_proxy__uri = new UNIVERSAL_CHARSTRING_template;
single_value.field_proxy__uri->decode_text(text_buf);
break;
case CoAP__Options::ALT_proxy__scheme:
single_value.field_proxy__scheme = new UNIVERSAL_CHARSTRING_template;
single_value.field_proxy__scheme->decode_text(text_buf);
break;
case CoAP__Options::ALT_size1:
single_value.field_size1 = new INTEGER_template;
single_value.field_size1->decode_text(text_buf);
break;
case CoAP__Options::ALT_unknown__option:
single_value.field_unknown__option = new UnknownOption_template;
single_value.field_unknown__option->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__FR:
single_value.field_oneM2M__FR = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__FR->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RQI:
single_value.field_oneM2M__RQI = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__RQI->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__OT:
single_value.field_oneM2M__OT = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__OT->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RQET:
single_value.field_oneM2M__RQET = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__RQET->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RSET:
single_value.field_oneM2M__RSET = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__RSET->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__OET:
single_value.field_oneM2M__OET = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__OET->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RTURI:
single_value.field_oneM2M__RTURI = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__RTURI->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__EC:
single_value.field_oneM2M__EC = new INTEGER_template;
single_value.field_oneM2M__EC->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__RSC:
single_value.field_oneM2M__RSC = new INTEGER_template;
single_value.field_oneM2M__RSC->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__GID:
single_value.field_oneM2M__GID = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__GID->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__TY:
single_value.field_oneM2M__TY = new INTEGER_template;
single_value.field_oneM2M__TY->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__CTO:
single_value.field_oneM2M__CTO = new INTEGER_template;
single_value.field_oneM2M__CTO->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__CTS:
single_value.field_oneM2M__CTS = new INTEGER_template;
single_value.field_oneM2M__CTS->decode_text(text_buf);
break;
case CoAP__Options::ALT_oneM2M__ATI:
single_value.field_oneM2M__ATI = new UNIVERSAL_CHARSTRING_template;
single_value.field_oneM2M__ATI->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @CoAP_Types.CoAP_Options.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CoAP__Options_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @CoAP_Types.CoAP_Options.");
}
}

boolean CoAP__Options_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CoAP__Options_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CoAP__Options_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@CoAP_Types.CoAP_Options'");
    }
    if (strcmp("if_match", param_field) == 0) {
      if__match().set_param(param);
      return;
    } else if (strcmp("uri_host", param_field) == 0) {
      uri__host().set_param(param);
      return;
    } else if (strcmp("etag", param_field) == 0) {
      etag().set_param(param);
      return;
    } else if (strcmp("if_none_match", param_field) == 0) {
      if__none__match().set_param(param);
      return;
    } else if (strcmp("observe", param_field) == 0) {
      observe().set_param(param);
      return;
    } else if (strcmp("uri_port", param_field) == 0) {
      uri__port().set_param(param);
      return;
    } else if (strcmp("location_path", param_field) == 0) {
      location__path().set_param(param);
      return;
    } else if (strcmp("uri_path", param_field) == 0) {
      uri__path().set_param(param);
      return;
    } else if (strcmp("content_format", param_field) == 0) {
      content__format().set_param(param);
      return;
    } else if (strcmp("max_age", param_field) == 0) {
      max__age().set_param(param);
      return;
    } else if (strcmp("uri_query", param_field) == 0) {
      uri__query().set_param(param);
      return;
    } else if (strcmp("accept", param_field) == 0) {
      accept().set_param(param);
      return;
    } else if (strcmp("location_query", param_field) == 0) {
      location__query().set_param(param);
      return;
    } else if (strcmp("block1", param_field) == 0) {
      block1().set_param(param);
      return;
    } else if (strcmp("block2", param_field) == 0) {
      block2().set_param(param);
      return;
    } else if (strcmp("proxy_uri", param_field) == 0) {
      proxy__uri().set_param(param);
      return;
    } else if (strcmp("proxy_scheme", param_field) == 0) {
      proxy__scheme().set_param(param);
      return;
    } else if (strcmp("size1", param_field) == 0) {
      size1().set_param(param);
      return;
    } else if (strcmp("unknown_option", param_field) == 0) {
      unknown__option().set_param(param);
      return;
    } else if (strcmp("oneM2M_FR", param_field) == 0) {
      oneM2M__FR().set_param(param);
      return;
    } else if (strcmp("oneM2M_RQI", param_field) == 0) {
      oneM2M__RQI().set_param(param);
      return;
    } else if (strcmp("oneM2M_OT", param_field) == 0) {
      oneM2M__OT().set_param(param);
      return;
    } else if (strcmp("oneM2M_RQET", param_field) == 0) {
      oneM2M__RQET().set_param(param);
      return;
    } else if (strcmp("oneM2M_RSET", param_field) == 0) {
      oneM2M__RSET().set_param(param);
      return;
    } else if (strcmp("oneM2M_OET", param_field) == 0) {
      oneM2M__OET().set_param(param);
      return;
    } else if (strcmp("oneM2M_RTURI", param_field) == 0) {
      oneM2M__RTURI().set_param(param);
      return;
    } else if (strcmp("oneM2M_EC", param_field) == 0) {
      oneM2M__EC().set_param(param);
      return;
    } else if (strcmp("oneM2M_RSC", param_field) == 0) {
      oneM2M__RSC().set_param(param);
      return;
    } else if (strcmp("oneM2M_GID", param_field) == 0) {
      oneM2M__GID().set_param(param);
      return;
    } else if (strcmp("oneM2M_TY", param_field) == 0) {
      oneM2M__TY().set_param(param);
      return;
    } else if (strcmp("oneM2M_CTO", param_field) == 0) {
      oneM2M__CTO().set_param(param);
      return;
    } else if (strcmp("oneM2M_CTS", param_field) == 0) {
      oneM2M__CTS().set_param(param);
      return;
    } else if (strcmp("oneM2M_ATI", param_field) == 0) {
      oneM2M__ATI().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@CoAP_Types.CoAP_Options'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CoAP__Options_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@CoAP_Types.CoAP_Options");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "if_match")) {
      if__match().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "uri_host")) {
      uri__host().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "etag")) {
      etag().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "if_none_match")) {
      if__none__match().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "observe")) {
      observe().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "uri_port")) {
      uri__port().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "location_path")) {
      location__path().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "uri_path")) {
      uri__path().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "content_format")) {
      content__format().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "max_age")) {
      max__age().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "uri_query")) {
      uri__query().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "accept")) {
      accept().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "location_query")) {
      location__query().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "block1")) {
      block1().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "block2")) {
      block2().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "proxy_uri")) {
      proxy__uri().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "proxy_scheme")) {
      proxy__scheme().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "size1")) {
      size1().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "unknown_option")) {
      unknown__option().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_FR")) {
      oneM2M__FR().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RQI")) {
      oneM2M__RQI().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_OT")) {
      oneM2M__OT().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RQET")) {
      oneM2M__RQET().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RSET")) {
      oneM2M__RSET().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_OET")) {
      oneM2M__OET().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RTURI")) {
      oneM2M__RTURI().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_EC")) {
      oneM2M__EC().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_RSC")) {
      oneM2M__RSC().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_GID")) {
      oneM2M__GID().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_TY")) {
      oneM2M__TY().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_CTO")) {
      oneM2M__CTO().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_CTS")) {
      oneM2M__CTS().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "oneM2M_ATI")) {
      oneM2M__ATI().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @CoAP_Types.CoAP_Options.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@CoAP_Types.CoAP_Options");
  }
  is_ifpresent = param.get_ifpresent();
}

void CoAP__Options_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case CoAP__Options::ALT_if__match:
single_value.field_if__match->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_uri__host:
single_value.field_uri__host->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_etag:
single_value.field_etag->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_if__none__match:
single_value.field_if__none__match->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_observe:
single_value.field_observe->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_uri__port:
single_value.field_uri__port->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_location__path:
single_value.field_location__path->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_uri__path:
single_value.field_uri__path->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_content__format:
single_value.field_content__format->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_max__age:
single_value.field_max__age->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_uri__query:
single_value.field_uri__query->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_accept:
single_value.field_accept->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_location__query:
single_value.field_location__query->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_block1:
single_value.field_block1->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_block2:
single_value.field_block2->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_proxy__uri:
single_value.field_proxy__uri->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_proxy__scheme:
single_value.field_proxy__scheme->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_size1:
single_value.field_size1->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_unknown__option:
single_value.field_unknown__option->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__FR:
single_value.field_oneM2M__FR->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__RQI:
single_value.field_oneM2M__RQI->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__OT:
single_value.field_oneM2M__OT->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__RQET:
single_value.field_oneM2M__RQET->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__RSET:
single_value.field_oneM2M__RSET->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__OET:
single_value.field_oneM2M__OET->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__RTURI:
single_value.field_oneM2M__RTURI->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__EC:
single_value.field_oneM2M__EC->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__RSC:
single_value.field_oneM2M__RSC->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__GID:
single_value.field_oneM2M__GID->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__TY:
single_value.field_oneM2M__TY->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__CTO:
single_value.field_oneM2M__CTO->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__CTS:
single_value.field_oneM2M__CTS->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
case CoAP__Options::ALT_oneM2M__ATI:
single_value.field_oneM2M__ATI->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Options");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @CoAP_Types.CoAP_Options.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.CoAP_Options");
}


const CoAP__Options CoAP__OptionsList::UNBOUND_ELEM;
boolean CoAP__OptionsList::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const CoAP__OptionsList*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (((const CoAP__OptionsList*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (((const CoAP__OptionsList*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const CoAP__OptionsList*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const CoAP__OptionsList*)left_ptr)->val_ptr->value_elements[left_index] == *((const CoAP__OptionsList*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const CoAP__OptionsList*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

CoAP__OptionsList::CoAP__OptionsList()
{
val_ptr = NULL;
}

CoAP__OptionsList::CoAP__OptionsList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

CoAP__OptionsList::CoAP__OptionsList(const CoAP__OptionsList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.CoAP_OptionsList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

CoAP__OptionsList::~CoAP__OptionsList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void CoAP__OptionsList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

CoAP__OptionsList& CoAP__OptionsList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

CoAP__OptionsList& CoAP__OptionsList::operator=(const CoAP__OptionsList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean CoAP__OptionsList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
return val_ptr->n_elements == 0 ;
}

boolean CoAP__OptionsList::operator==(const CoAP__OptionsList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

CoAP__Options& CoAP__OptionsList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @CoAP_Types.CoAP_OptionsList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (CoAP__Options**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new CoAP__Options(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new CoAP__Options;
}
return *val_ptr->value_elements[index_value];
}

CoAP__Options& CoAP__OptionsList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @CoAP_Types.CoAP_OptionsList.");
return (*this)[(int)index_value];
}

const CoAP__Options& CoAP__OptionsList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (index_value < 0) TTCN_error("Accessing an element of type @CoAP_Types.CoAP_OptionsList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @CoAP_Types.CoAP_OptionsList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const CoAP__Options& CoAP__OptionsList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @CoAP_Types.CoAP_OptionsList.");
return (*this)[(int)index_value];
}

CoAP__OptionsList CoAP__OptionsList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

CoAP__OptionsList CoAP__OptionsList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

CoAP__OptionsList CoAP__OptionsList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

CoAP__OptionsList CoAP__OptionsList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
CoAP__OptionsList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new CoAP__Options(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

CoAP__OptionsList CoAP__OptionsList::operator+(const CoAP__OptionsList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @CoAP_Types.CoAP_OptionsList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
CoAP__OptionsList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new CoAP__Options(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new CoAP__Options(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

CoAP__OptionsList CoAP__OptionsList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@CoAP_Types.CoAP_OptionsList","element");
CoAP__OptionsList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new CoAP__Options(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

CoAP__OptionsList CoAP__OptionsList::replace(int index, int len, const CoAP__OptionsList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@CoAP_Types.CoAP_OptionsList","element");
CoAP__OptionsList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new CoAP__Options(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new CoAP__Options(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new CoAP__Options(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

CoAP__OptionsList CoAP__OptionsList::replace(int index, int len, const CoAP__OptionsList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void CoAP__OptionsList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @CoAP_Types.CoAP_OptionsList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (CoAP__Options**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new CoAP__Options(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (CoAP__Options**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @CoAP_Types.CoAP_OptionsList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (CoAP__Options**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean CoAP__OptionsList::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int CoAP__OptionsList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @CoAP_Types.CoAP_OptionsList.");
return val_ptr->n_elements;
}

int CoAP__OptionsList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @CoAP_Types.CoAP_OptionsList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void CoAP__OptionsList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void CoAP__OptionsList::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("set of value", "@CoAP_Types.CoAP_OptionsList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@CoAP_Types.CoAP_OptionsList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void CoAP__OptionsList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void CoAP__OptionsList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @CoAP_Types.CoAP_OptionsList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void CoAP__OptionsList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @CoAP_Types.CoAP_OptionsList.");
val_ptr->value_elements = (CoAP__Options**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new CoAP__Options;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void CoAP__OptionsList_template::copy_value(const CoAP__OptionsList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @CoAP_Types.CoAP_OptionsList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (CoAP__Options_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new CoAP__Options_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new CoAP__Options_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void CoAP__OptionsList_template::copy_template(const CoAP__OptionsList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (CoAP__Options_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new CoAP__Options_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new CoAP__Options_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CoAP__OptionsList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new CoAP__Options_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.CoAP_OptionsList.");
break;
}
set_selection(other_value);
}

boolean CoAP__OptionsList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const CoAP__OptionsList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const CoAP__OptionsList*)value_ptr)[value_index], legacy);
else return ((const CoAP__OptionsList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean CoAP__OptionsList_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const CoAP__OptionsList_template*)template_ptr)->value_set.set_items[template_index].match((*(const CoAP__OptionsList*)value_ptr)[value_index], legacy);
else return ((const CoAP__OptionsList_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void CoAP__OptionsList_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const CoAP__OptionsList_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const CoAP__OptionsList*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const CoAP__OptionsList*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const CoAP__OptionsList_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

CoAP__OptionsList_template::CoAP__OptionsList_template()
{
}

CoAP__OptionsList_template::CoAP__OptionsList_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

CoAP__OptionsList_template::CoAP__OptionsList_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

CoAP__OptionsList_template::CoAP__OptionsList_template(const CoAP__OptionsList& other_value)
{
copy_value(other_value);
}

CoAP__OptionsList_template::CoAP__OptionsList_template(const OPTIONAL<CoAP__OptionsList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__OptionsList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.CoAP_OptionsList from an unbound optional field.");
}
}

CoAP__OptionsList_template::CoAP__OptionsList_template(const CoAP__OptionsList_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

CoAP__OptionsList_template::~CoAP__OptionsList_template()
{
clean_up();
}

void CoAP__OptionsList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CoAP__OptionsList_template& CoAP__OptionsList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CoAP__OptionsList_template& CoAP__OptionsList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

CoAP__OptionsList_template& CoAP__OptionsList_template::operator=(const CoAP__OptionsList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CoAP__OptionsList_template& CoAP__OptionsList_template::operator=(const OPTIONAL<CoAP__OptionsList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__OptionsList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.CoAP_OptionsList.");
}
return *this;
}

CoAP__OptionsList_template& CoAP__OptionsList_template::operator=(const CoAP__OptionsList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

CoAP__Options_template& CoAP__OptionsList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @CoAP_Types.CoAP_OptionsList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @CoAP_Types.CoAP_OptionsList.");
    break;
}
return *single_value.value_elements[index_value];
}

CoAP__Options_template& CoAP__OptionsList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @CoAP_Types.CoAP_OptionsList.");
return (*this)[(int)index_value];
}

const CoAP__Options_template& CoAP__OptionsList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @CoAP_Types.CoAP_OptionsList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @CoAP_Types.CoAP_OptionsList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @CoAP_Types.CoAP_OptionsList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const CoAP__Options_template& CoAP__OptionsList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @CoAP_Types.CoAP_OptionsList.");
return (*this)[(int)index_value];
}

void CoAP__OptionsList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @CoAP_Types.CoAP_OptionsList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (CoAP__Options_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new CoAP__Options_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new CoAP__Options_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (CoAP__Options_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int CoAP__OptionsList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int CoAP__OptionsList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @CoAP_Types.CoAP_OptionsList. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @CoAP_Types.CoAP_OptionsList. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @CoAP_Types.CoAP_OptionsList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @CoAP_Types.CoAP_OptionsList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @CoAP_Types.CoAP_OptionsList");
}

boolean CoAP__OptionsList_template::match(const CoAP__OptionsList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @CoAP_Types.CoAP_OptionsList.");
}
return FALSE;
}

boolean CoAP__OptionsList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

CoAP__OptionsList CoAP__OptionsList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.CoAP_OptionsList.");
CoAP__OptionsList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

CoAP__OptionsList CoAP__OptionsList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

CoAP__OptionsList CoAP__OptionsList_template::replace(int index, int len, const CoAP__OptionsList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

CoAP__OptionsList CoAP__OptionsList_template::replace(int index, int len, const CoAP__OptionsList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void CoAP__OptionsList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new CoAP__OptionsList_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new CoAP__Options_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @CoAP_Types.CoAP_OptionsList.");
}
set_selection(template_type);
}

CoAP__OptionsList_template& CoAP__OptionsList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @CoAP_Types.CoAP_OptionsList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @CoAP_Types.CoAP_OptionsList.");
return value_list.list_value[list_index];
}

CoAP__Options_template& CoAP__OptionsList_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @CoAP_Types.CoAP_OptionsList.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @CoAP_Types.CoAP_OptionsList.");
return value_set.set_items[set_index];
}

void CoAP__OptionsList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void CoAP__OptionsList_template::log_match(const CoAP__OptionsList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void CoAP__OptionsList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.CoAP_OptionsList.");
}
}

void CoAP__OptionsList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @CoAP_Types.CoAP_OptionsList.");
single_value.value_elements = (CoAP__Options_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new CoAP__Options_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CoAP__OptionsList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new CoAP__Options_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @CoAP_Types.CoAP_OptionsList.");
}
}

boolean CoAP__OptionsList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CoAP__OptionsList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CoAP__OptionsList_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CoAP__OptionsList_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      if (param.get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*param.get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(param.get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      set_item(p_i).set_param(*param.get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@CoAP_Types.CoAP_OptionsList");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void CoAP__OptionsList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_OptionsList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.CoAP_OptionsList");
}

boolean CoAP__OptionsList_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return FALSE;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
CoAP__ReqResp::CoAP__ReqResp()
{
}

CoAP__ReqResp::CoAP__ReqResp(const Header& par_header,
    const OCTETSTRING& par_token,
    const OPTIONAL<CoAP__OptionsList>& par_options,
    const OPTIONAL<OCTETSTRING>& par_payload)
  :   field_header(par_header),
  field_token(par_token),
  field_options(par_options),
  field_payload(par_payload)
{
}

CoAP__ReqResp::CoAP__ReqResp(const CoAP__ReqResp& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @CoAP_Types.CoAP_ReqResp.");
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.token().is_bound()) field_token = other_value.token();
else field_token.clean_up();
if (other_value.options().is_bound()) field_options = other_value.options();
else field_options.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void CoAP__ReqResp::clean_up()
{
field_header.clean_up();
field_token.clean_up();
field_options.clean_up();
field_payload.clean_up();
}

CoAP__ReqResp& CoAP__ReqResp::operator=(const CoAP__ReqResp& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @CoAP_Types.CoAP_ReqResp.");
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.token().is_bound()) field_token = other_value.token();
  else field_token.clean_up();
  if (other_value.options().is_bound()) field_options = other_value.options();
  else field_options.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean CoAP__ReqResp::operator==(const CoAP__ReqResp& other_value) const
{
return field_header==other_value.field_header
  && field_token==other_value.field_token
  && field_options==other_value.field_options
  && field_payload==other_value.field_payload;
}

boolean CoAP__ReqResp::is_bound() const
{
if(field_header.is_bound()) return TRUE;
if(field_token.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_options.get_selection() || field_options.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean CoAP__ReqResp::is_value() const
{
if(!field_header.is_value()) return FALSE;
if(!field_token.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_options.get_selection() && !field_options.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int CoAP__ReqResp::size_of() const
{
  int ret_val = 2;
  if (field_options.ispresent()) ret_val++;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void CoAP__ReqResp::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", token := ");
field_token.log();
TTCN_Logger::log_event_str(", options := ");
field_options.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void CoAP__ReqResp::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @CoAP_Types.CoAP_ReqResp has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) token().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) options().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "token")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          token().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "options")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          options().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.CoAP_ReqResp: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@CoAP_Types.CoAP_ReqResp");
  }
}

void CoAP__ReqResp::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (token().is_bound()) token().set_implicit_omit();
if (!options().is_bound()) options() = OMIT_VALUE;
else options().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void CoAP__ReqResp::encode_text(Text_Buf& text_buf) const
{
field_header.encode_text(text_buf);
field_token.encode_text(text_buf);
field_options.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void CoAP__ReqResp::decode_text(Text_Buf& text_buf)
{
field_header.decode_text(text_buf);
field_token.decode_text(text_buf);
field_options.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

struct CoAP__ReqResp_template::single_value_struct {
Header_template field_header;
OCTETSTRING_template field_token;
CoAP__OptionsList_template field_options;
OCTETSTRING_template field_payload;
};

void CoAP__ReqResp_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_token = ANY_VALUE;
single_value->field_options = ANY_OR_OMIT;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void CoAP__ReqResp_template::copy_value(const CoAP__ReqResp& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.token().is_bound()) {
  single_value->field_token = other_value.token();
} else {
  single_value->field_token.clean_up();
}
if (other_value.options().is_bound()) {
  if (other_value.options().ispresent()) single_value->field_options = other_value.options()();
  else single_value->field_options = OMIT_VALUE;
} else {
  single_value->field_options.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CoAP__ReqResp_template::copy_template(const CoAP__ReqResp_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.token().get_selection()) {
single_value->field_token = other_value.token();
} else {
single_value->field_token.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.options().get_selection()) {
single_value->field_options = other_value.options();
} else {
single_value->field_options.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CoAP__ReqResp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @CoAP_Types.CoAP_ReqResp.");
break;
}
set_selection(other_value);
}

CoAP__ReqResp_template::CoAP__ReqResp_template()
{
}

CoAP__ReqResp_template::CoAP__ReqResp_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CoAP__ReqResp_template::CoAP__ReqResp_template(const CoAP__ReqResp& other_value)
{
copy_value(other_value);
}

CoAP__ReqResp_template::CoAP__ReqResp_template(const OPTIONAL<CoAP__ReqResp>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__ReqResp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @CoAP_Types.CoAP_ReqResp from an unbound optional field.");
}
}

CoAP__ReqResp_template::CoAP__ReqResp_template(const CoAP__ReqResp_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CoAP__ReqResp_template::~CoAP__ReqResp_template()
{
clean_up();
}

CoAP__ReqResp_template& CoAP__ReqResp_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CoAP__ReqResp_template& CoAP__ReqResp_template::operator=(const CoAP__ReqResp& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CoAP__ReqResp_template& CoAP__ReqResp_template::operator=(const OPTIONAL<CoAP__ReqResp>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__ReqResp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @CoAP_Types.CoAP_ReqResp.");
}
return *this;
}

CoAP__ReqResp_template& CoAP__ReqResp_template::operator=(const CoAP__ReqResp_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CoAP__ReqResp_template::match(const CoAP__ReqResp& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.token().is_bound()) return FALSE;
if(!single_value->field_token.match(other_value.token(), legacy))return FALSE;
if(!other_value.options().is_bound()) return FALSE;
if((other_value.options().ispresent() ? !single_value->field_options.match((const CoAP__OptionsList&)other_value.options(), legacy) : !single_value->field_options.match_omit(legacy)))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const OCTETSTRING&)other_value.payload(), legacy) : !single_value->field_payload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @CoAP_Types.CoAP_ReqResp.");
}
return FALSE;
}

boolean CoAP__ReqResp_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_token.is_bound()) return TRUE;
if (single_value->field_options.is_omit() || single_value->field_options.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean CoAP__ReqResp_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_token.is_value()) return FALSE;
if (!single_value->field_options.is_omit() && !single_value->field_options.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void CoAP__ReqResp_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CoAP__ReqResp CoAP__ReqResp_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @CoAP_Types.CoAP_ReqResp.");
CoAP__ReqResp ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_token.is_bound()) {
ret_val.token() = single_value->field_token.valueof();
}
if (single_value->field_options.is_omit()) ret_val.options() = OMIT_VALUE;
else if (single_value->field_options.is_bound()) {
ret_val.options() = single_value->field_options.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void CoAP__ReqResp_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @CoAP_Types.CoAP_ReqResp.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CoAP__ReqResp_template[list_length];
}

CoAP__ReqResp_template& CoAP__ReqResp_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @CoAP_Types.CoAP_ReqResp.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @CoAP_Types.CoAP_ReqResp.");
return value_list.list_value[list_index];
}

Header_template& CoAP__ReqResp_template::header()
{
set_specific();
return single_value->field_header;
}

const Header_template& CoAP__ReqResp_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @CoAP_Types.CoAP_ReqResp.");
return single_value->field_header;
}

OCTETSTRING_template& CoAP__ReqResp_template::token()
{
set_specific();
return single_value->field_token;
}

const OCTETSTRING_template& CoAP__ReqResp_template::token() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field token of a non-specific template of type @CoAP_Types.CoAP_ReqResp.");
return single_value->field_token;
}

CoAP__OptionsList_template& CoAP__ReqResp_template::options()
{
set_specific();
return single_value->field_options;
}

const CoAP__OptionsList_template& CoAP__ReqResp_template::options() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field options of a non-specific template of type @CoAP_Types.CoAP_ReqResp.");
return single_value->field_options;
}

OCTETSTRING_template& CoAP__ReqResp_template::payload()
{
set_specific();
return single_value->field_payload;
}

const OCTETSTRING_template& CoAP__ReqResp_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @CoAP_Types.CoAP_ReqResp.");
return single_value->field_payload;
}

int CoAP__ReqResp_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_options.is_present()) ret_val++;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @CoAP_Types.CoAP_ReqResp containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @CoAP_Types.CoAP_ReqResp.");
  }
  return 0;
}

void CoAP__ReqResp_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", token := ");
single_value->field_token.log();
TTCN_Logger::log_event_str(", options := ");
single_value->field_options.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CoAP__ReqResp_template::log_match(const CoAP__ReqResp& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_token.match(match_value.token(), legacy)){
TTCN_Logger::log_logmatch_info(".token");
single_value->field_token.log_match(match_value.token(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.options().ispresent()){
if(!single_value->field_options.match(match_value.options(), legacy)){
TTCN_Logger::log_logmatch_info(".options");
single_value->field_options.log_match(match_value.options(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_options.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".options := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_options.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", token := ");
single_value->field_token.log_match(match_value.token(), legacy);
TTCN_Logger::log_event_str(", options := ");
if (match_value.options().ispresent()) single_value->field_options.log_match(match_value.options(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_options.log();
if (single_value->field_options.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CoAP__ReqResp_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_token.encode_text(text_buf);
single_value->field_options.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @CoAP_Types.CoAP_ReqResp.");
}
}

void CoAP__ReqResp_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_token.decode_text(text_buf);
single_value->field_options.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CoAP__ReqResp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @CoAP_Types.CoAP_ReqResp.");
}
}

void CoAP__ReqResp_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CoAP__ReqResp_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @CoAP_Types.CoAP_ReqResp has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) token().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) options().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "token")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          token().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "options")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          options().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @CoAP_Types.CoAP_ReqResp: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@CoAP_Types.CoAP_ReqResp");
  }
  is_ifpresent = param.get_ifpresent();
}

void CoAP__ReqResp_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_ReqResp");
single_value->field_token.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_ReqResp");
single_value->field_options.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_ReqResp");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_ReqResp");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.CoAP_ReqResp");
}

boolean CoAP__ReqResp_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CoAP__ReqResp_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CoAP__Message::copy_value(const CoAP__Message& other_value)
{
switch (other_value.union_selection) {
case ALT_msg:
field_msg = new CoAP__ReqResp(*other_value.field_msg);
break;
case ALT_raw__message:
field_raw__message = new OCTETSTRING(*other_value.field_raw__message);
break;
default:
TTCN_error("Assignment of an unbound union value of type @CoAP_Types.CoAP_Message.");
}
union_selection = other_value.union_selection;
}

CoAP__Message::CoAP__Message()
{
union_selection = UNBOUND_VALUE;
}

CoAP__Message::CoAP__Message(const CoAP__Message& other_value)
: Base_Type(){
copy_value(other_value);
}

CoAP__Message::~CoAP__Message()
{
clean_up();
}

CoAP__Message& CoAP__Message::operator=(const CoAP__Message& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean CoAP__Message::operator==(const CoAP__Message& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @CoAP_Types.CoAP_Message.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @CoAP_Types.CoAP_Message.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_msg:
return *field_msg == *other_value.field_msg;
case ALT_raw__message:
return *field_raw__message == *other_value.field_raw__message;
default:
return FALSE;
}
}

CoAP__ReqResp& CoAP__Message::msg()
{
if (union_selection != ALT_msg) {
clean_up();
field_msg = new CoAP__ReqResp;
union_selection = ALT_msg;
}
return *field_msg;
}

const CoAP__ReqResp& CoAP__Message::msg() const
{
if (union_selection != ALT_msg) TTCN_error("Using non-selected field msg in a value of union type @CoAP_Types.CoAP_Message.");
return *field_msg;
}

OCTETSTRING& CoAP__Message::raw__message()
{
if (union_selection != ALT_raw__message) {
clean_up();
field_raw__message = new OCTETSTRING;
union_selection = ALT_raw__message;
}
return *field_raw__message;
}

const OCTETSTRING& CoAP__Message::raw__message() const
{
if (union_selection != ALT_raw__message) TTCN_error("Using non-selected field raw_message in a value of union type @CoAP_Types.CoAP_Message.");
return *field_raw__message;
}

boolean CoAP__Message::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CoAP_Types.CoAP_Message.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @CoAP_Types.CoAP_Message.");
return union_selection == checked_selection;
}

boolean CoAP__Message::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean CoAP__Message::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_msg: return field_msg->is_value();
case ALT_raw__message: return field_raw__message->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void CoAP__Message::clean_up()
{
switch (union_selection) {
case ALT_msg:
  delete field_msg;
  break;
case ALT_raw__message:
  delete field_raw__message;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void CoAP__Message::log() const
{
switch (union_selection) {
case ALT_msg:
TTCN_Logger::log_event_str("{ msg := ");
field_msg->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_raw__message:
TTCN_Logger::log_event_str("{ raw_message := ");
field_raw__message->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void CoAP__Message::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "msg")) {
    msg().set_param(*mp_last);
    if (!msg().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "raw_message")) {
    raw__message().set_param(*mp_last);
    if (!raw__message().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @CoAP_Types.CoAP_Message.", mp_last->get_id()->get_name());
}

void CoAP__Message::set_implicit_omit()
{
switch (union_selection) {
case ALT_msg:
field_msg->set_implicit_omit(); break;
case ALT_raw__message:
field_raw__message->set_implicit_omit(); break;
default: break;
}
}

void CoAP__Message::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_msg:
field_msg->encode_text(text_buf);
break;
case ALT_raw__message:
field_raw__message->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @CoAP_Types.CoAP_Message.");
}
}

void CoAP__Message::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_msg:
msg().decode_text(text_buf);
break;
case ALT_raw__message:
raw__message().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @CoAP_Types.CoAP_Message.");
}
}

void CoAP__Message_template::copy_value(const CoAP__Message& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
single_value.field_msg = new CoAP__ReqResp_template(other_value.msg());
break;
case CoAP__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template(other_value.raw__message());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @CoAP_Types.CoAP_Message.");
}
set_selection(SPECIFIC_VALUE);
}

void CoAP__Message_template::copy_template(const CoAP__Message_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
single_value.field_msg = new CoAP__ReqResp_template(*other_value.single_value.field_msg);
break;
case CoAP__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template(*other_value.single_value.field_raw__message);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @CoAP_Types.CoAP_Message.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CoAP__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @CoAP_Types.CoAP_Message.");
}
set_selection(other_value);
}

CoAP__Message_template::CoAP__Message_template()
{
}

CoAP__Message_template::CoAP__Message_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CoAP__Message_template::CoAP__Message_template(const CoAP__Message& other_value)
{
copy_value(other_value);
}

CoAP__Message_template::CoAP__Message_template(const OPTIONAL<CoAP__Message>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @CoAP_Types.CoAP_Message from an unbound optional field.");
}
}

CoAP__Message_template::CoAP__Message_template(const CoAP__Message_template& other_value)
: Base_Template(){
copy_template(other_value);
}

CoAP__Message_template::~CoAP__Message_template()
{
clean_up();
}

void CoAP__Message_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
delete single_value.field_msg;
break;
case CoAP__Message::ALT_raw__message:
delete single_value.field_raw__message;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CoAP__Message_template& CoAP__Message_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CoAP__Message_template& CoAP__Message_template::operator=(const CoAP__Message& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CoAP__Message_template& CoAP__Message_template::operator=(const OPTIONAL<CoAP__Message>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CoAP__Message&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @CoAP_Types.CoAP_Message.");
}
return *this;
}

CoAP__Message_template& CoAP__Message_template::operator=(const CoAP__Message_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CoAP__Message_template::match(const CoAP__Message& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
CoAP__Message::union_selection_type value_selection = other_value.get_selection();
if (value_selection == CoAP__Message::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case CoAP__Message::ALT_msg:
return single_value.field_msg->match(other_value.msg(), legacy);
case CoAP__Message::ALT_raw__message:
return single_value.field_raw__message->match(other_value.raw__message(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @CoAP_Types.CoAP_Message.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @CoAP_Types.CoAP_Message.");
}
return FALSE;
}

boolean CoAP__Message_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
return single_value.field_msg->is_value();
case CoAP__Message::ALT_raw__message:
return single_value.field_raw__message->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @CoAP_Types.CoAP_Message.");
}
}

CoAP__Message CoAP__Message_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @CoAP_Types.CoAP_Message.");
CoAP__Message ret_val;
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
ret_val.msg() = single_value.field_msg->valueof();
break;
case CoAP__Message::ALT_raw__message:
ret_val.raw__message() = single_value.field_raw__message->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @CoAP_Types.CoAP_Message.");
}
return ret_val;
}

CoAP__Message_template& CoAP__Message_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @CoAP_Types.CoAP_Message.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @CoAP_Types.CoAP_Message.");
return value_list.list_value[list_index];
}
void CoAP__Message_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @CoAP_Types.CoAP_Message.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CoAP__Message_template[list_length];
}

CoAP__ReqResp_template& CoAP__Message_template::msg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Message::ALT_msg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_msg = new CoAP__ReqResp_template(ANY_VALUE);
else single_value.field_msg = new CoAP__ReqResp_template;
single_value.union_selection = CoAP__Message::ALT_msg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_msg;
}

const CoAP__ReqResp_template& CoAP__Message_template::msg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field msg in a non-specific template of union type @CoAP_Types.CoAP_Message.");
if (single_value.union_selection != CoAP__Message::ALT_msg) TTCN_error("Accessing non-selected field msg in a template of union type @CoAP_Types.CoAP_Message.");
return *single_value.field_msg;
}

OCTETSTRING_template& CoAP__Message_template::raw__message()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != CoAP__Message::ALT_raw__message) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_raw__message = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_raw__message = new OCTETSTRING_template;
single_value.union_selection = CoAP__Message::ALT_raw__message;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_raw__message;
}

const OCTETSTRING_template& CoAP__Message_template::raw__message() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field raw_message in a non-specific template of union type @CoAP_Types.CoAP_Message.");
if (single_value.union_selection != CoAP__Message::ALT_raw__message) TTCN_error("Accessing non-selected field raw_message in a template of union type @CoAP_Types.CoAP_Message.");
return *single_value.field_raw__message;
}

boolean CoAP__Message_template::ischosen(CoAP__Message::union_selection_type checked_selection) const
{
if (checked_selection == CoAP__Message::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @CoAP_Types.CoAP_Message.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == CoAP__Message::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Message.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Message containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @CoAP_Types.CoAP_Message, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @CoAP_Types.CoAP_Message");
}
return FALSE;
}

void CoAP__Message_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
TTCN_Logger::log_event_str("{ msg := ");
single_value.field_msg->log();
TTCN_Logger::log_event_str(" }");
break;
case CoAP__Message::ALT_raw__message:
TTCN_Logger::log_event_str("{ raw_message := ");
single_value.field_raw__message->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CoAP__Message_template::log_match(const CoAP__Message& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".msg");
single_value.field_msg->log_match(match_value.msg(), legacy);
} else {
TTCN_Logger::log_event_str("{ msg := ");
single_value.field_msg->log_match(match_value.msg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case CoAP__Message::ALT_raw__message:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".raw_message");
single_value.field_raw__message->log_match(match_value.raw__message(), legacy);
} else {
TTCN_Logger::log_event_str("{ raw_message := ");
single_value.field_raw__message->log_match(match_value.raw__message(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CoAP__Message_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
single_value.field_msg->encode_text(text_buf);
break;
case CoAP__Message::ALT_raw__message:
single_value.field_raw__message->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @CoAP_Types.CoAP_Message.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @CoAP_Types.CoAP_Message.");
}
}

void CoAP__Message_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = CoAP__Message::UNBOUND_VALUE;
CoAP__Message::union_selection_type new_selection = (CoAP__Message::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case CoAP__Message::ALT_msg:
single_value.field_msg = new CoAP__ReqResp_template;
single_value.field_msg->decode_text(text_buf);
break;
case CoAP__Message::ALT_raw__message:
single_value.field_raw__message = new OCTETSTRING_template;
single_value.field_raw__message->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @CoAP_Types.CoAP_Message.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CoAP__Message_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @CoAP_Types.CoAP_Message.");
}
}

boolean CoAP__Message_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CoAP__Message_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CoAP__Message_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@CoAP_Types.CoAP_Message'");
    }
    if (strcmp("msg", param_field) == 0) {
      msg().set_param(param);
      return;
    } else if (strcmp("raw_message", param_field) == 0) {
      raw__message().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@CoAP_Types.CoAP_Message'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CoAP__Message_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@CoAP_Types.CoAP_Message");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "msg")) {
      msg().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "raw_message")) {
      raw__message().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @CoAP_Types.CoAP_Message.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@CoAP_Types.CoAP_Message");
  }
  is_ifpresent = param.get_ifpresent();
}

void CoAP__Message_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case CoAP__Message::ALT_msg:
single_value.field_msg->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Message");
return;
case CoAP__Message::ALT_raw__message:
single_value.field_raw__message->check_restriction(t_res, t_name ? t_name : "@CoAP_Types.CoAP_Message");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @CoAP_Types.CoAP_Message.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@CoAP_Types.CoAP_Message");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const CoAP__OptionsList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @CoAP_Types.CoAP_OptionsList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "CoAP_Types");
module_object.add_function("f_CoAP_enc", (genericfunc_t)&f__CoAP__enc, NULL);
module_object.add_function("f_CoAP_dec", (genericfunc_t)&f__CoAP__dec, NULL);
current_location.update_lineno(24);
#line 24 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_EMPTY__MESSAGE.class_() = 0;
const_EMPTY__MESSAGE.detail() = 0;
current_location.update_lineno(26);
#line 26 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_METHOD__GET.class_() = 0;
const_METHOD__GET.detail() = 1;
current_location.update_lineno(27);
#line 27 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_METHOD__POST.class_() = 0;
const_METHOD__POST.detail() = 2;
current_location.update_lineno(28);
#line 28 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_METHOD__PUT.class_() = 0;
const_METHOD__PUT.detail() = 3;
current_location.update_lineno(29);
#line 29 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_METHOD__DELETE.class_() = 0;
const_METHOD__DELETE.detail() = 4;
current_location.update_lineno(31);
#line 31 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Created.class_() = 2;
const_RESPONSE__CODE__Created.detail() = 1;
current_location.update_lineno(32);
#line 32 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Deleted.class_() = 2;
const_RESPONSE__CODE__Deleted.detail() = 2;
current_location.update_lineno(33);
#line 33 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Valid.class_() = 2;
const_RESPONSE__CODE__Valid.detail() = 3;
current_location.update_lineno(34);
#line 34 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Changed.class_() = 2;
const_RESPONSE__CODE__Changed.detail() = 4;
current_location.update_lineno(35);
#line 35 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Content.class_() = 2;
const_RESPONSE__CODE__Content.detail() = 5;
current_location.update_lineno(37);
#line 37 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__BadRequest.class_() = 4;
const_RESPONSE__CODE__BadRequest.detail() = 0;
current_location.update_lineno(38);
#line 38 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Unauthorized.class_() = 4;
const_RESPONSE__CODE__Unauthorized.detail() = 1;
current_location.update_lineno(39);
#line 39 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__BadOption.class_() = 4;
const_RESPONSE__CODE__BadOption.detail() = 2;
current_location.update_lineno(40);
#line 40 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__Forbidden.class_() = 4;
const_RESPONSE__CODE__Forbidden.detail() = 3;
current_location.update_lineno(41);
#line 41 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__NotFound.class_() = 4;
const_RESPONSE__CODE__NotFound.detail() = 4;
current_location.update_lineno(42);
#line 42 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__MethodNotAllowed.class_() = 4;
const_RESPONSE__CODE__MethodNotAllowed.detail() = 5;
current_location.update_lineno(43);
#line 43 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__NotAcceptable.class_() = 4;
const_RESPONSE__CODE__NotAcceptable.detail() = 6;
current_location.update_lineno(44);
#line 44 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__PreconditionFailed.class_() = 4;
const_RESPONSE__CODE__PreconditionFailed.detail() = 12;
current_location.update_lineno(45);
#line 45 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__RequestEntityTooLarge.class_() = 4;
const_RESPONSE__CODE__RequestEntityTooLarge.detail() = 13;
current_location.update_lineno(46);
#line 46 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__UnsupportedContentFormat.class_() = 4;
const_RESPONSE__CODE__UnsupportedContentFormat.detail() = 15;
current_location.update_lineno(48);
#line 48 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__InternalServerError.class_() = 5;
const_RESPONSE__CODE__InternalServerError.detail() = 0;
current_location.update_lineno(49);
#line 49 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__NotImplemented.class_() = 5;
const_RESPONSE__CODE__NotImplemented.detail() = 1;
current_location.update_lineno(50);
#line 50 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__BadGateway.class_() = 5;
const_RESPONSE__CODE__BadGateway.detail() = 2;
current_location.update_lineno(51);
#line 51 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__ServiceUnavailable.class_() = 5;
const_RESPONSE__CODE__ServiceUnavailable.detail() = 3;
current_location.update_lineno(52);
#line 52 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__GatewayTimeout.class_() = 5;
const_RESPONSE__CODE__GatewayTimeout.detail() = 4;
current_location.update_lineno(53);
#line 53 "../oneM2MTester/ProtocolModules/CoAP/CoAP_Types.ttcn"
const_RESPONSE__CODE__ProxyingNotSupported.class_() = 5;
const_RESPONSE__CODE__ProxyingNotSupported.detail() = 5;
}


} /* end of namespace */
