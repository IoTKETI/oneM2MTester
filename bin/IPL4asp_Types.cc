// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "IPL4asp_Types.hh"

namespace IPL4asp__Types {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const CHARSTRING cs_0(22, "SRTP_AES128_CM_SHA1_32"),
cs_6(45, "SRTP_AES128_CM_SHA1_32:SRTP_AES128_CM_SHA1_80"),
cs_1(22, "SRTP_AES128_CM_SHA1_80"),
cs_3(22, "SRTP_AES128_F8_SHA1_32"),
cs_2(22, "SRTP_AES128_F8_SHA1_80"),
cs_5(17, "SRTP_NULL_SHA1_32"),
cs_4(17, "SRTP_NULL_SHA1_80");
static const unsigned char module_checksum[] = { 0x97, 0xa8, 0x6b, 0xc0, 0xab, 0x61, 0x38, 0xfb, 0x66, 0x96, 0xd8, 0xbe, 0xad, 0xbc, 0x39, 0x11 };

/* Global variable definitions */

const XERdescriptor_t       ConnectionId_xer_ = { {"ConnectionId>\n", "ConnectionId>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ConnectionId_descr_ = { "@IPL4asp_Types.ConnectionId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ConnectionId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ro__ConnectionId_descr_ = Socket__API__Definitions::ro__ConnectionId_descr_;
const XERdescriptor_t       AssociationId_xer_ = { {"AssociationId>\n", "AssociationId>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t AssociationId_descr_ = { "@IPL4asp_Types.AssociationId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &AssociationId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ro__AssociationId_descr_ = Socket__API__Definitions::ro__AssociationId_descr_;
const XERdescriptor_t       HostName_xer_ = { {"HostName>\n", "HostName>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t HostName_descr_ = { "@IPL4asp_Types.HostName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &HostName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PortNumber_xer_ = { {"PortNumber>\n", "PortNumber>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t PortNumber_descr_ = { "@IPL4asp_Types.PortNumber", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &PortNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& Socket_descr_ = Socket__API__Definitions::Socket_descr_;
const TTCN_Typedescriptor_t& SocketList_descr_ = Socket__API__Definitions::SocketList_descr_;
const TTCN_Typedescriptor_t& UdpTuple_descr_ = Socket__API__Definitions::UdpTuple_descr_;
const TTCN_Typedescriptor_t& TcpTuple_descr_ = Socket__API__Definitions::TcpTuple_descr_;
const TTCN_Typedescriptor_t& SctpTuple_descr_ = Socket__API__Definitions::SctpTuple_descr_;
const TTCN_Typedescriptor_t& SslTuple_descr_ = Socket__API__Definitions::SslTuple_descr_;
const TTCN_Typedescriptor_t& UnspecifiedTuple_descr_ = Socket__API__Definitions::UnspecifiedTuple_descr_;
const TTCN_Typedescriptor_t& ProtoTuple_descr_ = Socket__API__Definitions::ProtoTuple_descr_;
const TTCN_Typedescriptor_t& Result_descr_ = Socket__API__Definitions::Result_descr_;
const TTCN_Typedescriptor_t& Extended__Result_descr_ = Socket__API__Definitions::Extended__Result_descr_;
const XERdescriptor_t       UserData_xer_ = { {"UserData>\n", "UserData>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t UserData_descr_ = { "@IPL4asp_Types.UserData", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &UserData_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& PortError_descr_ = Socket__API__Definitions::PortError_descr_;
const TTCN_Typedescriptor_t& ConnectionOpenedEvent_descr_ = Socket__API__Definitions::ConnectionOpenedEvent_descr_;
const TTCN_Typedescriptor_t& ConnectionClosedEvent_descr_ = Socket__API__Definitions::ConnectionOpenedEvent_descr_;
const TTCN_Typedescriptor_t& SctpEvent_descr_ = Socket__API__Definitions::SctpEvent_descr_;
const TTCN_Typedescriptor_t& PortEvent_descr_ = Socket__API__Definitions::PortEvent_descr_;
const TTCN_Typedescriptor_t& SAC__STATE_descr_ = Socket__API__Definitions::SAC__STATE_descr_;
const TTCN_Typedescriptor_t& SctpAssocChange_descr_ = Socket__API__Definitions::SctpAssocChange_descr_;
const TTCN_Typedescriptor_t& SPC__STATE_descr_ = Socket__API__Definitions::SPC__STATE_descr_;
const TTCN_Typedescriptor_t& SctpPeerAddrChange_descr_ = Socket__API__Definitions::SctpPeerAddrChange_descr_;
const TTCN_Typedescriptor_t& SctpSendFailed_descr_ = Socket__API__Definitions::SctpSendFailed_descr_;
const TTCN_Typedescriptor_t& SctpRemoteError_descr_ = Socket__API__Definitions::SctpRemoteError_descr_;
const TTCN_Typedescriptor_t& SctpShutDownEvent_descr_ = Socket__API__Definitions::SctpShutDownEvent_descr_;
const TTCN_Typedescriptor_t& SctpPartialDeliveryEvent_descr_ = Socket__API__Definitions::SctpPartialDeliveryEvent_descr_;
const TTCN_Typedescriptor_t& SctpAdaptationIndication_descr_ = Socket__API__Definitions::SctpAdaptationIndication_descr_;
const TTCN_Typedescriptor_t& ro__integer_descr_ = Socket__API__Definitions::ro__integer_descr_;
const TTCN_Typedescriptor_t& f__getMsgLen_descr_ = Socket__API__Definitions::f__getMsgLen_descr_;
const TTCN_Typedescriptor_t& ro__charstring_descr_ = Socket__API__Definitions::ro__charstring_descr_;
// No XER for TcpKeepAlive
const TTCN_Typedescriptor_t TcpKeepAlive_descr_ = { "@IPL4asp_Types.TcpKeepAlive", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TcpKeepAlive_enable_xer_ = { {"enable>\n", "enable>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t TcpKeepAlive_enable_descr_ = { "@IPL4asp_Types.TcpKeepAlive.enable", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &TcpKeepAlive_enable_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TcpKeepAlive_count_xer_ = { {"count>\n", "count>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t TcpKeepAlive_count_descr_ = { "@IPL4asp_Types.TcpKeepAlive.count", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &TcpKeepAlive_count_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TcpKeepAlive_idle_xer_ = { {"idle>\n", "idle>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t TcpKeepAlive_idle_descr_ = { "@IPL4asp_Types.TcpKeepAlive.idle", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &TcpKeepAlive_idle_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TcpKeepAlive_interval_xer_ = { {"interval>\n", "interval>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t TcpKeepAlive_interval_descr_ = { "@IPL4asp_Types.TcpKeepAlive.interval", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &TcpKeepAlive_interval_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ReuseAddress
const TTCN_Typedescriptor_t ReuseAddress_descr_ = { "@IPL4asp_Types.ReuseAddress", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ReuseAddress_enable_xer_ = { {"enable>\n", "enable>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ReuseAddress_enable_descr_ = { "@IPL4asp_Types.ReuseAddress.enable", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &ReuseAddress_enable_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SctpEventHandle
const TTCN_Typedescriptor_t SctpEventHandle_descr_ = { "@IPL4asp_Types.SctpEventHandle", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__data__io__event_xer_ = { {"sctp_data_io_event>\n", "sctp_data_io_event>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__data__io__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_data_io_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__data__io__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__association__event_xer_ = { {"sctp_association_event>\n", "sctp_association_event>\n"}, {24, 24}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__association__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_association_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__association__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__address__event_xer_ = { {"sctp_address_event>\n", "sctp_address_event>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__address__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_address_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__address__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__send__failure__event_xer_ = { {"sctp_send_failure_event>\n", "sctp_send_failure_event>\n"}, {25, 25}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__send__failure__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_send_failure_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__send__failure__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__peer__error__event_xer_ = { {"sctp_peer_error_event>\n", "sctp_peer_error_event>\n"}, {23, 23}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__peer__error__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_peer_error_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__peer__error__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__shutdown__event_xer_ = { {"sctp_shutdown_event>\n", "sctp_shutdown_event>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__shutdown__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_shutdown_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__shutdown__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__partial__delivery__event_xer_ = { {"sctp_partial_delivery_event>\n", "sctp_partial_delivery_event>\n"}, {29, 29}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__partial__delivery__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_partial_delivery_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__partial__delivery__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__adaptation__layer__event_xer_ = { {"sctp_adaptation_layer_event>\n", "sctp_adaptation_layer_event>\n"}, {29, 29}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__adaptation__layer__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_adaptation_layer_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__adaptation__layer__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__authentication__event_xer_ = { {"sctp_authentication_event>\n", "sctp_authentication_event>\n"}, {27, 27}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__authentication__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_authentication_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__authentication__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SctpEventHandle_sctp__sender__dry__event_xer_ = { {"sctp_sender_dry_event>\n", "sctp_sender_dry_event>\n"}, {23, 23}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SctpEventHandle_sctp__sender__dry__event_descr_ = { "@IPL4asp_Types.SctpEventHandle.sctp_sender_dry_event", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SctpEventHandle_sctp__sender__dry__event_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Linger__opt_l__onoff_xer_ = { {"l_onoff>\n", "l_onoff>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Linger__opt_l__onoff_descr_ = { "@IPL4asp_Types.Linger_opt.l_onoff", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Linger__opt_l__onoff_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Linger__opt_l__linger_xer_ = { {"l_linger>\n", "l_linger>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Linger__opt_l__linger_descr_ = { "@IPL4asp_Types.Linger_opt.l_linger", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Linger__opt_l__linger_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Linger__opt
const TTCN_Typedescriptor_t Linger__opt_descr_ = { "@IPL4asp_Types.Linger_opt", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SSL__protocols
const TTCN_Typedescriptor_t SSL__protocols_descr_ = { "@IPL4asp_Types.SSL_protocols", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_SSLv2__supported_xer_ = { {"SSLv2_supported>\n", "SSLv2_supported>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_SSLv2__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.SSLv2_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_SSLv2__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_SSLv3__supported_xer_ = { {"SSLv3_supported>\n", "SSLv3_supported>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_SSLv3__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.SSLv3_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_SSLv3__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_TLSv1__supported_xer_ = { {"TLSv1_supported>\n", "TLSv1_supported>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_TLSv1__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.TLSv1_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_TLSv1__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_TLSv1__1__supported_xer_ = { {"TLSv1_1_supported>\n", "TLSv1_1_supported>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_TLSv1__1__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.TLSv1_1_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_TLSv1__1__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_TLSv1__2__supported_xer_ = { {"TLSv1_2_supported>\n", "TLSv1_2_supported>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_TLSv1__2__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.TLSv1_2_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_TLSv1__2__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_DTLSv1__supported_xer_ = { {"DTLSv1_supported>\n", "DTLSv1_supported>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_DTLSv1__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.DTLSv1_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_DTLSv1__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__protocols_DTLSv1__2__supported_xer_ = { {"DTLSv1_2_supported>\n", "DTLSv1_2_supported>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__protocols_DTLSv1__2__supported_descr_ = { "@IPL4asp_Types.SSL_protocols.DTLSv1_2_supported", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &SSL__protocols_DTLSv1__2__supported_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SSL__proto__support
const TTCN_Typedescriptor_t SSL__proto__support_descr_ = { "@IPL4asp_Types.SSL_proto_support", NULL, NULL, NULL, NULL, NULL, &SSL__protocols_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SSL__cert__options
const TTCN_Typedescriptor_t SSL__cert__options_descr_ = { "@IPL4asp_Types.SSL_cert_options", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__cert__options_ssl__key__file_xer_ = { {"ssl_key_file>\n", "ssl_key_file>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__cert__options_ssl__key__file_descr_ = { "@IPL4asp_Types.SSL_cert_options.ssl_key_file", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SSL__cert__options_ssl__key__file_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__cert__options_ssl__certificate__file_xer_ = { {"ssl_certificate_file>\n", "ssl_certificate_file>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__cert__options_ssl__certificate__file_descr_ = { "@IPL4asp_Types.SSL_cert_options.ssl_certificate_file", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SSL__cert__options_ssl__certificate__file_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__cert__options_ssl__trustedCAlist__file_xer_ = { {"ssl_trustedCAlist_file>\n", "ssl_trustedCAlist_file>\n"}, {24, 24}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__cert__options_ssl__trustedCAlist__file_descr_ = { "@IPL4asp_Types.SSL_cert_options.ssl_trustedCAlist_file", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SSL__cert__options_ssl__trustedCAlist__file_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__cert__options_ssl__cipher__list_xer_ = { {"ssl_cipher_list>\n", "ssl_cipher_list>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__cert__options_ssl__cipher__list_descr_ = { "@IPL4asp_Types.SSL_cert_options.ssl_cipher_list", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SSL__cert__options_ssl__cipher__list_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SSL__cert__options_ssl__password_xer_ = { {"ssl_password>\n", "ssl_password>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED |XER_OPTIONAL, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SSL__cert__options_ssl__password_descr_ = { "@IPL4asp_Types.SSL_cert_options.ssl_password", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SSL__cert__options_ssl__password_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Option
const TTCN_Typedescriptor_t Option_descr_ = { "@IPL4asp_Types.Option", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for HostList
const TTCN_Typedescriptor_t HostList_descr_ = { "@IPL4asp_Types.HostList", NULL, NULL, NULL, NULL, NULL, &HostName_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HostList_0_xer_ = { {"HostName>\n", "HostName>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t HostList_0_descr_ = { "@IPL4asp_Types.HostList.<oftype>", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &HostList_0_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_sctpEINConfigGroup_xer_ = { {"sctpEINConfigGroup>\n", "sctpEINConfigGroup>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_sctpEINConfigGroup_descr_ = { "@IPL4asp_Types.Option.sctpEINConfigGroup", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &Option_sctpEINConfigGroup_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_no__delay_xer_ = { {"no_delay>\n", "no_delay>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_no__delay_descr_ = { "@IPL4asp_Types.Option.no_delay", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &Option_no__delay_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_dtlsSrtpProfiles_xer_ = { {"dtlsSrtpProfiles>\n", "dtlsSrtpProfiles>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_dtlsSrtpProfiles_descr_ = { "@IPL4asp_Types.Option.dtlsSrtpProfiles", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Option_dtlsSrtpProfiles_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_freebind_xer_ = { {"freebind>\n", "freebind>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_freebind_descr_ = { "@IPL4asp_Types.Option.freebind", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &Option_freebind_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for Option_alpn__list
const TTCN_Typedescriptor_t Option_alpn__list_descr_ = { "@IPL4asp_Types.Option.alpn_list", NULL, NULL, NULL, NULL, NULL, &CHARSTRING_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_alpn__list_0_xer_ = { {"CHARSTRING>\n", "CHARSTRING>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_alpn__list_0_descr_ = { "@IPL4asp_Types.Option.alpn_list.<oftype>", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Option_alpn__list_0_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Option_tls__hostname_xer_ = { {"tls_hostname>\n", "tls_hostname>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t Option_tls__hostname_descr_ = { "@IPL4asp_Types.Option.tls_hostname", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &Option_tls__hostname_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for OptionList
const TTCN_Typedescriptor_t OptionList_descr_ = { "@IPL4asp_Types.OptionList", NULL, NULL, NULL, NULL, NULL, &Option_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__Send_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__Send_connId_descr_ = { "@IPL4asp_Types.ASP_Send.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__Send_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__Send_msg_xer_ = { {"msg>\n", "msg>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__Send_msg_descr_ = { "@IPL4asp_Types.ASP_Send.msg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__Send_msg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__Send
const TTCN_Typedescriptor_t ASP__Send_descr_ = { "@IPL4asp_Types.ASP_Send", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__SendTo_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__SendTo_connId_descr_ = { "@IPL4asp_Types.ASP_SendTo.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__SendTo_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__SendTo_remName_xer_ = { {"remName>\n", "remName>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__SendTo_remName_descr_ = { "@IPL4asp_Types.ASP_SendTo.remName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__SendTo_remName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__SendTo_remPort_xer_ = { {"remPort>\n", "remPort>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__SendTo_remPort_descr_ = { "@IPL4asp_Types.ASP_SendTo.remPort", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__SendTo_remPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__SendTo_msg_xer_ = { {"msg>\n", "msg>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__SendTo_msg_descr_ = { "@IPL4asp_Types.ASP_SendTo.msg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__SendTo_msg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__SendTo
const TTCN_Typedescriptor_t ASP__SendTo_descr_ = { "@IPL4asp_Types.ASP_SendTo", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_connId_xer_ = { {"connId>\n", "connId>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_connId_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.connId", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__RecvFrom_connId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_remName_xer_ = { {"remName>\n", "remName>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_remName_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.remName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__RecvFrom_remName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_remPort_xer_ = { {"remPort>\n", "remPort>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_remPort_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.remPort", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__RecvFrom_remPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_locName_xer_ = { {"locName>\n", "locName>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_locName_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.locName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ASP__RecvFrom_locName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_locPort_xer_ = { {"locPort>\n", "locPort>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_locPort_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.locPort", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__RecvFrom_locPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_userData_xer_ = { {"userData>\n", "userData>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_userData_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.userData", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &ASP__RecvFrom_userData_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ASP__RecvFrom_msg_xer_ = { {"msg>\n", "msg>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ASP__RecvFrom_msg_descr_ = { "@IPL4asp_Types.ASP_RecvFrom.msg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ASP__RecvFrom_msg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ASP__RecvFrom
const TTCN_Typedescriptor_t ASP__RecvFrom_descr_ = { "@IPL4asp_Types.ASP_RecvFrom", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_Typedescriptor_t& ASP__Event_descr_ = Socket__API__Definitions::PortEvent_descr_;
static Socket__API__Definitions::PortError const_IPL4__ERROR__GENERAL;
const Socket__API__Definitions::PortError& IPL4__ERROR__GENERAL = const_IPL4__ERROR__GENERAL;
static Socket__API__Definitions::PortError const_IPL4__ERROR__INSUFFICIENT__MEMORY;
const Socket__API__Definitions::PortError& IPL4__ERROR__INSUFFICIENT__MEMORY = const_IPL4__ERROR__INSUFFICIENT__MEMORY;
static Socket__API__Definitions::PortError const_IPL4__ERROR__INVALID__INPUT__PARAMETER;
const Socket__API__Definitions::PortError& IPL4__ERROR__INVALID__INPUT__PARAMETER = const_IPL4__ERROR__INVALID__INPUT__PARAMETER;
static Socket__API__Definitions::PortError const_IPL4__ERROR__UNSUPPORTED__TRANSPORT;
const Socket__API__Definitions::PortError& IPL4__ERROR__UNSUPPORTED__TRANSPORT = const_IPL4__ERROR__UNSUPPORTED__TRANSPORT;
static Socket__API__Definitions::PortError const_IPL4__ERROR__SOCKET;
const Socket__API__Definitions::PortError& IPL4__ERROR__SOCKET = const_IPL4__ERROR__SOCKET;
static Socket__API__Definitions::PortError const_IPL4__ERROR__HOSTNAME;
const Socket__API__Definitions::PortError& IPL4__ERROR__HOSTNAME = const_IPL4__ERROR__HOSTNAME;
static Socket__API__Definitions::PortError const_IPL4__ERROR__INVALID__CONNECTION;
const Socket__API__Definitions::PortError& IPL4__ERROR__INVALID__CONNECTION = const_IPL4__ERROR__INVALID__CONNECTION;
static Socket__API__Definitions::PortError const_IPL4__ERROR__TEMPORARILY__UNAVAILABLE;
const Socket__API__Definitions::PortError& IPL4__ERROR__TEMPORARILY__UNAVAILABLE = const_IPL4__ERROR__TEMPORARILY__UNAVAILABLE;
static Socket__API__Definitions::PortError const_IPL4__ERROR__AVAILABLE;
const Socket__API__Definitions::PortError& IPL4__ERROR__AVAILABLE = const_IPL4__ERROR__AVAILABLE;
const TTCN_Typedescriptor_t& f__IPL4__getMsgLen_descr_ = Socket__API__Definitions::f__getMsgLen_descr_;
// No XER for IPL4__Param
const TTCN_Typedescriptor_t IPL4__Param_descr_ = { "@IPL4asp_Types.IPL4_Param", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IPL4__ParamResult
const TTCN_Typedescriptor_t IPL4__ParamResult_descr_ = { "@IPL4asp_Types.IPL4_ParamResult", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__ParamResult_userData_xer_ = { {"userData>\n", "userData>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__ParamResult_userData_descr_ = { "@IPL4asp_Types.IPL4_ParamResult.userData", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &IPL4__ParamResult_userData_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__ParamResult_parentIdx_xer_ = { {"parentIdx>\n", "parentIdx>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__ParamResult_parentIdx_descr_ = { "@IPL4asp_Types.IPL4_ParamResult.parentIdx", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &IPL4__ParamResult_parentIdx_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IPL4__IPAddressType
const TTCN_Typedescriptor_t IPL4__IPAddressType_descr_ = { "@IPL4asp_Types.IPL4_IPAddressType", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__SrtpKeysAndSalts_localKey_xer_ = { {"localKey>\n", "localKey>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_localKey_descr_ = { "@IPL4asp_Types.IPL4_SrtpKeysAndSalts.localKey", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPL4__SrtpKeysAndSalts_localKey_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__SrtpKeysAndSalts_remoteKey_xer_ = { {"remoteKey>\n", "remoteKey>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_remoteKey_descr_ = { "@IPL4asp_Types.IPL4_SrtpKeysAndSalts.remoteKey", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPL4__SrtpKeysAndSalts_remoteKey_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__SrtpKeysAndSalts_localSalt_xer_ = { {"localSalt>\n", "localSalt>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_localSalt_descr_ = { "@IPL4asp_Types.IPL4_SrtpKeysAndSalts.localSalt", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPL4__SrtpKeysAndSalts_localSalt_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IPL4__SrtpKeysAndSalts_remoteSalt_xer_ = { {"remoteSalt>\n", "remoteSalt>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_remoteSalt_descr_ = { "@IPL4asp_Types.IPL4_SrtpKeysAndSalts.remoteSalt", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &IPL4__SrtpKeysAndSalts_remoteSalt_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IPL4__SrtpKeysAndSalts
const TTCN_Typedescriptor_t IPL4__SrtpKeysAndSalts_descr_ = { "@IPL4asp_Types.IPL4_SrtpKeysAndSalts", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for IPL4__DigestMethods
const TTCN_Typedescriptor_t IPL4__DigestMethods_descr_ = { "@IPL4asp_Types.IPL4_DigestMethods", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static CHARSTRING const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile = const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile = const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile = const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile = const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile = const_c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile = const_c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile;
static CHARSTRING const_c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile;
const CHARSTRING& c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile = const_c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile;
TTCN_Module module_object("IPL4asp_Types", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

TcpKeepAlive::TcpKeepAlive()
{
}

TcpKeepAlive::TcpKeepAlive(const OPTIONAL<BOOLEAN>& par_enable,
    const OPTIONAL<INTEGER>& par_count,
    const OPTIONAL<INTEGER>& par_idle,
    const OPTIONAL<INTEGER>& par_interval)
  :   field_enable(par_enable),
  field_count(par_count),
  field_idle(par_idle),
  field_interval(par_interval)
{
}

TcpKeepAlive::TcpKeepAlive(const TcpKeepAlive& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.TcpKeepAlive.");
if (other_value.enable().is_bound()) field_enable = other_value.enable();
else field_enable.clean_up();
if (other_value.count().is_bound()) field_count = other_value.count();
else field_count.clean_up();
if (other_value.idle().is_bound()) field_idle = other_value.idle();
else field_idle.clean_up();
if (other_value.interval().is_bound()) field_interval = other_value.interval();
else field_interval.clean_up();
}

void TcpKeepAlive::clean_up()
{
field_enable.clean_up();
field_count.clean_up();
field_idle.clean_up();
field_interval.clean_up();
}

TcpKeepAlive& TcpKeepAlive::operator=(const TcpKeepAlive& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.TcpKeepAlive.");
  if (other_value.enable().is_bound()) field_enable = other_value.enable();
  else field_enable.clean_up();
  if (other_value.count().is_bound()) field_count = other_value.count();
  else field_count.clean_up();
  if (other_value.idle().is_bound()) field_idle = other_value.idle();
  else field_idle.clean_up();
  if (other_value.interval().is_bound()) field_interval = other_value.interval();
  else field_interval.clean_up();
}
return *this;
}

boolean TcpKeepAlive::operator==(const TcpKeepAlive& other_value) const
{
return field_enable==other_value.field_enable
  && field_count==other_value.field_count
  && field_idle==other_value.field_idle
  && field_interval==other_value.field_interval;
}

boolean TcpKeepAlive::is_bound() const
{
if(OPTIONAL_OMIT == field_enable.get_selection() || field_enable.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_count.get_selection() || field_count.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_idle.get_selection() || field_idle.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_interval.get_selection() || field_interval.is_bound()) return TRUE;
return FALSE;
}
boolean TcpKeepAlive::is_value() const
{
if(OPTIONAL_OMIT != field_enable.get_selection() && !field_enable.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_count.get_selection() && !field_count.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_idle.get_selection() && !field_idle.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_interval.get_selection() && !field_interval.is_value()) return FALSE;
return TRUE;
}
int TcpKeepAlive::size_of() const
{
  int ret_val = 0;
  if (field_enable.ispresent()) ret_val++;
  if (field_count.ispresent()) ret_val++;
  if (field_idle.ispresent()) ret_val++;
  if (field_interval.ispresent()) ret_val++;
  return ret_val;
}

void TcpKeepAlive::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ enable := ");
field_enable.log();
TTCN_Logger::log_event_str(", count := ");
field_count.log();
TTCN_Logger::log_event_str(", idle := ");
field_idle.log();
TTCN_Logger::log_event_str(", interval := ");
field_interval.log();
TTCN_Logger::log_event_str(" }");
}

void TcpKeepAlive::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.TcpKeepAlive has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) enable().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) count().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) idle().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) interval().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "count")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          count().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "idle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          idle().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interval().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.TcpKeepAlive: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.TcpKeepAlive");
  }
}

void TcpKeepAlive::set_implicit_omit()
{
if (!enable().is_bound()) enable() = OMIT_VALUE;
else enable().set_implicit_omit();
if (!count().is_bound()) count() = OMIT_VALUE;
else count().set_implicit_omit();
if (!idle().is_bound()) idle() = OMIT_VALUE;
else idle().set_implicit_omit();
if (!interval().is_bound()) interval() = OMIT_VALUE;
else interval().set_implicit_omit();
}

void TcpKeepAlive::encode_text(Text_Buf& text_buf) const
{
field_enable.encode_text(text_buf);
field_count.encode_text(text_buf);
field_idle.encode_text(text_buf);
field_interval.encode_text(text_buf);
}

void TcpKeepAlive::decode_text(Text_Buf& text_buf)
{
field_enable.decode_text(text_buf);
field_count.decode_text(text_buf);
field_idle.decode_text(text_buf);
field_interval.decode_text(text_buf);
}

struct TcpKeepAlive_template::single_value_struct {
BOOLEAN_template field_enable;
INTEGER_template field_count;
INTEGER_template field_idle;
INTEGER_template field_interval;
};

void TcpKeepAlive_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_enable = ANY_OR_OMIT;
single_value->field_count = ANY_OR_OMIT;
single_value->field_idle = ANY_OR_OMIT;
single_value->field_interval = ANY_OR_OMIT;
}
}
}

void TcpKeepAlive_template::copy_value(const TcpKeepAlive& other_value)
{
single_value = new single_value_struct;
if (other_value.enable().is_bound()) {
  if (other_value.enable().ispresent()) single_value->field_enable = other_value.enable()();
  else single_value->field_enable = OMIT_VALUE;
} else {
  single_value->field_enable.clean_up();
}
if (other_value.count().is_bound()) {
  if (other_value.count().ispresent()) single_value->field_count = other_value.count()();
  else single_value->field_count = OMIT_VALUE;
} else {
  single_value->field_count.clean_up();
}
if (other_value.idle().is_bound()) {
  if (other_value.idle().ispresent()) single_value->field_idle = other_value.idle()();
  else single_value->field_idle = OMIT_VALUE;
} else {
  single_value->field_idle.clean_up();
}
if (other_value.interval().is_bound()) {
  if (other_value.interval().ispresent()) single_value->field_interval = other_value.interval()();
  else single_value->field_interval = OMIT_VALUE;
} else {
  single_value->field_interval.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TcpKeepAlive_template::copy_template(const TcpKeepAlive_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.enable().get_selection()) {
single_value->field_enable = other_value.enable();
} else {
single_value->field_enable.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.count().get_selection()) {
single_value->field_count = other_value.count();
} else {
single_value->field_count.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.idle().get_selection()) {
single_value->field_idle = other_value.idle();
} else {
single_value->field_idle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.interval().get_selection()) {
single_value->field_interval = other_value.interval();
} else {
single_value->field_interval.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TcpKeepAlive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
break;
}
set_selection(other_value);
}

TcpKeepAlive_template::TcpKeepAlive_template()
{
}

TcpKeepAlive_template::TcpKeepAlive_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TcpKeepAlive_template::TcpKeepAlive_template(const TcpKeepAlive& other_value)
{
copy_value(other_value);
}

TcpKeepAlive_template::TcpKeepAlive_template(const OPTIONAL<TcpKeepAlive>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TcpKeepAlive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.TcpKeepAlive from an unbound optional field.");
}
}

TcpKeepAlive_template::TcpKeepAlive_template(const TcpKeepAlive_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TcpKeepAlive_template::~TcpKeepAlive_template()
{
clean_up();
}

TcpKeepAlive_template& TcpKeepAlive_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TcpKeepAlive_template& TcpKeepAlive_template::operator=(const TcpKeepAlive& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TcpKeepAlive_template& TcpKeepAlive_template::operator=(const OPTIONAL<TcpKeepAlive>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TcpKeepAlive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.TcpKeepAlive.");
}
return *this;
}

TcpKeepAlive_template& TcpKeepAlive_template::operator=(const TcpKeepAlive_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TcpKeepAlive_template::match(const TcpKeepAlive& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.enable().is_bound()) return FALSE;
if((other_value.enable().ispresent() ? !single_value->field_enable.match((const BOOLEAN&)other_value.enable(), legacy) : !single_value->field_enable.match_omit(legacy)))return FALSE;
if(!other_value.count().is_bound()) return FALSE;
if((other_value.count().ispresent() ? !single_value->field_count.match((const INTEGER&)other_value.count(), legacy) : !single_value->field_count.match_omit(legacy)))return FALSE;
if(!other_value.idle().is_bound()) return FALSE;
if((other_value.idle().ispresent() ? !single_value->field_idle.match((const INTEGER&)other_value.idle(), legacy) : !single_value->field_idle.match_omit(legacy)))return FALSE;
if(!other_value.interval().is_bound()) return FALSE;
if((other_value.interval().ispresent() ? !single_value->field_interval.match((const INTEGER&)other_value.interval(), legacy) : !single_value->field_interval.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
}
return FALSE;
}

boolean TcpKeepAlive_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_enable.is_omit() || single_value->field_enable.is_bound()) return TRUE;
if (single_value->field_count.is_omit() || single_value->field_count.is_bound()) return TRUE;
if (single_value->field_idle.is_omit() || single_value->field_idle.is_bound()) return TRUE;
if (single_value->field_interval.is_omit() || single_value->field_interval.is_bound()) return TRUE;
return FALSE;
}

boolean TcpKeepAlive_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_enable.is_omit() && !single_value->field_enable.is_value()) return FALSE;
if (!single_value->field_count.is_omit() && !single_value->field_count.is_value()) return FALSE;
if (!single_value->field_idle.is_omit() && !single_value->field_idle.is_value()) return FALSE;
if (!single_value->field_interval.is_omit() && !single_value->field_interval.is_value()) return FALSE;
return TRUE;
}

void TcpKeepAlive_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TcpKeepAlive TcpKeepAlive_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
TcpKeepAlive ret_val;
if (single_value->field_enable.is_omit()) ret_val.enable() = OMIT_VALUE;
else if (single_value->field_enable.is_bound()) {
ret_val.enable() = single_value->field_enable.valueof();
}
if (single_value->field_count.is_omit()) ret_val.count() = OMIT_VALUE;
else if (single_value->field_count.is_bound()) {
ret_val.count() = single_value->field_count.valueof();
}
if (single_value->field_idle.is_omit()) ret_val.idle() = OMIT_VALUE;
else if (single_value->field_idle.is_bound()) {
ret_val.idle() = single_value->field_idle.valueof();
}
if (single_value->field_interval.is_omit()) ret_val.interval() = OMIT_VALUE;
else if (single_value->field_interval.is_bound()) {
ret_val.interval() = single_value->field_interval.valueof();
}
return ret_val;
}

void TcpKeepAlive_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.TcpKeepAlive.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TcpKeepAlive_template[list_length];
}

TcpKeepAlive_template& TcpKeepAlive_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.TcpKeepAlive.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.TcpKeepAlive.");
return value_list.list_value[list_index];
}

BOOLEAN_template& TcpKeepAlive_template::enable()
{
set_specific();
return single_value->field_enable;
}

const BOOLEAN_template& TcpKeepAlive_template::enable() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field enable of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
return single_value->field_enable;
}

INTEGER_template& TcpKeepAlive_template::count()
{
set_specific();
return single_value->field_count;
}

const INTEGER_template& TcpKeepAlive_template::count() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field count of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
return single_value->field_count;
}

INTEGER_template& TcpKeepAlive_template::idle()
{
set_specific();
return single_value->field_idle;
}

const INTEGER_template& TcpKeepAlive_template::idle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field idle of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
return single_value->field_idle;
}

INTEGER_template& TcpKeepAlive_template::interval()
{
set_specific();
return single_value->field_interval;
}

const INTEGER_template& TcpKeepAlive_template::interval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field interval of a non-specific template of type @IPL4asp_Types.TcpKeepAlive.");
return single_value->field_interval;
}

int TcpKeepAlive_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_enable.is_present()) ret_val++;
      if (single_value->field_count.is_present()) ret_val++;
      if (single_value->field_idle.is_present()) ret_val++;
      if (single_value->field_interval.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.TcpKeepAlive containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
  }
  return 0;
}

void TcpKeepAlive_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ enable := ");
single_value->field_enable.log();
TTCN_Logger::log_event_str(", count := ");
single_value->field_count.log();
TTCN_Logger::log_event_str(", idle := ");
single_value->field_idle.log();
TTCN_Logger::log_event_str(", interval := ");
single_value->field_interval.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TcpKeepAlive_template::log_match(const TcpKeepAlive& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.enable().ispresent()){
if(!single_value->field_enable.match(match_value.enable(), legacy)){
TTCN_Logger::log_logmatch_info(".enable");
single_value->field_enable.log_match(match_value.enable(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_enable.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".enable := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_enable.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.count().ispresent()){
if(!single_value->field_count.match(match_value.count(), legacy)){
TTCN_Logger::log_logmatch_info(".count");
single_value->field_count.log_match(match_value.count(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_count.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".count := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_count.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.idle().ispresent()){
if(!single_value->field_idle.match(match_value.idle(), legacy)){
TTCN_Logger::log_logmatch_info(".idle");
single_value->field_idle.log_match(match_value.idle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_idle.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".idle := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_idle.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.interval().ispresent()){
if(!single_value->field_interval.match(match_value.interval(), legacy)){
TTCN_Logger::log_logmatch_info(".interval");
single_value->field_interval.log_match(match_value.interval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_interval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".interval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_interval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ enable := ");
if (match_value.enable().ispresent()) single_value->field_enable.log_match(match_value.enable(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_enable.log();
if (single_value->field_enable.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", count := ");
if (match_value.count().ispresent()) single_value->field_count.log_match(match_value.count(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_count.log();
if (single_value->field_count.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", idle := ");
if (match_value.idle().ispresent()) single_value->field_idle.log_match(match_value.idle(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_idle.log();
if (single_value->field_idle.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", interval := ");
if (match_value.interval().ispresent()) single_value->field_interval.log_match(match_value.interval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_interval.log();
if (single_value->field_interval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TcpKeepAlive_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_enable.encode_text(text_buf);
single_value->field_count.encode_text(text_buf);
single_value->field_idle.encode_text(text_buf);
single_value->field_interval.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.TcpKeepAlive.");
}
}

void TcpKeepAlive_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_enable.decode_text(text_buf);
single_value->field_count.decode_text(text_buf);
single_value->field_idle.decode_text(text_buf);
single_value->field_interval.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TcpKeepAlive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.TcpKeepAlive.");
}
}

void TcpKeepAlive_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TcpKeepAlive_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.TcpKeepAlive has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) enable().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) count().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) idle().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) interval().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "count")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          count().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "idle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          idle().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interval().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.TcpKeepAlive: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.TcpKeepAlive");
  }
  is_ifpresent = param.get_ifpresent();
}

void TcpKeepAlive_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_enable.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.TcpKeepAlive");
single_value->field_count.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.TcpKeepAlive");
single_value->field_idle.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.TcpKeepAlive");
single_value->field_interval.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.TcpKeepAlive");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.TcpKeepAlive");
}

boolean TcpKeepAlive_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TcpKeepAlive_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ReuseAddress::ReuseAddress()
{
}

ReuseAddress::ReuseAddress(const OPTIONAL<BOOLEAN>& par_enable)
  :   field_enable(par_enable)
{
}

ReuseAddress::ReuseAddress(const ReuseAddress& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.ReuseAddress.");
if (other_value.enable().is_bound()) field_enable = other_value.enable();
else field_enable.clean_up();
}

void ReuseAddress::clean_up()
{
field_enable.clean_up();
}

ReuseAddress& ReuseAddress::operator=(const ReuseAddress& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.ReuseAddress.");
  if (other_value.enable().is_bound()) field_enable = other_value.enable();
  else field_enable.clean_up();
}
return *this;
}

boolean ReuseAddress::operator==(const ReuseAddress& other_value) const
{
return field_enable==other_value.field_enable;
}

boolean ReuseAddress::is_bound() const
{
if(OPTIONAL_OMIT == field_enable.get_selection() || field_enable.is_bound()) return TRUE;
return FALSE;
}
boolean ReuseAddress::is_value() const
{
if(OPTIONAL_OMIT != field_enable.get_selection() && !field_enable.is_value()) return FALSE;
return TRUE;
}
int ReuseAddress::size_of() const
{
  int ret_val = 0;
  if (field_enable.ispresent()) ret_val++;
  return ret_val;
}

void ReuseAddress::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ enable := ");
field_enable.log();
TTCN_Logger::log_event_str(" }");
}

void ReuseAddress::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.ReuseAddress has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) enable().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ReuseAddress: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.ReuseAddress");
  }
}

void ReuseAddress::set_implicit_omit()
{
if (!enable().is_bound()) enable() = OMIT_VALUE;
else enable().set_implicit_omit();
}

void ReuseAddress::encode_text(Text_Buf& text_buf) const
{
field_enable.encode_text(text_buf);
}

void ReuseAddress::decode_text(Text_Buf& text_buf)
{
field_enable.decode_text(text_buf);
}

struct ReuseAddress_template::single_value_struct {
BOOLEAN_template field_enable;
};

void ReuseAddress_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_enable = ANY_OR_OMIT;
}
}
}

void ReuseAddress_template::copy_value(const ReuseAddress& other_value)
{
single_value = new single_value_struct;
if (other_value.enable().is_bound()) {
  if (other_value.enable().ispresent()) single_value->field_enable = other_value.enable()();
  else single_value->field_enable = OMIT_VALUE;
} else {
  single_value->field_enable.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ReuseAddress_template::copy_template(const ReuseAddress_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.enable().get_selection()) {
single_value->field_enable = other_value.enable();
} else {
single_value->field_enable.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ReuseAddress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
break;
}
set_selection(other_value);
}

ReuseAddress_template::ReuseAddress_template()
{
}

ReuseAddress_template::ReuseAddress_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ReuseAddress_template::ReuseAddress_template(const ReuseAddress& other_value)
{
copy_value(other_value);
}

ReuseAddress_template::ReuseAddress_template(const OPTIONAL<ReuseAddress>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReuseAddress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.ReuseAddress from an unbound optional field.");
}
}

ReuseAddress_template::ReuseAddress_template(const ReuseAddress_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ReuseAddress_template::~ReuseAddress_template()
{
clean_up();
}

ReuseAddress_template& ReuseAddress_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ReuseAddress_template& ReuseAddress_template::operator=(const ReuseAddress& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ReuseAddress_template& ReuseAddress_template::operator=(const OPTIONAL<ReuseAddress>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReuseAddress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ReuseAddress.");
}
return *this;
}

ReuseAddress_template& ReuseAddress_template::operator=(const ReuseAddress_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ReuseAddress_template::match(const ReuseAddress& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.enable().is_bound()) return FALSE;
if((other_value.enable().ispresent() ? !single_value->field_enable.match((const BOOLEAN&)other_value.enable(), legacy) : !single_value->field_enable.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
}
return FALSE;
}

boolean ReuseAddress_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_enable.is_omit() || single_value->field_enable.is_bound()) return TRUE;
return FALSE;
}

boolean ReuseAddress_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_enable.is_omit() && !single_value->field_enable.is_value()) return FALSE;
return TRUE;
}

void ReuseAddress_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ReuseAddress ReuseAddress_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ReuseAddress.");
ReuseAddress ret_val;
if (single_value->field_enable.is_omit()) ret_val.enable() = OMIT_VALUE;
else if (single_value->field_enable.is_bound()) {
ret_val.enable() = single_value->field_enable.valueof();
}
return ret_val;
}

void ReuseAddress_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.ReuseAddress.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ReuseAddress_template[list_length];
}

ReuseAddress_template& ReuseAddress_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.ReuseAddress.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.ReuseAddress.");
return value_list.list_value[list_index];
}

BOOLEAN_template& ReuseAddress_template::enable()
{
set_specific();
return single_value->field_enable;
}

const BOOLEAN_template& ReuseAddress_template::enable() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field enable of a non-specific template of type @IPL4asp_Types.ReuseAddress.");
return single_value->field_enable;
}

int ReuseAddress_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_enable.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ReuseAddress containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
  }
  return 0;
}

void ReuseAddress_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ enable := ");
single_value->field_enable.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ReuseAddress_template::log_match(const ReuseAddress& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.enable().ispresent()){
if(!single_value->field_enable.match(match_value.enable(), legacy)){
TTCN_Logger::log_logmatch_info(".enable");
single_value->field_enable.log_match(match_value.enable(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_enable.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".enable := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_enable.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ enable := ");
if (match_value.enable().ispresent()) single_value->field_enable.log_match(match_value.enable(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_enable.log();
if (single_value->field_enable.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ReuseAddress_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_enable.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ReuseAddress.");
}
}

void ReuseAddress_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_enable.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ReuseAddress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ReuseAddress.");
}
}

void ReuseAddress_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ReuseAddress_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.ReuseAddress has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) enable().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enable().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ReuseAddress: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.ReuseAddress");
  }
  is_ifpresent = param.get_ifpresent();
}

void ReuseAddress_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_enable.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ReuseAddress");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.ReuseAddress");
}

boolean ReuseAddress_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ReuseAddress_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SctpEventHandle::SctpEventHandle()
{
}

SctpEventHandle::SctpEventHandle(const OPTIONAL<BOOLEAN>& par_sctp__data__io__event,
    const OPTIONAL<BOOLEAN>& par_sctp__association__event,
    const OPTIONAL<BOOLEAN>& par_sctp__address__event,
    const OPTIONAL<BOOLEAN>& par_sctp__send__failure__event,
    const OPTIONAL<BOOLEAN>& par_sctp__peer__error__event,
    const OPTIONAL<BOOLEAN>& par_sctp__shutdown__event,
    const OPTIONAL<BOOLEAN>& par_sctp__partial__delivery__event,
    const OPTIONAL<BOOLEAN>& par_sctp__adaptation__layer__event,
    const OPTIONAL<BOOLEAN>& par_sctp__authentication__event,
    const OPTIONAL<BOOLEAN>& par_sctp__sender__dry__event)
  :   field_sctp__data__io__event(par_sctp__data__io__event),
  field_sctp__association__event(par_sctp__association__event),
  field_sctp__address__event(par_sctp__address__event),
  field_sctp__send__failure__event(par_sctp__send__failure__event),
  field_sctp__peer__error__event(par_sctp__peer__error__event),
  field_sctp__shutdown__event(par_sctp__shutdown__event),
  field_sctp__partial__delivery__event(par_sctp__partial__delivery__event),
  field_sctp__adaptation__layer__event(par_sctp__adaptation__layer__event),
  field_sctp__authentication__event(par_sctp__authentication__event),
  field_sctp__sender__dry__event(par_sctp__sender__dry__event)
{
}

SctpEventHandle::SctpEventHandle(const SctpEventHandle& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.SctpEventHandle.");
if (other_value.sctp__data__io__event().is_bound()) field_sctp__data__io__event = other_value.sctp__data__io__event();
else field_sctp__data__io__event.clean_up();
if (other_value.sctp__association__event().is_bound()) field_sctp__association__event = other_value.sctp__association__event();
else field_sctp__association__event.clean_up();
if (other_value.sctp__address__event().is_bound()) field_sctp__address__event = other_value.sctp__address__event();
else field_sctp__address__event.clean_up();
if (other_value.sctp__send__failure__event().is_bound()) field_sctp__send__failure__event = other_value.sctp__send__failure__event();
else field_sctp__send__failure__event.clean_up();
if (other_value.sctp__peer__error__event().is_bound()) field_sctp__peer__error__event = other_value.sctp__peer__error__event();
else field_sctp__peer__error__event.clean_up();
if (other_value.sctp__shutdown__event().is_bound()) field_sctp__shutdown__event = other_value.sctp__shutdown__event();
else field_sctp__shutdown__event.clean_up();
if (other_value.sctp__partial__delivery__event().is_bound()) field_sctp__partial__delivery__event = other_value.sctp__partial__delivery__event();
else field_sctp__partial__delivery__event.clean_up();
if (other_value.sctp__adaptation__layer__event().is_bound()) field_sctp__adaptation__layer__event = other_value.sctp__adaptation__layer__event();
else field_sctp__adaptation__layer__event.clean_up();
if (other_value.sctp__authentication__event().is_bound()) field_sctp__authentication__event = other_value.sctp__authentication__event();
else field_sctp__authentication__event.clean_up();
if (other_value.sctp__sender__dry__event().is_bound()) field_sctp__sender__dry__event = other_value.sctp__sender__dry__event();
else field_sctp__sender__dry__event.clean_up();
}

void SctpEventHandle::clean_up()
{
field_sctp__data__io__event.clean_up();
field_sctp__association__event.clean_up();
field_sctp__address__event.clean_up();
field_sctp__send__failure__event.clean_up();
field_sctp__peer__error__event.clean_up();
field_sctp__shutdown__event.clean_up();
field_sctp__partial__delivery__event.clean_up();
field_sctp__adaptation__layer__event.clean_up();
field_sctp__authentication__event.clean_up();
field_sctp__sender__dry__event.clean_up();
}

SctpEventHandle& SctpEventHandle::operator=(const SctpEventHandle& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.SctpEventHandle.");
  if (other_value.sctp__data__io__event().is_bound()) field_sctp__data__io__event = other_value.sctp__data__io__event();
  else field_sctp__data__io__event.clean_up();
  if (other_value.sctp__association__event().is_bound()) field_sctp__association__event = other_value.sctp__association__event();
  else field_sctp__association__event.clean_up();
  if (other_value.sctp__address__event().is_bound()) field_sctp__address__event = other_value.sctp__address__event();
  else field_sctp__address__event.clean_up();
  if (other_value.sctp__send__failure__event().is_bound()) field_sctp__send__failure__event = other_value.sctp__send__failure__event();
  else field_sctp__send__failure__event.clean_up();
  if (other_value.sctp__peer__error__event().is_bound()) field_sctp__peer__error__event = other_value.sctp__peer__error__event();
  else field_sctp__peer__error__event.clean_up();
  if (other_value.sctp__shutdown__event().is_bound()) field_sctp__shutdown__event = other_value.sctp__shutdown__event();
  else field_sctp__shutdown__event.clean_up();
  if (other_value.sctp__partial__delivery__event().is_bound()) field_sctp__partial__delivery__event = other_value.sctp__partial__delivery__event();
  else field_sctp__partial__delivery__event.clean_up();
  if (other_value.sctp__adaptation__layer__event().is_bound()) field_sctp__adaptation__layer__event = other_value.sctp__adaptation__layer__event();
  else field_sctp__adaptation__layer__event.clean_up();
  if (other_value.sctp__authentication__event().is_bound()) field_sctp__authentication__event = other_value.sctp__authentication__event();
  else field_sctp__authentication__event.clean_up();
  if (other_value.sctp__sender__dry__event().is_bound()) field_sctp__sender__dry__event = other_value.sctp__sender__dry__event();
  else field_sctp__sender__dry__event.clean_up();
}
return *this;
}

boolean SctpEventHandle::operator==(const SctpEventHandle& other_value) const
{
return field_sctp__data__io__event==other_value.field_sctp__data__io__event
  && field_sctp__association__event==other_value.field_sctp__association__event
  && field_sctp__address__event==other_value.field_sctp__address__event
  && field_sctp__send__failure__event==other_value.field_sctp__send__failure__event
  && field_sctp__peer__error__event==other_value.field_sctp__peer__error__event
  && field_sctp__shutdown__event==other_value.field_sctp__shutdown__event
  && field_sctp__partial__delivery__event==other_value.field_sctp__partial__delivery__event
  && field_sctp__adaptation__layer__event==other_value.field_sctp__adaptation__layer__event
  && field_sctp__authentication__event==other_value.field_sctp__authentication__event
  && field_sctp__sender__dry__event==other_value.field_sctp__sender__dry__event;
}

boolean SctpEventHandle::is_bound() const
{
if(OPTIONAL_OMIT == field_sctp__data__io__event.get_selection() || field_sctp__data__io__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__association__event.get_selection() || field_sctp__association__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__address__event.get_selection() || field_sctp__address__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__send__failure__event.get_selection() || field_sctp__send__failure__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__peer__error__event.get_selection() || field_sctp__peer__error__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__shutdown__event.get_selection() || field_sctp__shutdown__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__partial__delivery__event.get_selection() || field_sctp__partial__delivery__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__adaptation__layer__event.get_selection() || field_sctp__adaptation__layer__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__authentication__event.get_selection() || field_sctp__authentication__event.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sctp__sender__dry__event.get_selection() || field_sctp__sender__dry__event.is_bound()) return TRUE;
return FALSE;
}
boolean SctpEventHandle::is_value() const
{
if(OPTIONAL_OMIT != field_sctp__data__io__event.get_selection() && !field_sctp__data__io__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__association__event.get_selection() && !field_sctp__association__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__address__event.get_selection() && !field_sctp__address__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__send__failure__event.get_selection() && !field_sctp__send__failure__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__peer__error__event.get_selection() && !field_sctp__peer__error__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__shutdown__event.get_selection() && !field_sctp__shutdown__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__partial__delivery__event.get_selection() && !field_sctp__partial__delivery__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__adaptation__layer__event.get_selection() && !field_sctp__adaptation__layer__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__authentication__event.get_selection() && !field_sctp__authentication__event.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sctp__sender__dry__event.get_selection() && !field_sctp__sender__dry__event.is_value()) return FALSE;
return TRUE;
}
int SctpEventHandle::size_of() const
{
  int ret_val = 0;
  if (field_sctp__data__io__event.ispresent()) ret_val++;
  if (field_sctp__association__event.ispresent()) ret_val++;
  if (field_sctp__address__event.ispresent()) ret_val++;
  if (field_sctp__send__failure__event.ispresent()) ret_val++;
  if (field_sctp__peer__error__event.ispresent()) ret_val++;
  if (field_sctp__shutdown__event.ispresent()) ret_val++;
  if (field_sctp__partial__delivery__event.ispresent()) ret_val++;
  if (field_sctp__adaptation__layer__event.ispresent()) ret_val++;
  if (field_sctp__authentication__event.ispresent()) ret_val++;
  if (field_sctp__sender__dry__event.ispresent()) ret_val++;
  return ret_val;
}

void SctpEventHandle::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ sctp_data_io_event := ");
field_sctp__data__io__event.log();
TTCN_Logger::log_event_str(", sctp_association_event := ");
field_sctp__association__event.log();
TTCN_Logger::log_event_str(", sctp_address_event := ");
field_sctp__address__event.log();
TTCN_Logger::log_event_str(", sctp_send_failure_event := ");
field_sctp__send__failure__event.log();
TTCN_Logger::log_event_str(", sctp_peer_error_event := ");
field_sctp__peer__error__event.log();
TTCN_Logger::log_event_str(", sctp_shutdown_event := ");
field_sctp__shutdown__event.log();
TTCN_Logger::log_event_str(", sctp_partial_delivery_event := ");
field_sctp__partial__delivery__event.log();
TTCN_Logger::log_event_str(", sctp_adaptation_layer_event := ");
field_sctp__adaptation__layer__event.log();
TTCN_Logger::log_event_str(", sctp_authentication_event := ");
field_sctp__authentication__event.log();
TTCN_Logger::log_event_str(", sctp_sender_dry_event := ");
field_sctp__sender__dry__event.log();
TTCN_Logger::log_event_str(" }");
}

void SctpEventHandle::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (10<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.SctpEventHandle has 10 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sctp__data__io__event().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sctp__association__event().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sctp__address__event().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) sctp__send__failure__event().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) sctp__peer__error__event().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) sctp__shutdown__event().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) sctp__partial__delivery__event().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) sctp__adaptation__layer__event().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) sctp__authentication__event().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) sctp__sender__dry__event().set_param(*param.get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_data_io_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__data__io__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_association_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__association__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_address_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__address__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_send_failure_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__send__failure__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_peer_error_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__peer__error__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_shutdown_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__shutdown__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_partial_delivery_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__partial__delivery__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_adaptation_layer_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__adaptation__layer__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_authentication_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__authentication__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_sender_dry_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__sender__dry__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.SctpEventHandle: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.SctpEventHandle");
  }
}

void SctpEventHandle::set_implicit_omit()
{
if (!sctp__data__io__event().is_bound()) sctp__data__io__event() = OMIT_VALUE;
else sctp__data__io__event().set_implicit_omit();
if (!sctp__association__event().is_bound()) sctp__association__event() = OMIT_VALUE;
else sctp__association__event().set_implicit_omit();
if (!sctp__address__event().is_bound()) sctp__address__event() = OMIT_VALUE;
else sctp__address__event().set_implicit_omit();
if (!sctp__send__failure__event().is_bound()) sctp__send__failure__event() = OMIT_VALUE;
else sctp__send__failure__event().set_implicit_omit();
if (!sctp__peer__error__event().is_bound()) sctp__peer__error__event() = OMIT_VALUE;
else sctp__peer__error__event().set_implicit_omit();
if (!sctp__shutdown__event().is_bound()) sctp__shutdown__event() = OMIT_VALUE;
else sctp__shutdown__event().set_implicit_omit();
if (!sctp__partial__delivery__event().is_bound()) sctp__partial__delivery__event() = OMIT_VALUE;
else sctp__partial__delivery__event().set_implicit_omit();
if (!sctp__adaptation__layer__event().is_bound()) sctp__adaptation__layer__event() = OMIT_VALUE;
else sctp__adaptation__layer__event().set_implicit_omit();
if (!sctp__authentication__event().is_bound()) sctp__authentication__event() = OMIT_VALUE;
else sctp__authentication__event().set_implicit_omit();
if (!sctp__sender__dry__event().is_bound()) sctp__sender__dry__event() = OMIT_VALUE;
else sctp__sender__dry__event().set_implicit_omit();
}

void SctpEventHandle::encode_text(Text_Buf& text_buf) const
{
field_sctp__data__io__event.encode_text(text_buf);
field_sctp__association__event.encode_text(text_buf);
field_sctp__address__event.encode_text(text_buf);
field_sctp__send__failure__event.encode_text(text_buf);
field_sctp__peer__error__event.encode_text(text_buf);
field_sctp__shutdown__event.encode_text(text_buf);
field_sctp__partial__delivery__event.encode_text(text_buf);
field_sctp__adaptation__layer__event.encode_text(text_buf);
field_sctp__authentication__event.encode_text(text_buf);
field_sctp__sender__dry__event.encode_text(text_buf);
}

void SctpEventHandle::decode_text(Text_Buf& text_buf)
{
field_sctp__data__io__event.decode_text(text_buf);
field_sctp__association__event.decode_text(text_buf);
field_sctp__address__event.decode_text(text_buf);
field_sctp__send__failure__event.decode_text(text_buf);
field_sctp__peer__error__event.decode_text(text_buf);
field_sctp__shutdown__event.decode_text(text_buf);
field_sctp__partial__delivery__event.decode_text(text_buf);
field_sctp__adaptation__layer__event.decode_text(text_buf);
field_sctp__authentication__event.decode_text(text_buf);
field_sctp__sender__dry__event.decode_text(text_buf);
}

struct SctpEventHandle_template::single_value_struct {
BOOLEAN_template field_sctp__data__io__event;
BOOLEAN_template field_sctp__association__event;
BOOLEAN_template field_sctp__address__event;
BOOLEAN_template field_sctp__send__failure__event;
BOOLEAN_template field_sctp__peer__error__event;
BOOLEAN_template field_sctp__shutdown__event;
BOOLEAN_template field_sctp__partial__delivery__event;
BOOLEAN_template field_sctp__adaptation__layer__event;
BOOLEAN_template field_sctp__authentication__event;
BOOLEAN_template field_sctp__sender__dry__event;
};

void SctpEventHandle_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_sctp__data__io__event = ANY_OR_OMIT;
single_value->field_sctp__association__event = ANY_OR_OMIT;
single_value->field_sctp__address__event = ANY_OR_OMIT;
single_value->field_sctp__send__failure__event = ANY_OR_OMIT;
single_value->field_sctp__peer__error__event = ANY_OR_OMIT;
single_value->field_sctp__shutdown__event = ANY_OR_OMIT;
single_value->field_sctp__partial__delivery__event = ANY_OR_OMIT;
single_value->field_sctp__adaptation__layer__event = ANY_OR_OMIT;
single_value->field_sctp__authentication__event = ANY_OR_OMIT;
single_value->field_sctp__sender__dry__event = ANY_OR_OMIT;
}
}
}

void SctpEventHandle_template::copy_value(const SctpEventHandle& other_value)
{
single_value = new single_value_struct;
if (other_value.sctp__data__io__event().is_bound()) {
  if (other_value.sctp__data__io__event().ispresent()) single_value->field_sctp__data__io__event = other_value.sctp__data__io__event()();
  else single_value->field_sctp__data__io__event = OMIT_VALUE;
} else {
  single_value->field_sctp__data__io__event.clean_up();
}
if (other_value.sctp__association__event().is_bound()) {
  if (other_value.sctp__association__event().ispresent()) single_value->field_sctp__association__event = other_value.sctp__association__event()();
  else single_value->field_sctp__association__event = OMIT_VALUE;
} else {
  single_value->field_sctp__association__event.clean_up();
}
if (other_value.sctp__address__event().is_bound()) {
  if (other_value.sctp__address__event().ispresent()) single_value->field_sctp__address__event = other_value.sctp__address__event()();
  else single_value->field_sctp__address__event = OMIT_VALUE;
} else {
  single_value->field_sctp__address__event.clean_up();
}
if (other_value.sctp__send__failure__event().is_bound()) {
  if (other_value.sctp__send__failure__event().ispresent()) single_value->field_sctp__send__failure__event = other_value.sctp__send__failure__event()();
  else single_value->field_sctp__send__failure__event = OMIT_VALUE;
} else {
  single_value->field_sctp__send__failure__event.clean_up();
}
if (other_value.sctp__peer__error__event().is_bound()) {
  if (other_value.sctp__peer__error__event().ispresent()) single_value->field_sctp__peer__error__event = other_value.sctp__peer__error__event()();
  else single_value->field_sctp__peer__error__event = OMIT_VALUE;
} else {
  single_value->field_sctp__peer__error__event.clean_up();
}
if (other_value.sctp__shutdown__event().is_bound()) {
  if (other_value.sctp__shutdown__event().ispresent()) single_value->field_sctp__shutdown__event = other_value.sctp__shutdown__event()();
  else single_value->field_sctp__shutdown__event = OMIT_VALUE;
} else {
  single_value->field_sctp__shutdown__event.clean_up();
}
if (other_value.sctp__partial__delivery__event().is_bound()) {
  if (other_value.sctp__partial__delivery__event().ispresent()) single_value->field_sctp__partial__delivery__event = other_value.sctp__partial__delivery__event()();
  else single_value->field_sctp__partial__delivery__event = OMIT_VALUE;
} else {
  single_value->field_sctp__partial__delivery__event.clean_up();
}
if (other_value.sctp__adaptation__layer__event().is_bound()) {
  if (other_value.sctp__adaptation__layer__event().ispresent()) single_value->field_sctp__adaptation__layer__event = other_value.sctp__adaptation__layer__event()();
  else single_value->field_sctp__adaptation__layer__event = OMIT_VALUE;
} else {
  single_value->field_sctp__adaptation__layer__event.clean_up();
}
if (other_value.sctp__authentication__event().is_bound()) {
  if (other_value.sctp__authentication__event().ispresent()) single_value->field_sctp__authentication__event = other_value.sctp__authentication__event()();
  else single_value->field_sctp__authentication__event = OMIT_VALUE;
} else {
  single_value->field_sctp__authentication__event.clean_up();
}
if (other_value.sctp__sender__dry__event().is_bound()) {
  if (other_value.sctp__sender__dry__event().ispresent()) single_value->field_sctp__sender__dry__event = other_value.sctp__sender__dry__event()();
  else single_value->field_sctp__sender__dry__event = OMIT_VALUE;
} else {
  single_value->field_sctp__sender__dry__event.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SctpEventHandle_template::copy_template(const SctpEventHandle_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.sctp__data__io__event().get_selection()) {
single_value->field_sctp__data__io__event = other_value.sctp__data__io__event();
} else {
single_value->field_sctp__data__io__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__association__event().get_selection()) {
single_value->field_sctp__association__event = other_value.sctp__association__event();
} else {
single_value->field_sctp__association__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__address__event().get_selection()) {
single_value->field_sctp__address__event = other_value.sctp__address__event();
} else {
single_value->field_sctp__address__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__send__failure__event().get_selection()) {
single_value->field_sctp__send__failure__event = other_value.sctp__send__failure__event();
} else {
single_value->field_sctp__send__failure__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__peer__error__event().get_selection()) {
single_value->field_sctp__peer__error__event = other_value.sctp__peer__error__event();
} else {
single_value->field_sctp__peer__error__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__shutdown__event().get_selection()) {
single_value->field_sctp__shutdown__event = other_value.sctp__shutdown__event();
} else {
single_value->field_sctp__shutdown__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__partial__delivery__event().get_selection()) {
single_value->field_sctp__partial__delivery__event = other_value.sctp__partial__delivery__event();
} else {
single_value->field_sctp__partial__delivery__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__adaptation__layer__event().get_selection()) {
single_value->field_sctp__adaptation__layer__event = other_value.sctp__adaptation__layer__event();
} else {
single_value->field_sctp__adaptation__layer__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__authentication__event().get_selection()) {
single_value->field_sctp__authentication__event = other_value.sctp__authentication__event();
} else {
single_value->field_sctp__authentication__event.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sctp__sender__dry__event().get_selection()) {
single_value->field_sctp__sender__dry__event = other_value.sctp__sender__dry__event();
} else {
single_value->field_sctp__sender__dry__event.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SctpEventHandle_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
break;
}
set_selection(other_value);
}

SctpEventHandle_template::SctpEventHandle_template()
{
}

SctpEventHandle_template::SctpEventHandle_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SctpEventHandle_template::SctpEventHandle_template(const SctpEventHandle& other_value)
{
copy_value(other_value);
}

SctpEventHandle_template::SctpEventHandle_template(const OPTIONAL<SctpEventHandle>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpEventHandle&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.SctpEventHandle from an unbound optional field.");
}
}

SctpEventHandle_template::SctpEventHandle_template(const SctpEventHandle_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SctpEventHandle_template::~SctpEventHandle_template()
{
clean_up();
}

SctpEventHandle_template& SctpEventHandle_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SctpEventHandle_template& SctpEventHandle_template::operator=(const SctpEventHandle& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SctpEventHandle_template& SctpEventHandle_template::operator=(const OPTIONAL<SctpEventHandle>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SctpEventHandle&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SctpEventHandle.");
}
return *this;
}

SctpEventHandle_template& SctpEventHandle_template::operator=(const SctpEventHandle_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SctpEventHandle_template::match(const SctpEventHandle& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.sctp__data__io__event().is_bound()) return FALSE;
if((other_value.sctp__data__io__event().ispresent() ? !single_value->field_sctp__data__io__event.match((const BOOLEAN&)other_value.sctp__data__io__event(), legacy) : !single_value->field_sctp__data__io__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__association__event().is_bound()) return FALSE;
if((other_value.sctp__association__event().ispresent() ? !single_value->field_sctp__association__event.match((const BOOLEAN&)other_value.sctp__association__event(), legacy) : !single_value->field_sctp__association__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__address__event().is_bound()) return FALSE;
if((other_value.sctp__address__event().ispresent() ? !single_value->field_sctp__address__event.match((const BOOLEAN&)other_value.sctp__address__event(), legacy) : !single_value->field_sctp__address__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__send__failure__event().is_bound()) return FALSE;
if((other_value.sctp__send__failure__event().ispresent() ? !single_value->field_sctp__send__failure__event.match((const BOOLEAN&)other_value.sctp__send__failure__event(), legacy) : !single_value->field_sctp__send__failure__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__peer__error__event().is_bound()) return FALSE;
if((other_value.sctp__peer__error__event().ispresent() ? !single_value->field_sctp__peer__error__event.match((const BOOLEAN&)other_value.sctp__peer__error__event(), legacy) : !single_value->field_sctp__peer__error__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__shutdown__event().is_bound()) return FALSE;
if((other_value.sctp__shutdown__event().ispresent() ? !single_value->field_sctp__shutdown__event.match((const BOOLEAN&)other_value.sctp__shutdown__event(), legacy) : !single_value->field_sctp__shutdown__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__partial__delivery__event().is_bound()) return FALSE;
if((other_value.sctp__partial__delivery__event().ispresent() ? !single_value->field_sctp__partial__delivery__event.match((const BOOLEAN&)other_value.sctp__partial__delivery__event(), legacy) : !single_value->field_sctp__partial__delivery__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__adaptation__layer__event().is_bound()) return FALSE;
if((other_value.sctp__adaptation__layer__event().ispresent() ? !single_value->field_sctp__adaptation__layer__event.match((const BOOLEAN&)other_value.sctp__adaptation__layer__event(), legacy) : !single_value->field_sctp__adaptation__layer__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__authentication__event().is_bound()) return FALSE;
if((other_value.sctp__authentication__event().ispresent() ? !single_value->field_sctp__authentication__event.match((const BOOLEAN&)other_value.sctp__authentication__event(), legacy) : !single_value->field_sctp__authentication__event.match_omit(legacy)))return FALSE;
if(!other_value.sctp__sender__dry__event().is_bound()) return FALSE;
if((other_value.sctp__sender__dry__event().ispresent() ? !single_value->field_sctp__sender__dry__event.match((const BOOLEAN&)other_value.sctp__sender__dry__event(), legacy) : !single_value->field_sctp__sender__dry__event.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
}
return FALSE;
}

boolean SctpEventHandle_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_sctp__data__io__event.is_omit() || single_value->field_sctp__data__io__event.is_bound()) return TRUE;
if (single_value->field_sctp__association__event.is_omit() || single_value->field_sctp__association__event.is_bound()) return TRUE;
if (single_value->field_sctp__address__event.is_omit() || single_value->field_sctp__address__event.is_bound()) return TRUE;
if (single_value->field_sctp__send__failure__event.is_omit() || single_value->field_sctp__send__failure__event.is_bound()) return TRUE;
if (single_value->field_sctp__peer__error__event.is_omit() || single_value->field_sctp__peer__error__event.is_bound()) return TRUE;
if (single_value->field_sctp__shutdown__event.is_omit() || single_value->field_sctp__shutdown__event.is_bound()) return TRUE;
if (single_value->field_sctp__partial__delivery__event.is_omit() || single_value->field_sctp__partial__delivery__event.is_bound()) return TRUE;
if (single_value->field_sctp__adaptation__layer__event.is_omit() || single_value->field_sctp__adaptation__layer__event.is_bound()) return TRUE;
if (single_value->field_sctp__authentication__event.is_omit() || single_value->field_sctp__authentication__event.is_bound()) return TRUE;
if (single_value->field_sctp__sender__dry__event.is_omit() || single_value->field_sctp__sender__dry__event.is_bound()) return TRUE;
return FALSE;
}

boolean SctpEventHandle_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_sctp__data__io__event.is_omit() && !single_value->field_sctp__data__io__event.is_value()) return FALSE;
if (!single_value->field_sctp__association__event.is_omit() && !single_value->field_sctp__association__event.is_value()) return FALSE;
if (!single_value->field_sctp__address__event.is_omit() && !single_value->field_sctp__address__event.is_value()) return FALSE;
if (!single_value->field_sctp__send__failure__event.is_omit() && !single_value->field_sctp__send__failure__event.is_value()) return FALSE;
if (!single_value->field_sctp__peer__error__event.is_omit() && !single_value->field_sctp__peer__error__event.is_value()) return FALSE;
if (!single_value->field_sctp__shutdown__event.is_omit() && !single_value->field_sctp__shutdown__event.is_value()) return FALSE;
if (!single_value->field_sctp__partial__delivery__event.is_omit() && !single_value->field_sctp__partial__delivery__event.is_value()) return FALSE;
if (!single_value->field_sctp__adaptation__layer__event.is_omit() && !single_value->field_sctp__adaptation__layer__event.is_value()) return FALSE;
if (!single_value->field_sctp__authentication__event.is_omit() && !single_value->field_sctp__authentication__event.is_value()) return FALSE;
if (!single_value->field_sctp__sender__dry__event.is_omit() && !single_value->field_sctp__sender__dry__event.is_value()) return FALSE;
return TRUE;
}

void SctpEventHandle_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SctpEventHandle SctpEventHandle_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
SctpEventHandle ret_val;
if (single_value->field_sctp__data__io__event.is_omit()) ret_val.sctp__data__io__event() = OMIT_VALUE;
else if (single_value->field_sctp__data__io__event.is_bound()) {
ret_val.sctp__data__io__event() = single_value->field_sctp__data__io__event.valueof();
}
if (single_value->field_sctp__association__event.is_omit()) ret_val.sctp__association__event() = OMIT_VALUE;
else if (single_value->field_sctp__association__event.is_bound()) {
ret_val.sctp__association__event() = single_value->field_sctp__association__event.valueof();
}
if (single_value->field_sctp__address__event.is_omit()) ret_val.sctp__address__event() = OMIT_VALUE;
else if (single_value->field_sctp__address__event.is_bound()) {
ret_val.sctp__address__event() = single_value->field_sctp__address__event.valueof();
}
if (single_value->field_sctp__send__failure__event.is_omit()) ret_val.sctp__send__failure__event() = OMIT_VALUE;
else if (single_value->field_sctp__send__failure__event.is_bound()) {
ret_val.sctp__send__failure__event() = single_value->field_sctp__send__failure__event.valueof();
}
if (single_value->field_sctp__peer__error__event.is_omit()) ret_val.sctp__peer__error__event() = OMIT_VALUE;
else if (single_value->field_sctp__peer__error__event.is_bound()) {
ret_val.sctp__peer__error__event() = single_value->field_sctp__peer__error__event.valueof();
}
if (single_value->field_sctp__shutdown__event.is_omit()) ret_val.sctp__shutdown__event() = OMIT_VALUE;
else if (single_value->field_sctp__shutdown__event.is_bound()) {
ret_val.sctp__shutdown__event() = single_value->field_sctp__shutdown__event.valueof();
}
if (single_value->field_sctp__partial__delivery__event.is_omit()) ret_val.sctp__partial__delivery__event() = OMIT_VALUE;
else if (single_value->field_sctp__partial__delivery__event.is_bound()) {
ret_val.sctp__partial__delivery__event() = single_value->field_sctp__partial__delivery__event.valueof();
}
if (single_value->field_sctp__adaptation__layer__event.is_omit()) ret_val.sctp__adaptation__layer__event() = OMIT_VALUE;
else if (single_value->field_sctp__adaptation__layer__event.is_bound()) {
ret_val.sctp__adaptation__layer__event() = single_value->field_sctp__adaptation__layer__event.valueof();
}
if (single_value->field_sctp__authentication__event.is_omit()) ret_val.sctp__authentication__event() = OMIT_VALUE;
else if (single_value->field_sctp__authentication__event.is_bound()) {
ret_val.sctp__authentication__event() = single_value->field_sctp__authentication__event.valueof();
}
if (single_value->field_sctp__sender__dry__event.is_omit()) ret_val.sctp__sender__dry__event() = OMIT_VALUE;
else if (single_value->field_sctp__sender__dry__event.is_bound()) {
ret_val.sctp__sender__dry__event() = single_value->field_sctp__sender__dry__event.valueof();
}
return ret_val;
}

void SctpEventHandle_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.SctpEventHandle.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SctpEventHandle_template[list_length];
}

SctpEventHandle_template& SctpEventHandle_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.SctpEventHandle.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.SctpEventHandle.");
return value_list.list_value[list_index];
}

BOOLEAN_template& SctpEventHandle_template::sctp__data__io__event()
{
set_specific();
return single_value->field_sctp__data__io__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__data__io__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_data_io_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__data__io__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__association__event()
{
set_specific();
return single_value->field_sctp__association__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__association__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_association_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__association__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__address__event()
{
set_specific();
return single_value->field_sctp__address__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__address__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_address_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__address__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__send__failure__event()
{
set_specific();
return single_value->field_sctp__send__failure__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__send__failure__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_send_failure_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__send__failure__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__peer__error__event()
{
set_specific();
return single_value->field_sctp__peer__error__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__peer__error__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_peer_error_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__peer__error__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__shutdown__event()
{
set_specific();
return single_value->field_sctp__shutdown__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__shutdown__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_shutdown_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__shutdown__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__partial__delivery__event()
{
set_specific();
return single_value->field_sctp__partial__delivery__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__partial__delivery__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_partial_delivery_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__partial__delivery__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__adaptation__layer__event()
{
set_specific();
return single_value->field_sctp__adaptation__layer__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__adaptation__layer__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_adaptation_layer_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__adaptation__layer__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__authentication__event()
{
set_specific();
return single_value->field_sctp__authentication__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__authentication__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_authentication_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__authentication__event;
}

BOOLEAN_template& SctpEventHandle_template::sctp__sender__dry__event()
{
set_specific();
return single_value->field_sctp__sender__dry__event;
}

const BOOLEAN_template& SctpEventHandle_template::sctp__sender__dry__event() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sctp_sender_dry_event of a non-specific template of type @IPL4asp_Types.SctpEventHandle.");
return single_value->field_sctp__sender__dry__event;
}

int SctpEventHandle_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_sctp__data__io__event.is_present()) ret_val++;
      if (single_value->field_sctp__association__event.is_present()) ret_val++;
      if (single_value->field_sctp__address__event.is_present()) ret_val++;
      if (single_value->field_sctp__send__failure__event.is_present()) ret_val++;
      if (single_value->field_sctp__peer__error__event.is_present()) ret_val++;
      if (single_value->field_sctp__shutdown__event.is_present()) ret_val++;
      if (single_value->field_sctp__partial__delivery__event.is_present()) ret_val++;
      if (single_value->field_sctp__adaptation__layer__event.is_present()) ret_val++;
      if (single_value->field_sctp__authentication__event.is_present()) ret_val++;
      if (single_value->field_sctp__sender__dry__event.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SctpEventHandle containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
  }
  return 0;
}

void SctpEventHandle_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ sctp_data_io_event := ");
single_value->field_sctp__data__io__event.log();
TTCN_Logger::log_event_str(", sctp_association_event := ");
single_value->field_sctp__association__event.log();
TTCN_Logger::log_event_str(", sctp_address_event := ");
single_value->field_sctp__address__event.log();
TTCN_Logger::log_event_str(", sctp_send_failure_event := ");
single_value->field_sctp__send__failure__event.log();
TTCN_Logger::log_event_str(", sctp_peer_error_event := ");
single_value->field_sctp__peer__error__event.log();
TTCN_Logger::log_event_str(", sctp_shutdown_event := ");
single_value->field_sctp__shutdown__event.log();
TTCN_Logger::log_event_str(", sctp_partial_delivery_event := ");
single_value->field_sctp__partial__delivery__event.log();
TTCN_Logger::log_event_str(", sctp_adaptation_layer_event := ");
single_value->field_sctp__adaptation__layer__event.log();
TTCN_Logger::log_event_str(", sctp_authentication_event := ");
single_value->field_sctp__authentication__event.log();
TTCN_Logger::log_event_str(", sctp_sender_dry_event := ");
single_value->field_sctp__sender__dry__event.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SctpEventHandle_template::log_match(const SctpEventHandle& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.sctp__data__io__event().ispresent()){
if(!single_value->field_sctp__data__io__event.match(match_value.sctp__data__io__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_data_io_event");
single_value->field_sctp__data__io__event.log_match(match_value.sctp__data__io__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__data__io__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_data_io_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__data__io__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__association__event().ispresent()){
if(!single_value->field_sctp__association__event.match(match_value.sctp__association__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_association_event");
single_value->field_sctp__association__event.log_match(match_value.sctp__association__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__association__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_association_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__association__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__address__event().ispresent()){
if(!single_value->field_sctp__address__event.match(match_value.sctp__address__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_address_event");
single_value->field_sctp__address__event.log_match(match_value.sctp__address__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__address__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_address_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__address__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__send__failure__event().ispresent()){
if(!single_value->field_sctp__send__failure__event.match(match_value.sctp__send__failure__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_send_failure_event");
single_value->field_sctp__send__failure__event.log_match(match_value.sctp__send__failure__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__send__failure__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_send_failure_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__send__failure__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__peer__error__event().ispresent()){
if(!single_value->field_sctp__peer__error__event.match(match_value.sctp__peer__error__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_peer_error_event");
single_value->field_sctp__peer__error__event.log_match(match_value.sctp__peer__error__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__peer__error__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_peer_error_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__peer__error__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__shutdown__event().ispresent()){
if(!single_value->field_sctp__shutdown__event.match(match_value.sctp__shutdown__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_shutdown_event");
single_value->field_sctp__shutdown__event.log_match(match_value.sctp__shutdown__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__shutdown__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_shutdown_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__shutdown__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__partial__delivery__event().ispresent()){
if(!single_value->field_sctp__partial__delivery__event.match(match_value.sctp__partial__delivery__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_partial_delivery_event");
single_value->field_sctp__partial__delivery__event.log_match(match_value.sctp__partial__delivery__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__partial__delivery__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_partial_delivery_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__partial__delivery__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__adaptation__layer__event().ispresent()){
if(!single_value->field_sctp__adaptation__layer__event.match(match_value.sctp__adaptation__layer__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_adaptation_layer_event");
single_value->field_sctp__adaptation__layer__event.log_match(match_value.sctp__adaptation__layer__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__adaptation__layer__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_adaptation_layer_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__adaptation__layer__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__authentication__event().ispresent()){
if(!single_value->field_sctp__authentication__event.match(match_value.sctp__authentication__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_authentication_event");
single_value->field_sctp__authentication__event.log_match(match_value.sctp__authentication__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__authentication__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_authentication_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__authentication__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.sctp__sender__dry__event().ispresent()){
if(!single_value->field_sctp__sender__dry__event.match(match_value.sctp__sender__dry__event(), legacy)){
TTCN_Logger::log_logmatch_info(".sctp_sender_dry_event");
single_value->field_sctp__sender__dry__event.log_match(match_value.sctp__sender__dry__event(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sctp__sender__dry__event.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sctp_sender_dry_event := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sctp__sender__dry__event.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ sctp_data_io_event := ");
if (match_value.sctp__data__io__event().ispresent()) single_value->field_sctp__data__io__event.log_match(match_value.sctp__data__io__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__data__io__event.log();
if (single_value->field_sctp__data__io__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_association_event := ");
if (match_value.sctp__association__event().ispresent()) single_value->field_sctp__association__event.log_match(match_value.sctp__association__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__association__event.log();
if (single_value->field_sctp__association__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_address_event := ");
if (match_value.sctp__address__event().ispresent()) single_value->field_sctp__address__event.log_match(match_value.sctp__address__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__address__event.log();
if (single_value->field_sctp__address__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_send_failure_event := ");
if (match_value.sctp__send__failure__event().ispresent()) single_value->field_sctp__send__failure__event.log_match(match_value.sctp__send__failure__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__send__failure__event.log();
if (single_value->field_sctp__send__failure__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_peer_error_event := ");
if (match_value.sctp__peer__error__event().ispresent()) single_value->field_sctp__peer__error__event.log_match(match_value.sctp__peer__error__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__peer__error__event.log();
if (single_value->field_sctp__peer__error__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_shutdown_event := ");
if (match_value.sctp__shutdown__event().ispresent()) single_value->field_sctp__shutdown__event.log_match(match_value.sctp__shutdown__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__shutdown__event.log();
if (single_value->field_sctp__shutdown__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_partial_delivery_event := ");
if (match_value.sctp__partial__delivery__event().ispresent()) single_value->field_sctp__partial__delivery__event.log_match(match_value.sctp__partial__delivery__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__partial__delivery__event.log();
if (single_value->field_sctp__partial__delivery__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_adaptation_layer_event := ");
if (match_value.sctp__adaptation__layer__event().ispresent()) single_value->field_sctp__adaptation__layer__event.log_match(match_value.sctp__adaptation__layer__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__adaptation__layer__event.log();
if (single_value->field_sctp__adaptation__layer__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_authentication_event := ");
if (match_value.sctp__authentication__event().ispresent()) single_value->field_sctp__authentication__event.log_match(match_value.sctp__authentication__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__authentication__event.log();
if (single_value->field_sctp__authentication__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", sctp_sender_dry_event := ");
if (match_value.sctp__sender__dry__event().ispresent()) single_value->field_sctp__sender__dry__event.log_match(match_value.sctp__sender__dry__event(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sctp__sender__dry__event.log();
if (single_value->field_sctp__sender__dry__event.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SctpEventHandle_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_sctp__data__io__event.encode_text(text_buf);
single_value->field_sctp__association__event.encode_text(text_buf);
single_value->field_sctp__address__event.encode_text(text_buf);
single_value->field_sctp__send__failure__event.encode_text(text_buf);
single_value->field_sctp__peer__error__event.encode_text(text_buf);
single_value->field_sctp__shutdown__event.encode_text(text_buf);
single_value->field_sctp__partial__delivery__event.encode_text(text_buf);
single_value->field_sctp__adaptation__layer__event.encode_text(text_buf);
single_value->field_sctp__authentication__event.encode_text(text_buf);
single_value->field_sctp__sender__dry__event.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SctpEventHandle.");
}
}

void SctpEventHandle_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_sctp__data__io__event.decode_text(text_buf);
single_value->field_sctp__association__event.decode_text(text_buf);
single_value->field_sctp__address__event.decode_text(text_buf);
single_value->field_sctp__send__failure__event.decode_text(text_buf);
single_value->field_sctp__peer__error__event.decode_text(text_buf);
single_value->field_sctp__shutdown__event.decode_text(text_buf);
single_value->field_sctp__partial__delivery__event.decode_text(text_buf);
single_value->field_sctp__adaptation__layer__event.decode_text(text_buf);
single_value->field_sctp__authentication__event.decode_text(text_buf);
single_value->field_sctp__sender__dry__event.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SctpEventHandle_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.SctpEventHandle.");
}
}

void SctpEventHandle_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SctpEventHandle_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (10<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.SctpEventHandle has 10 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) sctp__data__io__event().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sctp__association__event().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) sctp__address__event().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) sctp__send__failure__event().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) sctp__peer__error__event().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) sctp__shutdown__event().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) sctp__partial__delivery__event().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) sctp__adaptation__layer__event().set_param(*param.get_elem(7));
    if (param.get_size()>8 && param.get_elem(8)->get_type()!=Module_Param::MP_NotUsed) sctp__authentication__event().set_param(*param.get_elem(8));
    if (param.get_size()>9 && param.get_elem(9)->get_type()!=Module_Param::MP_NotUsed) sctp__sender__dry__event().set_param(*param.get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_data_io_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__data__io__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_association_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__association__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_address_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__address__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_send_failure_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__send__failure__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_peer_error_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__peer__error__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_shutdown_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__shutdown__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_partial_delivery_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__partial__delivery__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_adaptation_layer_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__adaptation__layer__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_authentication_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__authentication__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sctp_sender_dry_event")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sctp__sender__dry__event().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.SctpEventHandle: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.SctpEventHandle");
  }
  is_ifpresent = param.get_ifpresent();
}

void SctpEventHandle_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_sctp__data__io__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__association__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__address__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__send__failure__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__peer__error__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__shutdown__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__partial__delivery__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__adaptation__layer__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__authentication__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
single_value->field_sctp__sender__dry__event.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.SctpEventHandle");
}

boolean SctpEventHandle_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SctpEventHandle_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Linger__opt::Linger__opt()
{
}

Linger__opt::Linger__opt(const INTEGER& par_l__onoff,
    const INTEGER& par_l__linger)
  :   field_l__onoff(par_l__onoff),
  field_l__linger(par_l__linger)
{
}

Linger__opt::Linger__opt(const Linger__opt& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.Linger_opt.");
if (other_value.l__onoff().is_bound()) field_l__onoff = other_value.l__onoff();
else field_l__onoff.clean_up();
if (other_value.l__linger().is_bound()) field_l__linger = other_value.l__linger();
else field_l__linger.clean_up();
}

void Linger__opt::clean_up()
{
field_l__onoff.clean_up();
field_l__linger.clean_up();
}

Linger__opt& Linger__opt::operator=(const Linger__opt& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.Linger_opt.");
  if (other_value.l__onoff().is_bound()) field_l__onoff = other_value.l__onoff();
  else field_l__onoff.clean_up();
  if (other_value.l__linger().is_bound()) field_l__linger = other_value.l__linger();
  else field_l__linger.clean_up();
}
return *this;
}

boolean Linger__opt::operator==(const Linger__opt& other_value) const
{
return field_l__onoff==other_value.field_l__onoff
  && field_l__linger==other_value.field_l__linger;
}

boolean Linger__opt::is_bound() const
{
if(field_l__onoff.is_bound()) return TRUE;
if(field_l__linger.is_bound()) return TRUE;
return FALSE;
}
boolean Linger__opt::is_value() const
{
if(!field_l__onoff.is_value()) return FALSE;
if(!field_l__linger.is_value()) return FALSE;
return TRUE;
}
void Linger__opt::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ l_onoff := ");
field_l__onoff.log();
TTCN_Logger::log_event_str(", l_linger := ");
field_l__linger.log();
TTCN_Logger::log_event_str(" }");
}

void Linger__opt::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.Linger_opt has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) l__onoff().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) l__linger().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "l_onoff")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          l__onoff().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "l_linger")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          l__linger().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.Linger_opt: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.Linger_opt");
  }
}

void Linger__opt::set_implicit_omit()
{
if (l__onoff().is_bound()) l__onoff().set_implicit_omit();
if (l__linger().is_bound()) l__linger().set_implicit_omit();
}

void Linger__opt::encode_text(Text_Buf& text_buf) const
{
field_l__onoff.encode_text(text_buf);
field_l__linger.encode_text(text_buf);
}

void Linger__opt::decode_text(Text_Buf& text_buf)
{
field_l__onoff.decode_text(text_buf);
field_l__linger.decode_text(text_buf);
}

struct Linger__opt_template::single_value_struct {
INTEGER_template field_l__onoff;
INTEGER_template field_l__linger;
};

void Linger__opt_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_l__onoff = ANY_VALUE;
single_value->field_l__linger = ANY_VALUE;
}
}
}

void Linger__opt_template::copy_value(const Linger__opt& other_value)
{
single_value = new single_value_struct;
if (other_value.l__onoff().is_bound()) {
  single_value->field_l__onoff = other_value.l__onoff();
} else {
  single_value->field_l__onoff.clean_up();
}
if (other_value.l__linger().is_bound()) {
  single_value->field_l__linger = other_value.l__linger();
} else {
  single_value->field_l__linger.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Linger__opt_template::copy_template(const Linger__opt_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.l__onoff().get_selection()) {
single_value->field_l__onoff = other_value.l__onoff();
} else {
single_value->field_l__onoff.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.l__linger().get_selection()) {
single_value->field_l__linger = other_value.l__linger();
} else {
single_value->field_l__linger.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Linger__opt_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
break;
}
set_selection(other_value);
}

Linger__opt_template::Linger__opt_template()
{
}

Linger__opt_template::Linger__opt_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Linger__opt_template::Linger__opt_template(const Linger__opt& other_value)
{
copy_value(other_value);
}

Linger__opt_template::Linger__opt_template(const OPTIONAL<Linger__opt>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Linger__opt&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.Linger_opt from an unbound optional field.");
}
}

Linger__opt_template::Linger__opt_template(const Linger__opt_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Linger__opt_template::~Linger__opt_template()
{
clean_up();
}

Linger__opt_template& Linger__opt_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Linger__opt_template& Linger__opt_template::operator=(const Linger__opt& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Linger__opt_template& Linger__opt_template::operator=(const OPTIONAL<Linger__opt>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Linger__opt&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.Linger_opt.");
}
return *this;
}

Linger__opt_template& Linger__opt_template::operator=(const Linger__opt_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Linger__opt_template::match(const Linger__opt& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.l__onoff().is_bound()) return FALSE;
if(!single_value->field_l__onoff.match(other_value.l__onoff(), legacy))return FALSE;
if(!other_value.l__linger().is_bound()) return FALSE;
if(!single_value->field_l__linger.match(other_value.l__linger(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
}
return FALSE;
}

boolean Linger__opt_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_l__onoff.is_bound()) return TRUE;
if (single_value->field_l__linger.is_bound()) return TRUE;
return FALSE;
}

boolean Linger__opt_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_l__onoff.is_value()) return FALSE;
if (!single_value->field_l__linger.is_value()) return FALSE;
return TRUE;
}

void Linger__opt_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Linger__opt Linger__opt_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.Linger_opt.");
Linger__opt ret_val;
if (single_value->field_l__onoff.is_bound()) {
ret_val.l__onoff() = single_value->field_l__onoff.valueof();
}
if (single_value->field_l__linger.is_bound()) {
ret_val.l__linger() = single_value->field_l__linger.valueof();
}
return ret_val;
}

void Linger__opt_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.Linger_opt.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Linger__opt_template[list_length];
}

Linger__opt_template& Linger__opt_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.Linger_opt.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.Linger_opt.");
return value_list.list_value[list_index];
}

INTEGER_template& Linger__opt_template::l__onoff()
{
set_specific();
return single_value->field_l__onoff;
}

const INTEGER_template& Linger__opt_template::l__onoff() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field l_onoff of a non-specific template of type @IPL4asp_Types.Linger_opt.");
return single_value->field_l__onoff;
}

INTEGER_template& Linger__opt_template::l__linger()
{
set_specific();
return single_value->field_l__linger;
}

const INTEGER_template& Linger__opt_template::l__linger() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field l_linger of a non-specific template of type @IPL4asp_Types.Linger_opt.");
return single_value->field_l__linger;
}

int Linger__opt_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.Linger_opt containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
  }
  return 0;
}

void Linger__opt_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ l_onoff := ");
single_value->field_l__onoff.log();
TTCN_Logger::log_event_str(", l_linger := ");
single_value->field_l__linger.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Linger__opt_template::log_match(const Linger__opt& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_l__onoff.match(match_value.l__onoff(), legacy)){
TTCN_Logger::log_logmatch_info(".l_onoff");
single_value->field_l__onoff.log_match(match_value.l__onoff(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_l__linger.match(match_value.l__linger(), legacy)){
TTCN_Logger::log_logmatch_info(".l_linger");
single_value->field_l__linger.log_match(match_value.l__linger(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ l_onoff := ");
single_value->field_l__onoff.log_match(match_value.l__onoff(), legacy);
TTCN_Logger::log_event_str(", l_linger := ");
single_value->field_l__linger.log_match(match_value.l__linger(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Linger__opt_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_l__onoff.encode_text(text_buf);
single_value->field_l__linger.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.Linger_opt.");
}
}

void Linger__opt_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_l__onoff.decode_text(text_buf);
single_value->field_l__linger.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Linger__opt_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.Linger_opt.");
}
}

void Linger__opt_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Linger__opt_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.Linger_opt has 2 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) l__onoff().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) l__linger().set_param(*param.get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "l_onoff")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          l__onoff().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "l_linger")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          l__linger().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.Linger_opt: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.Linger_opt");
  }
  is_ifpresent = param.get_ifpresent();
}

void Linger__opt_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_l__onoff.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Linger_opt");
single_value->field_l__linger.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Linger_opt");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.Linger_opt");
}

boolean Linger__opt_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Linger__opt_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SSL__protocols::copy_value(const SSL__protocols& other_value)
{
switch (other_value.union_selection) {
case ALT_SSLv2__supported:
field_SSLv2__supported = new BOOLEAN(*other_value.field_SSLv2__supported);
break;
case ALT_SSLv3__supported:
field_SSLv3__supported = new BOOLEAN(*other_value.field_SSLv3__supported);
break;
case ALT_TLSv1__supported:
field_TLSv1__supported = new BOOLEAN(*other_value.field_TLSv1__supported);
break;
case ALT_TLSv1__1__supported:
field_TLSv1__1__supported = new BOOLEAN(*other_value.field_TLSv1__1__supported);
break;
case ALT_TLSv1__2__supported:
field_TLSv1__2__supported = new BOOLEAN(*other_value.field_TLSv1__2__supported);
break;
case ALT_DTLSv1__supported:
field_DTLSv1__supported = new BOOLEAN(*other_value.field_DTLSv1__supported);
break;
case ALT_DTLSv1__2__supported:
field_DTLSv1__2__supported = new BOOLEAN(*other_value.field_DTLSv1__2__supported);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IPL4asp_Types.SSL_protocols.");
}
union_selection = other_value.union_selection;
}

SSL__protocols::SSL__protocols()
{
union_selection = UNBOUND_VALUE;
}

SSL__protocols::SSL__protocols(const SSL__protocols& other_value)
: Base_Type(){
copy_value(other_value);
}

SSL__protocols::~SSL__protocols()
{
clean_up();
}

SSL__protocols& SSL__protocols::operator=(const SSL__protocols& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SSL__protocols::operator==(const SSL__protocols& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IPL4asp_Types.SSL_protocols.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IPL4asp_Types.SSL_protocols.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_SSLv2__supported:
return *field_SSLv2__supported == *other_value.field_SSLv2__supported;
case ALT_SSLv3__supported:
return *field_SSLv3__supported == *other_value.field_SSLv3__supported;
case ALT_TLSv1__supported:
return *field_TLSv1__supported == *other_value.field_TLSv1__supported;
case ALT_TLSv1__1__supported:
return *field_TLSv1__1__supported == *other_value.field_TLSv1__1__supported;
case ALT_TLSv1__2__supported:
return *field_TLSv1__2__supported == *other_value.field_TLSv1__2__supported;
case ALT_DTLSv1__supported:
return *field_DTLSv1__supported == *other_value.field_DTLSv1__supported;
case ALT_DTLSv1__2__supported:
return *field_DTLSv1__2__supported == *other_value.field_DTLSv1__2__supported;
default:
return FALSE;
}
}

BOOLEAN& SSL__protocols::SSLv2__supported()
{
if (union_selection != ALT_SSLv2__supported) {
clean_up();
field_SSLv2__supported = new BOOLEAN;
union_selection = ALT_SSLv2__supported;
}
return *field_SSLv2__supported;
}

const BOOLEAN& SSL__protocols::SSLv2__supported() const
{
if (union_selection != ALT_SSLv2__supported) TTCN_error("Using non-selected field SSLv2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_SSLv2__supported;
}

BOOLEAN& SSL__protocols::SSLv3__supported()
{
if (union_selection != ALT_SSLv3__supported) {
clean_up();
field_SSLv3__supported = new BOOLEAN;
union_selection = ALT_SSLv3__supported;
}
return *field_SSLv3__supported;
}

const BOOLEAN& SSL__protocols::SSLv3__supported() const
{
if (union_selection != ALT_SSLv3__supported) TTCN_error("Using non-selected field SSLv3_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_SSLv3__supported;
}

BOOLEAN& SSL__protocols::TLSv1__supported()
{
if (union_selection != ALT_TLSv1__supported) {
clean_up();
field_TLSv1__supported = new BOOLEAN;
union_selection = ALT_TLSv1__supported;
}
return *field_TLSv1__supported;
}

const BOOLEAN& SSL__protocols::TLSv1__supported() const
{
if (union_selection != ALT_TLSv1__supported) TTCN_error("Using non-selected field TLSv1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_TLSv1__supported;
}

BOOLEAN& SSL__protocols::TLSv1__1__supported()
{
if (union_selection != ALT_TLSv1__1__supported) {
clean_up();
field_TLSv1__1__supported = new BOOLEAN;
union_selection = ALT_TLSv1__1__supported;
}
return *field_TLSv1__1__supported;
}

const BOOLEAN& SSL__protocols::TLSv1__1__supported() const
{
if (union_selection != ALT_TLSv1__1__supported) TTCN_error("Using non-selected field TLSv1_1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_TLSv1__1__supported;
}

BOOLEAN& SSL__protocols::TLSv1__2__supported()
{
if (union_selection != ALT_TLSv1__2__supported) {
clean_up();
field_TLSv1__2__supported = new BOOLEAN;
union_selection = ALT_TLSv1__2__supported;
}
return *field_TLSv1__2__supported;
}

const BOOLEAN& SSL__protocols::TLSv1__2__supported() const
{
if (union_selection != ALT_TLSv1__2__supported) TTCN_error("Using non-selected field TLSv1_2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_TLSv1__2__supported;
}

BOOLEAN& SSL__protocols::DTLSv1__supported()
{
if (union_selection != ALT_DTLSv1__supported) {
clean_up();
field_DTLSv1__supported = new BOOLEAN;
union_selection = ALT_DTLSv1__supported;
}
return *field_DTLSv1__supported;
}

const BOOLEAN& SSL__protocols::DTLSv1__supported() const
{
if (union_selection != ALT_DTLSv1__supported) TTCN_error("Using non-selected field DTLSv1_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_DTLSv1__supported;
}

BOOLEAN& SSL__protocols::DTLSv1__2__supported()
{
if (union_selection != ALT_DTLSv1__2__supported) {
clean_up();
field_DTLSv1__2__supported = new BOOLEAN;
union_selection = ALT_DTLSv1__2__supported;
}
return *field_DTLSv1__2__supported;
}

const BOOLEAN& SSL__protocols::DTLSv1__2__supported() const
{
if (union_selection != ALT_DTLSv1__2__supported) TTCN_error("Using non-selected field DTLSv1_2_supported in a value of union type @IPL4asp_Types.SSL_protocols.");
return *field_DTLSv1__2__supported;
}

boolean SSL__protocols::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.SSL_protocols.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IPL4asp_Types.SSL_protocols.");
return union_selection == checked_selection;
}

boolean SSL__protocols::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SSL__protocols::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_SSLv2__supported: return field_SSLv2__supported->is_value();
case ALT_SSLv3__supported: return field_SSLv3__supported->is_value();
case ALT_TLSv1__supported: return field_TLSv1__supported->is_value();
case ALT_TLSv1__1__supported: return field_TLSv1__1__supported->is_value();
case ALT_TLSv1__2__supported: return field_TLSv1__2__supported->is_value();
case ALT_DTLSv1__supported: return field_DTLSv1__supported->is_value();
case ALT_DTLSv1__2__supported: return field_DTLSv1__2__supported->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SSL__protocols::clean_up()
{
switch (union_selection) {
case ALT_SSLv2__supported:
  delete field_SSLv2__supported;
  break;
case ALT_SSLv3__supported:
  delete field_SSLv3__supported;
  break;
case ALT_TLSv1__supported:
  delete field_TLSv1__supported;
  break;
case ALT_TLSv1__1__supported:
  delete field_TLSv1__1__supported;
  break;
case ALT_TLSv1__2__supported:
  delete field_TLSv1__2__supported;
  break;
case ALT_DTLSv1__supported:
  delete field_DTLSv1__supported;
  break;
case ALT_DTLSv1__2__supported:
  delete field_DTLSv1__2__supported;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SSL__protocols::log() const
{
switch (union_selection) {
case ALT_SSLv2__supported:
TTCN_Logger::log_event_str("{ SSLv2_supported := ");
field_SSLv2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_SSLv3__supported:
TTCN_Logger::log_event_str("{ SSLv3_supported := ");
field_SSLv3__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_TLSv1__supported:
TTCN_Logger::log_event_str("{ TLSv1_supported := ");
field_TLSv1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_TLSv1__1__supported:
TTCN_Logger::log_event_str("{ TLSv1_1_supported := ");
field_TLSv1__1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_TLSv1__2__supported:
TTCN_Logger::log_event_str("{ TLSv1_2_supported := ");
field_TLSv1__2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_DTLSv1__supported:
TTCN_Logger::log_event_str("{ DTLSv1_supported := ");
field_DTLSv1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_DTLSv1__2__supported:
TTCN_Logger::log_event_str("{ DTLSv1_2_supported := ");
field_DTLSv1__2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SSL__protocols::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "SSLv2_supported")) {
    SSLv2__supported().set_param(*mp_last);
    if (!SSLv2__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "SSLv3_supported")) {
    SSLv3__supported().set_param(*mp_last);
    if (!SSLv3__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_supported")) {
    TLSv1__supported().set_param(*mp_last);
    if (!TLSv1__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_1_supported")) {
    TLSv1__1__supported().set_param(*mp_last);
    if (!TLSv1__1__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_2_supported")) {
    TLSv1__2__supported().set_param(*mp_last);
    if (!TLSv1__2__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "DTLSv1_supported")) {
    DTLSv1__supported().set_param(*mp_last);
    if (!DTLSv1__supported().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "DTLSv1_2_supported")) {
    DTLSv1__2__supported().set_param(*mp_last);
    if (!DTLSv1__2__supported().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @IPL4asp_Types.SSL_protocols.", mp_last->get_id()->get_name());
}

void SSL__protocols::set_implicit_omit()
{
switch (union_selection) {
case ALT_SSLv2__supported:
field_SSLv2__supported->set_implicit_omit(); break;
case ALT_SSLv3__supported:
field_SSLv3__supported->set_implicit_omit(); break;
case ALT_TLSv1__supported:
field_TLSv1__supported->set_implicit_omit(); break;
case ALT_TLSv1__1__supported:
field_TLSv1__1__supported->set_implicit_omit(); break;
case ALT_TLSv1__2__supported:
field_TLSv1__2__supported->set_implicit_omit(); break;
case ALT_DTLSv1__supported:
field_DTLSv1__supported->set_implicit_omit(); break;
case ALT_DTLSv1__2__supported:
field_DTLSv1__2__supported->set_implicit_omit(); break;
default: break;
}
}

void SSL__protocols::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_SSLv2__supported:
field_SSLv2__supported->encode_text(text_buf);
break;
case ALT_SSLv3__supported:
field_SSLv3__supported->encode_text(text_buf);
break;
case ALT_TLSv1__supported:
field_TLSv1__supported->encode_text(text_buf);
break;
case ALT_TLSv1__1__supported:
field_TLSv1__1__supported->encode_text(text_buf);
break;
case ALT_TLSv1__2__supported:
field_TLSv1__2__supported->encode_text(text_buf);
break;
case ALT_DTLSv1__supported:
field_DTLSv1__supported->encode_text(text_buf);
break;
case ALT_DTLSv1__2__supported:
field_DTLSv1__2__supported->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.SSL_protocols.");
}
}

void SSL__protocols::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_SSLv2__supported:
SSLv2__supported().decode_text(text_buf);
break;
case ALT_SSLv3__supported:
SSLv3__supported().decode_text(text_buf);
break;
case ALT_TLSv1__supported:
TLSv1__supported().decode_text(text_buf);
break;
case ALT_TLSv1__1__supported:
TLSv1__1__supported().decode_text(text_buf);
break;
case ALT_TLSv1__2__supported:
TLSv1__2__supported().decode_text(text_buf);
break;
case ALT_DTLSv1__supported:
DTLSv1__supported().decode_text(text_buf);
break;
case ALT_DTLSv1__2__supported:
DTLSv1__2__supported().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.SSL_protocols.");
}
}

void SSL__protocols_template::copy_value(const SSL__protocols& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
single_value.field_SSLv2__supported = new BOOLEAN_template(other_value.SSLv2__supported());
break;
case SSL__protocols::ALT_SSLv3__supported:
single_value.field_SSLv3__supported = new BOOLEAN_template(other_value.SSLv3__supported());
break;
case SSL__protocols::ALT_TLSv1__supported:
single_value.field_TLSv1__supported = new BOOLEAN_template(other_value.TLSv1__supported());
break;
case SSL__protocols::ALT_TLSv1__1__supported:
single_value.field_TLSv1__1__supported = new BOOLEAN_template(other_value.TLSv1__1__supported());
break;
case SSL__protocols::ALT_TLSv1__2__supported:
single_value.field_TLSv1__2__supported = new BOOLEAN_template(other_value.TLSv1__2__supported());
break;
case SSL__protocols::ALT_DTLSv1__supported:
single_value.field_DTLSv1__supported = new BOOLEAN_template(other_value.DTLSv1__supported());
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
single_value.field_DTLSv1__2__supported = new BOOLEAN_template(other_value.DTLSv1__2__supported());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IPL4asp_Types.SSL_protocols.");
}
set_selection(SPECIFIC_VALUE);
}

void SSL__protocols_template::copy_template(const SSL__protocols_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
single_value.field_SSLv2__supported = new BOOLEAN_template(*other_value.single_value.field_SSLv2__supported);
break;
case SSL__protocols::ALT_SSLv3__supported:
single_value.field_SSLv3__supported = new BOOLEAN_template(*other_value.single_value.field_SSLv3__supported);
break;
case SSL__protocols::ALT_TLSv1__supported:
single_value.field_TLSv1__supported = new BOOLEAN_template(*other_value.single_value.field_TLSv1__supported);
break;
case SSL__protocols::ALT_TLSv1__1__supported:
single_value.field_TLSv1__1__supported = new BOOLEAN_template(*other_value.single_value.field_TLSv1__1__supported);
break;
case SSL__protocols::ALT_TLSv1__2__supported:
single_value.field_TLSv1__2__supported = new BOOLEAN_template(*other_value.single_value.field_TLSv1__2__supported);
break;
case SSL__protocols::ALT_DTLSv1__supported:
single_value.field_DTLSv1__supported = new BOOLEAN_template(*other_value.single_value.field_DTLSv1__supported);
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
single_value.field_DTLSv1__2__supported = new BOOLEAN_template(*other_value.single_value.field_DTLSv1__2__supported);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.SSL_protocols.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SSL__protocols_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IPL4asp_Types.SSL_protocols.");
}
set_selection(other_value);
}

SSL__protocols_template::SSL__protocols_template()
{
}

SSL__protocols_template::SSL__protocols_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SSL__protocols_template::SSL__protocols_template(const SSL__protocols& other_value)
{
copy_value(other_value);
}

SSL__protocols_template::SSL__protocols_template(const OPTIONAL<SSL__protocols>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__protocols&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IPL4asp_Types.SSL_protocols from an unbound optional field.");
}
}

SSL__protocols_template::SSL__protocols_template(const SSL__protocols_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SSL__protocols_template::~SSL__protocols_template()
{
clean_up();
}

void SSL__protocols_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
delete single_value.field_SSLv2__supported;
break;
case SSL__protocols::ALT_SSLv3__supported:
delete single_value.field_SSLv3__supported;
break;
case SSL__protocols::ALT_TLSv1__supported:
delete single_value.field_TLSv1__supported;
break;
case SSL__protocols::ALT_TLSv1__1__supported:
delete single_value.field_TLSv1__1__supported;
break;
case SSL__protocols::ALT_TLSv1__2__supported:
delete single_value.field_TLSv1__2__supported;
break;
case SSL__protocols::ALT_DTLSv1__supported:
delete single_value.field_DTLSv1__supported;
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
delete single_value.field_DTLSv1__2__supported;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SSL__protocols_template& SSL__protocols_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SSL__protocols_template& SSL__protocols_template::operator=(const SSL__protocols& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SSL__protocols_template& SSL__protocols_template::operator=(const OPTIONAL<SSL__protocols>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__protocols&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IPL4asp_Types.SSL_protocols.");
}
return *this;
}

SSL__protocols_template& SSL__protocols_template::operator=(const SSL__protocols_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SSL__protocols_template::match(const SSL__protocols& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SSL__protocols::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SSL__protocols::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SSL__protocols::ALT_SSLv2__supported:
return single_value.field_SSLv2__supported->match(other_value.SSLv2__supported(), legacy);
case SSL__protocols::ALT_SSLv3__supported:
return single_value.field_SSLv3__supported->match(other_value.SSLv3__supported(), legacy);
case SSL__protocols::ALT_TLSv1__supported:
return single_value.field_TLSv1__supported->match(other_value.TLSv1__supported(), legacy);
case SSL__protocols::ALT_TLSv1__1__supported:
return single_value.field_TLSv1__1__supported->match(other_value.TLSv1__1__supported(), legacy);
case SSL__protocols::ALT_TLSv1__2__supported:
return single_value.field_TLSv1__2__supported->match(other_value.TLSv1__2__supported(), legacy);
case SSL__protocols::ALT_DTLSv1__supported:
return single_value.field_DTLSv1__supported->match(other_value.DTLSv1__supported(), legacy);
case SSL__protocols::ALT_DTLSv1__2__supported:
return single_value.field_DTLSv1__2__supported->match(other_value.DTLSv1__2__supported(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.SSL_protocols.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IPL4asp_Types.SSL_protocols.");
}
return FALSE;
}

boolean SSL__protocols_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
return single_value.field_SSLv2__supported->is_value();
case SSL__protocols::ALT_SSLv3__supported:
return single_value.field_SSLv3__supported->is_value();
case SSL__protocols::ALT_TLSv1__supported:
return single_value.field_TLSv1__supported->is_value();
case SSL__protocols::ALT_TLSv1__1__supported:
return single_value.field_TLSv1__1__supported->is_value();
case SSL__protocols::ALT_TLSv1__2__supported:
return single_value.field_TLSv1__2__supported->is_value();
case SSL__protocols::ALT_DTLSv1__supported:
return single_value.field_DTLSv1__supported->is_value();
case SSL__protocols::ALT_DTLSv1__2__supported:
return single_value.field_DTLSv1__2__supported->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.SSL_protocols.");
}
}

SSL__protocols SSL__protocols_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
SSL__protocols ret_val;
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
ret_val.SSLv2__supported() = single_value.field_SSLv2__supported->valueof();
break;
case SSL__protocols::ALT_SSLv3__supported:
ret_val.SSLv3__supported() = single_value.field_SSLv3__supported->valueof();
break;
case SSL__protocols::ALT_TLSv1__supported:
ret_val.TLSv1__supported() = single_value.field_TLSv1__supported->valueof();
break;
case SSL__protocols::ALT_TLSv1__1__supported:
ret_val.TLSv1__1__supported() = single_value.field_TLSv1__1__supported->valueof();
break;
case SSL__protocols::ALT_TLSv1__2__supported:
ret_val.TLSv1__2__supported() = single_value.field_TLSv1__2__supported->valueof();
break;
case SSL__protocols::ALT_DTLSv1__supported:
ret_val.DTLSv1__supported() = single_value.field_DTLSv1__supported->valueof();
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
ret_val.DTLSv1__2__supported() = single_value.field_DTLSv1__2__supported->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.SSL_protocols.");
}
return ret_val;
}

SSL__protocols_template& SSL__protocols_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.SSL_protocols.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.SSL_protocols.");
return value_list.list_value[list_index];
}
void SSL__protocols_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.SSL_protocols.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SSL__protocols_template[list_length];
}

BOOLEAN_template& SSL__protocols_template::SSLv2__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_SSLv2__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_SSLv2__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_SSLv2__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_SSLv2__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_SSLv2__supported;
}

const BOOLEAN_template& SSL__protocols_template::SSLv2__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field SSLv2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_SSLv2__supported) TTCN_error("Accessing non-selected field SSLv2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_SSLv2__supported;
}

BOOLEAN_template& SSL__protocols_template::SSLv3__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_SSLv3__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_SSLv3__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_SSLv3__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_SSLv3__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_SSLv3__supported;
}

const BOOLEAN_template& SSL__protocols_template::SSLv3__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field SSLv3_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_SSLv3__supported) TTCN_error("Accessing non-selected field SSLv3_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_SSLv3__supported;
}

BOOLEAN_template& SSL__protocols_template::TLSv1__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_TLSv1__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_TLSv1__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_TLSv1__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_TLSv1__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_TLSv1__supported;
}

const BOOLEAN_template& SSL__protocols_template::TLSv1__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field TLSv1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_TLSv1__supported) TTCN_error("Accessing non-selected field TLSv1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_TLSv1__supported;
}

BOOLEAN_template& SSL__protocols_template::TLSv1__1__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_TLSv1__1__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_TLSv1__1__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_TLSv1__1__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_TLSv1__1__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_TLSv1__1__supported;
}

const BOOLEAN_template& SSL__protocols_template::TLSv1__1__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field TLSv1_1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_TLSv1__1__supported) TTCN_error("Accessing non-selected field TLSv1_1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_TLSv1__1__supported;
}

BOOLEAN_template& SSL__protocols_template::TLSv1__2__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_TLSv1__2__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_TLSv1__2__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_TLSv1__2__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_TLSv1__2__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_TLSv1__2__supported;
}

const BOOLEAN_template& SSL__protocols_template::TLSv1__2__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field TLSv1_2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_TLSv1__2__supported) TTCN_error("Accessing non-selected field TLSv1_2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_TLSv1__2__supported;
}

BOOLEAN_template& SSL__protocols_template::DTLSv1__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_DTLSv1__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_DTLSv1__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_DTLSv1__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_DTLSv1__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_DTLSv1__supported;
}

const BOOLEAN_template& SSL__protocols_template::DTLSv1__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field DTLSv1_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_DTLSv1__supported) TTCN_error("Accessing non-selected field DTLSv1_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_DTLSv1__supported;
}

BOOLEAN_template& SSL__protocols_template::DTLSv1__2__supported()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SSL__protocols::ALT_DTLSv1__2__supported) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_DTLSv1__2__supported = new BOOLEAN_template(ANY_VALUE);
else single_value.field_DTLSv1__2__supported = new BOOLEAN_template;
single_value.union_selection = SSL__protocols::ALT_DTLSv1__2__supported;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_DTLSv1__2__supported;
}

const BOOLEAN_template& SSL__protocols_template::DTLSv1__2__supported() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field DTLSv1_2_supported in a non-specific template of union type @IPL4asp_Types.SSL_protocols.");
if (single_value.union_selection != SSL__protocols::ALT_DTLSv1__2__supported) TTCN_error("Accessing non-selected field DTLSv1_2_supported in a template of union type @IPL4asp_Types.SSL_protocols.");
return *single_value.field_DTLSv1__2__supported;
}

boolean SSL__protocols_template::ischosen(SSL__protocols::union_selection_type checked_selection) const
{
if (checked_selection == SSL__protocols::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.SSL_protocols.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SSL__protocols::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.SSL_protocols.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.SSL_protocols containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IPL4asp_Types.SSL_protocols, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IPL4asp_Types.SSL_protocols");
}
return FALSE;
}

void SSL__protocols_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
TTCN_Logger::log_event_str("{ SSLv2_supported := ");
single_value.field_SSLv2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_SSLv3__supported:
TTCN_Logger::log_event_str("{ SSLv3_supported := ");
single_value.field_SSLv3__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_TLSv1__supported:
TTCN_Logger::log_event_str("{ TLSv1_supported := ");
single_value.field_TLSv1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_TLSv1__1__supported:
TTCN_Logger::log_event_str("{ TLSv1_1_supported := ");
single_value.field_TLSv1__1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_TLSv1__2__supported:
TTCN_Logger::log_event_str("{ TLSv1_2_supported := ");
single_value.field_TLSv1__2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_DTLSv1__supported:
TTCN_Logger::log_event_str("{ DTLSv1_supported := ");
single_value.field_DTLSv1__supported->log();
TTCN_Logger::log_event_str(" }");
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
TTCN_Logger::log_event_str("{ DTLSv1_2_supported := ");
single_value.field_DTLSv1__2__supported->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SSL__protocols_template::log_match(const SSL__protocols& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".SSLv2_supported");
single_value.field_SSLv2__supported->log_match(match_value.SSLv2__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ SSLv2_supported := ");
single_value.field_SSLv2__supported->log_match(match_value.SSLv2__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_SSLv3__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".SSLv3_supported");
single_value.field_SSLv3__supported->log_match(match_value.SSLv3__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ SSLv3_supported := ");
single_value.field_SSLv3__supported->log_match(match_value.SSLv3__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_TLSv1__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".TLSv1_supported");
single_value.field_TLSv1__supported->log_match(match_value.TLSv1__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ TLSv1_supported := ");
single_value.field_TLSv1__supported->log_match(match_value.TLSv1__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_TLSv1__1__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".TLSv1_1_supported");
single_value.field_TLSv1__1__supported->log_match(match_value.TLSv1__1__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ TLSv1_1_supported := ");
single_value.field_TLSv1__1__supported->log_match(match_value.TLSv1__1__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_TLSv1__2__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".TLSv1_2_supported");
single_value.field_TLSv1__2__supported->log_match(match_value.TLSv1__2__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ TLSv1_2_supported := ");
single_value.field_TLSv1__2__supported->log_match(match_value.TLSv1__2__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_DTLSv1__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".DTLSv1_supported");
single_value.field_DTLSv1__supported->log_match(match_value.DTLSv1__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ DTLSv1_supported := ");
single_value.field_DTLSv1__supported->log_match(match_value.DTLSv1__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".DTLSv1_2_supported");
single_value.field_DTLSv1__2__supported->log_match(match_value.DTLSv1__2__supported(), legacy);
} else {
TTCN_Logger::log_event_str("{ DTLSv1_2_supported := ");
single_value.field_DTLSv1__2__supported->log_match(match_value.DTLSv1__2__supported(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SSL__protocols_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
single_value.field_SSLv2__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_SSLv3__supported:
single_value.field_SSLv3__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__supported:
single_value.field_TLSv1__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__1__supported:
single_value.field_TLSv1__1__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__2__supported:
single_value.field_TLSv1__2__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_DTLSv1__supported:
single_value.field_DTLSv1__supported->encode_text(text_buf);
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
single_value.field_DTLSv1__2__supported->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IPL4asp_Types.SSL_protocols.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.SSL_protocols.");
}
}

void SSL__protocols_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SSL__protocols::UNBOUND_VALUE;
SSL__protocols::union_selection_type new_selection = (SSL__protocols::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SSL__protocols::ALT_SSLv2__supported:
single_value.field_SSLv2__supported = new BOOLEAN_template;
single_value.field_SSLv2__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_SSLv3__supported:
single_value.field_SSLv3__supported = new BOOLEAN_template;
single_value.field_SSLv3__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__supported:
single_value.field_TLSv1__supported = new BOOLEAN_template;
single_value.field_TLSv1__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__1__supported:
single_value.field_TLSv1__1__supported = new BOOLEAN_template;
single_value.field_TLSv1__1__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_TLSv1__2__supported:
single_value.field_TLSv1__2__supported = new BOOLEAN_template;
single_value.field_TLSv1__2__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_DTLSv1__supported:
single_value.field_DTLSv1__supported = new BOOLEAN_template;
single_value.field_DTLSv1__supported->decode_text(text_buf);
break;
case SSL__protocols::ALT_DTLSv1__2__supported:
single_value.field_DTLSv1__2__supported = new BOOLEAN_template;
single_value.field_DTLSv1__2__supported->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IPL4asp_Types.SSL_protocols.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SSL__protocols_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.SSL_protocols.");
}
}

boolean SSL__protocols_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SSL__protocols_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SSL__protocols_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IPL4asp_Types.SSL_protocols'");
    }
    if (strcmp("SSLv2_supported", param_field) == 0) {
      SSLv2__supported().set_param(param);
      return;
    } else if (strcmp("SSLv3_supported", param_field) == 0) {
      SSLv3__supported().set_param(param);
      return;
    } else if (strcmp("TLSv1_supported", param_field) == 0) {
      TLSv1__supported().set_param(param);
      return;
    } else if (strcmp("TLSv1_1_supported", param_field) == 0) {
      TLSv1__1__supported().set_param(param);
      return;
    } else if (strcmp("TLSv1_2_supported", param_field) == 0) {
      TLSv1__2__supported().set_param(param);
      return;
    } else if (strcmp("DTLSv1_supported", param_field) == 0) {
      DTLSv1__supported().set_param(param);
      return;
    } else if (strcmp("DTLSv1_2_supported", param_field) == 0) {
      DTLSv1__2__supported().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IPL4asp_Types.SSL_protocols'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SSL__protocols_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@IPL4asp_Types.SSL_protocols");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "SSLv2_supported")) {
      SSLv2__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "SSLv3_supported")) {
      SSLv3__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_supported")) {
      TLSv1__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_1_supported")) {
      TLSv1__1__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "TLSv1_2_supported")) {
      TLSv1__2__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "DTLSv1_supported")) {
      DTLSv1__supported().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "DTLSv1_2_supported")) {
      DTLSv1__2__supported().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IPL4asp_Types.SSL_protocols.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IPL4asp_Types.SSL_protocols");
  }
  is_ifpresent = param.get_ifpresent();
}

void SSL__protocols_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SSL__protocols::ALT_SSLv2__supported:
single_value.field_SSLv2__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_SSLv3__supported:
single_value.field_SSLv3__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_TLSv1__supported:
single_value.field_TLSv1__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_TLSv1__1__supported:
single_value.field_TLSv1__1__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_TLSv1__2__supported:
single_value.field_TLSv1__2__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_DTLSv1__supported:
single_value.field_DTLSv1__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
case SSL__protocols::ALT_DTLSv1__2__supported:
single_value.field_DTLSv1__2__supported->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.SSL_protocols.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.SSL_protocols");
}


const SSL__protocols SSL__proto__support::UNBOUND_ELEM;
SSL__proto__support::SSL__proto__support()
{
val_ptr = NULL;
}

SSL__proto__support::SSL__proto__support(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

SSL__proto__support::SSL__proto__support(const SSL__proto__support& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.SSL_proto_support.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

SSL__proto__support::~SSL__proto__support()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void SSL__proto__support::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

SSL__proto__support& SSL__proto__support::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

SSL__proto__support& SSL__proto__support::operator=(const SSL__proto__support& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean SSL__proto__support::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
return val_ptr->n_elements == 0 ;
}

boolean SSL__proto__support::operator==(const SSL__proto__support& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

SSL__protocols& SSL__proto__support::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @IPL4asp_Types.SSL_proto_support using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (SSL__protocols**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SSL__protocols(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new SSL__protocols;
}
return *val_ptr->value_elements[index_value];
}

SSL__protocols& SSL__proto__support::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IPL4asp_Types.SSL_proto_support.");
return (*this)[(int)index_value];
}

const SSL__protocols& SSL__proto__support::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (index_value < 0) TTCN_error("Accessing an element of type @IPL4asp_Types.SSL_proto_support using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @IPL4asp_Types.SSL_proto_support: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const SSL__protocols& SSL__proto__support::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IPL4asp_Types.SSL_proto_support.");
return (*this)[(int)index_value];
}

SSL__proto__support SSL__proto__support::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

SSL__proto__support SSL__proto__support::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

SSL__proto__support SSL__proto__support::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

SSL__proto__support SSL__proto__support::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
SSL__proto__support ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new SSL__protocols(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

SSL__proto__support SSL__proto__support::operator+(const SSL__proto__support& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @IPL4asp_Types.SSL_proto_support concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
SSL__proto__support ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SSL__protocols(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new SSL__protocols(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

SSL__proto__support SSL__proto__support::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@IPL4asp_Types.SSL_proto_support","element");
SSL__proto__support ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new SSL__protocols(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

SSL__proto__support SSL__proto__support::replace(int index, int len, const SSL__proto__support& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
check_replace_arguments(val_ptr->n_elements, index, len, "@IPL4asp_Types.SSL_proto_support","element");
SSL__proto__support ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SSL__protocols(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new SSL__protocols(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new SSL__protocols(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

SSL__proto__support SSL__proto__support::replace(int index, int len, const SSL__proto__support_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void SSL__proto__support::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @IPL4asp_Types.SSL_proto_support.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (SSL__protocols**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SSL__protocols(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (SSL__protocols**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @IPL4asp_Types.SSL_proto_support: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (SSL__protocols**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean SSL__proto__support::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int SSL__proto__support::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
return val_ptr->n_elements;
}

int SSL__proto__support::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @IPL4asp_Types.SSL_proto_support.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void SSL__proto__support::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void SSL__proto__support::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@IPL4asp_Types.SSL_proto_support");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@IPL4asp_Types.SSL_proto_support");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void SSL__proto__support::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void SSL__proto__support::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @IPL4asp_Types.SSL_proto_support.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void SSL__proto__support::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @IPL4asp_Types.SSL_proto_support.");
val_ptr->value_elements = (SSL__protocols**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new SSL__protocols;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void SSL__proto__support_template::copy_value(const SSL__proto__support& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @IPL4asp_Types.SSL_proto_support with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (SSL__protocols_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new SSL__protocols_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new SSL__protocols_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void SSL__proto__support_template::copy_template(const SSL__proto__support_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (SSL__protocols_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new SSL__protocols_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new SSL__protocols_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SSL__proto__support_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.");
break;
}
set_selection(other_value);
}

boolean SSL__proto__support_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SSL__proto__support_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const SSL__proto__support*)value_ptr)[value_index], legacy);
else return ((const SSL__proto__support_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

SSL__proto__support_template::SSL__proto__support_template()
{
}

SSL__proto__support_template::SSL__proto__support_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

SSL__proto__support_template::SSL__proto__support_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

SSL__proto__support_template::SSL__proto__support_template(const SSL__proto__support& other_value)
{
copy_value(other_value);
}

SSL__proto__support_template::SSL__proto__support_template(const OPTIONAL<SSL__proto__support>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__proto__support&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.SSL_proto_support from an unbound optional field.");
}
}

SSL__proto__support_template::SSL__proto__support_template(const SSL__proto__support_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

SSL__proto__support_template::~SSL__proto__support_template()
{
clean_up();
}

void SSL__proto__support_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SSL__proto__support_template& SSL__proto__support_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SSL__proto__support_template& SSL__proto__support_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

SSL__proto__support_template& SSL__proto__support_template::operator=(const SSL__proto__support& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SSL__proto__support_template& SSL__proto__support_template::operator=(const OPTIONAL<SSL__proto__support>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__proto__support&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SSL_proto_support.");
}
return *this;
}

SSL__proto__support_template& SSL__proto__support_template::operator=(const SSL__proto__support_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

SSL__protocols_template& SSL__proto__support_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IPL4asp_Types.SSL_proto_support using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @IPL4asp_Types.SSL_proto_support.");
    break;
}
return *single_value.value_elements[index_value];
}

SSL__protocols_template& SSL__proto__support_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.SSL_proto_support.");
return (*this)[(int)index_value];
}

const SSL__protocols_template& SSL__proto__support_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IPL4asp_Types.SSL_proto_support using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @IPL4asp_Types.SSL_proto_support.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @IPL4asp_Types.SSL_proto_support: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const SSL__protocols_template& SSL__proto__support_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.SSL_proto_support.");
return (*this)[(int)index_value];
}

void SSL__proto__support_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @IPL4asp_Types.SSL_proto_support.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (SSL__protocols_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SSL__protocols_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SSL__protocols_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (SSL__protocols_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int SSL__proto__support_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int SSL__proto__support_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.SSL_proto_support containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @IPL4asp_Types.SSL_proto_support");
}

boolean SSL__proto__support_template::match(const SSL__proto__support& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.");
}
return FALSE;
}

boolean SSL__proto__support_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

SSL__proto__support SSL__proto__support_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SSL_proto_support.");
SSL__proto__support ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

SSL__proto__support SSL__proto__support_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

SSL__proto__support SSL__proto__support_template::replace(int index, int len, const SSL__proto__support_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

SSL__proto__support SSL__proto__support_template::replace(int index, int len, const SSL__proto__support& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void SSL__proto__support_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new SSL__proto__support_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.SSL_proto_support.");
}
set_selection(template_type);
}

SSL__proto__support_template& SSL__proto__support_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @IPL4asp_Types.SSL_proto_support.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @IPL4asp_Types.SSL_proto_support.");
return value_list.list_value[list_index];
}

void SSL__proto__support_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void SSL__proto__support_template::log_match(const SSL__proto__support& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SSL__proto__support_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SSL_proto_support.");
}
}

void SSL__proto__support_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @IPL4asp_Types.SSL_proto_support.");
single_value.value_elements = (SSL__protocols_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new SSL__protocols_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SSL__proto__support_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @IPL4asp_Types.SSL_proto_support.");
}
}

boolean SSL__proto__support_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SSL__proto__support_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SSL__proto__support_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SSL__proto__support_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@IPL4asp_Types.SSL_proto_support");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void SSL__proto__support_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_proto_support");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.SSL_proto_support");
}

boolean SSL__proto__support_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
SSL__cert__options::SSL__cert__options()
{
}

SSL__cert__options::SSL__cert__options(const OPTIONAL<CHARSTRING>& par_ssl__key__file,
    const OPTIONAL<CHARSTRING>& par_ssl__certificate__file,
    const OPTIONAL<CHARSTRING>& par_ssl__trustedCAlist__file,
    const OPTIONAL<CHARSTRING>& par_ssl__cipher__list,
    const OPTIONAL<CHARSTRING>& par_ssl__password)
  :   field_ssl__key__file(par_ssl__key__file),
  field_ssl__certificate__file(par_ssl__certificate__file),
  field_ssl__trustedCAlist__file(par_ssl__trustedCAlist__file),
  field_ssl__cipher__list(par_ssl__cipher__list),
  field_ssl__password(par_ssl__password)
{
}

SSL__cert__options::SSL__cert__options(const SSL__cert__options& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.SSL_cert_options.");
if (other_value.ssl__key__file().is_bound()) field_ssl__key__file = other_value.ssl__key__file();
else field_ssl__key__file.clean_up();
if (other_value.ssl__certificate__file().is_bound()) field_ssl__certificate__file = other_value.ssl__certificate__file();
else field_ssl__certificate__file.clean_up();
if (other_value.ssl__trustedCAlist__file().is_bound()) field_ssl__trustedCAlist__file = other_value.ssl__trustedCAlist__file();
else field_ssl__trustedCAlist__file.clean_up();
if (other_value.ssl__cipher__list().is_bound()) field_ssl__cipher__list = other_value.ssl__cipher__list();
else field_ssl__cipher__list.clean_up();
if (other_value.ssl__password().is_bound()) field_ssl__password = other_value.ssl__password();
else field_ssl__password.clean_up();
}

void SSL__cert__options::clean_up()
{
field_ssl__key__file.clean_up();
field_ssl__certificate__file.clean_up();
field_ssl__trustedCAlist__file.clean_up();
field_ssl__cipher__list.clean_up();
field_ssl__password.clean_up();
}

SSL__cert__options& SSL__cert__options::operator=(const SSL__cert__options& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.SSL_cert_options.");
  if (other_value.ssl__key__file().is_bound()) field_ssl__key__file = other_value.ssl__key__file();
  else field_ssl__key__file.clean_up();
  if (other_value.ssl__certificate__file().is_bound()) field_ssl__certificate__file = other_value.ssl__certificate__file();
  else field_ssl__certificate__file.clean_up();
  if (other_value.ssl__trustedCAlist__file().is_bound()) field_ssl__trustedCAlist__file = other_value.ssl__trustedCAlist__file();
  else field_ssl__trustedCAlist__file.clean_up();
  if (other_value.ssl__cipher__list().is_bound()) field_ssl__cipher__list = other_value.ssl__cipher__list();
  else field_ssl__cipher__list.clean_up();
  if (other_value.ssl__password().is_bound()) field_ssl__password = other_value.ssl__password();
  else field_ssl__password.clean_up();
}
return *this;
}

boolean SSL__cert__options::operator==(const SSL__cert__options& other_value) const
{
return field_ssl__key__file==other_value.field_ssl__key__file
  && field_ssl__certificate__file==other_value.field_ssl__certificate__file
  && field_ssl__trustedCAlist__file==other_value.field_ssl__trustedCAlist__file
  && field_ssl__cipher__list==other_value.field_ssl__cipher__list
  && field_ssl__password==other_value.field_ssl__password;
}

boolean SSL__cert__options::is_bound() const
{
if(OPTIONAL_OMIT == field_ssl__key__file.get_selection() || field_ssl__key__file.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ssl__certificate__file.get_selection() || field_ssl__certificate__file.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ssl__trustedCAlist__file.get_selection() || field_ssl__trustedCAlist__file.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ssl__cipher__list.get_selection() || field_ssl__cipher__list.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ssl__password.get_selection() || field_ssl__password.is_bound()) return TRUE;
return FALSE;
}
boolean SSL__cert__options::is_value() const
{
if(OPTIONAL_OMIT != field_ssl__key__file.get_selection() && !field_ssl__key__file.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ssl__certificate__file.get_selection() && !field_ssl__certificate__file.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ssl__trustedCAlist__file.get_selection() && !field_ssl__trustedCAlist__file.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ssl__cipher__list.get_selection() && !field_ssl__cipher__list.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ssl__password.get_selection() && !field_ssl__password.is_value()) return FALSE;
return TRUE;
}
int SSL__cert__options::size_of() const
{
  int ret_val = 0;
  if (field_ssl__key__file.ispresent()) ret_val++;
  if (field_ssl__certificate__file.ispresent()) ret_val++;
  if (field_ssl__trustedCAlist__file.ispresent()) ret_val++;
  if (field_ssl__cipher__list.ispresent()) ret_val++;
  if (field_ssl__password.ispresent()) ret_val++;
  return ret_val;
}

void SSL__cert__options::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ssl_key_file := ");
field_ssl__key__file.log();
TTCN_Logger::log_event_str(", ssl_certificate_file := ");
field_ssl__certificate__file.log();
TTCN_Logger::log_event_str(", ssl_trustedCAlist_file := ");
field_ssl__trustedCAlist__file.log();
TTCN_Logger::log_event_str(", ssl_cipher_list := ");
field_ssl__cipher__list.log();
TTCN_Logger::log_event_str(", ssl_password := ");
field_ssl__password.log();
TTCN_Logger::log_event_str(" }");
}

void SSL__cert__options::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.SSL_cert_options has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ssl__key__file().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ssl__certificate__file().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ssl__trustedCAlist__file().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) ssl__cipher__list().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) ssl__password().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_key_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__key__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_certificate_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__certificate__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_trustedCAlist_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__trustedCAlist__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_cipher_list")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__cipher__list().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_password")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__password().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.SSL_cert_options: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.SSL_cert_options");
  }
}

void SSL__cert__options::set_implicit_omit()
{
if (!ssl__key__file().is_bound()) ssl__key__file() = OMIT_VALUE;
else ssl__key__file().set_implicit_omit();
if (!ssl__certificate__file().is_bound()) ssl__certificate__file() = OMIT_VALUE;
else ssl__certificate__file().set_implicit_omit();
if (!ssl__trustedCAlist__file().is_bound()) ssl__trustedCAlist__file() = OMIT_VALUE;
else ssl__trustedCAlist__file().set_implicit_omit();
if (!ssl__cipher__list().is_bound()) ssl__cipher__list() = OMIT_VALUE;
else ssl__cipher__list().set_implicit_omit();
if (!ssl__password().is_bound()) ssl__password() = OMIT_VALUE;
else ssl__password().set_implicit_omit();
}

void SSL__cert__options::encode_text(Text_Buf& text_buf) const
{
field_ssl__key__file.encode_text(text_buf);
field_ssl__certificate__file.encode_text(text_buf);
field_ssl__trustedCAlist__file.encode_text(text_buf);
field_ssl__cipher__list.encode_text(text_buf);
field_ssl__password.encode_text(text_buf);
}

void SSL__cert__options::decode_text(Text_Buf& text_buf)
{
field_ssl__key__file.decode_text(text_buf);
field_ssl__certificate__file.decode_text(text_buf);
field_ssl__trustedCAlist__file.decode_text(text_buf);
field_ssl__cipher__list.decode_text(text_buf);
field_ssl__password.decode_text(text_buf);
}

struct SSL__cert__options_template::single_value_struct {
CHARSTRING_template field_ssl__key__file;
CHARSTRING_template field_ssl__certificate__file;
CHARSTRING_template field_ssl__trustedCAlist__file;
CHARSTRING_template field_ssl__cipher__list;
CHARSTRING_template field_ssl__password;
};

void SSL__cert__options_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ssl__key__file = ANY_OR_OMIT;
single_value->field_ssl__certificate__file = ANY_OR_OMIT;
single_value->field_ssl__trustedCAlist__file = ANY_OR_OMIT;
single_value->field_ssl__cipher__list = ANY_OR_OMIT;
single_value->field_ssl__password = ANY_OR_OMIT;
}
}
}

void SSL__cert__options_template::copy_value(const SSL__cert__options& other_value)
{
single_value = new single_value_struct;
if (other_value.ssl__key__file().is_bound()) {
  if (other_value.ssl__key__file().ispresent()) single_value->field_ssl__key__file = other_value.ssl__key__file()();
  else single_value->field_ssl__key__file = OMIT_VALUE;
} else {
  single_value->field_ssl__key__file.clean_up();
}
if (other_value.ssl__certificate__file().is_bound()) {
  if (other_value.ssl__certificate__file().ispresent()) single_value->field_ssl__certificate__file = other_value.ssl__certificate__file()();
  else single_value->field_ssl__certificate__file = OMIT_VALUE;
} else {
  single_value->field_ssl__certificate__file.clean_up();
}
if (other_value.ssl__trustedCAlist__file().is_bound()) {
  if (other_value.ssl__trustedCAlist__file().ispresent()) single_value->field_ssl__trustedCAlist__file = other_value.ssl__trustedCAlist__file()();
  else single_value->field_ssl__trustedCAlist__file = OMIT_VALUE;
} else {
  single_value->field_ssl__trustedCAlist__file.clean_up();
}
if (other_value.ssl__cipher__list().is_bound()) {
  if (other_value.ssl__cipher__list().ispresent()) single_value->field_ssl__cipher__list = other_value.ssl__cipher__list()();
  else single_value->field_ssl__cipher__list = OMIT_VALUE;
} else {
  single_value->field_ssl__cipher__list.clean_up();
}
if (other_value.ssl__password().is_bound()) {
  if (other_value.ssl__password().ispresent()) single_value->field_ssl__password = other_value.ssl__password()();
  else single_value->field_ssl__password = OMIT_VALUE;
} else {
  single_value->field_ssl__password.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SSL__cert__options_template::copy_template(const SSL__cert__options_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ssl__key__file().get_selection()) {
single_value->field_ssl__key__file = other_value.ssl__key__file();
} else {
single_value->field_ssl__key__file.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ssl__certificate__file().get_selection()) {
single_value->field_ssl__certificate__file = other_value.ssl__certificate__file();
} else {
single_value->field_ssl__certificate__file.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ssl__trustedCAlist__file().get_selection()) {
single_value->field_ssl__trustedCAlist__file = other_value.ssl__trustedCAlist__file();
} else {
single_value->field_ssl__trustedCAlist__file.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ssl__cipher__list().get_selection()) {
single_value->field_ssl__cipher__list = other_value.ssl__cipher__list();
} else {
single_value->field_ssl__cipher__list.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ssl__password().get_selection()) {
single_value->field_ssl__password = other_value.ssl__password();
} else {
single_value->field_ssl__password.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SSL__cert__options_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
break;
}
set_selection(other_value);
}

SSL__cert__options_template::SSL__cert__options_template()
{
}

SSL__cert__options_template::SSL__cert__options_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SSL__cert__options_template::SSL__cert__options_template(const SSL__cert__options& other_value)
{
copy_value(other_value);
}

SSL__cert__options_template::SSL__cert__options_template(const OPTIONAL<SSL__cert__options>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__cert__options&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.SSL_cert_options from an unbound optional field.");
}
}

SSL__cert__options_template::SSL__cert__options_template(const SSL__cert__options_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SSL__cert__options_template::~SSL__cert__options_template()
{
clean_up();
}

SSL__cert__options_template& SSL__cert__options_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SSL__cert__options_template& SSL__cert__options_template::operator=(const SSL__cert__options& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SSL__cert__options_template& SSL__cert__options_template::operator=(const OPTIONAL<SSL__cert__options>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SSL__cert__options&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.SSL_cert_options.");
}
return *this;
}

SSL__cert__options_template& SSL__cert__options_template::operator=(const SSL__cert__options_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SSL__cert__options_template::match(const SSL__cert__options& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ssl__key__file().is_bound()) return FALSE;
if((other_value.ssl__key__file().ispresent() ? !single_value->field_ssl__key__file.match((const CHARSTRING&)other_value.ssl__key__file(), legacy) : !single_value->field_ssl__key__file.match_omit(legacy)))return FALSE;
if(!other_value.ssl__certificate__file().is_bound()) return FALSE;
if((other_value.ssl__certificate__file().ispresent() ? !single_value->field_ssl__certificate__file.match((const CHARSTRING&)other_value.ssl__certificate__file(), legacy) : !single_value->field_ssl__certificate__file.match_omit(legacy)))return FALSE;
if(!other_value.ssl__trustedCAlist__file().is_bound()) return FALSE;
if((other_value.ssl__trustedCAlist__file().ispresent() ? !single_value->field_ssl__trustedCAlist__file.match((const CHARSTRING&)other_value.ssl__trustedCAlist__file(), legacy) : !single_value->field_ssl__trustedCAlist__file.match_omit(legacy)))return FALSE;
if(!other_value.ssl__cipher__list().is_bound()) return FALSE;
if((other_value.ssl__cipher__list().ispresent() ? !single_value->field_ssl__cipher__list.match((const CHARSTRING&)other_value.ssl__cipher__list(), legacy) : !single_value->field_ssl__cipher__list.match_omit(legacy)))return FALSE;
if(!other_value.ssl__password().is_bound()) return FALSE;
if((other_value.ssl__password().ispresent() ? !single_value->field_ssl__password.match((const CHARSTRING&)other_value.ssl__password(), legacy) : !single_value->field_ssl__password.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
}
return FALSE;
}

boolean SSL__cert__options_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ssl__key__file.is_omit() || single_value->field_ssl__key__file.is_bound()) return TRUE;
if (single_value->field_ssl__certificate__file.is_omit() || single_value->field_ssl__certificate__file.is_bound()) return TRUE;
if (single_value->field_ssl__trustedCAlist__file.is_omit() || single_value->field_ssl__trustedCAlist__file.is_bound()) return TRUE;
if (single_value->field_ssl__cipher__list.is_omit() || single_value->field_ssl__cipher__list.is_bound()) return TRUE;
if (single_value->field_ssl__password.is_omit() || single_value->field_ssl__password.is_bound()) return TRUE;
return FALSE;
}

boolean SSL__cert__options_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ssl__key__file.is_omit() && !single_value->field_ssl__key__file.is_value()) return FALSE;
if (!single_value->field_ssl__certificate__file.is_omit() && !single_value->field_ssl__certificate__file.is_value()) return FALSE;
if (!single_value->field_ssl__trustedCAlist__file.is_omit() && !single_value->field_ssl__trustedCAlist__file.is_value()) return FALSE;
if (!single_value->field_ssl__cipher__list.is_omit() && !single_value->field_ssl__cipher__list.is_value()) return FALSE;
if (!single_value->field_ssl__password.is_omit() && !single_value->field_ssl__password.is_value()) return FALSE;
return TRUE;
}

void SSL__cert__options_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SSL__cert__options SSL__cert__options_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
SSL__cert__options ret_val;
if (single_value->field_ssl__key__file.is_omit()) ret_val.ssl__key__file() = OMIT_VALUE;
else if (single_value->field_ssl__key__file.is_bound()) {
ret_val.ssl__key__file() = single_value->field_ssl__key__file.valueof();
}
if (single_value->field_ssl__certificate__file.is_omit()) ret_val.ssl__certificate__file() = OMIT_VALUE;
else if (single_value->field_ssl__certificate__file.is_bound()) {
ret_val.ssl__certificate__file() = single_value->field_ssl__certificate__file.valueof();
}
if (single_value->field_ssl__trustedCAlist__file.is_omit()) ret_val.ssl__trustedCAlist__file() = OMIT_VALUE;
else if (single_value->field_ssl__trustedCAlist__file.is_bound()) {
ret_val.ssl__trustedCAlist__file() = single_value->field_ssl__trustedCAlist__file.valueof();
}
if (single_value->field_ssl__cipher__list.is_omit()) ret_val.ssl__cipher__list() = OMIT_VALUE;
else if (single_value->field_ssl__cipher__list.is_bound()) {
ret_val.ssl__cipher__list() = single_value->field_ssl__cipher__list.valueof();
}
if (single_value->field_ssl__password.is_omit()) ret_val.ssl__password() = OMIT_VALUE;
else if (single_value->field_ssl__password.is_bound()) {
ret_val.ssl__password() = single_value->field_ssl__password.valueof();
}
return ret_val;
}

void SSL__cert__options_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.SSL_cert_options.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SSL__cert__options_template[list_length];
}

SSL__cert__options_template& SSL__cert__options_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.SSL_cert_options.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.SSL_cert_options.");
return value_list.list_value[list_index];
}

CHARSTRING_template& SSL__cert__options_template::ssl__key__file()
{
set_specific();
return single_value->field_ssl__key__file;
}

const CHARSTRING_template& SSL__cert__options_template::ssl__key__file() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssl_key_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
return single_value->field_ssl__key__file;
}

CHARSTRING_template& SSL__cert__options_template::ssl__certificate__file()
{
set_specific();
return single_value->field_ssl__certificate__file;
}

const CHARSTRING_template& SSL__cert__options_template::ssl__certificate__file() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssl_certificate_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
return single_value->field_ssl__certificate__file;
}

CHARSTRING_template& SSL__cert__options_template::ssl__trustedCAlist__file()
{
set_specific();
return single_value->field_ssl__trustedCAlist__file;
}

const CHARSTRING_template& SSL__cert__options_template::ssl__trustedCAlist__file() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssl_trustedCAlist_file of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
return single_value->field_ssl__trustedCAlist__file;
}

CHARSTRING_template& SSL__cert__options_template::ssl__cipher__list()
{
set_specific();
return single_value->field_ssl__cipher__list;
}

const CHARSTRING_template& SSL__cert__options_template::ssl__cipher__list() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssl_cipher_list of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
return single_value->field_ssl__cipher__list;
}

CHARSTRING_template& SSL__cert__options_template::ssl__password()
{
set_specific();
return single_value->field_ssl__password;
}

const CHARSTRING_template& SSL__cert__options_template::ssl__password() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ssl_password of a non-specific template of type @IPL4asp_Types.SSL_cert_options.");
return single_value->field_ssl__password;
}

int SSL__cert__options_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_ssl__key__file.is_present()) ret_val++;
      if (single_value->field_ssl__certificate__file.is_present()) ret_val++;
      if (single_value->field_ssl__trustedCAlist__file.is_present()) ret_val++;
      if (single_value->field_ssl__cipher__list.is_present()) ret_val++;
      if (single_value->field_ssl__password.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.SSL_cert_options containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
  }
  return 0;
}

void SSL__cert__options_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ssl_key_file := ");
single_value->field_ssl__key__file.log();
TTCN_Logger::log_event_str(", ssl_certificate_file := ");
single_value->field_ssl__certificate__file.log();
TTCN_Logger::log_event_str(", ssl_trustedCAlist_file := ");
single_value->field_ssl__trustedCAlist__file.log();
TTCN_Logger::log_event_str(", ssl_cipher_list := ");
single_value->field_ssl__cipher__list.log();
TTCN_Logger::log_event_str(", ssl_password := ");
single_value->field_ssl__password.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SSL__cert__options_template::log_match(const SSL__cert__options& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.ssl__key__file().ispresent()){
if(!single_value->field_ssl__key__file.match(match_value.ssl__key__file(), legacy)){
TTCN_Logger::log_logmatch_info(".ssl_key_file");
single_value->field_ssl__key__file.log_match(match_value.ssl__key__file(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssl__key__file.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssl_key_file := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssl__key__file.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ssl__certificate__file().ispresent()){
if(!single_value->field_ssl__certificate__file.match(match_value.ssl__certificate__file(), legacy)){
TTCN_Logger::log_logmatch_info(".ssl_certificate_file");
single_value->field_ssl__certificate__file.log_match(match_value.ssl__certificate__file(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssl__certificate__file.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssl_certificate_file := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssl__certificate__file.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ssl__trustedCAlist__file().ispresent()){
if(!single_value->field_ssl__trustedCAlist__file.match(match_value.ssl__trustedCAlist__file(), legacy)){
TTCN_Logger::log_logmatch_info(".ssl_trustedCAlist_file");
single_value->field_ssl__trustedCAlist__file.log_match(match_value.ssl__trustedCAlist__file(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssl__trustedCAlist__file.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssl_trustedCAlist_file := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssl__trustedCAlist__file.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ssl__cipher__list().ispresent()){
if(!single_value->field_ssl__cipher__list.match(match_value.ssl__cipher__list(), legacy)){
TTCN_Logger::log_logmatch_info(".ssl_cipher_list");
single_value->field_ssl__cipher__list.log_match(match_value.ssl__cipher__list(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssl__cipher__list.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssl_cipher_list := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssl__cipher__list.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ssl__password().ispresent()){
if(!single_value->field_ssl__password.match(match_value.ssl__password(), legacy)){
TTCN_Logger::log_logmatch_info(".ssl_password");
single_value->field_ssl__password.log_match(match_value.ssl__password(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ssl__password.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ssl_password := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ssl__password.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ssl_key_file := ");
if (match_value.ssl__key__file().ispresent()) single_value->field_ssl__key__file.log_match(match_value.ssl__key__file(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssl__key__file.log();
if (single_value->field_ssl__key__file.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ssl_certificate_file := ");
if (match_value.ssl__certificate__file().ispresent()) single_value->field_ssl__certificate__file.log_match(match_value.ssl__certificate__file(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssl__certificate__file.log();
if (single_value->field_ssl__certificate__file.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ssl_trustedCAlist_file := ");
if (match_value.ssl__trustedCAlist__file().ispresent()) single_value->field_ssl__trustedCAlist__file.log_match(match_value.ssl__trustedCAlist__file(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssl__trustedCAlist__file.log();
if (single_value->field_ssl__trustedCAlist__file.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ssl_cipher_list := ");
if (match_value.ssl__cipher__list().ispresent()) single_value->field_ssl__cipher__list.log_match(match_value.ssl__cipher__list(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssl__cipher__list.log();
if (single_value->field_ssl__cipher__list.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ssl_password := ");
if (match_value.ssl__password().ispresent()) single_value->field_ssl__password.log_match(match_value.ssl__password(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ssl__password.log();
if (single_value->field_ssl__password.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SSL__cert__options_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ssl__key__file.encode_text(text_buf);
single_value->field_ssl__certificate__file.encode_text(text_buf);
single_value->field_ssl__trustedCAlist__file.encode_text(text_buf);
single_value->field_ssl__cipher__list.encode_text(text_buf);
single_value->field_ssl__password.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.SSL_cert_options.");
}
}

void SSL__cert__options_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ssl__key__file.decode_text(text_buf);
single_value->field_ssl__certificate__file.decode_text(text_buf);
single_value->field_ssl__trustedCAlist__file.decode_text(text_buf);
single_value->field_ssl__cipher__list.decode_text(text_buf);
single_value->field_ssl__password.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SSL__cert__options_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.SSL_cert_options.");
}
}

void SSL__cert__options_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SSL__cert__options_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.SSL_cert_options has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ssl__key__file().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ssl__certificate__file().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ssl__trustedCAlist__file().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) ssl__cipher__list().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) ssl__password().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_key_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__key__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_certificate_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__certificate__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_trustedCAlist_file")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__trustedCAlist__file().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_cipher_list")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__cipher__list().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ssl_password")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ssl__password().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.SSL_cert_options: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.SSL_cert_options");
  }
  is_ifpresent = param.get_ifpresent();
}

void SSL__cert__options_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ssl__key__file.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
single_value->field_ssl__certificate__file.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
single_value->field_ssl__trustedCAlist__file.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
single_value->field_ssl__cipher__list.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
single_value->field_ssl__password.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.SSL_cert_options");
}

boolean SSL__cert__options_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SSL__cert__options_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Option::copy_value(const Option& other_value)
{
switch (other_value.union_selection) {
case ALT_reuseAddress:
field_reuseAddress = new ReuseAddress(*other_value.field_reuseAddress);
break;
case ALT_tcpKeepAlive:
field_tcpKeepAlive = new TcpKeepAlive(*other_value.field_tcpKeepAlive);
break;
case ALT_sctpEventHandle:
field_sctpEventHandle = new SctpEventHandle(*other_value.field_sctpEventHandle);
break;
case ALT_sslKeepAlive:
field_sslKeepAlive = new TcpKeepAlive(*other_value.field_sslKeepAlive);
break;
case ALT_sctpAdditionalLocalAddresses:
field_sctpAdditionalLocalAddresses = new HostList(*other_value.field_sctpAdditionalLocalAddresses);
break;
case ALT_sctpEINConfigGroup:
field_sctpEINConfigGroup = new INTEGER(*other_value.field_sctpEINConfigGroup);
break;
case ALT_solinger:
field_solinger = new Linger__opt(*other_value.field_solinger);
break;
case ALT_ssl__support:
field_ssl__support = new SSL__proto__support(*other_value.field_ssl__support);
break;
case ALT_no__delay:
field_no__delay = new BOOLEAN(*other_value.field_no__delay);
break;
case ALT_dtlsSrtpProfiles:
field_dtlsSrtpProfiles = new CHARSTRING(*other_value.field_dtlsSrtpProfiles);
break;
case ALT_cert__options:
field_cert__options = new SSL__cert__options(*other_value.field_cert__options);
break;
case ALT_freebind:
field_freebind = new BOOLEAN(*other_value.field_freebind);
break;
case ALT_alpn__list:
field_alpn__list = new Option_alpn__list(*other_value.field_alpn__list);
break;
case ALT_tls__hostname:
field_tls__hostname = new CHARSTRING(*other_value.field_tls__hostname);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IPL4asp_Types.Option.");
}
union_selection = other_value.union_selection;
}

Option::Option()
{
union_selection = UNBOUND_VALUE;
}

Option::Option(const Option& other_value)
: Base_Type(){
copy_value(other_value);
}

Option::~Option()
{
clean_up();
}

Option& Option::operator=(const Option& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean Option::operator==(const Option& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IPL4asp_Types.Option.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IPL4asp_Types.Option.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_reuseAddress:
return *field_reuseAddress == *other_value.field_reuseAddress;
case ALT_tcpKeepAlive:
return *field_tcpKeepAlive == *other_value.field_tcpKeepAlive;
case ALT_sctpEventHandle:
return *field_sctpEventHandle == *other_value.field_sctpEventHandle;
case ALT_sslKeepAlive:
return *field_sslKeepAlive == *other_value.field_sslKeepAlive;
case ALT_sctpAdditionalLocalAddresses:
return *field_sctpAdditionalLocalAddresses == *other_value.field_sctpAdditionalLocalAddresses;
case ALT_sctpEINConfigGroup:
return *field_sctpEINConfigGroup == *other_value.field_sctpEINConfigGroup;
case ALT_solinger:
return *field_solinger == *other_value.field_solinger;
case ALT_ssl__support:
return *field_ssl__support == *other_value.field_ssl__support;
case ALT_no__delay:
return *field_no__delay == *other_value.field_no__delay;
case ALT_dtlsSrtpProfiles:
return *field_dtlsSrtpProfiles == *other_value.field_dtlsSrtpProfiles;
case ALT_cert__options:
return *field_cert__options == *other_value.field_cert__options;
case ALT_freebind:
return *field_freebind == *other_value.field_freebind;
case ALT_alpn__list:
return *field_alpn__list == *other_value.field_alpn__list;
case ALT_tls__hostname:
return *field_tls__hostname == *other_value.field_tls__hostname;
default:
return FALSE;
}
}

ReuseAddress& Option::reuseAddress()
{
if (union_selection != ALT_reuseAddress) {
clean_up();
field_reuseAddress = new ReuseAddress;
union_selection = ALT_reuseAddress;
}
return *field_reuseAddress;
}

const ReuseAddress& Option::reuseAddress() const
{
if (union_selection != ALT_reuseAddress) TTCN_error("Using non-selected field reuseAddress in a value of union type @IPL4asp_Types.Option.");
return *field_reuseAddress;
}

TcpKeepAlive& Option::tcpKeepAlive()
{
if (union_selection != ALT_tcpKeepAlive) {
clean_up();
field_tcpKeepAlive = new TcpKeepAlive;
union_selection = ALT_tcpKeepAlive;
}
return *field_tcpKeepAlive;
}

const TcpKeepAlive& Option::tcpKeepAlive() const
{
if (union_selection != ALT_tcpKeepAlive) TTCN_error("Using non-selected field tcpKeepAlive in a value of union type @IPL4asp_Types.Option.");
return *field_tcpKeepAlive;
}

SctpEventHandle& Option::sctpEventHandle()
{
if (union_selection != ALT_sctpEventHandle) {
clean_up();
field_sctpEventHandle = new SctpEventHandle;
union_selection = ALT_sctpEventHandle;
}
return *field_sctpEventHandle;
}

const SctpEventHandle& Option::sctpEventHandle() const
{
if (union_selection != ALT_sctpEventHandle) TTCN_error("Using non-selected field sctpEventHandle in a value of union type @IPL4asp_Types.Option.");
return *field_sctpEventHandle;
}

TcpKeepAlive& Option::sslKeepAlive()
{
if (union_selection != ALT_sslKeepAlive) {
clean_up();
field_sslKeepAlive = new TcpKeepAlive;
union_selection = ALT_sslKeepAlive;
}
return *field_sslKeepAlive;
}

const TcpKeepAlive& Option::sslKeepAlive() const
{
if (union_selection != ALT_sslKeepAlive) TTCN_error("Using non-selected field sslKeepAlive in a value of union type @IPL4asp_Types.Option.");
return *field_sslKeepAlive;
}

HostList& Option::sctpAdditionalLocalAddresses()
{
if (union_selection != ALT_sctpAdditionalLocalAddresses) {
clean_up();
field_sctpAdditionalLocalAddresses = new HostList;
union_selection = ALT_sctpAdditionalLocalAddresses;
}
return *field_sctpAdditionalLocalAddresses;
}

const HostList& Option::sctpAdditionalLocalAddresses() const
{
if (union_selection != ALT_sctpAdditionalLocalAddresses) TTCN_error("Using non-selected field sctpAdditionalLocalAddresses in a value of union type @IPL4asp_Types.Option.");
return *field_sctpAdditionalLocalAddresses;
}

INTEGER& Option::sctpEINConfigGroup()
{
if (union_selection != ALT_sctpEINConfigGroup) {
clean_up();
field_sctpEINConfigGroup = new INTEGER;
union_selection = ALT_sctpEINConfigGroup;
}
return *field_sctpEINConfigGroup;
}

const INTEGER& Option::sctpEINConfigGroup() const
{
if (union_selection != ALT_sctpEINConfigGroup) TTCN_error("Using non-selected field sctpEINConfigGroup in a value of union type @IPL4asp_Types.Option.");
return *field_sctpEINConfigGroup;
}

Linger__opt& Option::solinger()
{
if (union_selection != ALT_solinger) {
clean_up();
field_solinger = new Linger__opt;
union_selection = ALT_solinger;
}
return *field_solinger;
}

const Linger__opt& Option::solinger() const
{
if (union_selection != ALT_solinger) TTCN_error("Using non-selected field solinger in a value of union type @IPL4asp_Types.Option.");
return *field_solinger;
}

SSL__proto__support& Option::ssl__support()
{
if (union_selection != ALT_ssl__support) {
clean_up();
field_ssl__support = new SSL__proto__support;
union_selection = ALT_ssl__support;
}
return *field_ssl__support;
}

const SSL__proto__support& Option::ssl__support() const
{
if (union_selection != ALT_ssl__support) TTCN_error("Using non-selected field ssl_support in a value of union type @IPL4asp_Types.Option.");
return *field_ssl__support;
}

BOOLEAN& Option::no__delay()
{
if (union_selection != ALT_no__delay) {
clean_up();
field_no__delay = new BOOLEAN;
union_selection = ALT_no__delay;
}
return *field_no__delay;
}

const BOOLEAN& Option::no__delay() const
{
if (union_selection != ALT_no__delay) TTCN_error("Using non-selected field no_delay in a value of union type @IPL4asp_Types.Option.");
return *field_no__delay;
}

CHARSTRING& Option::dtlsSrtpProfiles()
{
if (union_selection != ALT_dtlsSrtpProfiles) {
clean_up();
field_dtlsSrtpProfiles = new CHARSTRING;
union_selection = ALT_dtlsSrtpProfiles;
}
return *field_dtlsSrtpProfiles;
}

const CHARSTRING& Option::dtlsSrtpProfiles() const
{
if (union_selection != ALT_dtlsSrtpProfiles) TTCN_error("Using non-selected field dtlsSrtpProfiles in a value of union type @IPL4asp_Types.Option.");
return *field_dtlsSrtpProfiles;
}

SSL__cert__options& Option::cert__options()
{
if (union_selection != ALT_cert__options) {
clean_up();
field_cert__options = new SSL__cert__options;
union_selection = ALT_cert__options;
}
return *field_cert__options;
}

const SSL__cert__options& Option::cert__options() const
{
if (union_selection != ALT_cert__options) TTCN_error("Using non-selected field cert_options in a value of union type @IPL4asp_Types.Option.");
return *field_cert__options;
}

BOOLEAN& Option::freebind()
{
if (union_selection != ALT_freebind) {
clean_up();
field_freebind = new BOOLEAN;
union_selection = ALT_freebind;
}
return *field_freebind;
}

const BOOLEAN& Option::freebind() const
{
if (union_selection != ALT_freebind) TTCN_error("Using non-selected field freebind in a value of union type @IPL4asp_Types.Option.");
return *field_freebind;
}

Option_alpn__list& Option::alpn__list()
{
if (union_selection != ALT_alpn__list) {
clean_up();
field_alpn__list = new Option_alpn__list;
union_selection = ALT_alpn__list;
}
return *field_alpn__list;
}

const Option_alpn__list& Option::alpn__list() const
{
if (union_selection != ALT_alpn__list) TTCN_error("Using non-selected field alpn_list in a value of union type @IPL4asp_Types.Option.");
return *field_alpn__list;
}

CHARSTRING& Option::tls__hostname()
{
if (union_selection != ALT_tls__hostname) {
clean_up();
field_tls__hostname = new CHARSTRING;
union_selection = ALT_tls__hostname;
}
return *field_tls__hostname;
}

const CHARSTRING& Option::tls__hostname() const
{
if (union_selection != ALT_tls__hostname) TTCN_error("Using non-selected field tls_hostname in a value of union type @IPL4asp_Types.Option.");
return *field_tls__hostname;
}

boolean Option::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.Option.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IPL4asp_Types.Option.");
return union_selection == checked_selection;
}

boolean Option::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean Option::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_reuseAddress: return field_reuseAddress->is_value();
case ALT_tcpKeepAlive: return field_tcpKeepAlive->is_value();
case ALT_sctpEventHandle: return field_sctpEventHandle->is_value();
case ALT_sslKeepAlive: return field_sslKeepAlive->is_value();
case ALT_sctpAdditionalLocalAddresses: return field_sctpAdditionalLocalAddresses->is_value();
case ALT_sctpEINConfigGroup: return field_sctpEINConfigGroup->is_value();
case ALT_solinger: return field_solinger->is_value();
case ALT_ssl__support: return field_ssl__support->is_value();
case ALT_no__delay: return field_no__delay->is_value();
case ALT_dtlsSrtpProfiles: return field_dtlsSrtpProfiles->is_value();
case ALT_cert__options: return field_cert__options->is_value();
case ALT_freebind: return field_freebind->is_value();
case ALT_alpn__list: return field_alpn__list->is_value();
case ALT_tls__hostname: return field_tls__hostname->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void Option::clean_up()
{
switch (union_selection) {
case ALT_reuseAddress:
  delete field_reuseAddress;
  break;
case ALT_tcpKeepAlive:
  delete field_tcpKeepAlive;
  break;
case ALT_sctpEventHandle:
  delete field_sctpEventHandle;
  break;
case ALT_sslKeepAlive:
  delete field_sslKeepAlive;
  break;
case ALT_sctpAdditionalLocalAddresses:
  delete field_sctpAdditionalLocalAddresses;
  break;
case ALT_sctpEINConfigGroup:
  delete field_sctpEINConfigGroup;
  break;
case ALT_solinger:
  delete field_solinger;
  break;
case ALT_ssl__support:
  delete field_ssl__support;
  break;
case ALT_no__delay:
  delete field_no__delay;
  break;
case ALT_dtlsSrtpProfiles:
  delete field_dtlsSrtpProfiles;
  break;
case ALT_cert__options:
  delete field_cert__options;
  break;
case ALT_freebind:
  delete field_freebind;
  break;
case ALT_alpn__list:
  delete field_alpn__list;
  break;
case ALT_tls__hostname:
  delete field_tls__hostname;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void Option::log() const
{
switch (union_selection) {
case ALT_reuseAddress:
TTCN_Logger::log_event_str("{ reuseAddress := ");
field_reuseAddress->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tcpKeepAlive:
TTCN_Logger::log_event_str("{ tcpKeepAlive := ");
field_tcpKeepAlive->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpEventHandle:
TTCN_Logger::log_event_str("{ sctpEventHandle := ");
field_sctpEventHandle->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sslKeepAlive:
TTCN_Logger::log_event_str("{ sslKeepAlive := ");
field_sslKeepAlive->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpAdditionalLocalAddresses:
TTCN_Logger::log_event_str("{ sctpAdditionalLocalAddresses := ");
field_sctpAdditionalLocalAddresses->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sctpEINConfigGroup:
TTCN_Logger::log_event_str("{ sctpEINConfigGroup := ");
field_sctpEINConfigGroup->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_solinger:
TTCN_Logger::log_event_str("{ solinger := ");
field_solinger->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_ssl__support:
TTCN_Logger::log_event_str("{ ssl_support := ");
field_ssl__support->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_no__delay:
TTCN_Logger::log_event_str("{ no_delay := ");
field_no__delay->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_dtlsSrtpProfiles:
TTCN_Logger::log_event_str("{ dtlsSrtpProfiles := ");
field_dtlsSrtpProfiles->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_cert__options:
TTCN_Logger::log_event_str("{ cert_options := ");
field_cert__options->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_freebind:
TTCN_Logger::log_event_str("{ freebind := ");
field_freebind->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_alpn__list:
TTCN_Logger::log_event_str("{ alpn_list := ");
field_alpn__list->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tls__hostname:
TTCN_Logger::log_event_str("{ tls_hostname := ");
field_tls__hostname->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void Option::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "reuseAddress")) {
    reuseAddress().set_param(*mp_last);
    if (!reuseAddress().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tcpKeepAlive")) {
    tcpKeepAlive().set_param(*mp_last);
    if (!tcpKeepAlive().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpEventHandle")) {
    sctpEventHandle().set_param(*mp_last);
    if (!sctpEventHandle().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sslKeepAlive")) {
    sslKeepAlive().set_param(*mp_last);
    if (!sslKeepAlive().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpAdditionalLocalAddresses")) {
    sctpAdditionalLocalAddresses().set_param(*mp_last);
    if (!sctpAdditionalLocalAddresses().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sctpEINConfigGroup")) {
    sctpEINConfigGroup().set_param(*mp_last);
    if (!sctpEINConfigGroup().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "solinger")) {
    solinger().set_param(*mp_last);
    if (!solinger().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "ssl_support")) {
    ssl__support().set_param(*mp_last);
    if (!ssl__support().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "no_delay")) {
    no__delay().set_param(*mp_last);
    if (!no__delay().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "dtlsSrtpProfiles")) {
    dtlsSrtpProfiles().set_param(*mp_last);
    if (!dtlsSrtpProfiles().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "cert_options")) {
    cert__options().set_param(*mp_last);
    if (!cert__options().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "freebind")) {
    freebind().set_param(*mp_last);
    if (!freebind().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "alpn_list")) {
    alpn__list().set_param(*mp_last);
    if (!alpn__list().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tls_hostname")) {
    tls__hostname().set_param(*mp_last);
    if (!tls__hostname().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @IPL4asp_Types.Option.", mp_last->get_id()->get_name());
}

void Option::set_implicit_omit()
{
switch (union_selection) {
case ALT_reuseAddress:
field_reuseAddress->set_implicit_omit(); break;
case ALT_tcpKeepAlive:
field_tcpKeepAlive->set_implicit_omit(); break;
case ALT_sctpEventHandle:
field_sctpEventHandle->set_implicit_omit(); break;
case ALT_sslKeepAlive:
field_sslKeepAlive->set_implicit_omit(); break;
case ALT_sctpAdditionalLocalAddresses:
field_sctpAdditionalLocalAddresses->set_implicit_omit(); break;
case ALT_sctpEINConfigGroup:
field_sctpEINConfigGroup->set_implicit_omit(); break;
case ALT_solinger:
field_solinger->set_implicit_omit(); break;
case ALT_ssl__support:
field_ssl__support->set_implicit_omit(); break;
case ALT_no__delay:
field_no__delay->set_implicit_omit(); break;
case ALT_dtlsSrtpProfiles:
field_dtlsSrtpProfiles->set_implicit_omit(); break;
case ALT_cert__options:
field_cert__options->set_implicit_omit(); break;
case ALT_freebind:
field_freebind->set_implicit_omit(); break;
case ALT_alpn__list:
field_alpn__list->set_implicit_omit(); break;
case ALT_tls__hostname:
field_tls__hostname->set_implicit_omit(); break;
default: break;
}
}

void Option::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_reuseAddress:
field_reuseAddress->encode_text(text_buf);
break;
case ALT_tcpKeepAlive:
field_tcpKeepAlive->encode_text(text_buf);
break;
case ALT_sctpEventHandle:
field_sctpEventHandle->encode_text(text_buf);
break;
case ALT_sslKeepAlive:
field_sslKeepAlive->encode_text(text_buf);
break;
case ALT_sctpAdditionalLocalAddresses:
field_sctpAdditionalLocalAddresses->encode_text(text_buf);
break;
case ALT_sctpEINConfigGroup:
field_sctpEINConfigGroup->encode_text(text_buf);
break;
case ALT_solinger:
field_solinger->encode_text(text_buf);
break;
case ALT_ssl__support:
field_ssl__support->encode_text(text_buf);
break;
case ALT_no__delay:
field_no__delay->encode_text(text_buf);
break;
case ALT_dtlsSrtpProfiles:
field_dtlsSrtpProfiles->encode_text(text_buf);
break;
case ALT_cert__options:
field_cert__options->encode_text(text_buf);
break;
case ALT_freebind:
field_freebind->encode_text(text_buf);
break;
case ALT_alpn__list:
field_alpn__list->encode_text(text_buf);
break;
case ALT_tls__hostname:
field_tls__hostname->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.Option.");
}
}

void Option::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_reuseAddress:
reuseAddress().decode_text(text_buf);
break;
case ALT_tcpKeepAlive:
tcpKeepAlive().decode_text(text_buf);
break;
case ALT_sctpEventHandle:
sctpEventHandle().decode_text(text_buf);
break;
case ALT_sslKeepAlive:
sslKeepAlive().decode_text(text_buf);
break;
case ALT_sctpAdditionalLocalAddresses:
sctpAdditionalLocalAddresses().decode_text(text_buf);
break;
case ALT_sctpEINConfigGroup:
sctpEINConfigGroup().decode_text(text_buf);
break;
case ALT_solinger:
solinger().decode_text(text_buf);
break;
case ALT_ssl__support:
ssl__support().decode_text(text_buf);
break;
case ALT_no__delay:
no__delay().decode_text(text_buf);
break;
case ALT_dtlsSrtpProfiles:
dtlsSrtpProfiles().decode_text(text_buf);
break;
case ALT_cert__options:
cert__options().decode_text(text_buf);
break;
case ALT_freebind:
freebind().decode_text(text_buf);
break;
case ALT_alpn__list:
alpn__list().decode_text(text_buf);
break;
case ALT_tls__hostname:
tls__hostname().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.Option.");
}
}

void Option_template::copy_value(const Option& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
single_value.field_reuseAddress = new ReuseAddress_template(other_value.reuseAddress());
break;
case Option::ALT_tcpKeepAlive:
single_value.field_tcpKeepAlive = new TcpKeepAlive_template(other_value.tcpKeepAlive());
break;
case Option::ALT_sctpEventHandle:
single_value.field_sctpEventHandle = new SctpEventHandle_template(other_value.sctpEventHandle());
break;
case Option::ALT_sslKeepAlive:
single_value.field_sslKeepAlive = new TcpKeepAlive_template(other_value.sslKeepAlive());
break;
case Option::ALT_sctpAdditionalLocalAddresses:
single_value.field_sctpAdditionalLocalAddresses = new HostList_template(other_value.sctpAdditionalLocalAddresses());
break;
case Option::ALT_sctpEINConfigGroup:
single_value.field_sctpEINConfigGroup = new INTEGER_template(other_value.sctpEINConfigGroup());
break;
case Option::ALT_solinger:
single_value.field_solinger = new Linger__opt_template(other_value.solinger());
break;
case Option::ALT_ssl__support:
single_value.field_ssl__support = new SSL__proto__support_template(other_value.ssl__support());
break;
case Option::ALT_no__delay:
single_value.field_no__delay = new BOOLEAN_template(other_value.no__delay());
break;
case Option::ALT_dtlsSrtpProfiles:
single_value.field_dtlsSrtpProfiles = new CHARSTRING_template(other_value.dtlsSrtpProfiles());
break;
case Option::ALT_cert__options:
single_value.field_cert__options = new SSL__cert__options_template(other_value.cert__options());
break;
case Option::ALT_freebind:
single_value.field_freebind = new BOOLEAN_template(other_value.freebind());
break;
case Option::ALT_alpn__list:
single_value.field_alpn__list = new Option_alpn__list_template(other_value.alpn__list());
break;
case Option::ALT_tls__hostname:
single_value.field_tls__hostname = new CHARSTRING_template(other_value.tls__hostname());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IPL4asp_Types.Option.");
}
set_selection(SPECIFIC_VALUE);
}

void Option_template::copy_template(const Option_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
single_value.field_reuseAddress = new ReuseAddress_template(*other_value.single_value.field_reuseAddress);
break;
case Option::ALT_tcpKeepAlive:
single_value.field_tcpKeepAlive = new TcpKeepAlive_template(*other_value.single_value.field_tcpKeepAlive);
break;
case Option::ALT_sctpEventHandle:
single_value.field_sctpEventHandle = new SctpEventHandle_template(*other_value.single_value.field_sctpEventHandle);
break;
case Option::ALT_sslKeepAlive:
single_value.field_sslKeepAlive = new TcpKeepAlive_template(*other_value.single_value.field_sslKeepAlive);
break;
case Option::ALT_sctpAdditionalLocalAddresses:
single_value.field_sctpAdditionalLocalAddresses = new HostList_template(*other_value.single_value.field_sctpAdditionalLocalAddresses);
break;
case Option::ALT_sctpEINConfigGroup:
single_value.field_sctpEINConfigGroup = new INTEGER_template(*other_value.single_value.field_sctpEINConfigGroup);
break;
case Option::ALT_solinger:
single_value.field_solinger = new Linger__opt_template(*other_value.single_value.field_solinger);
break;
case Option::ALT_ssl__support:
single_value.field_ssl__support = new SSL__proto__support_template(*other_value.single_value.field_ssl__support);
break;
case Option::ALT_no__delay:
single_value.field_no__delay = new BOOLEAN_template(*other_value.single_value.field_no__delay);
break;
case Option::ALT_dtlsSrtpProfiles:
single_value.field_dtlsSrtpProfiles = new CHARSTRING_template(*other_value.single_value.field_dtlsSrtpProfiles);
break;
case Option::ALT_cert__options:
single_value.field_cert__options = new SSL__cert__options_template(*other_value.single_value.field_cert__options);
break;
case Option::ALT_freebind:
single_value.field_freebind = new BOOLEAN_template(*other_value.single_value.field_freebind);
break;
case Option::ALT_alpn__list:
single_value.field_alpn__list = new Option_alpn__list_template(*other_value.single_value.field_alpn__list);
break;
case Option::ALT_tls__hostname:
single_value.field_tls__hostname = new CHARSTRING_template(*other_value.single_value.field_tls__hostname);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.Option.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Option_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IPL4asp_Types.Option.");
}
set_selection(other_value);
}

Option_template::Option_template()
{
}

Option_template::Option_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Option_template::Option_template(const Option& other_value)
{
copy_value(other_value);
}

Option_template::Option_template(const OPTIONAL<Option>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Option&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IPL4asp_Types.Option from an unbound optional field.");
}
}

Option_template::Option_template(const Option_template& other_value)
: Base_Template(){
copy_template(other_value);
}

Option_template::~Option_template()
{
clean_up();
}

void Option_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
delete single_value.field_reuseAddress;
break;
case Option::ALT_tcpKeepAlive:
delete single_value.field_tcpKeepAlive;
break;
case Option::ALT_sctpEventHandle:
delete single_value.field_sctpEventHandle;
break;
case Option::ALT_sslKeepAlive:
delete single_value.field_sslKeepAlive;
break;
case Option::ALT_sctpAdditionalLocalAddresses:
delete single_value.field_sctpAdditionalLocalAddresses;
break;
case Option::ALT_sctpEINConfigGroup:
delete single_value.field_sctpEINConfigGroup;
break;
case Option::ALT_solinger:
delete single_value.field_solinger;
break;
case Option::ALT_ssl__support:
delete single_value.field_ssl__support;
break;
case Option::ALT_no__delay:
delete single_value.field_no__delay;
break;
case Option::ALT_dtlsSrtpProfiles:
delete single_value.field_dtlsSrtpProfiles;
break;
case Option::ALT_cert__options:
delete single_value.field_cert__options;
break;
case Option::ALT_freebind:
delete single_value.field_freebind;
break;
case Option::ALT_alpn__list:
delete single_value.field_alpn__list;
break;
case Option::ALT_tls__hostname:
delete single_value.field_tls__hostname;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Option_template& Option_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Option_template& Option_template::operator=(const Option& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Option_template& Option_template::operator=(const OPTIONAL<Option>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Option&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IPL4asp_Types.Option.");
}
return *this;
}

Option_template& Option_template::operator=(const Option_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Option_template::match(const Option& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
Option::union_selection_type value_selection = other_value.get_selection();
if (value_selection == Option::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case Option::ALT_reuseAddress:
return single_value.field_reuseAddress->match(other_value.reuseAddress(), legacy);
case Option::ALT_tcpKeepAlive:
return single_value.field_tcpKeepAlive->match(other_value.tcpKeepAlive(), legacy);
case Option::ALT_sctpEventHandle:
return single_value.field_sctpEventHandle->match(other_value.sctpEventHandle(), legacy);
case Option::ALT_sslKeepAlive:
return single_value.field_sslKeepAlive->match(other_value.sslKeepAlive(), legacy);
case Option::ALT_sctpAdditionalLocalAddresses:
return single_value.field_sctpAdditionalLocalAddresses->match(other_value.sctpAdditionalLocalAddresses(), legacy);
case Option::ALT_sctpEINConfigGroup:
return single_value.field_sctpEINConfigGroup->match(other_value.sctpEINConfigGroup(), legacy);
case Option::ALT_solinger:
return single_value.field_solinger->match(other_value.solinger(), legacy);
case Option::ALT_ssl__support:
return single_value.field_ssl__support->match(other_value.ssl__support(), legacy);
case Option::ALT_no__delay:
return single_value.field_no__delay->match(other_value.no__delay(), legacy);
case Option::ALT_dtlsSrtpProfiles:
return single_value.field_dtlsSrtpProfiles->match(other_value.dtlsSrtpProfiles(), legacy);
case Option::ALT_cert__options:
return single_value.field_cert__options->match(other_value.cert__options(), legacy);
case Option::ALT_freebind:
return single_value.field_freebind->match(other_value.freebind(), legacy);
case Option::ALT_alpn__list:
return single_value.field_alpn__list->match(other_value.alpn__list(), legacy);
case Option::ALT_tls__hostname:
return single_value.field_tls__hostname->match(other_value.tls__hostname(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.Option.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IPL4asp_Types.Option.");
}
return FALSE;
}

boolean Option_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
return single_value.field_reuseAddress->is_value();
case Option::ALT_tcpKeepAlive:
return single_value.field_tcpKeepAlive->is_value();
case Option::ALT_sctpEventHandle:
return single_value.field_sctpEventHandle->is_value();
case Option::ALT_sslKeepAlive:
return single_value.field_sslKeepAlive->is_value();
case Option::ALT_sctpAdditionalLocalAddresses:
return single_value.field_sctpAdditionalLocalAddresses->is_value();
case Option::ALT_sctpEINConfigGroup:
return single_value.field_sctpEINConfigGroup->is_value();
case Option::ALT_solinger:
return single_value.field_solinger->is_value();
case Option::ALT_ssl__support:
return single_value.field_ssl__support->is_value();
case Option::ALT_no__delay:
return single_value.field_no__delay->is_value();
case Option::ALT_dtlsSrtpProfiles:
return single_value.field_dtlsSrtpProfiles->is_value();
case Option::ALT_cert__options:
return single_value.field_cert__options->is_value();
case Option::ALT_freebind:
return single_value.field_freebind->is_value();
case Option::ALT_alpn__list:
return single_value.field_alpn__list->is_value();
case Option::ALT_tls__hostname:
return single_value.field_tls__hostname->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.Option.");
}
}

Option Option_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.Option.");
Option ret_val;
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
ret_val.reuseAddress() = single_value.field_reuseAddress->valueof();
break;
case Option::ALT_tcpKeepAlive:
ret_val.tcpKeepAlive() = single_value.field_tcpKeepAlive->valueof();
break;
case Option::ALT_sctpEventHandle:
ret_val.sctpEventHandle() = single_value.field_sctpEventHandle->valueof();
break;
case Option::ALT_sslKeepAlive:
ret_val.sslKeepAlive() = single_value.field_sslKeepAlive->valueof();
break;
case Option::ALT_sctpAdditionalLocalAddresses:
ret_val.sctpAdditionalLocalAddresses() = single_value.field_sctpAdditionalLocalAddresses->valueof();
break;
case Option::ALT_sctpEINConfigGroup:
ret_val.sctpEINConfigGroup() = single_value.field_sctpEINConfigGroup->valueof();
break;
case Option::ALT_solinger:
ret_val.solinger() = single_value.field_solinger->valueof();
break;
case Option::ALT_ssl__support:
ret_val.ssl__support() = single_value.field_ssl__support->valueof();
break;
case Option::ALT_no__delay:
ret_val.no__delay() = single_value.field_no__delay->valueof();
break;
case Option::ALT_dtlsSrtpProfiles:
ret_val.dtlsSrtpProfiles() = single_value.field_dtlsSrtpProfiles->valueof();
break;
case Option::ALT_cert__options:
ret_val.cert__options() = single_value.field_cert__options->valueof();
break;
case Option::ALT_freebind:
ret_val.freebind() = single_value.field_freebind->valueof();
break;
case Option::ALT_alpn__list:
ret_val.alpn__list() = single_value.field_alpn__list->valueof();
break;
case Option::ALT_tls__hostname:
ret_val.tls__hostname() = single_value.field_tls__hostname->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.Option.");
}
return ret_val;
}

Option_template& Option_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.Option.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.Option.");
return value_list.list_value[list_index];
}
void Option_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.Option.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Option_template[list_length];
}

ReuseAddress_template& Option_template::reuseAddress()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_reuseAddress) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_reuseAddress = new ReuseAddress_template(ANY_VALUE);
else single_value.field_reuseAddress = new ReuseAddress_template;
single_value.union_selection = Option::ALT_reuseAddress;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_reuseAddress;
}

const ReuseAddress_template& Option_template::reuseAddress() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field reuseAddress in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_reuseAddress) TTCN_error("Accessing non-selected field reuseAddress in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_reuseAddress;
}

TcpKeepAlive_template& Option_template::tcpKeepAlive()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_tcpKeepAlive) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tcpKeepAlive = new TcpKeepAlive_template(ANY_VALUE);
else single_value.field_tcpKeepAlive = new TcpKeepAlive_template;
single_value.union_selection = Option::ALT_tcpKeepAlive;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tcpKeepAlive;
}

const TcpKeepAlive_template& Option_template::tcpKeepAlive() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tcpKeepAlive in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_tcpKeepAlive) TTCN_error("Accessing non-selected field tcpKeepAlive in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_tcpKeepAlive;
}

SctpEventHandle_template& Option_template::sctpEventHandle()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_sctpEventHandle) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpEventHandle = new SctpEventHandle_template(ANY_VALUE);
else single_value.field_sctpEventHandle = new SctpEventHandle_template;
single_value.union_selection = Option::ALT_sctpEventHandle;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpEventHandle;
}

const SctpEventHandle_template& Option_template::sctpEventHandle() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpEventHandle in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_sctpEventHandle) TTCN_error("Accessing non-selected field sctpEventHandle in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_sctpEventHandle;
}

TcpKeepAlive_template& Option_template::sslKeepAlive()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_sslKeepAlive) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sslKeepAlive = new TcpKeepAlive_template(ANY_VALUE);
else single_value.field_sslKeepAlive = new TcpKeepAlive_template;
single_value.union_selection = Option::ALT_sslKeepAlive;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sslKeepAlive;
}

const TcpKeepAlive_template& Option_template::sslKeepAlive() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sslKeepAlive in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_sslKeepAlive) TTCN_error("Accessing non-selected field sslKeepAlive in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_sslKeepAlive;
}

HostList_template& Option_template::sctpAdditionalLocalAddresses()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_sctpAdditionalLocalAddresses) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpAdditionalLocalAddresses = new HostList_template(ANY_VALUE);
else single_value.field_sctpAdditionalLocalAddresses = new HostList_template;
single_value.union_selection = Option::ALT_sctpAdditionalLocalAddresses;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpAdditionalLocalAddresses;
}

const HostList_template& Option_template::sctpAdditionalLocalAddresses() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpAdditionalLocalAddresses in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_sctpAdditionalLocalAddresses) TTCN_error("Accessing non-selected field sctpAdditionalLocalAddresses in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_sctpAdditionalLocalAddresses;
}

INTEGER_template& Option_template::sctpEINConfigGroup()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_sctpEINConfigGroup) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sctpEINConfigGroup = new INTEGER_template(ANY_VALUE);
else single_value.field_sctpEINConfigGroup = new INTEGER_template;
single_value.union_selection = Option::ALT_sctpEINConfigGroup;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sctpEINConfigGroup;
}

const INTEGER_template& Option_template::sctpEINConfigGroup() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sctpEINConfigGroup in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_sctpEINConfigGroup) TTCN_error("Accessing non-selected field sctpEINConfigGroup in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_sctpEINConfigGroup;
}

Linger__opt_template& Option_template::solinger()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_solinger) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_solinger = new Linger__opt_template(ANY_VALUE);
else single_value.field_solinger = new Linger__opt_template;
single_value.union_selection = Option::ALT_solinger;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_solinger;
}

const Linger__opt_template& Option_template::solinger() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field solinger in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_solinger) TTCN_error("Accessing non-selected field solinger in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_solinger;
}

SSL__proto__support_template& Option_template::ssl__support()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_ssl__support) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ssl__support = new SSL__proto__support_template(ANY_VALUE);
else single_value.field_ssl__support = new SSL__proto__support_template;
single_value.union_selection = Option::ALT_ssl__support;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ssl__support;
}

const SSL__proto__support_template& Option_template::ssl__support() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ssl_support in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_ssl__support) TTCN_error("Accessing non-selected field ssl_support in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_ssl__support;
}

BOOLEAN_template& Option_template::no__delay()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_no__delay) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_no__delay = new BOOLEAN_template(ANY_VALUE);
else single_value.field_no__delay = new BOOLEAN_template;
single_value.union_selection = Option::ALT_no__delay;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_no__delay;
}

const BOOLEAN_template& Option_template::no__delay() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field no_delay in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_no__delay) TTCN_error("Accessing non-selected field no_delay in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_no__delay;
}

CHARSTRING_template& Option_template::dtlsSrtpProfiles()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_dtlsSrtpProfiles) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_dtlsSrtpProfiles = new CHARSTRING_template(ANY_VALUE);
else single_value.field_dtlsSrtpProfiles = new CHARSTRING_template;
single_value.union_selection = Option::ALT_dtlsSrtpProfiles;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_dtlsSrtpProfiles;
}

const CHARSTRING_template& Option_template::dtlsSrtpProfiles() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field dtlsSrtpProfiles in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_dtlsSrtpProfiles) TTCN_error("Accessing non-selected field dtlsSrtpProfiles in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_dtlsSrtpProfiles;
}

SSL__cert__options_template& Option_template::cert__options()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_cert__options) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_cert__options = new SSL__cert__options_template(ANY_VALUE);
else single_value.field_cert__options = new SSL__cert__options_template;
single_value.union_selection = Option::ALT_cert__options;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_cert__options;
}

const SSL__cert__options_template& Option_template::cert__options() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field cert_options in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_cert__options) TTCN_error("Accessing non-selected field cert_options in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_cert__options;
}

BOOLEAN_template& Option_template::freebind()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_freebind) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_freebind = new BOOLEAN_template(ANY_VALUE);
else single_value.field_freebind = new BOOLEAN_template;
single_value.union_selection = Option::ALT_freebind;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_freebind;
}

const BOOLEAN_template& Option_template::freebind() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field freebind in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_freebind) TTCN_error("Accessing non-selected field freebind in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_freebind;
}

Option_alpn__list_template& Option_template::alpn__list()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_alpn__list) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_alpn__list = new Option_alpn__list_template(ANY_VALUE);
else single_value.field_alpn__list = new Option_alpn__list_template;
single_value.union_selection = Option::ALT_alpn__list;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_alpn__list;
}

const Option_alpn__list_template& Option_template::alpn__list() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field alpn_list in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_alpn__list) TTCN_error("Accessing non-selected field alpn_list in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_alpn__list;
}

CHARSTRING_template& Option_template::tls__hostname()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Option::ALT_tls__hostname) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tls__hostname = new CHARSTRING_template(ANY_VALUE);
else single_value.field_tls__hostname = new CHARSTRING_template;
single_value.union_selection = Option::ALT_tls__hostname;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tls__hostname;
}

const CHARSTRING_template& Option_template::tls__hostname() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tls_hostname in a non-specific template of union type @IPL4asp_Types.Option.");
if (single_value.union_selection != Option::ALT_tls__hostname) TTCN_error("Accessing non-selected field tls_hostname in a template of union type @IPL4asp_Types.Option.");
return *single_value.field_tls__hostname;
}

boolean Option_template::ischosen(Option::union_selection_type checked_selection) const
{
if (checked_selection == Option::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.Option.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == Option::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.Option.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.Option containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IPL4asp_Types.Option, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IPL4asp_Types.Option");
}
return FALSE;
}

void Option_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
TTCN_Logger::log_event_str("{ reuseAddress := ");
single_value.field_reuseAddress->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_tcpKeepAlive:
TTCN_Logger::log_event_str("{ tcpKeepAlive := ");
single_value.field_tcpKeepAlive->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_sctpEventHandle:
TTCN_Logger::log_event_str("{ sctpEventHandle := ");
single_value.field_sctpEventHandle->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_sslKeepAlive:
TTCN_Logger::log_event_str("{ sslKeepAlive := ");
single_value.field_sslKeepAlive->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_sctpAdditionalLocalAddresses:
TTCN_Logger::log_event_str("{ sctpAdditionalLocalAddresses := ");
single_value.field_sctpAdditionalLocalAddresses->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_sctpEINConfigGroup:
TTCN_Logger::log_event_str("{ sctpEINConfigGroup := ");
single_value.field_sctpEINConfigGroup->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_solinger:
TTCN_Logger::log_event_str("{ solinger := ");
single_value.field_solinger->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_ssl__support:
TTCN_Logger::log_event_str("{ ssl_support := ");
single_value.field_ssl__support->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_no__delay:
TTCN_Logger::log_event_str("{ no_delay := ");
single_value.field_no__delay->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_dtlsSrtpProfiles:
TTCN_Logger::log_event_str("{ dtlsSrtpProfiles := ");
single_value.field_dtlsSrtpProfiles->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_cert__options:
TTCN_Logger::log_event_str("{ cert_options := ");
single_value.field_cert__options->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_freebind:
TTCN_Logger::log_event_str("{ freebind := ");
single_value.field_freebind->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_alpn__list:
TTCN_Logger::log_event_str("{ alpn_list := ");
single_value.field_alpn__list->log();
TTCN_Logger::log_event_str(" }");
break;
case Option::ALT_tls__hostname:
TTCN_Logger::log_event_str("{ tls_hostname := ");
single_value.field_tls__hostname->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Option_template::log_match(const Option& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".reuseAddress");
single_value.field_reuseAddress->log_match(match_value.reuseAddress(), legacy);
} else {
TTCN_Logger::log_event_str("{ reuseAddress := ");
single_value.field_reuseAddress->log_match(match_value.reuseAddress(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_tcpKeepAlive:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tcpKeepAlive");
single_value.field_tcpKeepAlive->log_match(match_value.tcpKeepAlive(), legacy);
} else {
TTCN_Logger::log_event_str("{ tcpKeepAlive := ");
single_value.field_tcpKeepAlive->log_match(match_value.tcpKeepAlive(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_sctpEventHandle:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpEventHandle");
single_value.field_sctpEventHandle->log_match(match_value.sctpEventHandle(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpEventHandle := ");
single_value.field_sctpEventHandle->log_match(match_value.sctpEventHandle(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_sslKeepAlive:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sslKeepAlive");
single_value.field_sslKeepAlive->log_match(match_value.sslKeepAlive(), legacy);
} else {
TTCN_Logger::log_event_str("{ sslKeepAlive := ");
single_value.field_sslKeepAlive->log_match(match_value.sslKeepAlive(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_sctpAdditionalLocalAddresses:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpAdditionalLocalAddresses");
single_value.field_sctpAdditionalLocalAddresses->log_match(match_value.sctpAdditionalLocalAddresses(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpAdditionalLocalAddresses := ");
single_value.field_sctpAdditionalLocalAddresses->log_match(match_value.sctpAdditionalLocalAddresses(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_sctpEINConfigGroup:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sctpEINConfigGroup");
single_value.field_sctpEINConfigGroup->log_match(match_value.sctpEINConfigGroup(), legacy);
} else {
TTCN_Logger::log_event_str("{ sctpEINConfigGroup := ");
single_value.field_sctpEINConfigGroup->log_match(match_value.sctpEINConfigGroup(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_solinger:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".solinger");
single_value.field_solinger->log_match(match_value.solinger(), legacy);
} else {
TTCN_Logger::log_event_str("{ solinger := ");
single_value.field_solinger->log_match(match_value.solinger(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_ssl__support:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ssl_support");
single_value.field_ssl__support->log_match(match_value.ssl__support(), legacy);
} else {
TTCN_Logger::log_event_str("{ ssl_support := ");
single_value.field_ssl__support->log_match(match_value.ssl__support(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_no__delay:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".no_delay");
single_value.field_no__delay->log_match(match_value.no__delay(), legacy);
} else {
TTCN_Logger::log_event_str("{ no_delay := ");
single_value.field_no__delay->log_match(match_value.no__delay(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_dtlsSrtpProfiles:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".dtlsSrtpProfiles");
single_value.field_dtlsSrtpProfiles->log_match(match_value.dtlsSrtpProfiles(), legacy);
} else {
TTCN_Logger::log_event_str("{ dtlsSrtpProfiles := ");
single_value.field_dtlsSrtpProfiles->log_match(match_value.dtlsSrtpProfiles(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_cert__options:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".cert_options");
single_value.field_cert__options->log_match(match_value.cert__options(), legacy);
} else {
TTCN_Logger::log_event_str("{ cert_options := ");
single_value.field_cert__options->log_match(match_value.cert__options(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_freebind:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".freebind");
single_value.field_freebind->log_match(match_value.freebind(), legacy);
} else {
TTCN_Logger::log_event_str("{ freebind := ");
single_value.field_freebind->log_match(match_value.freebind(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_alpn__list:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".alpn_list");
single_value.field_alpn__list->log_match(match_value.alpn__list(), legacy);
} else {
TTCN_Logger::log_event_str("{ alpn_list := ");
single_value.field_alpn__list->log_match(match_value.alpn__list(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Option::ALT_tls__hostname:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tls_hostname");
single_value.field_tls__hostname->log_match(match_value.tls__hostname(), legacy);
} else {
TTCN_Logger::log_event_str("{ tls_hostname := ");
single_value.field_tls__hostname->log_match(match_value.tls__hostname(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Option_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
single_value.field_reuseAddress->encode_text(text_buf);
break;
case Option::ALT_tcpKeepAlive:
single_value.field_tcpKeepAlive->encode_text(text_buf);
break;
case Option::ALT_sctpEventHandle:
single_value.field_sctpEventHandle->encode_text(text_buf);
break;
case Option::ALT_sslKeepAlive:
single_value.field_sslKeepAlive->encode_text(text_buf);
break;
case Option::ALT_sctpAdditionalLocalAddresses:
single_value.field_sctpAdditionalLocalAddresses->encode_text(text_buf);
break;
case Option::ALT_sctpEINConfigGroup:
single_value.field_sctpEINConfigGroup->encode_text(text_buf);
break;
case Option::ALT_solinger:
single_value.field_solinger->encode_text(text_buf);
break;
case Option::ALT_ssl__support:
single_value.field_ssl__support->encode_text(text_buf);
break;
case Option::ALT_no__delay:
single_value.field_no__delay->encode_text(text_buf);
break;
case Option::ALT_dtlsSrtpProfiles:
single_value.field_dtlsSrtpProfiles->encode_text(text_buf);
break;
case Option::ALT_cert__options:
single_value.field_cert__options->encode_text(text_buf);
break;
case Option::ALT_freebind:
single_value.field_freebind->encode_text(text_buf);
break;
case Option::ALT_alpn__list:
single_value.field_alpn__list->encode_text(text_buf);
break;
case Option::ALT_tls__hostname:
single_value.field_tls__hostname->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IPL4asp_Types.Option.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.Option.");
}
}

void Option_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = Option::UNBOUND_VALUE;
Option::union_selection_type new_selection = (Option::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case Option::ALT_reuseAddress:
single_value.field_reuseAddress = new ReuseAddress_template;
single_value.field_reuseAddress->decode_text(text_buf);
break;
case Option::ALT_tcpKeepAlive:
single_value.field_tcpKeepAlive = new TcpKeepAlive_template;
single_value.field_tcpKeepAlive->decode_text(text_buf);
break;
case Option::ALT_sctpEventHandle:
single_value.field_sctpEventHandle = new SctpEventHandle_template;
single_value.field_sctpEventHandle->decode_text(text_buf);
break;
case Option::ALT_sslKeepAlive:
single_value.field_sslKeepAlive = new TcpKeepAlive_template;
single_value.field_sslKeepAlive->decode_text(text_buf);
break;
case Option::ALT_sctpAdditionalLocalAddresses:
single_value.field_sctpAdditionalLocalAddresses = new HostList_template;
single_value.field_sctpAdditionalLocalAddresses->decode_text(text_buf);
break;
case Option::ALT_sctpEINConfigGroup:
single_value.field_sctpEINConfigGroup = new INTEGER_template;
single_value.field_sctpEINConfigGroup->decode_text(text_buf);
break;
case Option::ALT_solinger:
single_value.field_solinger = new Linger__opt_template;
single_value.field_solinger->decode_text(text_buf);
break;
case Option::ALT_ssl__support:
single_value.field_ssl__support = new SSL__proto__support_template;
single_value.field_ssl__support->decode_text(text_buf);
break;
case Option::ALT_no__delay:
single_value.field_no__delay = new BOOLEAN_template;
single_value.field_no__delay->decode_text(text_buf);
break;
case Option::ALT_dtlsSrtpProfiles:
single_value.field_dtlsSrtpProfiles = new CHARSTRING_template;
single_value.field_dtlsSrtpProfiles->decode_text(text_buf);
break;
case Option::ALT_cert__options:
single_value.field_cert__options = new SSL__cert__options_template;
single_value.field_cert__options->decode_text(text_buf);
break;
case Option::ALT_freebind:
single_value.field_freebind = new BOOLEAN_template;
single_value.field_freebind->decode_text(text_buf);
break;
case Option::ALT_alpn__list:
single_value.field_alpn__list = new Option_alpn__list_template;
single_value.field_alpn__list->decode_text(text_buf);
break;
case Option::ALT_tls__hostname:
single_value.field_tls__hostname = new CHARSTRING_template;
single_value.field_tls__hostname->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IPL4asp_Types.Option.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Option_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.Option.");
}
}

boolean Option_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Option_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Option_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IPL4asp_Types.Option'");
    }
    if (strcmp("reuseAddress", param_field) == 0) {
      reuseAddress().set_param(param);
      return;
    } else if (strcmp("tcpKeepAlive", param_field) == 0) {
      tcpKeepAlive().set_param(param);
      return;
    } else if (strcmp("sctpEventHandle", param_field) == 0) {
      sctpEventHandle().set_param(param);
      return;
    } else if (strcmp("sslKeepAlive", param_field) == 0) {
      sslKeepAlive().set_param(param);
      return;
    } else if (strcmp("sctpAdditionalLocalAddresses", param_field) == 0) {
      sctpAdditionalLocalAddresses().set_param(param);
      return;
    } else if (strcmp("sctpEINConfigGroup", param_field) == 0) {
      sctpEINConfigGroup().set_param(param);
      return;
    } else if (strcmp("solinger", param_field) == 0) {
      solinger().set_param(param);
      return;
    } else if (strcmp("ssl_support", param_field) == 0) {
      ssl__support().set_param(param);
      return;
    } else if (strcmp("no_delay", param_field) == 0) {
      no__delay().set_param(param);
      return;
    } else if (strcmp("dtlsSrtpProfiles", param_field) == 0) {
      dtlsSrtpProfiles().set_param(param);
      return;
    } else if (strcmp("cert_options", param_field) == 0) {
      cert__options().set_param(param);
      return;
    } else if (strcmp("freebind", param_field) == 0) {
      freebind().set_param(param);
      return;
    } else if (strcmp("alpn_list", param_field) == 0) {
      alpn__list().set_param(param);
      return;
    } else if (strcmp("tls_hostname", param_field) == 0) {
      tls__hostname().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IPL4asp_Types.Option'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Option_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@IPL4asp_Types.Option");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "reuseAddress")) {
      reuseAddress().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tcpKeepAlive")) {
      tcpKeepAlive().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpEventHandle")) {
      sctpEventHandle().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sslKeepAlive")) {
      sslKeepAlive().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpAdditionalLocalAddresses")) {
      sctpAdditionalLocalAddresses().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sctpEINConfigGroup")) {
      sctpEINConfigGroup().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "solinger")) {
      solinger().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "ssl_support")) {
      ssl__support().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "no_delay")) {
      no__delay().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "dtlsSrtpProfiles")) {
      dtlsSrtpProfiles().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "cert_options")) {
      cert__options().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "freebind")) {
      freebind().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "alpn_list")) {
      alpn__list().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tls_hostname")) {
      tls__hostname().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IPL4asp_Types.Option.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IPL4asp_Types.Option");
  }
  is_ifpresent = param.get_ifpresent();
}

void Option_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case Option::ALT_reuseAddress:
single_value.field_reuseAddress->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_tcpKeepAlive:
single_value.field_tcpKeepAlive->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_sctpEventHandle:
single_value.field_sctpEventHandle->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_sslKeepAlive:
single_value.field_sslKeepAlive->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_sctpAdditionalLocalAddresses:
single_value.field_sctpAdditionalLocalAddresses->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_sctpEINConfigGroup:
single_value.field_sctpEINConfigGroup->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_solinger:
single_value.field_solinger->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_ssl__support:
single_value.field_ssl__support->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_no__delay:
single_value.field_no__delay->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_dtlsSrtpProfiles:
single_value.field_dtlsSrtpProfiles->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_cert__options:
single_value.field_cert__options->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_freebind:
single_value.field_freebind->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_alpn__list:
single_value.field_alpn__list->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
case Option::ALT_tls__hostname:
single_value.field_tls__hostname->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.Option");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.Option.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.Option");
}


const Option OptionList::UNBOUND_ELEM;
OptionList::OptionList()
{
val_ptr = NULL;
}

OptionList::OptionList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

OptionList::OptionList(const OptionList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.OptionList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

OptionList::~OptionList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void OptionList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

OptionList& OptionList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

OptionList& OptionList::operator=(const OptionList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @IPL4asp_Types.OptionList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean OptionList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");
return val_ptr->n_elements == 0 ;
}

boolean OptionList::operator==(const OptionList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

Option& OptionList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @IPL4asp_Types.OptionList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (Option**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Option(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new Option;
}
return *val_ptr->value_elements[index_value];
}

Option& OptionList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IPL4asp_Types.OptionList.");
return (*this)[(int)index_value];
}

const Option& OptionList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @IPL4asp_Types.OptionList.");
if (index_value < 0) TTCN_error("Accessing an element of type @IPL4asp_Types.OptionList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @IPL4asp_Types.OptionList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const Option& OptionList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @IPL4asp_Types.OptionList.");
return (*this)[(int)index_value];
}

OptionList OptionList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

OptionList OptionList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

OptionList OptionList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

OptionList OptionList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @IPL4asp_Types.OptionList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
OptionList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new Option(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

OptionList OptionList::operator+(const OptionList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @IPL4asp_Types.OptionList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
OptionList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Option(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new Option(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

OptionList OptionList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @IPL4asp_Types.OptionList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@IPL4asp_Types.OptionList","element");
OptionList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new Option(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

OptionList OptionList::replace(int index, int len, const OptionList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @IPL4asp_Types.OptionList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @IPL4asp_Types.OptionList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@IPL4asp_Types.OptionList","element");
OptionList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Option(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new Option(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new Option(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

OptionList OptionList::replace(int index, int len, const OptionList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void OptionList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @IPL4asp_Types.OptionList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (Option**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Option(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (Option**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @IPL4asp_Types.OptionList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (Option**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean OptionList::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int OptionList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @IPL4asp_Types.OptionList.");
return val_ptr->n_elements;
}

int OptionList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @IPL4asp_Types.OptionList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void OptionList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void OptionList::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@IPL4asp_Types.OptionList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@IPL4asp_Types.OptionList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void OptionList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void OptionList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @IPL4asp_Types.OptionList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void OptionList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @IPL4asp_Types.OptionList.");
val_ptr->value_elements = (Option**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new Option;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void OptionList_template::copy_value(const OptionList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @IPL4asp_Types.OptionList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (Option_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new Option_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new Option_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void OptionList_template::copy_template(const OptionList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (Option_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new Option_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new Option_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new OptionList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.");
break;
}
set_selection(other_value);
}

boolean OptionList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const OptionList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const OptionList*)value_ptr)[value_index], legacy);
else return ((const OptionList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

OptionList_template::OptionList_template()
{
}

OptionList_template::OptionList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

OptionList_template::OptionList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

OptionList_template::OptionList_template(const OptionList& other_value)
{
copy_value(other_value);
}

OptionList_template::OptionList_template(const OPTIONAL<OptionList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const OptionList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.OptionList from an unbound optional field.");
}
}

OptionList_template::OptionList_template(const OptionList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

OptionList_template::~OptionList_template()
{
clean_up();
}

void OptionList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

OptionList_template& OptionList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

OptionList_template& OptionList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

OptionList_template& OptionList_template::operator=(const OptionList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

OptionList_template& OptionList_template::operator=(const OPTIONAL<OptionList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const OptionList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.OptionList.");
}
return *this;
}

OptionList_template& OptionList_template::operator=(const OptionList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Option_template& OptionList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IPL4asp_Types.OptionList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @IPL4asp_Types.OptionList.");
    break;
}
return *single_value.value_elements[index_value];
}

Option_template& OptionList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.OptionList.");
return (*this)[(int)index_value];
}

const Option_template& OptionList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @IPL4asp_Types.OptionList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @IPL4asp_Types.OptionList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @IPL4asp_Types.OptionList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const Option_template& OptionList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @IPL4asp_Types.OptionList.");
return (*this)[(int)index_value];
}

void OptionList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @IPL4asp_Types.OptionList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (Option_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Option_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Option_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (Option_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int OptionList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int OptionList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @IPL4asp_Types.OptionList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @IPL4asp_Types.OptionList");
}

boolean OptionList_template::match(const OptionList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.");
}
return FALSE;
}

boolean OptionList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

OptionList OptionList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.OptionList.");
OptionList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

OptionList OptionList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

OptionList OptionList_template::replace(int index, int len, const OptionList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

OptionList OptionList_template::replace(int index, int len, const OptionList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void OptionList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new OptionList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @IPL4asp_Types.OptionList.");
}
set_selection(template_type);
}

OptionList_template& OptionList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @IPL4asp_Types.OptionList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @IPL4asp_Types.OptionList.");
return value_list.list_value[list_index];
}

void OptionList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void OptionList_template::log_match(const OptionList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void OptionList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.OptionList.");
}
}

void OptionList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @IPL4asp_Types.OptionList.");
single_value.value_elements = (Option_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new Option_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new OptionList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @IPL4asp_Types.OptionList.");
}
}

boolean OptionList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean OptionList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void OptionList_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    OptionList_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@IPL4asp_Types.OptionList");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void OptionList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.OptionList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.OptionList");
}

boolean OptionList_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
ASP__Send::ASP__Send()
{
}

ASP__Send::ASP__Send(const INTEGER& par_connId,
    const OPTIONAL<Socket__API__Definitions::ProtoTuple>& par_proto,
    const OCTETSTRING& par_msg)
  :   field_connId(par_connId),
  field_proto(par_proto),
  field_msg(par_msg)
{
}

ASP__Send::ASP__Send(const ASP__Send& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.ASP_Send.");
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.msg().is_bound()) field_msg = other_value.msg();
else field_msg.clean_up();
}

void ASP__Send::clean_up()
{
field_connId.clean_up();
field_proto.clean_up();
field_msg.clean_up();
}

ASP__Send& ASP__Send::operator=(const ASP__Send& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.ASP_Send.");
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.msg().is_bound()) field_msg = other_value.msg();
  else field_msg.clean_up();
}
return *this;
}

boolean ASP__Send::operator==(const ASP__Send& other_value) const
{
return field_connId==other_value.field_connId
  && field_proto==other_value.field_proto
  && field_msg==other_value.field_msg;
}

boolean ASP__Send::is_bound() const
{
if(field_connId.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_proto.get_selection() || field_proto.is_bound()) return TRUE;
if(field_msg.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__Send::is_value() const
{
if(!field_connId.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_proto.get_selection() && !field_proto.is_value()) return FALSE;
if(!field_msg.is_value()) return FALSE;
return TRUE;
}
int ASP__Send::size_of() const
{
  int ret_val = 2;
  if (field_proto.ispresent()) ret_val++;
  return ret_val;
}

void ASP__Send::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", msg := ");
field_msg.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__Send::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.ASP_Send has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_Send: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.ASP_Send");
  }
}

void ASP__Send::set_implicit_omit()
{
if (connId().is_bound()) connId().set_implicit_omit();
if (!proto().is_bound()) proto() = OMIT_VALUE;
else proto().set_implicit_omit();
if (msg().is_bound()) msg().set_implicit_omit();
}

void ASP__Send::encode_text(Text_Buf& text_buf) const
{
field_connId.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_msg.encode_text(text_buf);
}

void ASP__Send::decode_text(Text_Buf& text_buf)
{
field_connId.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_msg.decode_text(text_buf);
}

struct ASP__Send_template::single_value_struct {
INTEGER_template field_connId;
Socket__API__Definitions::ProtoTuple_template field_proto;
OCTETSTRING_template field_msg;
};

void ASP__Send_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connId = ANY_VALUE;
single_value->field_proto = ANY_OR_OMIT;
single_value->field_msg = ANY_VALUE;
}
}
}

void ASP__Send_template::copy_value(const ASP__Send& other_value)
{
single_value = new single_value_struct;
if (other_value.connId().is_bound()) {
  single_value->field_connId = other_value.connId();
} else {
  single_value->field_connId.clean_up();
}
if (other_value.proto().is_bound()) {
  if (other_value.proto().ispresent()) single_value->field_proto = other_value.proto()();
  else single_value->field_proto = OMIT_VALUE;
} else {
  single_value->field_proto.clean_up();
}
if (other_value.msg().is_bound()) {
  single_value->field_msg = other_value.msg();
} else {
  single_value->field_msg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__Send_template::copy_template(const ASP__Send_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msg().get_selection()) {
single_value->field_msg = other_value.msg();
} else {
single_value->field_msg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__Send_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
break;
}
set_selection(other_value);
}

ASP__Send_template::ASP__Send_template()
{
}

ASP__Send_template::ASP__Send_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__Send_template::ASP__Send_template(const ASP__Send& other_value)
{
copy_value(other_value);
}

ASP__Send_template::ASP__Send_template(const OPTIONAL<ASP__Send>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Send&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.ASP_Send from an unbound optional field.");
}
}

ASP__Send_template::ASP__Send_template(const ASP__Send_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__Send_template::~ASP__Send_template()
{
clean_up();
}

ASP__Send_template& ASP__Send_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__Send_template& ASP__Send_template::operator=(const ASP__Send& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__Send_template& ASP__Send_template::operator=(const OPTIONAL<ASP__Send>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__Send&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_Send.");
}
return *this;
}

ASP__Send_template& ASP__Send_template::operator=(const ASP__Send_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__Send_template::match(const ASP__Send& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connId().is_bound()) return FALSE;
if(!single_value->field_connId.match(other_value.connId(), legacy))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if((other_value.proto().ispresent() ? !single_value->field_proto.match((const Socket__API__Definitions::ProtoTuple&)other_value.proto(), legacy) : !single_value->field_proto.match_omit(legacy)))return FALSE;
if(!other_value.msg().is_bound()) return FALSE;
if(!single_value->field_msg.match(other_value.msg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
}
return FALSE;
}

boolean ASP__Send_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_proto.is_omit() || single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_msg.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__Send_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_proto.is_omit() && !single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_msg.is_value()) return FALSE;
return TRUE;
}

void ASP__Send_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__Send ASP__Send_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_Send.");
ASP__Send ret_val;
if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_proto.is_omit()) ret_val.proto() = OMIT_VALUE;
else if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_msg.is_bound()) {
ret_val.msg() = single_value->field_msg.valueof();
}
return ret_val;
}

void ASP__Send_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.ASP_Send.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__Send_template[list_length];
}

ASP__Send_template& ASP__Send_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_Send.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.ASP_Send.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__Send_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& ASP__Send_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_Send.");
return single_value->field_connId;
}

Socket__API__Definitions::ProtoTuple_template& ASP__Send_template::proto()
{
set_specific();
return single_value->field_proto;
}

const Socket__API__Definitions::ProtoTuple_template& ASP__Send_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_Send.");
return single_value->field_proto;
}

OCTETSTRING_template& ASP__Send_template::msg()
{
set_specific();
return single_value->field_msg;
}

const OCTETSTRING_template& ASP__Send_template::msg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_Send.");
return single_value->field_msg;
}

int ASP__Send_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_proto.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_Send containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
  }
  return 0;
}

void ASP__Send_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__Send_template::log_match(const ASP__Send& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.proto().ispresent()){
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_proto.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".proto := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_proto.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_msg.match(match_value.msg(), legacy)){
TTCN_Logger::log_logmatch_info(".msg");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::log_event_str(", proto := ");
if (match_value.proto().ispresent()) single_value->field_proto.log_match(match_value.proto(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_proto.log();
if (single_value->field_proto.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__Send_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connId.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_msg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_Send.");
}
}

void ASP__Send_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connId.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_msg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__Send_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_Send.");
}
}

void ASP__Send_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ASP__Send_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.ASP_Send has 3 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_Send: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.ASP_Send");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__Send_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_Send");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_Send");
single_value->field_msg.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_Send");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.ASP_Send");
}

boolean ASP__Send_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__Send_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__SendTo::ASP__SendTo()
{
}

ASP__SendTo::ASP__SendTo(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const OPTIONAL<Socket__API__Definitions::ProtoTuple>& par_proto,
    const OCTETSTRING& par_msg)
  :   field_connId(par_connId),
  field_remName(par_remName),
  field_remPort(par_remPort),
  field_proto(par_proto),
  field_msg(par_msg)
{
}

ASP__SendTo::ASP__SendTo(const ASP__SendTo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.ASP_SendTo.");
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.remName().is_bound()) field_remName = other_value.remName();
else field_remName.clean_up();
if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
else field_remPort.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.msg().is_bound()) field_msg = other_value.msg();
else field_msg.clean_up();
}

void ASP__SendTo::clean_up()
{
field_connId.clean_up();
field_remName.clean_up();
field_remPort.clean_up();
field_proto.clean_up();
field_msg.clean_up();
}

ASP__SendTo& ASP__SendTo::operator=(const ASP__SendTo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.ASP_SendTo.");
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.remName().is_bound()) field_remName = other_value.remName();
  else field_remName.clean_up();
  if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
  else field_remPort.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.msg().is_bound()) field_msg = other_value.msg();
  else field_msg.clean_up();
}
return *this;
}

boolean ASP__SendTo::operator==(const ASP__SendTo& other_value) const
{
return field_connId==other_value.field_connId
  && field_remName==other_value.field_remName
  && field_remPort==other_value.field_remPort
  && field_proto==other_value.field_proto
  && field_msg==other_value.field_msg;
}

boolean ASP__SendTo::is_bound() const
{
if(field_connId.is_bound()) return TRUE;
if(field_remName.is_bound()) return TRUE;
if(field_remPort.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_proto.get_selection() || field_proto.is_bound()) return TRUE;
if(field_msg.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__SendTo::is_value() const
{
if(!field_connId.is_value()) return FALSE;
if(!field_remName.is_value()) return FALSE;
if(!field_remPort.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_proto.get_selection() && !field_proto.is_value()) return FALSE;
if(!field_msg.is_value()) return FALSE;
return TRUE;
}
int ASP__SendTo::size_of() const
{
  int ret_val = 4;
  if (field_proto.ispresent()) ret_val++;
  return ret_val;
}

void ASP__SendTo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
field_remPort.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", msg := ");
field_msg.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__SendTo::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.ASP_SendTo has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_SendTo: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.ASP_SendTo");
  }
}

void ASP__SendTo::set_implicit_omit()
{
if (connId().is_bound()) connId().set_implicit_omit();
if (remName().is_bound()) remName().set_implicit_omit();
if (remPort().is_bound()) remPort().set_implicit_omit();
if (!proto().is_bound()) proto() = OMIT_VALUE;
else proto().set_implicit_omit();
if (msg().is_bound()) msg().set_implicit_omit();
}

void ASP__SendTo::encode_text(Text_Buf& text_buf) const
{
field_connId.encode_text(text_buf);
field_remName.encode_text(text_buf);
field_remPort.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_msg.encode_text(text_buf);
}

void ASP__SendTo::decode_text(Text_Buf& text_buf)
{
field_connId.decode_text(text_buf);
field_remName.decode_text(text_buf);
field_remPort.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_msg.decode_text(text_buf);
}

struct ASP__SendTo_template::single_value_struct {
INTEGER_template field_connId;
CHARSTRING_template field_remName;
INTEGER_template field_remPort;
Socket__API__Definitions::ProtoTuple_template field_proto;
OCTETSTRING_template field_msg;
};

void ASP__SendTo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connId = ANY_VALUE;
single_value->field_remName = ANY_VALUE;
single_value->field_remPort = ANY_VALUE;
single_value->field_proto = ANY_OR_OMIT;
single_value->field_msg = ANY_VALUE;
}
}
}

void ASP__SendTo_template::copy_value(const ASP__SendTo& other_value)
{
single_value = new single_value_struct;
if (other_value.connId().is_bound()) {
  single_value->field_connId = other_value.connId();
} else {
  single_value->field_connId.clean_up();
}
if (other_value.remName().is_bound()) {
  single_value->field_remName = other_value.remName();
} else {
  single_value->field_remName.clean_up();
}
if (other_value.remPort().is_bound()) {
  single_value->field_remPort = other_value.remPort();
} else {
  single_value->field_remPort.clean_up();
}
if (other_value.proto().is_bound()) {
  if (other_value.proto().ispresent()) single_value->field_proto = other_value.proto()();
  else single_value->field_proto = OMIT_VALUE;
} else {
  single_value->field_proto.clean_up();
}
if (other_value.msg().is_bound()) {
  single_value->field_msg = other_value.msg();
} else {
  single_value->field_msg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__SendTo_template::copy_template(const ASP__SendTo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remName().get_selection()) {
single_value->field_remName = other_value.remName();
} else {
single_value->field_remName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remPort().get_selection()) {
single_value->field_remPort = other_value.remPort();
} else {
single_value->field_remPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msg().get_selection()) {
single_value->field_msg = other_value.msg();
} else {
single_value->field_msg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__SendTo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
break;
}
set_selection(other_value);
}

ASP__SendTo_template::ASP__SendTo_template()
{
}

ASP__SendTo_template::ASP__SendTo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__SendTo_template::ASP__SendTo_template(const ASP__SendTo& other_value)
{
copy_value(other_value);
}

ASP__SendTo_template::ASP__SendTo_template(const OPTIONAL<ASP__SendTo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__SendTo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.ASP_SendTo from an unbound optional field.");
}
}

ASP__SendTo_template::ASP__SendTo_template(const ASP__SendTo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__SendTo_template::~ASP__SendTo_template()
{
clean_up();
}

ASP__SendTo_template& ASP__SendTo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__SendTo_template& ASP__SendTo_template::operator=(const ASP__SendTo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__SendTo_template& ASP__SendTo_template::operator=(const OPTIONAL<ASP__SendTo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__SendTo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_SendTo.");
}
return *this;
}

ASP__SendTo_template& ASP__SendTo_template::operator=(const ASP__SendTo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__SendTo_template::match(const ASP__SendTo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connId().is_bound()) return FALSE;
if(!single_value->field_connId.match(other_value.connId(), legacy))return FALSE;
if(!other_value.remName().is_bound()) return FALSE;
if(!single_value->field_remName.match(other_value.remName(), legacy))return FALSE;
if(!other_value.remPort().is_bound()) return FALSE;
if(!single_value->field_remPort.match(other_value.remPort(), legacy))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if((other_value.proto().ispresent() ? !single_value->field_proto.match((const Socket__API__Definitions::ProtoTuple&)other_value.proto(), legacy) : !single_value->field_proto.match_omit(legacy)))return FALSE;
if(!other_value.msg().is_bound()) return FALSE;
if(!single_value->field_msg.match(other_value.msg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
}
return FALSE;
}

boolean ASP__SendTo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_remName.is_bound()) return TRUE;
if (single_value->field_remPort.is_bound()) return TRUE;
if (single_value->field_proto.is_omit() || single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_msg.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__SendTo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_remName.is_value()) return FALSE;
if (!single_value->field_remPort.is_value()) return FALSE;
if (!single_value->field_proto.is_omit() && !single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_msg.is_value()) return FALSE;
return TRUE;
}

void ASP__SendTo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__SendTo ASP__SendTo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
ASP__SendTo ret_val;
if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_remName.is_bound()) {
ret_val.remName() = single_value->field_remName.valueof();
}
if (single_value->field_remPort.is_bound()) {
ret_val.remPort() = single_value->field_remPort.valueof();
}
if (single_value->field_proto.is_omit()) ret_val.proto() = OMIT_VALUE;
else if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_msg.is_bound()) {
ret_val.msg() = single_value->field_msg.valueof();
}
return ret_val;
}

void ASP__SendTo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.ASP_SendTo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__SendTo_template[list_length];
}

ASP__SendTo_template& ASP__SendTo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_SendTo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.ASP_SendTo.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__SendTo_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& ASP__SendTo_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
return single_value->field_connId;
}

CHARSTRING_template& ASP__SendTo_template::remName()
{
set_specific();
return single_value->field_remName;
}

const CHARSTRING_template& ASP__SendTo_template::remName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remName of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
return single_value->field_remName;
}

INTEGER_template& ASP__SendTo_template::remPort()
{
set_specific();
return single_value->field_remPort;
}

const INTEGER_template& ASP__SendTo_template::remPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remPort of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
return single_value->field_remPort;
}

Socket__API__Definitions::ProtoTuple_template& ASP__SendTo_template::proto()
{
set_specific();
return single_value->field_proto;
}

const Socket__API__Definitions::ProtoTuple_template& ASP__SendTo_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
return single_value->field_proto;
}

OCTETSTRING_template& ASP__SendTo_template::msg()
{
set_specific();
return single_value->field_msg;
}

const OCTETSTRING_template& ASP__SendTo_template::msg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_SendTo.");
return single_value->field_msg;
}

int ASP__SendTo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 4;
      if (single_value->field_proto.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_SendTo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
  }
  return 0;
}

void ASP__SendTo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__SendTo_template::log_match(const ASP__SendTo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remName.match(match_value.remName(), legacy)){
TTCN_Logger::log_logmatch_info(".remName");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remPort.match(match_value.remPort(), legacy)){
TTCN_Logger::log_logmatch_info(".remPort");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.proto().ispresent()){
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_proto.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".proto := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_proto.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_msg.match(match_value.msg(), legacy)){
TTCN_Logger::log_logmatch_info(".msg");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::log_event_str(", proto := ");
if (match_value.proto().ispresent()) single_value->field_proto.log_match(match_value.proto(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_proto.log();
if (single_value->field_proto.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__SendTo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connId.encode_text(text_buf);
single_value->field_remName.encode_text(text_buf);
single_value->field_remPort.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_msg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_SendTo.");
}
}

void ASP__SendTo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connId.decode_text(text_buf);
single_value->field_remName.decode_text(text_buf);
single_value->field_remPort.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_msg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__SendTo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_SendTo.");
}
}

void ASP__SendTo_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ASP__SendTo_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.ASP_SendTo has 5 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_SendTo: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.ASP_SendTo");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__SendTo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
single_value->field_remName.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
single_value->field_remPort.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
single_value->field_msg.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.ASP_SendTo");
}

boolean ASP__SendTo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__SendTo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ASP__RecvFrom::ASP__RecvFrom()
{
}

ASP__RecvFrom::ASP__RecvFrom(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const CHARSTRING& par_locName,
    const INTEGER& par_locPort,
    const Socket__API__Definitions::ProtoTuple& par_proto,
    const INTEGER& par_userData,
    const OCTETSTRING& par_msg)
  :   field_connId(par_connId),
  field_remName(par_remName),
  field_remPort(par_remPort),
  field_locName(par_locName),
  field_locPort(par_locPort),
  field_proto(par_proto),
  field_userData(par_userData),
  field_msg(par_msg)
{
}

ASP__RecvFrom::ASP__RecvFrom(const ASP__RecvFrom& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.ASP_RecvFrom.");
if (other_value.connId().is_bound()) field_connId = other_value.connId();
else field_connId.clean_up();
if (other_value.remName().is_bound()) field_remName = other_value.remName();
else field_remName.clean_up();
if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
else field_remPort.clean_up();
if (other_value.locName().is_bound()) field_locName = other_value.locName();
else field_locName.clean_up();
if (other_value.locPort().is_bound()) field_locPort = other_value.locPort();
else field_locPort.clean_up();
if (other_value.proto().is_bound()) field_proto = other_value.proto();
else field_proto.clean_up();
if (other_value.userData().is_bound()) field_userData = other_value.userData();
else field_userData.clean_up();
if (other_value.msg().is_bound()) field_msg = other_value.msg();
else field_msg.clean_up();
}

void ASP__RecvFrom::clean_up()
{
field_connId.clean_up();
field_remName.clean_up();
field_remPort.clean_up();
field_locName.clean_up();
field_locPort.clean_up();
field_proto.clean_up();
field_userData.clean_up();
field_msg.clean_up();
}

ASP__RecvFrom& ASP__RecvFrom::operator=(const ASP__RecvFrom& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.ASP_RecvFrom.");
  if (other_value.connId().is_bound()) field_connId = other_value.connId();
  else field_connId.clean_up();
  if (other_value.remName().is_bound()) field_remName = other_value.remName();
  else field_remName.clean_up();
  if (other_value.remPort().is_bound()) field_remPort = other_value.remPort();
  else field_remPort.clean_up();
  if (other_value.locName().is_bound()) field_locName = other_value.locName();
  else field_locName.clean_up();
  if (other_value.locPort().is_bound()) field_locPort = other_value.locPort();
  else field_locPort.clean_up();
  if (other_value.proto().is_bound()) field_proto = other_value.proto();
  else field_proto.clean_up();
  if (other_value.userData().is_bound()) field_userData = other_value.userData();
  else field_userData.clean_up();
  if (other_value.msg().is_bound()) field_msg = other_value.msg();
  else field_msg.clean_up();
}
return *this;
}

boolean ASP__RecvFrom::operator==(const ASP__RecvFrom& other_value) const
{
return field_connId==other_value.field_connId
  && field_remName==other_value.field_remName
  && field_remPort==other_value.field_remPort
  && field_locName==other_value.field_locName
  && field_locPort==other_value.field_locPort
  && field_proto==other_value.field_proto
  && field_userData==other_value.field_userData
  && field_msg==other_value.field_msg;
}

boolean ASP__RecvFrom::is_bound() const
{
if(field_connId.is_bound()) return TRUE;
if(field_remName.is_bound()) return TRUE;
if(field_remPort.is_bound()) return TRUE;
if(field_locName.is_bound()) return TRUE;
if(field_locPort.is_bound()) return TRUE;
if(field_proto.is_bound()) return TRUE;
if(field_userData.is_bound()) return TRUE;
if(field_msg.is_bound()) return TRUE;
return FALSE;
}
boolean ASP__RecvFrom::is_value() const
{
if(!field_connId.is_value()) return FALSE;
if(!field_remName.is_value()) return FALSE;
if(!field_remPort.is_value()) return FALSE;
if(!field_locName.is_value()) return FALSE;
if(!field_locPort.is_value()) return FALSE;
if(!field_proto.is_value()) return FALSE;
if(!field_userData.is_value()) return FALSE;
if(!field_msg.is_value()) return FALSE;
return TRUE;
}
void ASP__RecvFrom::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ connId := ");
field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
field_remPort.log();
TTCN_Logger::log_event_str(", locName := ");
field_locName.log();
TTCN_Logger::log_event_str(", locPort := ");
field_locPort.log();
TTCN_Logger::log_event_str(", proto := ");
field_proto.log();
TTCN_Logger::log_event_str(", userData := ");
field_userData.log();
TTCN_Logger::log_event_str(", msg := ");
field_msg.log();
TTCN_Logger::log_event_str(" }");
}

void ASP__RecvFrom::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (8<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.ASP_RecvFrom has 8 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) locName().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) locPort().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) userData().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userData().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_RecvFrom: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.ASP_RecvFrom");
  }
}

void ASP__RecvFrom::set_implicit_omit()
{
if (connId().is_bound()) connId().set_implicit_omit();
if (remName().is_bound()) remName().set_implicit_omit();
if (remPort().is_bound()) remPort().set_implicit_omit();
if (locName().is_bound()) locName().set_implicit_omit();
if (locPort().is_bound()) locPort().set_implicit_omit();
if (proto().is_bound()) proto().set_implicit_omit();
if (userData().is_bound()) userData().set_implicit_omit();
if (msg().is_bound()) msg().set_implicit_omit();
}

void ASP__RecvFrom::encode_text(Text_Buf& text_buf) const
{
field_connId.encode_text(text_buf);
field_remName.encode_text(text_buf);
field_remPort.encode_text(text_buf);
field_locName.encode_text(text_buf);
field_locPort.encode_text(text_buf);
field_proto.encode_text(text_buf);
field_userData.encode_text(text_buf);
field_msg.encode_text(text_buf);
}

void ASP__RecvFrom::decode_text(Text_Buf& text_buf)
{
field_connId.decode_text(text_buf);
field_remName.decode_text(text_buf);
field_remPort.decode_text(text_buf);
field_locName.decode_text(text_buf);
field_locPort.decode_text(text_buf);
field_proto.decode_text(text_buf);
field_userData.decode_text(text_buf);
field_msg.decode_text(text_buf);
}

struct ASP__RecvFrom_template::single_value_struct {
INTEGER_template field_connId;
CHARSTRING_template field_remName;
INTEGER_template field_remPort;
CHARSTRING_template field_locName;
INTEGER_template field_locPort;
Socket__API__Definitions::ProtoTuple_template field_proto;
INTEGER_template field_userData;
OCTETSTRING_template field_msg;
};

void ASP__RecvFrom_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_connId = ANY_VALUE;
single_value->field_remName = ANY_VALUE;
single_value->field_remPort = ANY_VALUE;
single_value->field_locName = ANY_VALUE;
single_value->field_locPort = ANY_VALUE;
single_value->field_proto = ANY_VALUE;
single_value->field_userData = ANY_VALUE;
single_value->field_msg = ANY_VALUE;
}
}
}

void ASP__RecvFrom_template::copy_value(const ASP__RecvFrom& other_value)
{
single_value = new single_value_struct;
if (other_value.connId().is_bound()) {
  single_value->field_connId = other_value.connId();
} else {
  single_value->field_connId.clean_up();
}
if (other_value.remName().is_bound()) {
  single_value->field_remName = other_value.remName();
} else {
  single_value->field_remName.clean_up();
}
if (other_value.remPort().is_bound()) {
  single_value->field_remPort = other_value.remPort();
} else {
  single_value->field_remPort.clean_up();
}
if (other_value.locName().is_bound()) {
  single_value->field_locName = other_value.locName();
} else {
  single_value->field_locName.clean_up();
}
if (other_value.locPort().is_bound()) {
  single_value->field_locPort = other_value.locPort();
} else {
  single_value->field_locPort.clean_up();
}
if (other_value.proto().is_bound()) {
  single_value->field_proto = other_value.proto();
} else {
  single_value->field_proto.clean_up();
}
if (other_value.userData().is_bound()) {
  single_value->field_userData = other_value.userData();
} else {
  single_value->field_userData.clean_up();
}
if (other_value.msg().is_bound()) {
  single_value->field_msg = other_value.msg();
} else {
  single_value->field_msg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ASP__RecvFrom_template::copy_template(const ASP__RecvFrom_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.connId().get_selection()) {
single_value->field_connId = other_value.connId();
} else {
single_value->field_connId.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remName().get_selection()) {
single_value->field_remName = other_value.remName();
} else {
single_value->field_remName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remPort().get_selection()) {
single_value->field_remPort = other_value.remPort();
} else {
single_value->field_remPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.locName().get_selection()) {
single_value->field_locName = other_value.locName();
} else {
single_value->field_locName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.locPort().get_selection()) {
single_value->field_locPort = other_value.locPort();
} else {
single_value->field_locPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.proto().get_selection()) {
single_value->field_proto = other_value.proto();
} else {
single_value->field_proto.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.userData().get_selection()) {
single_value->field_userData = other_value.userData();
} else {
single_value->field_userData.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.msg().get_selection()) {
single_value->field_msg = other_value.msg();
} else {
single_value->field_msg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ASP__RecvFrom_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
break;
}
set_selection(other_value);
}

ASP__RecvFrom_template::ASP__RecvFrom_template()
{
}

ASP__RecvFrom_template::ASP__RecvFrom_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ASP__RecvFrom_template::ASP__RecvFrom_template(const ASP__RecvFrom& other_value)
{
copy_value(other_value);
}

ASP__RecvFrom_template::ASP__RecvFrom_template(const OPTIONAL<ASP__RecvFrom>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__RecvFrom&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.ASP_RecvFrom from an unbound optional field.");
}
}

ASP__RecvFrom_template::ASP__RecvFrom_template(const ASP__RecvFrom_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ASP__RecvFrom_template::~ASP__RecvFrom_template()
{
clean_up();
}

ASP__RecvFrom_template& ASP__RecvFrom_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ASP__RecvFrom_template& ASP__RecvFrom_template::operator=(const ASP__RecvFrom& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ASP__RecvFrom_template& ASP__RecvFrom_template::operator=(const OPTIONAL<ASP__RecvFrom>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ASP__RecvFrom&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.ASP_RecvFrom.");
}
return *this;
}

ASP__RecvFrom_template& ASP__RecvFrom_template::operator=(const ASP__RecvFrom_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ASP__RecvFrom_template::match(const ASP__RecvFrom& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.connId().is_bound()) return FALSE;
if(!single_value->field_connId.match(other_value.connId(), legacy))return FALSE;
if(!other_value.remName().is_bound()) return FALSE;
if(!single_value->field_remName.match(other_value.remName(), legacy))return FALSE;
if(!other_value.remPort().is_bound()) return FALSE;
if(!single_value->field_remPort.match(other_value.remPort(), legacy))return FALSE;
if(!other_value.locName().is_bound()) return FALSE;
if(!single_value->field_locName.match(other_value.locName(), legacy))return FALSE;
if(!other_value.locPort().is_bound()) return FALSE;
if(!single_value->field_locPort.match(other_value.locPort(), legacy))return FALSE;
if(!other_value.proto().is_bound()) return FALSE;
if(!single_value->field_proto.match(other_value.proto(), legacy))return FALSE;
if(!other_value.userData().is_bound()) return FALSE;
if(!single_value->field_userData.match(other_value.userData(), legacy))return FALSE;
if(!other_value.msg().is_bound()) return FALSE;
if(!single_value->field_msg.match(other_value.msg(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
}
return FALSE;
}

boolean ASP__RecvFrom_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_connId.is_bound()) return TRUE;
if (single_value->field_remName.is_bound()) return TRUE;
if (single_value->field_remPort.is_bound()) return TRUE;
if (single_value->field_locName.is_bound()) return TRUE;
if (single_value->field_locPort.is_bound()) return TRUE;
if (single_value->field_proto.is_bound()) return TRUE;
if (single_value->field_userData.is_bound()) return TRUE;
if (single_value->field_msg.is_bound()) return TRUE;
return FALSE;
}

boolean ASP__RecvFrom_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_connId.is_value()) return FALSE;
if (!single_value->field_remName.is_value()) return FALSE;
if (!single_value->field_remPort.is_value()) return FALSE;
if (!single_value->field_locName.is_value()) return FALSE;
if (!single_value->field_locPort.is_value()) return FALSE;
if (!single_value->field_proto.is_value()) return FALSE;
if (!single_value->field_userData.is_value()) return FALSE;
if (!single_value->field_msg.is_value()) return FALSE;
return TRUE;
}

void ASP__RecvFrom_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ASP__RecvFrom ASP__RecvFrom_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
ASP__RecvFrom ret_val;
if (single_value->field_connId.is_bound()) {
ret_val.connId() = single_value->field_connId.valueof();
}
if (single_value->field_remName.is_bound()) {
ret_val.remName() = single_value->field_remName.valueof();
}
if (single_value->field_remPort.is_bound()) {
ret_val.remPort() = single_value->field_remPort.valueof();
}
if (single_value->field_locName.is_bound()) {
ret_val.locName() = single_value->field_locName.valueof();
}
if (single_value->field_locPort.is_bound()) {
ret_val.locPort() = single_value->field_locPort.valueof();
}
if (single_value->field_proto.is_bound()) {
ret_val.proto() = single_value->field_proto.valueof();
}
if (single_value->field_userData.is_bound()) {
ret_val.userData() = single_value->field_userData.valueof();
}
if (single_value->field_msg.is_bound()) {
ret_val.msg() = single_value->field_msg.valueof();
}
return ret_val;
}

void ASP__RecvFrom_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.ASP_RecvFrom.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ASP__RecvFrom_template[list_length];
}

ASP__RecvFrom_template& ASP__RecvFrom_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.ASP_RecvFrom.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.ASP_RecvFrom.");
return value_list.list_value[list_index];
}

INTEGER_template& ASP__RecvFrom_template::connId()
{
set_specific();
return single_value->field_connId;
}

const INTEGER_template& ASP__RecvFrom_template::connId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field connId of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_connId;
}

CHARSTRING_template& ASP__RecvFrom_template::remName()
{
set_specific();
return single_value->field_remName;
}

const CHARSTRING_template& ASP__RecvFrom_template::remName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remName of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_remName;
}

INTEGER_template& ASP__RecvFrom_template::remPort()
{
set_specific();
return single_value->field_remPort;
}

const INTEGER_template& ASP__RecvFrom_template::remPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remPort of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_remPort;
}

CHARSTRING_template& ASP__RecvFrom_template::locName()
{
set_specific();
return single_value->field_locName;
}

const CHARSTRING_template& ASP__RecvFrom_template::locName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field locName of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_locName;
}

INTEGER_template& ASP__RecvFrom_template::locPort()
{
set_specific();
return single_value->field_locPort;
}

const INTEGER_template& ASP__RecvFrom_template::locPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field locPort of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_locPort;
}

Socket__API__Definitions::ProtoTuple_template& ASP__RecvFrom_template::proto()
{
set_specific();
return single_value->field_proto;
}

const Socket__API__Definitions::ProtoTuple_template& ASP__RecvFrom_template::proto() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field proto of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_proto;
}

INTEGER_template& ASP__RecvFrom_template::userData()
{
set_specific();
return single_value->field_userData;
}

const INTEGER_template& ASP__RecvFrom_template::userData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field userData of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_userData;
}

OCTETSTRING_template& ASP__RecvFrom_template::msg()
{
set_specific();
return single_value->field_msg;
}

const OCTETSTRING_template& ASP__RecvFrom_template::msg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msg of a non-specific template of type @IPL4asp_Types.ASP_RecvFrom.");
return single_value->field_msg;
}

int ASP__RecvFrom_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 8;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.ASP_RecvFrom containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
  }
  return 0;
}

void ASP__RecvFrom_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log();
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log();
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log();
TTCN_Logger::log_event_str(", locName := ");
single_value->field_locName.log();
TTCN_Logger::log_event_str(", locPort := ");
single_value->field_locPort.log();
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log();
TTCN_Logger::log_event_str(", userData := ");
single_value->field_userData.log();
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ASP__RecvFrom_template::log_match(const ASP__RecvFrom& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_connId.match(match_value.connId(), legacy)){
TTCN_Logger::log_logmatch_info(".connId");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remName.match(match_value.remName(), legacy)){
TTCN_Logger::log_logmatch_info(".remName");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remPort.match(match_value.remPort(), legacy)){
TTCN_Logger::log_logmatch_info(".remPort");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_locName.match(match_value.locName(), legacy)){
TTCN_Logger::log_logmatch_info(".locName");
single_value->field_locName.log_match(match_value.locName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_locPort.match(match_value.locPort(), legacy)){
TTCN_Logger::log_logmatch_info(".locPort");
single_value->field_locPort.log_match(match_value.locPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_proto.match(match_value.proto(), legacy)){
TTCN_Logger::log_logmatch_info(".proto");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_userData.match(match_value.userData(), legacy)){
TTCN_Logger::log_logmatch_info(".userData");
single_value->field_userData.log_match(match_value.userData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_msg.match(match_value.msg(), legacy)){
TTCN_Logger::log_logmatch_info(".msg");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ connId := ");
single_value->field_connId.log_match(match_value.connId(), legacy);
TTCN_Logger::log_event_str(", remName := ");
single_value->field_remName.log_match(match_value.remName(), legacy);
TTCN_Logger::log_event_str(", remPort := ");
single_value->field_remPort.log_match(match_value.remPort(), legacy);
TTCN_Logger::log_event_str(", locName := ");
single_value->field_locName.log_match(match_value.locName(), legacy);
TTCN_Logger::log_event_str(", locPort := ");
single_value->field_locPort.log_match(match_value.locPort(), legacy);
TTCN_Logger::log_event_str(", proto := ");
single_value->field_proto.log_match(match_value.proto(), legacy);
TTCN_Logger::log_event_str(", userData := ");
single_value->field_userData.log_match(match_value.userData(), legacy);
TTCN_Logger::log_event_str(", msg := ");
single_value->field_msg.log_match(match_value.msg(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ASP__RecvFrom_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_connId.encode_text(text_buf);
single_value->field_remName.encode_text(text_buf);
single_value->field_remPort.encode_text(text_buf);
single_value->field_locName.encode_text(text_buf);
single_value->field_locPort.encode_text(text_buf);
single_value->field_proto.encode_text(text_buf);
single_value->field_userData.encode_text(text_buf);
single_value->field_msg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.ASP_RecvFrom.");
}
}

void ASP__RecvFrom_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_connId.decode_text(text_buf);
single_value->field_remName.decode_text(text_buf);
single_value->field_remPort.decode_text(text_buf);
single_value->field_locName.decode_text(text_buf);
single_value->field_locPort.decode_text(text_buf);
single_value->field_proto.decode_text(text_buf);
single_value->field_userData.decode_text(text_buf);
single_value->field_msg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ASP__RecvFrom_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.ASP_RecvFrom.");
}
}

void ASP__RecvFrom_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ASP__RecvFrom_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.ASP_RecvFrom has 8 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) connId().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remName().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) remPort().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) locName().set_param(*param.get_elem(3));
    if (param.get_size()>4 && param.get_elem(4)->get_type()!=Module_Param::MP_NotUsed) locPort().set_param(*param.get_elem(4));
    if (param.get_size()>5 && param.get_elem(5)->get_type()!=Module_Param::MP_NotUsed) proto().set_param(*param.get_elem(5));
    if (param.get_size()>6 && param.get_elem(6)->get_type()!=Module_Param::MP_NotUsed) userData().set_param(*param.get_elem(6));
    if (param.get_size()>7 && param.get_elem(7)->get_type()!=Module_Param::MP_NotUsed) msg().set_param(*param.get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "connId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          connId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locName().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "locPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          locPort().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "proto")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          proto().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "userData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          userData().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msg().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.ASP_RecvFrom: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.ASP_RecvFrom");
  }
  is_ifpresent = param.get_ifpresent();
}

void ASP__RecvFrom_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_connId.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_remName.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_remPort.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_locName.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_locPort.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_proto.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_userData.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
single_value->field_msg.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.ASP_RecvFrom");
}

boolean ASP__RecvFrom_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ASP__RecvFrom_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

IPL4__Param::IPL4__Param()
{
enum_value = UNBOUND_VALUE;
}

IPL4__Param::IPL4__Param(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @IPL4asp_Types.IPL4_Param with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

IPL4__Param::IPL4__Param(enum_type other_value)
{
enum_value = other_value;
}

IPL4__Param::IPL4__Param(const IPL4__Param& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
enum_value = other_value.enum_value;
}

IPL4__Param& IPL4__Param::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_Param.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

IPL4__Param& IPL4__Param::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

IPL4__Param& IPL4__Param::operator=(const IPL4__Param& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
enum_value = other_value.enum_value;
return *this;
}

boolean IPL4__Param::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value == other_value;
}

boolean IPL4__Param::operator==(const IPL4__Param& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value == other_value.enum_value;
}

boolean IPL4__Param::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value < other_value;
}

boolean IPL4__Param::operator<(const IPL4__Param& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value < other_value.enum_value;
}

boolean IPL4__Param::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value > other_value;
}

boolean IPL4__Param::operator>(const IPL4__Param& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value > other_value.enum_value;
}

const char *IPL4__Param::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case IPL4__LOCALADDRESS: return "IPL4_LOCALADDRESS";
case IPL4__REMOTEADDRESS: return "IPL4_REMOTEADDRESS";
case IPL4__PROTO: return "IPL4_PROTO";
case IPL4__USERDATA: return "IPL4_USERDATA";
case IPL4__PARENTIDX: return "IPL4_PARENTIDX";
default: return "<unknown>";
}
}

IPL4__Param::enum_type IPL4__Param::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "IPL4_LOCALADDRESS")) return IPL4__LOCALADDRESS;
else if (!strcmp(str_par, "IPL4_REMOTEADDRESS")) return IPL4__REMOTEADDRESS;
else if (!strcmp(str_par, "IPL4_PROTO")) return IPL4__PROTO;
else if (!strcmp(str_par, "IPL4_USERDATA")) return IPL4__USERDATA;
else if (!strcmp(str_par, "IPL4_PARENTIDX")) return IPL4__PARENTIDX;
else return UNKNOWN_VALUE;
}

boolean IPL4__Param::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int IPL4__Param::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_Param.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int IPL4__Param::enum2int(const IPL4__Param& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_Param.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void IPL4__Param::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_Param.", int_val);
enum_value = (enum_type)int_val;
}

IPL4__Param::operator IPL4__Param::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @IPL4asp_Types.IPL4_Param.");
return enum_value;
}

void IPL4__Param::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void IPL4__Param::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@IPL4asp_Types.IPL4_Param");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_Param.");
  }
}

void IPL4__Param::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
text_buf.push_int(enum_value);
}

void IPL4__Param::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @IPL4asp_Types.IPL4_Param.", enum_value);
}

void IPL4__Param_template::copy_template(const IPL4__Param_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPL4__Param_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
}
}

IPL4__Param_template::IPL4__Param_template()
{
}

IPL4__Param_template::IPL4__Param_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPL4__Param_template::IPL4__Param_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!IPL4__Param::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @IPL4asp_Types.IPL4_Param with unknown numeric value %d.", other_value);
single_value = (IPL4__Param::enum_type)other_value;
}

IPL4__Param_template::IPL4__Param_template(IPL4__Param::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

IPL4__Param_template::IPL4__Param_template(const IPL4__Param& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == IPL4__Param::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_Param.");
single_value = other_value.enum_value;
}

IPL4__Param_template::IPL4__Param_template(const OPTIONAL<IPL4__Param>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__Param::enum_type)(const IPL4__Param&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @IPL4asp_Types.IPL4_Param from an unbound optional field.");
}
}

IPL4__Param_template::IPL4__Param_template(const IPL4__Param_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

IPL4__Param_template::~IPL4__Param_template()
{
clean_up();
}

boolean IPL4__Param_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean IPL4__Param_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != IPL4__Param::UNBOUND_VALUE;
}

void IPL4__Param_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

IPL4__Param_template& IPL4__Param_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPL4__Param_template& IPL4__Param_template::operator=(int other_value)
{
if (!IPL4__Param::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @IPL4asp_Types.IPL4_Param.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__Param::enum_type)other_value;
return *this;
}

IPL4__Param_template& IPL4__Param_template::operator=(IPL4__Param::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

IPL4__Param_template& IPL4__Param_template::operator=(const IPL4__Param& other_value)
{
if (other_value.enum_value == IPL4__Param::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_Param to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

IPL4__Param_template& IPL4__Param_template::operator=(const OPTIONAL<IPL4__Param>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__Param::enum_type)(const IPL4__Param&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @IPL4asp_Types.IPL4_Param.");
}
return *this;
}

IPL4__Param_template& IPL4__Param_template::operator=(const IPL4__Param_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPL4__Param_template::match(IPL4__Param::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
}
return FALSE;
}

boolean IPL4__Param_template::match(const IPL4__Param& other_value, boolean) const
{
if (other_value.enum_value == IPL4__Param::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @IPL4asp_Types.IPL4_Param with an unbound value.");
return match(other_value.enum_value);
}

IPL4__Param::enum_type IPL4__Param_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_Param.");
return single_value;
}

void IPL4__Param_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_Param.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPL4__Param_template[list_length];
}

IPL4__Param_template& IPL4__Param_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @IPL4asp_Types.IPL4_Param.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_Param.");
return value_list.list_value[list_index];
}

void IPL4__Param_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(IPL4__Param::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPL4__Param_template::log_match(const IPL4__Param& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void IPL4__Param_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_Param.");
}
}

void IPL4__Param_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (IPL4__Param::enum_type)text_buf.pull_int().get_val();
if (!IPL4__Param::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @IPL4asp_Types.IPL4_Param.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPL4__Param_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_Param.");
}
}

boolean IPL4__Param_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IPL4__Param_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IPL4__Param_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IPL4__Param_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    IPL4__Param::enum_type enum_val = IPL4__Param::str_to_enum(m_p->get_enumerated());
    if (!IPL4__Param::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_Param.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@IPL4asp_Types.IPL4_Param");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPL4__Param_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.IPL4_Param");
}

void IPL4__ParamResult::copy_value(const IPL4__ParamResult& other_value)
{
switch (other_value.union_selection) {
case ALT_local:
field_local = new Socket__API__Definitions::Socket(*other_value.field_local);
break;
case ALT_remote:
field_remote = new Socket__API__Definitions::Socket(*other_value.field_remote);
break;
case ALT_proto:
field_proto = new Socket__API__Definitions::ProtoTuple(*other_value.field_proto);
break;
case ALT_userData:
field_userData = new INTEGER(*other_value.field_userData);
break;
case ALT_parentIdx:
field_parentIdx = new INTEGER(*other_value.field_parentIdx);
break;
default:
TTCN_error("Assignment of an unbound union value of type @IPL4asp_Types.IPL4_ParamResult.");
}
union_selection = other_value.union_selection;
}

IPL4__ParamResult::IPL4__ParamResult()
{
union_selection = UNBOUND_VALUE;
}

IPL4__ParamResult::IPL4__ParamResult(const IPL4__ParamResult& other_value)
: Base_Type(){
copy_value(other_value);
}

IPL4__ParamResult::~IPL4__ParamResult()
{
clean_up();
}

IPL4__ParamResult& IPL4__ParamResult::operator=(const IPL4__ParamResult& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean IPL4__ParamResult::operator==(const IPL4__ParamResult& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @IPL4asp_Types.IPL4_ParamResult.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @IPL4asp_Types.IPL4_ParamResult.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_local:
return *field_local == *other_value.field_local;
case ALT_remote:
return *field_remote == *other_value.field_remote;
case ALT_proto:
return *field_proto == *other_value.field_proto;
case ALT_userData:
return *field_userData == *other_value.field_userData;
case ALT_parentIdx:
return *field_parentIdx == *other_value.field_parentIdx;
default:
return FALSE;
}
}

Socket__API__Definitions::Socket& IPL4__ParamResult::local()
{
if (union_selection != ALT_local) {
clean_up();
field_local = new Socket__API__Definitions::Socket;
union_selection = ALT_local;
}
return *field_local;
}

const Socket__API__Definitions::Socket& IPL4__ParamResult::local() const
{
if (union_selection != ALT_local) TTCN_error("Using non-selected field local in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
return *field_local;
}

Socket__API__Definitions::Socket& IPL4__ParamResult::remote()
{
if (union_selection != ALT_remote) {
clean_up();
field_remote = new Socket__API__Definitions::Socket;
union_selection = ALT_remote;
}
return *field_remote;
}

const Socket__API__Definitions::Socket& IPL4__ParamResult::remote() const
{
if (union_selection != ALT_remote) TTCN_error("Using non-selected field remote in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
return *field_remote;
}

Socket__API__Definitions::ProtoTuple& IPL4__ParamResult::proto()
{
if (union_selection != ALT_proto) {
clean_up();
field_proto = new Socket__API__Definitions::ProtoTuple;
union_selection = ALT_proto;
}
return *field_proto;
}

const Socket__API__Definitions::ProtoTuple& IPL4__ParamResult::proto() const
{
if (union_selection != ALT_proto) TTCN_error("Using non-selected field proto in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
return *field_proto;
}

INTEGER& IPL4__ParamResult::userData()
{
if (union_selection != ALT_userData) {
clean_up();
field_userData = new INTEGER;
union_selection = ALT_userData;
}
return *field_userData;
}

const INTEGER& IPL4__ParamResult::userData() const
{
if (union_selection != ALT_userData) TTCN_error("Using non-selected field userData in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
return *field_userData;
}

INTEGER& IPL4__ParamResult::parentIdx()
{
if (union_selection != ALT_parentIdx) {
clean_up();
field_parentIdx = new INTEGER;
union_selection = ALT_parentIdx;
}
return *field_parentIdx;
}

const INTEGER& IPL4__ParamResult::parentIdx() const
{
if (union_selection != ALT_parentIdx) TTCN_error("Using non-selected field parentIdx in a value of union type @IPL4asp_Types.IPL4_ParamResult.");
return *field_parentIdx;
}

boolean IPL4__ParamResult::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.IPL4_ParamResult.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @IPL4asp_Types.IPL4_ParamResult.");
return union_selection == checked_selection;
}

boolean IPL4__ParamResult::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean IPL4__ParamResult::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_local: return field_local->is_value();
case ALT_remote: return field_remote->is_value();
case ALT_proto: return field_proto->is_value();
case ALT_userData: return field_userData->is_value();
case ALT_parentIdx: return field_parentIdx->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void IPL4__ParamResult::clean_up()
{
switch (union_selection) {
case ALT_local:
  delete field_local;
  break;
case ALT_remote:
  delete field_remote;
  break;
case ALT_proto:
  delete field_proto;
  break;
case ALT_userData:
  delete field_userData;
  break;
case ALT_parentIdx:
  delete field_parentIdx;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void IPL4__ParamResult::log() const
{
switch (union_selection) {
case ALT_local:
TTCN_Logger::log_event_str("{ local := ");
field_local->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_remote:
TTCN_Logger::log_event_str("{ remote := ");
field_remote->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_proto:
TTCN_Logger::log_event_str("{ proto := ");
field_proto->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_userData:
TTCN_Logger::log_event_str("{ userData := ");
field_userData->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_parentIdx:
TTCN_Logger::log_event_str("{ parentIdx := ");
field_parentIdx->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void IPL4__ParamResult::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "local")) {
    local().set_param(*mp_last);
    if (!local().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "remote")) {
    remote().set_param(*mp_last);
    if (!remote().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "proto")) {
    proto().set_param(*mp_last);
    if (!proto().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "userData")) {
    userData().set_param(*mp_last);
    if (!userData().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "parentIdx")) {
    parentIdx().set_param(*mp_last);
    if (!parentIdx().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @IPL4asp_Types.IPL4_ParamResult.", mp_last->get_id()->get_name());
}

void IPL4__ParamResult::set_implicit_omit()
{
switch (union_selection) {
case ALT_local:
field_local->set_implicit_omit(); break;
case ALT_remote:
field_remote->set_implicit_omit(); break;
case ALT_proto:
field_proto->set_implicit_omit(); break;
case ALT_userData:
field_userData->set_implicit_omit(); break;
case ALT_parentIdx:
field_parentIdx->set_implicit_omit(); break;
default: break;
}
}

void IPL4__ParamResult::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_local:
field_local->encode_text(text_buf);
break;
case ALT_remote:
field_remote->encode_text(text_buf);
break;
case ALT_proto:
field_proto->encode_text(text_buf);
break;
case ALT_userData:
field_userData->encode_text(text_buf);
break;
case ALT_parentIdx:
field_parentIdx->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @IPL4asp_Types.IPL4_ParamResult.");
}
}

void IPL4__ParamResult::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_local:
local().decode_text(text_buf);
break;
case ALT_remote:
remote().decode_text(text_buf);
break;
case ALT_proto:
proto().decode_text(text_buf);
break;
case ALT_userData:
userData().decode_text(text_buf);
break;
case ALT_parentIdx:
parentIdx().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @IPL4asp_Types.IPL4_ParamResult.");
}
}

void IPL4__ParamResult_template::copy_value(const IPL4__ParamResult& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
single_value.field_local = new Socket__API__Definitions::Socket_template(other_value.local());
break;
case IPL4__ParamResult::ALT_remote:
single_value.field_remote = new Socket__API__Definitions::Socket_template(other_value.remote());
break;
case IPL4__ParamResult::ALT_proto:
single_value.field_proto = new Socket__API__Definitions::ProtoTuple_template(other_value.proto());
break;
case IPL4__ParamResult::ALT_userData:
single_value.field_userData = new INTEGER_template(other_value.userData());
break;
case IPL4__ParamResult::ALT_parentIdx:
single_value.field_parentIdx = new INTEGER_template(other_value.parentIdx());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @IPL4asp_Types.IPL4_ParamResult.");
}
set_selection(SPECIFIC_VALUE);
}

void IPL4__ParamResult_template::copy_template(const IPL4__ParamResult_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
single_value.field_local = new Socket__API__Definitions::Socket_template(*other_value.single_value.field_local);
break;
case IPL4__ParamResult::ALT_remote:
single_value.field_remote = new Socket__API__Definitions::Socket_template(*other_value.single_value.field_remote);
break;
case IPL4__ParamResult::ALT_proto:
single_value.field_proto = new Socket__API__Definitions::ProtoTuple_template(*other_value.single_value.field_proto);
break;
case IPL4__ParamResult::ALT_userData:
single_value.field_userData = new INTEGER_template(*other_value.single_value.field_userData);
break;
case IPL4__ParamResult::ALT_parentIdx:
single_value.field_parentIdx = new INTEGER_template(*other_value.single_value.field_parentIdx);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @IPL4asp_Types.IPL4_ParamResult.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPL4__ParamResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
set_selection(other_value);
}

IPL4__ParamResult_template::IPL4__ParamResult_template()
{
}

IPL4__ParamResult_template::IPL4__ParamResult_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPL4__ParamResult_template::IPL4__ParamResult_template(const IPL4__ParamResult& other_value)
{
copy_value(other_value);
}

IPL4__ParamResult_template::IPL4__ParamResult_template(const OPTIONAL<IPL4__ParamResult>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPL4__ParamResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @IPL4asp_Types.IPL4_ParamResult from an unbound optional field.");
}
}

IPL4__ParamResult_template::IPL4__ParamResult_template(const IPL4__ParamResult_template& other_value)
: Base_Template(){
copy_template(other_value);
}

IPL4__ParamResult_template::~IPL4__ParamResult_template()
{
clean_up();
}

void IPL4__ParamResult_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
delete single_value.field_local;
break;
case IPL4__ParamResult::ALT_remote:
delete single_value.field_remote;
break;
case IPL4__ParamResult::ALT_proto:
delete single_value.field_proto;
break;
case IPL4__ParamResult::ALT_userData:
delete single_value.field_userData;
break;
case IPL4__ParamResult::ALT_parentIdx:
delete single_value.field_parentIdx;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPL4__ParamResult_template& IPL4__ParamResult_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPL4__ParamResult_template& IPL4__ParamResult_template::operator=(const IPL4__ParamResult& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPL4__ParamResult_template& IPL4__ParamResult_template::operator=(const OPTIONAL<IPL4__ParamResult>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPL4__ParamResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
return *this;
}

IPL4__ParamResult_template& IPL4__ParamResult_template::operator=(const IPL4__ParamResult_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPL4__ParamResult_template::match(const IPL4__ParamResult& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
IPL4__ParamResult::union_selection_type value_selection = other_value.get_selection();
if (value_selection == IPL4__ParamResult::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case IPL4__ParamResult::ALT_local:
return single_value.field_local->match(other_value.local(), legacy);
case IPL4__ParamResult::ALT_remote:
return single_value.field_remote->match(other_value.remote(), legacy);
case IPL4__ParamResult::ALT_proto:
return single_value.field_proto->match(other_value.proto(), legacy);
case IPL4__ParamResult::ALT_userData:
return single_value.field_userData->match(other_value.userData(), legacy);
case IPL4__ParamResult::ALT_parentIdx:
return single_value.field_parentIdx->match(other_value.parentIdx(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
return FALSE;
}

boolean IPL4__ParamResult_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
return single_value.field_local->is_value();
case IPL4__ParamResult::ALT_remote:
return single_value.field_remote->is_value();
case IPL4__ParamResult::ALT_proto:
return single_value.field_proto->is_value();
case IPL4__ParamResult::ALT_userData:
return single_value.field_userData->is_value();
case IPL4__ParamResult::ALT_parentIdx:
return single_value.field_parentIdx->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
}

IPL4__ParamResult IPL4__ParamResult_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
IPL4__ParamResult ret_val;
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
ret_val.local() = single_value.field_local->valueof();
break;
case IPL4__ParamResult::ALT_remote:
ret_val.remote() = single_value.field_remote->valueof();
break;
case IPL4__ParamResult::ALT_proto:
ret_val.proto() = single_value.field_proto->valueof();
break;
case IPL4__ParamResult::ALT_userData:
ret_val.userData() = single_value.field_userData->valueof();
break;
case IPL4__ParamResult::ALT_parentIdx:
ret_val.parentIdx() = single_value.field_parentIdx->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
return ret_val;
}

IPL4__ParamResult_template& IPL4__ParamResult_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @IPL4asp_Types.IPL4_ParamResult.");
return value_list.list_value[list_index];
}
void IPL4__ParamResult_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @IPL4asp_Types.IPL4_ParamResult.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPL4__ParamResult_template[list_length];
}

Socket__API__Definitions::Socket_template& IPL4__ParamResult_template::local()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPL4__ParamResult::ALT_local) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_local = new Socket__API__Definitions::Socket_template(ANY_VALUE);
else single_value.field_local = new Socket__API__Definitions::Socket_template;
single_value.union_selection = IPL4__ParamResult::ALT_local;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_local;
}

const Socket__API__Definitions::Socket_template& IPL4__ParamResult_template::local() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field local in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (single_value.union_selection != IPL4__ParamResult::ALT_local) TTCN_error("Accessing non-selected field local in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return *single_value.field_local;
}

Socket__API__Definitions::Socket_template& IPL4__ParamResult_template::remote()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPL4__ParamResult::ALT_remote) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_remote = new Socket__API__Definitions::Socket_template(ANY_VALUE);
else single_value.field_remote = new Socket__API__Definitions::Socket_template;
single_value.union_selection = IPL4__ParamResult::ALT_remote;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_remote;
}

const Socket__API__Definitions::Socket_template& IPL4__ParamResult_template::remote() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field remote in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (single_value.union_selection != IPL4__ParamResult::ALT_remote) TTCN_error("Accessing non-selected field remote in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return *single_value.field_remote;
}

Socket__API__Definitions::ProtoTuple_template& IPL4__ParamResult_template::proto()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPL4__ParamResult::ALT_proto) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_proto = new Socket__API__Definitions::ProtoTuple_template(ANY_VALUE);
else single_value.field_proto = new Socket__API__Definitions::ProtoTuple_template;
single_value.union_selection = IPL4__ParamResult::ALT_proto;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_proto;
}

const Socket__API__Definitions::ProtoTuple_template& IPL4__ParamResult_template::proto() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field proto in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (single_value.union_selection != IPL4__ParamResult::ALT_proto) TTCN_error("Accessing non-selected field proto in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return *single_value.field_proto;
}

INTEGER_template& IPL4__ParamResult_template::userData()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPL4__ParamResult::ALT_userData) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_userData = new INTEGER_template(ANY_VALUE);
else single_value.field_userData = new INTEGER_template;
single_value.union_selection = IPL4__ParamResult::ALT_userData;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_userData;
}

const INTEGER_template& IPL4__ParamResult_template::userData() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field userData in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (single_value.union_selection != IPL4__ParamResult::ALT_userData) TTCN_error("Accessing non-selected field userData in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return *single_value.field_userData;
}

INTEGER_template& IPL4__ParamResult_template::parentIdx()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != IPL4__ParamResult::ALT_parentIdx) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_parentIdx = new INTEGER_template(ANY_VALUE);
else single_value.field_parentIdx = new INTEGER_template;
single_value.union_selection = IPL4__ParamResult::ALT_parentIdx;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_parentIdx;
}

const INTEGER_template& IPL4__ParamResult_template::parentIdx() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field parentIdx in a non-specific template of union type @IPL4asp_Types.IPL4_ParamResult.");
if (single_value.union_selection != IPL4__ParamResult::ALT_parentIdx) TTCN_error("Accessing non-selected field parentIdx in a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return *single_value.field_parentIdx;
}

boolean IPL4__ParamResult_template::ischosen(IPL4__ParamResult::union_selection_type checked_selection) const
{
if (checked_selection == IPL4__ParamResult::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @IPL4asp_Types.IPL4_ParamResult.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == IPL4__ParamResult::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @IPL4asp_Types.IPL4_ParamResult containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @IPL4asp_Types.IPL4_ParamResult, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @IPL4asp_Types.IPL4_ParamResult");
}
return FALSE;
}

void IPL4__ParamResult_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
TTCN_Logger::log_event_str("{ local := ");
single_value.field_local->log();
TTCN_Logger::log_event_str(" }");
break;
case IPL4__ParamResult::ALT_remote:
TTCN_Logger::log_event_str("{ remote := ");
single_value.field_remote->log();
TTCN_Logger::log_event_str(" }");
break;
case IPL4__ParamResult::ALT_proto:
TTCN_Logger::log_event_str("{ proto := ");
single_value.field_proto->log();
TTCN_Logger::log_event_str(" }");
break;
case IPL4__ParamResult::ALT_userData:
TTCN_Logger::log_event_str("{ userData := ");
single_value.field_userData->log();
TTCN_Logger::log_event_str(" }");
break;
case IPL4__ParamResult::ALT_parentIdx:
TTCN_Logger::log_event_str("{ parentIdx := ");
single_value.field_parentIdx->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPL4__ParamResult_template::log_match(const IPL4__ParamResult& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".local");
single_value.field_local->log_match(match_value.local(), legacy);
} else {
TTCN_Logger::log_event_str("{ local := ");
single_value.field_local->log_match(match_value.local(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case IPL4__ParamResult::ALT_remote:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".remote");
single_value.field_remote->log_match(match_value.remote(), legacy);
} else {
TTCN_Logger::log_event_str("{ remote := ");
single_value.field_remote->log_match(match_value.remote(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case IPL4__ParamResult::ALT_proto:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".proto");
single_value.field_proto->log_match(match_value.proto(), legacy);
} else {
TTCN_Logger::log_event_str("{ proto := ");
single_value.field_proto->log_match(match_value.proto(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case IPL4__ParamResult::ALT_userData:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".userData");
single_value.field_userData->log_match(match_value.userData(), legacy);
} else {
TTCN_Logger::log_event_str("{ userData := ");
single_value.field_userData->log_match(match_value.userData(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case IPL4__ParamResult::ALT_parentIdx:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".parentIdx");
single_value.field_parentIdx->log_match(match_value.parentIdx(), legacy);
} else {
TTCN_Logger::log_event_str("{ parentIdx := ");
single_value.field_parentIdx->log_match(match_value.parentIdx(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPL4__ParamResult_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
single_value.field_local->encode_text(text_buf);
break;
case IPL4__ParamResult::ALT_remote:
single_value.field_remote->encode_text(text_buf);
break;
case IPL4__ParamResult::ALT_proto:
single_value.field_proto->encode_text(text_buf);
break;
case IPL4__ParamResult::ALT_userData:
single_value.field_userData->encode_text(text_buf);
break;
case IPL4__ParamResult::ALT_parentIdx:
single_value.field_parentIdx->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @IPL4asp_Types.IPL4_ParamResult.");
}
}

void IPL4__ParamResult_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = IPL4__ParamResult::UNBOUND_VALUE;
IPL4__ParamResult::union_selection_type new_selection = (IPL4__ParamResult::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case IPL4__ParamResult::ALT_local:
single_value.field_local = new Socket__API__Definitions::Socket_template;
single_value.field_local->decode_text(text_buf);
break;
case IPL4__ParamResult::ALT_remote:
single_value.field_remote = new Socket__API__Definitions::Socket_template;
single_value.field_remote->decode_text(text_buf);
break;
case IPL4__ParamResult::ALT_proto:
single_value.field_proto = new Socket__API__Definitions::ProtoTuple_template;
single_value.field_proto->decode_text(text_buf);
break;
case IPL4__ParamResult::ALT_userData:
single_value.field_userData = new INTEGER_template;
single_value.field_userData->decode_text(text_buf);
break;
case IPL4__ParamResult::ALT_parentIdx:
single_value.field_parentIdx = new INTEGER_template;
single_value.field_parentIdx->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @IPL4asp_Types.IPL4_ParamResult.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPL4__ParamResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @IPL4asp_Types.IPL4_ParamResult.");
}
}

boolean IPL4__ParamResult_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IPL4__ParamResult_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IPL4__ParamResult_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@IPL4asp_Types.IPL4_ParamResult'");
    }
    if (strcmp("local", param_field) == 0) {
      local().set_param(param);
      return;
    } else if (strcmp("remote", param_field) == 0) {
      remote().set_param(param);
      return;
    } else if (strcmp("proto", param_field) == 0) {
      proto().set_param(param);
      return;
    } else if (strcmp("userData", param_field) == 0) {
      userData().set_param(param);
      return;
    } else if (strcmp("parentIdx", param_field) == 0) {
      parentIdx().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@IPL4asp_Types.IPL4_ParamResult'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IPL4__ParamResult_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@IPL4asp_Types.IPL4_ParamResult");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "local")) {
      local().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "remote")) {
      remote().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "proto")) {
      proto().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "userData")) {
      userData().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "parentIdx")) {
      parentIdx().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @IPL4asp_Types.IPL4_ParamResult.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@IPL4asp_Types.IPL4_ParamResult");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPL4__ParamResult_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case IPL4__ParamResult::ALT_local:
single_value.field_local->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
return;
case IPL4__ParamResult::ALT_remote:
single_value.field_remote->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
return;
case IPL4__ParamResult::ALT_proto:
single_value.field_proto->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
return;
case IPL4__ParamResult::ALT_userData:
single_value.field_userData->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
return;
case IPL4__ParamResult::ALT_parentIdx:
single_value.field_parentIdx->check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @IPL4asp_Types.IPL4_ParamResult.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.IPL4_ParamResult");
}

IPL4__IPAddressType::IPL4__IPAddressType()
{
enum_value = UNBOUND_VALUE;
}

IPL4__IPAddressType::IPL4__IPAddressType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @IPL4asp_Types.IPL4_IPAddressType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

IPL4__IPAddressType::IPL4__IPAddressType(enum_type other_value)
{
enum_value = other_value;
}

IPL4__IPAddressType::IPL4__IPAddressType(const IPL4__IPAddressType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
enum_value = other_value.enum_value;
}

IPL4__IPAddressType& IPL4__IPAddressType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

IPL4__IPAddressType& IPL4__IPAddressType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

IPL4__IPAddressType& IPL4__IPAddressType::operator=(const IPL4__IPAddressType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
enum_value = other_value.enum_value;
return *this;
}

boolean IPL4__IPAddressType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value == other_value;
}

boolean IPL4__IPAddressType::operator==(const IPL4__IPAddressType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value == other_value.enum_value;
}

boolean IPL4__IPAddressType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value < other_value;
}

boolean IPL4__IPAddressType::operator<(const IPL4__IPAddressType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value < other_value.enum_value;
}

boolean IPL4__IPAddressType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value > other_value;
}

boolean IPL4__IPAddressType::operator>(const IPL4__IPAddressType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value > other_value.enum_value;
}

const char *IPL4__IPAddressType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case IPv4: return "IPv4";
case IPv6: return "IPv6";
default: return "<unknown>";
}
}

IPL4__IPAddressType::enum_type IPL4__IPAddressType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "IPv4")) return IPv4;
else if (!strcmp(str_par, "IPv6")) return IPv6;
else return UNKNOWN_VALUE;
}

boolean IPL4__IPAddressType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int IPL4__IPAddressType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int IPL4__IPAddressType::enum2int(const IPL4__IPAddressType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void IPL4__IPAddressType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", int_val);
enum_value = (enum_type)int_val;
}

IPL4__IPAddressType::operator IPL4__IPAddressType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return enum_value;
}

void IPL4__IPAddressType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void IPL4__IPAddressType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@IPL4asp_Types.IPL4_IPAddressType");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_IPAddressType.");
  }
}

void IPL4__IPAddressType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
text_buf.push_int(enum_value);
}

void IPL4__IPAddressType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @IPL4asp_Types.IPL4_IPAddressType.", enum_value);
}

void IPL4__IPAddressType_template::copy_template(const IPL4__IPAddressType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPL4__IPAddressType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
}
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template()
{
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!IPL4__IPAddressType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType with unknown numeric value %d.", other_value);
single_value = (IPL4__IPAddressType::enum_type)other_value;
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(IPL4__IPAddressType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(const IPL4__IPAddressType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == IPL4__IPAddressType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
single_value = other_value.enum_value;
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(const OPTIONAL<IPL4__IPAddressType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__IPAddressType::enum_type)(const IPL4__IPAddressType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType from an unbound optional field.");
}
}

IPL4__IPAddressType_template::IPL4__IPAddressType_template(const IPL4__IPAddressType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

IPL4__IPAddressType_template::~IPL4__IPAddressType_template()
{
clean_up();
}

boolean IPL4__IPAddressType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean IPL4__IPAddressType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != IPL4__IPAddressType::UNBOUND_VALUE;
}

void IPL4__IPAddressType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(int other_value)
{
if (!IPL4__IPAddressType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__IPAddressType::enum_type)other_value;
return *this;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(IPL4__IPAddressType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(const IPL4__IPAddressType& other_value)
{
if (other_value.enum_value == IPL4__IPAddressType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_IPAddressType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(const OPTIONAL<IPL4__IPAddressType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__IPAddressType::enum_type)(const IPL4__IPAddressType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
}
return *this;
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::operator=(const IPL4__IPAddressType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPL4__IPAddressType_template::match(IPL4__IPAddressType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
}
return FALSE;
}

boolean IPL4__IPAddressType_template::match(const IPL4__IPAddressType& other_value, boolean) const
{
if (other_value.enum_value == IPL4__IPAddressType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType with an unbound value.");
return match(other_value.enum_value);
}

IPL4__IPAddressType::enum_type IPL4__IPAddressType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return single_value;
}

void IPL4__IPAddressType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPL4__IPAddressType_template[list_length];
}

IPL4__IPAddressType_template& IPL4__IPAddressType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
return value_list.list_value[list_index];
}

void IPL4__IPAddressType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(IPL4__IPAddressType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPL4__IPAddressType_template::log_match(const IPL4__IPAddressType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void IPL4__IPAddressType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
}
}

void IPL4__IPAddressType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (IPL4__IPAddressType::enum_type)text_buf.pull_int().get_val();
if (!IPL4__IPAddressType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPL4__IPAddressType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_IPAddressType.");
}
}

boolean IPL4__IPAddressType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IPL4__IPAddressType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IPL4__IPAddressType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IPL4__IPAddressType_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    IPL4__IPAddressType::enum_type enum_val = IPL4__IPAddressType::str_to_enum(m_p->get_enumerated());
    if (!IPL4__IPAddressType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_IPAddressType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@IPL4asp_Types.IPL4_IPAddressType");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPL4__IPAddressType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.IPL4_IPAddressType");
}

IPL4__SrtpKeysAndSalts::IPL4__SrtpKeysAndSalts()
{
}

IPL4__SrtpKeysAndSalts::IPL4__SrtpKeysAndSalts(const OCTETSTRING& par_localKey,
    const OCTETSTRING& par_remoteKey,
    const OCTETSTRING& par_localSalt,
    const OCTETSTRING& par_remoteSalt)
  :   field_localKey(par_localKey),
  field_remoteKey(par_remoteKey),
  field_localSalt(par_localSalt),
  field_remoteSalt(par_remoteSalt)
{
}

IPL4__SrtpKeysAndSalts::IPL4__SrtpKeysAndSalts(const IPL4__SrtpKeysAndSalts& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
if (other_value.localKey().is_bound()) field_localKey = other_value.localKey();
else field_localKey.clean_up();
if (other_value.remoteKey().is_bound()) field_remoteKey = other_value.remoteKey();
else field_remoteKey.clean_up();
if (other_value.localSalt().is_bound()) field_localSalt = other_value.localSalt();
else field_localSalt.clean_up();
if (other_value.remoteSalt().is_bound()) field_remoteSalt = other_value.remoteSalt();
else field_remoteSalt.clean_up();
}

void IPL4__SrtpKeysAndSalts::clean_up()
{
field_localKey.clean_up();
field_remoteKey.clean_up();
field_localSalt.clean_up();
field_remoteSalt.clean_up();
}

IPL4__SrtpKeysAndSalts& IPL4__SrtpKeysAndSalts::operator=(const IPL4__SrtpKeysAndSalts& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
  if (other_value.localKey().is_bound()) field_localKey = other_value.localKey();
  else field_localKey.clean_up();
  if (other_value.remoteKey().is_bound()) field_remoteKey = other_value.remoteKey();
  else field_remoteKey.clean_up();
  if (other_value.localSalt().is_bound()) field_localSalt = other_value.localSalt();
  else field_localSalt.clean_up();
  if (other_value.remoteSalt().is_bound()) field_remoteSalt = other_value.remoteSalt();
  else field_remoteSalt.clean_up();
}
return *this;
}

boolean IPL4__SrtpKeysAndSalts::operator==(const IPL4__SrtpKeysAndSalts& other_value) const
{
return field_localKey==other_value.field_localKey
  && field_remoteKey==other_value.field_remoteKey
  && field_localSalt==other_value.field_localSalt
  && field_remoteSalt==other_value.field_remoteSalt;
}

boolean IPL4__SrtpKeysAndSalts::is_bound() const
{
if(field_localKey.is_bound()) return TRUE;
if(field_remoteKey.is_bound()) return TRUE;
if(field_localSalt.is_bound()) return TRUE;
if(field_remoteSalt.is_bound()) return TRUE;
return FALSE;
}
boolean IPL4__SrtpKeysAndSalts::is_value() const
{
if(!field_localKey.is_value()) return FALSE;
if(!field_remoteKey.is_value()) return FALSE;
if(!field_localSalt.is_value()) return FALSE;
if(!field_remoteSalt.is_value()) return FALSE;
return TRUE;
}
void IPL4__SrtpKeysAndSalts::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ localKey := ");
field_localKey.log();
TTCN_Logger::log_event_str(", remoteKey := ");
field_remoteKey.log();
TTCN_Logger::log_event_str(", localSalt := ");
field_localSalt.log();
TTCN_Logger::log_event_str(", remoteSalt := ");
field_remoteSalt.log();
TTCN_Logger::log_event_str(" }");
}

void IPL4__SrtpKeysAndSalts::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record value of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) localKey().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remoteKey().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) localSalt().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) remoteSalt().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localKey().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteKey().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localSalt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localSalt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteSalt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteSalt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.IPL4_SrtpKeysAndSalts: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
  }
}

void IPL4__SrtpKeysAndSalts::set_implicit_omit()
{
if (localKey().is_bound()) localKey().set_implicit_omit();
if (remoteKey().is_bound()) remoteKey().set_implicit_omit();
if (localSalt().is_bound()) localSalt().set_implicit_omit();
if (remoteSalt().is_bound()) remoteSalt().set_implicit_omit();
}

void IPL4__SrtpKeysAndSalts::encode_text(Text_Buf& text_buf) const
{
field_localKey.encode_text(text_buf);
field_remoteKey.encode_text(text_buf);
field_localSalt.encode_text(text_buf);
field_remoteSalt.encode_text(text_buf);
}

void IPL4__SrtpKeysAndSalts::decode_text(Text_Buf& text_buf)
{
field_localKey.decode_text(text_buf);
field_remoteKey.decode_text(text_buf);
field_localSalt.decode_text(text_buf);
field_remoteSalt.decode_text(text_buf);
}

struct IPL4__SrtpKeysAndSalts_template::single_value_struct {
OCTETSTRING_template field_localKey;
OCTETSTRING_template field_remoteKey;
OCTETSTRING_template field_localSalt;
OCTETSTRING_template field_remoteSalt;
};

void IPL4__SrtpKeysAndSalts_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_localKey = ANY_VALUE;
single_value->field_remoteKey = ANY_VALUE;
single_value->field_localSalt = ANY_VALUE;
single_value->field_remoteSalt = ANY_VALUE;
}
}
}

void IPL4__SrtpKeysAndSalts_template::copy_value(const IPL4__SrtpKeysAndSalts& other_value)
{
single_value = new single_value_struct;
if (other_value.localKey().is_bound()) {
  single_value->field_localKey = other_value.localKey();
} else {
  single_value->field_localKey.clean_up();
}
if (other_value.remoteKey().is_bound()) {
  single_value->field_remoteKey = other_value.remoteKey();
} else {
  single_value->field_remoteKey.clean_up();
}
if (other_value.localSalt().is_bound()) {
  single_value->field_localSalt = other_value.localSalt();
} else {
  single_value->field_localSalt.clean_up();
}
if (other_value.remoteSalt().is_bound()) {
  single_value->field_remoteSalt = other_value.remoteSalt();
} else {
  single_value->field_remoteSalt.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IPL4__SrtpKeysAndSalts_template::copy_template(const IPL4__SrtpKeysAndSalts_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.localKey().get_selection()) {
single_value->field_localKey = other_value.localKey();
} else {
single_value->field_localKey.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remoteKey().get_selection()) {
single_value->field_remoteKey = other_value.remoteKey();
} else {
single_value->field_remoteKey.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.localSalt().get_selection()) {
single_value->field_localSalt = other_value.localSalt();
} else {
single_value->field_localSalt.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.remoteSalt().get_selection()) {
single_value->field_remoteSalt = other_value.remoteSalt();
} else {
single_value->field_remoteSalt.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPL4__SrtpKeysAndSalts_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
break;
}
set_selection(other_value);
}

IPL4__SrtpKeysAndSalts_template::IPL4__SrtpKeysAndSalts_template()
{
}

IPL4__SrtpKeysAndSalts_template::IPL4__SrtpKeysAndSalts_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPL4__SrtpKeysAndSalts_template::IPL4__SrtpKeysAndSalts_template(const IPL4__SrtpKeysAndSalts& other_value)
{
copy_value(other_value);
}

IPL4__SrtpKeysAndSalts_template::IPL4__SrtpKeysAndSalts_template(const OPTIONAL<IPL4__SrtpKeysAndSalts>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPL4__SrtpKeysAndSalts&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts from an unbound optional field.");
}
}

IPL4__SrtpKeysAndSalts_template::IPL4__SrtpKeysAndSalts_template(const IPL4__SrtpKeysAndSalts_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IPL4__SrtpKeysAndSalts_template::~IPL4__SrtpKeysAndSalts_template()
{
clean_up();
}

IPL4__SrtpKeysAndSalts_template& IPL4__SrtpKeysAndSalts_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPL4__SrtpKeysAndSalts_template& IPL4__SrtpKeysAndSalts_template::operator=(const IPL4__SrtpKeysAndSalts& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IPL4__SrtpKeysAndSalts_template& IPL4__SrtpKeysAndSalts_template::operator=(const OPTIONAL<IPL4__SrtpKeysAndSalts>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IPL4__SrtpKeysAndSalts&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
}
return *this;
}

IPL4__SrtpKeysAndSalts_template& IPL4__SrtpKeysAndSalts_template::operator=(const IPL4__SrtpKeysAndSalts_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPL4__SrtpKeysAndSalts_template::match(const IPL4__SrtpKeysAndSalts& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.localKey().is_bound()) return FALSE;
if(!single_value->field_localKey.match(other_value.localKey(), legacy))return FALSE;
if(!other_value.remoteKey().is_bound()) return FALSE;
if(!single_value->field_remoteKey.match(other_value.remoteKey(), legacy))return FALSE;
if(!other_value.localSalt().is_bound()) return FALSE;
if(!single_value->field_localSalt.match(other_value.localSalt(), legacy))return FALSE;
if(!other_value.remoteSalt().is_bound()) return FALSE;
if(!single_value->field_remoteSalt.match(other_value.remoteSalt(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
}
return FALSE;
}

boolean IPL4__SrtpKeysAndSalts_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_localKey.is_bound()) return TRUE;
if (single_value->field_remoteKey.is_bound()) return TRUE;
if (single_value->field_localSalt.is_bound()) return TRUE;
if (single_value->field_remoteSalt.is_bound()) return TRUE;
return FALSE;
}

boolean IPL4__SrtpKeysAndSalts_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_localKey.is_value()) return FALSE;
if (!single_value->field_remoteKey.is_value()) return FALSE;
if (!single_value->field_localSalt.is_value()) return FALSE;
if (!single_value->field_remoteSalt.is_value()) return FALSE;
return TRUE;
}

void IPL4__SrtpKeysAndSalts_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IPL4__SrtpKeysAndSalts IPL4__SrtpKeysAndSalts_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
IPL4__SrtpKeysAndSalts ret_val;
if (single_value->field_localKey.is_bound()) {
ret_val.localKey() = single_value->field_localKey.valueof();
}
if (single_value->field_remoteKey.is_bound()) {
ret_val.remoteKey() = single_value->field_remoteKey.valueof();
}
if (single_value->field_localSalt.is_bound()) {
ret_val.localSalt() = single_value->field_localSalt.valueof();
}
if (single_value->field_remoteSalt.is_bound()) {
ret_val.remoteSalt() = single_value->field_remoteSalt.valueof();
}
return ret_val;
}

void IPL4__SrtpKeysAndSalts_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPL4__SrtpKeysAndSalts_template[list_length];
}

IPL4__SrtpKeysAndSalts_template& IPL4__SrtpKeysAndSalts_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::localKey()
{
set_specific();
return single_value->field_localKey;
}

const OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::localKey() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field localKey of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
return single_value->field_localKey;
}

OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::remoteKey()
{
set_specific();
return single_value->field_remoteKey;
}

const OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::remoteKey() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remoteKey of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
return single_value->field_remoteKey;
}

OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::localSalt()
{
set_specific();
return single_value->field_localSalt;
}

const OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::localSalt() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field localSalt of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
return single_value->field_localSalt;
}

OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::remoteSalt()
{
set_specific();
return single_value->field_remoteSalt;
}

const OCTETSTRING_template& IPL4__SrtpKeysAndSalts_template::remoteSalt() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field remoteSalt of a non-specific template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
return single_value->field_remoteSalt;
}

int IPL4__SrtpKeysAndSalts_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
  }
  return 0;
}

void IPL4__SrtpKeysAndSalts_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ localKey := ");
single_value->field_localKey.log();
TTCN_Logger::log_event_str(", remoteKey := ");
single_value->field_remoteKey.log();
TTCN_Logger::log_event_str(", localSalt := ");
single_value->field_localSalt.log();
TTCN_Logger::log_event_str(", remoteSalt := ");
single_value->field_remoteSalt.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPL4__SrtpKeysAndSalts_template::log_match(const IPL4__SrtpKeysAndSalts& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_localKey.match(match_value.localKey(), legacy)){
TTCN_Logger::log_logmatch_info(".localKey");
single_value->field_localKey.log_match(match_value.localKey(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remoteKey.match(match_value.remoteKey(), legacy)){
TTCN_Logger::log_logmatch_info(".remoteKey");
single_value->field_remoteKey.log_match(match_value.remoteKey(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_localSalt.match(match_value.localSalt(), legacy)){
TTCN_Logger::log_logmatch_info(".localSalt");
single_value->field_localSalt.log_match(match_value.localSalt(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_remoteSalt.match(match_value.remoteSalt(), legacy)){
TTCN_Logger::log_logmatch_info(".remoteSalt");
single_value->field_remoteSalt.log_match(match_value.remoteSalt(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ localKey := ");
single_value->field_localKey.log_match(match_value.localKey(), legacy);
TTCN_Logger::log_event_str(", remoteKey := ");
single_value->field_remoteKey.log_match(match_value.remoteKey(), legacy);
TTCN_Logger::log_event_str(", localSalt := ");
single_value->field_localSalt.log_match(match_value.localSalt(), legacy);
TTCN_Logger::log_event_str(", remoteSalt := ");
single_value->field_remoteSalt.log_match(match_value.remoteSalt(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IPL4__SrtpKeysAndSalts_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_localKey.encode_text(text_buf);
single_value->field_remoteKey.encode_text(text_buf);
single_value->field_localSalt.encode_text(text_buf);
single_value->field_remoteSalt.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
}
}

void IPL4__SrtpKeysAndSalts_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_localKey.decode_text(text_buf);
single_value->field_remoteKey.decode_text(text_buf);
single_value->field_localSalt.decode_text(text_buf);
single_value->field_remoteSalt.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPL4__SrtpKeysAndSalts_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts.");
}
}

void IPL4__SrtpKeysAndSalts_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IPL4__SrtpKeysAndSalts_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<param.get_size()) {
      param.error("record template of type @IPL4asp_Types.IPL4_SrtpKeysAndSalts has 4 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) localKey().set_param(*param.get_elem(0));
    if (param.get_size()>1 && param.get_elem(1)->get_type()!=Module_Param::MP_NotUsed) remoteKey().set_param(*param.get_elem(1));
    if (param.get_size()>2 && param.get_elem(2)->get_type()!=Module_Param::MP_NotUsed) localSalt().set_param(*param.get_elem(2));
    if (param.get_size()>3 && param.get_elem(3)->get_type()!=Module_Param::MP_NotUsed) remoteSalt().set_param(*param.get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localKey().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteKey().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "localSalt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          localSalt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "remoteSalt")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          remoteSalt().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @IPL4asp_Types.IPL4_SrtpKeysAndSalts: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPL4__SrtpKeysAndSalts_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_localKey.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
single_value->field_remoteKey.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
single_value->field_localSalt.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
single_value->field_remoteSalt.check_restriction(t_res, t_name ? t_name : "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.IPL4_SrtpKeysAndSalts");
}

boolean IPL4__SrtpKeysAndSalts_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IPL4__SrtpKeysAndSalts_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

IPL4__DigestMethods::IPL4__DigestMethods()
{
enum_value = UNBOUND_VALUE;
}

IPL4__DigestMethods::IPL4__DigestMethods(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @IPL4asp_Types.IPL4_DigestMethods with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

IPL4__DigestMethods::IPL4__DigestMethods(enum_type other_value)
{
enum_value = other_value;
}

IPL4__DigestMethods::IPL4__DigestMethods(const IPL4__DigestMethods& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
enum_value = other_value.enum_value;
}

IPL4__DigestMethods& IPL4__DigestMethods::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

IPL4__DigestMethods& IPL4__DigestMethods::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

IPL4__DigestMethods& IPL4__DigestMethods::operator=(const IPL4__DigestMethods& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
enum_value = other_value.enum_value;
return *this;
}

boolean IPL4__DigestMethods::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value == other_value;
}

boolean IPL4__DigestMethods::operator==(const IPL4__DigestMethods& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value == other_value.enum_value;
}

boolean IPL4__DigestMethods::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value < other_value;
}

boolean IPL4__DigestMethods::operator<(const IPL4__DigestMethods& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value < other_value.enum_value;
}

boolean IPL4__DigestMethods::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value > other_value;
}

boolean IPL4__DigestMethods::operator>(const IPL4__DigestMethods& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value > other_value.enum_value;
}

const char *IPL4__DigestMethods::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case NULL__method: return "NULL_method";
case MD4: return "MD4";
case MD5: return "MD5";
case SHA: return "SHA";
case SHA1: return "SHA1";
case DSS: return "DSS";
case DSS1: return "DSS1";
case ECDSA: return "ECDSA";
case SHA224: return "SHA224";
case SHA256: return "SHA256";
case SHA384: return "SHA384";
case SHA512: return "SHA512";
case MDC2: return "MDC2";
case RIPEMD160: return "RIPEMD160";
case WHIRLPOOL: return "WHIRLPOOL";
default: return "<unknown>";
}
}

IPL4__DigestMethods::enum_type IPL4__DigestMethods::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "NULL_method")) return NULL__method;
else if (!strcmp(str_par, "MD4")) return MD4;
else if (!strcmp(str_par, "MD5")) return MD5;
else if (!strcmp(str_par, "SHA")) return SHA;
else if (!strcmp(str_par, "SHA1")) return SHA1;
else if (!strcmp(str_par, "DSS")) return DSS;
else if (!strcmp(str_par, "DSS1")) return DSS1;
else if (!strcmp(str_par, "ECDSA")) return ECDSA;
else if (!strcmp(str_par, "SHA224")) return SHA224;
else if (!strcmp(str_par, "SHA256")) return SHA256;
else if (!strcmp(str_par, "SHA384")) return SHA384;
else if (!strcmp(str_par, "SHA512")) return SHA512;
else if (!strcmp(str_par, "MDC2")) return MDC2;
else if (!strcmp(str_par, "RIPEMD160")) return RIPEMD160;
else if (!strcmp(str_par, "WHIRLPOOL")) return WHIRLPOOL;
else return UNKNOWN_VALUE;
}

boolean IPL4__DigestMethods::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
return TRUE;
default:
return FALSE;
}
}

int IPL4__DigestMethods::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int IPL4__DigestMethods::enum2int(const IPL4__DigestMethods& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void IPL4__DigestMethods::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", int_val);
enum_value = (enum_type)int_val;
}

IPL4__DigestMethods::operator IPL4__DigestMethods::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return enum_value;
}

void IPL4__DigestMethods::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void IPL4__DigestMethods::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@IPL4asp_Types.IPL4_DigestMethods");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_DigestMethods.");
  }
}

void IPL4__DigestMethods::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
text_buf.push_int(enum_value);
}

void IPL4__DigestMethods::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @IPL4asp_Types.IPL4_DigestMethods.", enum_value);
}

void IPL4__DigestMethods_template::copy_template(const IPL4__DigestMethods_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IPL4__DigestMethods_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
}
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template()
{
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!IPL4__DigestMethods::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods with unknown numeric value %d.", other_value);
single_value = (IPL4__DigestMethods::enum_type)other_value;
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(IPL4__DigestMethods::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(const IPL4__DigestMethods& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == IPL4__DigestMethods::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
single_value = other_value.enum_value;
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(const OPTIONAL<IPL4__DigestMethods>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__DigestMethods::enum_type)(const IPL4__DigestMethods&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods from an unbound optional field.");
}
}

IPL4__DigestMethods_template::IPL4__DigestMethods_template(const IPL4__DigestMethods_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

IPL4__DigestMethods_template::~IPL4__DigestMethods_template()
{
clean_up();
}

boolean IPL4__DigestMethods_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean IPL4__DigestMethods_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != IPL4__DigestMethods::UNBOUND_VALUE;
}

void IPL4__DigestMethods_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(int other_value)
{
if (!IPL4__DigestMethods::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__DigestMethods::enum_type)other_value;
return *this;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(IPL4__DigestMethods::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(const IPL4__DigestMethods& other_value)
{
if (other_value.enum_value == IPL4__DigestMethods::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @IPL4asp_Types.IPL4_DigestMethods to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(const OPTIONAL<IPL4__DigestMethods>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (IPL4__DigestMethods::enum_type)(const IPL4__DigestMethods&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
}
return *this;
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::operator=(const IPL4__DigestMethods_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IPL4__DigestMethods_template::match(IPL4__DigestMethods::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
}
return FALSE;
}

boolean IPL4__DigestMethods_template::match(const IPL4__DigestMethods& other_value, boolean) const
{
if (other_value.enum_value == IPL4__DigestMethods::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods with an unbound value.");
return match(other_value.enum_value);
}

IPL4__DigestMethods::enum_type IPL4__DigestMethods_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return single_value;
}

void IPL4__DigestMethods_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IPL4__DigestMethods_template[list_length];
}

IPL4__DigestMethods_template& IPL4__DigestMethods_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
return value_list.list_value[list_index];
}

void IPL4__DigestMethods_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(IPL4__DigestMethods::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IPL4__DigestMethods_template::log_match(const IPL4__DigestMethods& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void IPL4__DigestMethods_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
}
}

void IPL4__DigestMethods_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (IPL4__DigestMethods::enum_type)text_buf.pull_int().get_val();
if (!IPL4__DigestMethods::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IPL4__DigestMethods_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @IPL4asp_Types.IPL4_DigestMethods.");
}
}

boolean IPL4__DigestMethods_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IPL4__DigestMethods_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void IPL4__DigestMethods_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IPL4__DigestMethods_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    IPL4__DigestMethods::enum_type enum_val = IPL4__DigestMethods::str_to_enum(m_p->get_enumerated());
    if (!IPL4__DigestMethods::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @IPL4asp_Types.IPL4_DigestMethods.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@IPL4asp_Types.IPL4_DigestMethods");
  }
  is_ifpresent = param.get_ifpresent();
}

void IPL4__DigestMethods_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@IPL4asp_Types.IPL4_DigestMethods");
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const SSL__proto__support& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @IPL4asp_Types.SSL_proto_support.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const OptionList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @IPL4asp_Types.OptionList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "IPL4asp_Types");
Socket__API__Definitions::module_object.pre_init_module();
current_location.update_lineno(504);
#line 504 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__GENERAL = Socket__API__Definitions::PortError::ERROR__GENERAL;
current_location.update_lineno(505);
#line 505 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__INSUFFICIENT__MEMORY = Socket__API__Definitions::PortError::ERROR__INSUFFICIENT__MEMORY;
current_location.update_lineno(506);
#line 506 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__INVALID__INPUT__PARAMETER = Socket__API__Definitions::PortError::ERROR__INVALID__INPUT__PARAMETER;
current_location.update_lineno(507);
#line 507 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__UNSUPPORTED__TRANSPORT = Socket__API__Definitions::PortError::ERROR__UNSUPPORTED__PROTOCOL;
current_location.update_lineno(508);
#line 508 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__SOCKET = Socket__API__Definitions::PortError::ERROR__SOCKET;
current_location.update_lineno(509);
#line 509 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__HOSTNAME = Socket__API__Definitions::PortError::ERROR__HOSTNAME;
current_location.update_lineno(510);
#line 510 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__INVALID__CONNECTION = Socket__API__Definitions::PortError::ERROR__INVALID__CONNECTION;
current_location.update_lineno(511);
#line 511 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__TEMPORARILY__UNAVAILABLE = Socket__API__Definitions::PortError::ERROR__TEMPORARILY__UNAVAILABLE;
current_location.update_lineno(512);
#line 512 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_IPL4__ERROR__AVAILABLE = Socket__API__Definitions::PortError::ERROR__AVAILABLE;
current_location.update_lineno(576);
#line 576 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__32__Profile = cs_0;
current_location.update_lineno(577);
#line 577 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__AES128__CM__SHA1__80__Profile = cs_1;
current_location.update_lineno(578);
#line 578 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__80__Profile = cs_2;
current_location.update_lineno(579);
#line 579 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__AES128__F8__SHA1__32__Profile = cs_3;
current_location.update_lineno(580);
#line 580 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__NULL__SHA1__80__Profile = cs_4;
current_location.update_lineno(581);
#line 581 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__NULL__SHA1__32__Profile = cs_5;
current_location.update_lineno(583);
#line 583 "../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn"
const_c__IPL4__DTLS__SRTP__ALL__KNOWN__Profile = cs_6;
}

static void post_init_module()
{
TTCN_Location current_location("../oneM2MTester/Ports/IPL4asp/IPL4asp_Types.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "IPL4asp_Types");
Socket__API__Definitions::module_object.post_init_module();
}


} /* end of namespace */
