// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for jaeyounghwang (jaeyounghwang@ubuntu) on Mon Sep 18 04:04:30 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef Socket__API__Definitions_HH
#define Socket__API__Definitions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef Socket__API__Definitions_HH
#endif

namespace Socket__API__Definitions {

/* Forward declarations of classes */

typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER ro__ConnectionId;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template ro__ConnectionId_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER ro__AssociationId;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template ro__AssociationId_template;
class Socket;
class Socket_template;
class SocketList;
class SocketList_template;
class UdpTuple;
class UdpTuple_template;
class UdpLightTuple;
class UdpLightTuple_template;
class TcpTuple;
class TcpTuple_template;
class SctpTuple;
class SctpTuple_template;
class SslTuple;
class SslTuple_template;
class DtlsTuple;
class DtlsTuple_template;
class UnspecifiedTuple;
class UnspecifiedTuple_template;
class ProtoTuple;
class ProtoTuple_template;
class PortError;
class PortError_template;
class Result;
class Result_template;
class Extended__Result;
class Extended__Result_template;
class ConnectionOpenedEvent;
class ConnectionOpenedEvent_template;
class SctpEvent;
class SctpEvent_template;
class SAC__STATE;
class SAC__STATE_template;
class SctpAssocChange;
class SctpAssocChange_template;
class SPC__STATE;
class SPC__STATE_template;
class SctpPeerAddrChange;
class SctpPeerAddrChange_template;
class SctpSendFailed;
class SctpSendFailed_template;
class SctpRemoteError;
class SctpRemoteError_template;
class SctpShutDownEvent;
class SctpShutDownEvent_template;
class SctpPartialDeliveryEvent;
class SctpPartialDeliveryEvent_template;
class SctpAdaptationIndication;
class SctpAdaptationIndication_template;
class SctpSenderDryEvent;
class SctpSenderDryEvent_template;
class PortEvent;
class PortEvent_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER ro__integer;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template ro__integer_template;
class f__getMsgLen;
class f__getMsgLen_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING ro__charstring;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template ro__charstring_template;

} /* end of namespace */

#ifndef Socket__API__Definitions_HH
#define Socket__API__Definitions_HH

namespace Socket__API__Definitions {

/* Type definitions */

typedef INTEGER ConnectionId;
typedef INTEGER_template ConnectionId_template;
typedef INTEGER AssociationId;
typedef INTEGER_template AssociationId_template;
typedef CHARSTRING HostName;
typedef CHARSTRING_template HostName_template;
typedef INTEGER PortNumber;
typedef INTEGER_template PortNumber_template;
typedef INTEGER UserData;
typedef INTEGER_template UserData_template;
typedef ConnectionOpenedEvent ConnectionClosedEvent;
typedef ConnectionOpenedEvent_template ConnectionClosedEvent_template;

/* Class definitions */

class Socket {
  CHARSTRING field_hostName;
  INTEGER field_portNumber;
public:
  Socket();
  Socket(const CHARSTRING& par_hostName,
    const INTEGER& par_portNumber);
  Socket(const Socket& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Socket& operator=(const Socket& other_value);
  boolean operator==(const Socket& other_value) const;
  inline boolean operator!=(const Socket& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& hostName()
    {return field_hostName;}
  inline const CHARSTRING& hostName() const
    {return field_hostName;}
  inline INTEGER& portNumber()
    {return field_portNumber;}
  inline const INTEGER& portNumber() const
    {return field_portNumber;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Socket_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Socket_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Socket& other_value);
void copy_template(const Socket_template& other_value);

public:
Socket_template();
Socket_template(template_sel other_value);
Socket_template(const Socket& other_value);
Socket_template(const OPTIONAL<Socket>& other_value);
Socket_template(const Socket_template& other_value);
~Socket_template();
Socket_template& operator=(template_sel other_value);
Socket_template& operator=(const Socket& other_value);
Socket_template& operator=(const OPTIONAL<Socket>& other_value);
Socket_template& operator=(const Socket_template& other_value);
boolean match(const Socket& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Socket valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Socket_template& list_item(unsigned int list_index) const;
CHARSTRING_template& hostName();
const CHARSTRING_template& hostName() const;
INTEGER_template& portNumber();
const INTEGER_template& portNumber() const;
int size_of() const;
void log() const;
void log_match(const Socket& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SocketList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Socket **value_elements;
} *val_ptr;

static const Socket UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SocketList& other_value);

public:
  typedef Socket of_type;
SocketList();
SocketList(null_type other_value);
SocketList(const SocketList& other_value);
~SocketList();

void clean_up();
SocketList& operator=(null_type other_value);
SocketList& operator=(const SocketList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SocketList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SocketList& other_value) const { return !(*this == other_value); }

Socket& operator[](int index_value);
Socket& operator[](const INTEGER& index_value);
const Socket& operator[](int index_value) const;
const Socket& operator[](const INTEGER& index_value) const;

SocketList operator<<=(int rotate_count) const;
SocketList operator<<=(const INTEGER& rotate_count) const;
SocketList operator>>=(int rotate_count) const;
SocketList operator>>=(const INTEGER& rotate_count) const;

SocketList operator+(const SocketList& other_value) const;

SocketList substr(int index, int returncount) const;

SocketList replace(int index, int len, const SocketList& repl) const;

SocketList replace(int index, int len, const SocketList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SocketList_template : public Record_Of_Template {
union {
struct {
int n_elements;
Socket_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SocketList_template *list_value;
} value_list;
};
void copy_value(const SocketList& other_value);
void copy_template(const SocketList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SocketList_template();
SocketList_template(template_sel other_value);
SocketList_template(null_type other_value);
SocketList_template(const SocketList& other_value);
SocketList_template(const OPTIONAL<SocketList>& other_value);
SocketList_template(const SocketList_template& other_value);
~SocketList_template();

void clean_up();
SocketList_template& operator=(template_sel other_value);
SocketList_template& operator=(null_type other_value);
SocketList_template& operator=(const SocketList& other_value);
SocketList_template& operator=(const OPTIONAL<SocketList>& other_value);
SocketList_template& operator=(const SocketList_template& other_value);

Socket_template& operator[](int index_value);
Socket_template& operator[](const INTEGER& index_value);
const Socket_template& operator[](int index_value) const;
const Socket_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SocketList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SocketList valueof() const;
SocketList substr(int index, int returncount) const;

SocketList replace(int index, int len, const SocketList_template& repl) const;

SocketList replace(int index, int len, const SocketList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SocketList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SocketList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class UdpTuple : public Base_Type {
boolean bound_flag;
public:
UdpTuple();
UdpTuple(null_type other_value);
UdpTuple(const UdpTuple& other_value);
UdpTuple& operator=(null_type other_value);
UdpTuple& operator=(const UdpTuple& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const UdpTuple& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UdpTuple& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class UdpTuple_template : public Base_Template {
struct {
unsigned int n_values;
UdpTuple_template *list_value;
} value_list;
void copy_template(const UdpTuple_template& other_value);

public:
UdpTuple_template();
UdpTuple_template(template_sel other_value);
UdpTuple_template(null_type other_value);
UdpTuple_template(const UdpTuple& other_value);
UdpTuple_template(const OPTIONAL<UdpTuple>& other_value);
UdpTuple_template(const UdpTuple_template& other_value);
~UdpTuple_template();
void clean_up();
UdpTuple_template& operator=(template_sel other_value);
UdpTuple_template& operator=(null_type other_value);
UdpTuple_template& operator=(const UdpTuple& other_value);
UdpTuple_template& operator=(const OPTIONAL<UdpTuple>& other_value);
UdpTuple_template& operator=(const UdpTuple_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const UdpTuple& other_value, boolean legacy = FALSE) const;
UdpTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UdpTuple_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const UdpTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UdpLightTuple : public Base_Type {
boolean bound_flag;
public:
UdpLightTuple();
UdpLightTuple(null_type other_value);
UdpLightTuple(const UdpLightTuple& other_value);
UdpLightTuple& operator=(null_type other_value);
UdpLightTuple& operator=(const UdpLightTuple& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const UdpLightTuple& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UdpLightTuple& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class UdpLightTuple_template : public Base_Template {
struct {
unsigned int n_values;
UdpLightTuple_template *list_value;
} value_list;
void copy_template(const UdpLightTuple_template& other_value);

public:
UdpLightTuple_template();
UdpLightTuple_template(template_sel other_value);
UdpLightTuple_template(null_type other_value);
UdpLightTuple_template(const UdpLightTuple& other_value);
UdpLightTuple_template(const OPTIONAL<UdpLightTuple>& other_value);
UdpLightTuple_template(const UdpLightTuple_template& other_value);
~UdpLightTuple_template();
void clean_up();
UdpLightTuple_template& operator=(template_sel other_value);
UdpLightTuple_template& operator=(null_type other_value);
UdpLightTuple_template& operator=(const UdpLightTuple& other_value);
UdpLightTuple_template& operator=(const OPTIONAL<UdpLightTuple>& other_value);
UdpLightTuple_template& operator=(const UdpLightTuple_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const UdpLightTuple& other_value, boolean legacy = FALSE) const;
UdpLightTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UdpLightTuple_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const UdpLightTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TcpTuple : public Base_Type {
boolean bound_flag;
public:
TcpTuple();
TcpTuple(null_type other_value);
TcpTuple(const TcpTuple& other_value);
TcpTuple& operator=(null_type other_value);
TcpTuple& operator=(const TcpTuple& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const TcpTuple& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TcpTuple& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class TcpTuple_template : public Base_Template {
struct {
unsigned int n_values;
TcpTuple_template *list_value;
} value_list;
void copy_template(const TcpTuple_template& other_value);

public:
TcpTuple_template();
TcpTuple_template(template_sel other_value);
TcpTuple_template(null_type other_value);
TcpTuple_template(const TcpTuple& other_value);
TcpTuple_template(const OPTIONAL<TcpTuple>& other_value);
TcpTuple_template(const TcpTuple_template& other_value);
~TcpTuple_template();
void clean_up();
TcpTuple_template& operator=(template_sel other_value);
TcpTuple_template& operator=(null_type other_value);
TcpTuple_template& operator=(const TcpTuple& other_value);
TcpTuple_template& operator=(const OPTIONAL<TcpTuple>& other_value);
TcpTuple_template& operator=(const TcpTuple_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const TcpTuple& other_value, boolean legacy = FALSE) const;
TcpTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TcpTuple_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const TcpTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpTuple {
  OPTIONAL<INTEGER> field_sinfo__stream;
  OPTIONAL<INTEGER> field_sinfo__ppid;
  OPTIONAL<SocketList> field_remSocks;
  OPTIONAL<INTEGER> field_assocId;
public:
  SctpTuple();
  SctpTuple(const OPTIONAL<INTEGER>& par_sinfo__stream,
    const OPTIONAL<INTEGER>& par_sinfo__ppid,
    const OPTIONAL<SocketList>& par_remSocks,
    const OPTIONAL<INTEGER>& par_assocId);
  SctpTuple(const SctpTuple& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpTuple& operator=(const SctpTuple& other_value);
  boolean operator==(const SctpTuple& other_value) const;
  inline boolean operator!=(const SctpTuple& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& sinfo__stream()
    {return field_sinfo__stream;}
  inline const OPTIONAL<INTEGER>& sinfo__stream() const
    {return field_sinfo__stream;}
  inline OPTIONAL<INTEGER>& sinfo__ppid()
    {return field_sinfo__ppid;}
  inline const OPTIONAL<INTEGER>& sinfo__ppid() const
    {return field_sinfo__ppid;}
  inline OPTIONAL<SocketList>& remSocks()
    {return field_remSocks;}
  inline const OPTIONAL<SocketList>& remSocks() const
    {return field_remSocks;}
  inline OPTIONAL<INTEGER>& assocId()
    {return field_assocId;}
  inline const OPTIONAL<INTEGER>& assocId() const
    {return field_assocId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpTuple_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpTuple_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpTuple& other_value);
void copy_template(const SctpTuple_template& other_value);

public:
SctpTuple_template();
SctpTuple_template(template_sel other_value);
SctpTuple_template(const SctpTuple& other_value);
SctpTuple_template(const OPTIONAL<SctpTuple>& other_value);
SctpTuple_template(const SctpTuple_template& other_value);
~SctpTuple_template();
SctpTuple_template& operator=(template_sel other_value);
SctpTuple_template& operator=(const SctpTuple& other_value);
SctpTuple_template& operator=(const OPTIONAL<SctpTuple>& other_value);
SctpTuple_template& operator=(const SctpTuple_template& other_value);
boolean match(const SctpTuple& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpTuple_template& list_item(unsigned int list_index) const;
INTEGER_template& sinfo__stream();
const INTEGER_template& sinfo__stream() const;
INTEGER_template& sinfo__ppid();
const INTEGER_template& sinfo__ppid() const;
SocketList_template& remSocks();
const SocketList_template& remSocks() const;
INTEGER_template& assocId();
const INTEGER_template& assocId() const;
int size_of() const;
void log() const;
void log_match(const SctpTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SslTuple : public Base_Type {
boolean bound_flag;
public:
SslTuple();
SslTuple(null_type other_value);
SslTuple(const SslTuple& other_value);
SslTuple& operator=(null_type other_value);
SslTuple& operator=(const SslTuple& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const SslTuple& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SslTuple& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SslTuple_template : public Base_Template {
struct {
unsigned int n_values;
SslTuple_template *list_value;
} value_list;
void copy_template(const SslTuple_template& other_value);

public:
SslTuple_template();
SslTuple_template(template_sel other_value);
SslTuple_template(null_type other_value);
SslTuple_template(const SslTuple& other_value);
SslTuple_template(const OPTIONAL<SslTuple>& other_value);
SslTuple_template(const SslTuple_template& other_value);
~SslTuple_template();
void clean_up();
SslTuple_template& operator=(template_sel other_value);
SslTuple_template& operator=(null_type other_value);
SslTuple_template& operator=(const SslTuple& other_value);
SslTuple_template& operator=(const OPTIONAL<SslTuple>& other_value);
SslTuple_template& operator=(const SslTuple_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const SslTuple& other_value, boolean legacy = FALSE) const;
SslTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SslTuple_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const SslTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DtlsTuple : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_udp = 1, ALT_sctp = 2 };
private:
union_selection_type union_selection;
union {
UdpTuple *field_udp;
SctpTuple *field_sctp;
};
void copy_value(const DtlsTuple& other_value);

public:
DtlsTuple();
DtlsTuple(const DtlsTuple& other_value);
~DtlsTuple();
DtlsTuple& operator=(const DtlsTuple& other_value);
boolean operator==(const DtlsTuple& other_value) const;
inline boolean operator!=(const DtlsTuple& other_value) const { return !(*this == other_value); }
UdpTuple& udp();
const UdpTuple& udp() const;
SctpTuple& sctp();
const SctpTuple& sctp() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class DtlsTuple_template : public Base_Template {
union {
struct {
DtlsTuple::union_selection_type union_selection;
union {
UdpTuple_template *field_udp;
SctpTuple_template *field_sctp;
};
} single_value;
struct {
unsigned int n_values;
DtlsTuple_template *list_value;
} value_list;
};
void copy_value(const DtlsTuple& other_value);

void copy_template(const DtlsTuple_template& other_value);

public:
DtlsTuple_template();
DtlsTuple_template(template_sel other_value);
DtlsTuple_template(const DtlsTuple& other_value);
DtlsTuple_template(const OPTIONAL<DtlsTuple>& other_value);
DtlsTuple_template(const DtlsTuple_template& other_value);
~DtlsTuple_template();
void clean_up();
DtlsTuple_template& operator=(template_sel other_value);
DtlsTuple_template& operator=(const DtlsTuple& other_value);
DtlsTuple_template& operator=(const OPTIONAL<DtlsTuple>& other_value);
DtlsTuple_template& operator=(const DtlsTuple_template& other_value);
boolean match(const DtlsTuple& other_value, boolean legacy = FALSE) const;
boolean is_value() const;DtlsTuple valueof() const;
DtlsTuple_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
UdpTuple_template& udp();
const UdpTuple_template& udp() const;
SctpTuple_template& sctp();
const SctpTuple_template& sctp() const;
boolean ischosen(DtlsTuple::union_selection_type checked_selection) const;
void log() const;
void log_match(const DtlsTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UnspecifiedTuple : public Base_Type {
boolean bound_flag;
public:
UnspecifiedTuple();
UnspecifiedTuple(null_type other_value);
UnspecifiedTuple(const UnspecifiedTuple& other_value);
UnspecifiedTuple& operator=(null_type other_value);
UnspecifiedTuple& operator=(const UnspecifiedTuple& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const UnspecifiedTuple& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UnspecifiedTuple& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class UnspecifiedTuple_template : public Base_Template {
struct {
unsigned int n_values;
UnspecifiedTuple_template *list_value;
} value_list;
void copy_template(const UnspecifiedTuple_template& other_value);

public:
UnspecifiedTuple_template();
UnspecifiedTuple_template(template_sel other_value);
UnspecifiedTuple_template(null_type other_value);
UnspecifiedTuple_template(const UnspecifiedTuple& other_value);
UnspecifiedTuple_template(const OPTIONAL<UnspecifiedTuple>& other_value);
UnspecifiedTuple_template(const UnspecifiedTuple_template& other_value);
~UnspecifiedTuple_template();
void clean_up();
UnspecifiedTuple_template& operator=(template_sel other_value);
UnspecifiedTuple_template& operator=(null_type other_value);
UnspecifiedTuple_template& operator=(const UnspecifiedTuple& other_value);
UnspecifiedTuple_template& operator=(const OPTIONAL<UnspecifiedTuple>& other_value);
UnspecifiedTuple_template& operator=(const UnspecifiedTuple_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const UnspecifiedTuple& other_value, boolean legacy = FALSE) const;
UnspecifiedTuple valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UnspecifiedTuple_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const UnspecifiedTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ProtoTuple : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_udp = 1, ALT_udpLight = 2, ALT_tcp = 3, ALT_sctp = 4, ALT_ssl = 5, ALT_dtls = 6, ALT_unspecified = 7 };
private:
union_selection_type union_selection;
union {
UdpTuple *field_udp;
UdpLightTuple *field_udpLight;
TcpTuple *field_tcp;
SctpTuple *field_sctp;
SslTuple *field_ssl;
DtlsTuple *field_dtls;
UnspecifiedTuple *field_unspecified;
};
void copy_value(const ProtoTuple& other_value);

public:
ProtoTuple();
ProtoTuple(const ProtoTuple& other_value);
~ProtoTuple();
ProtoTuple& operator=(const ProtoTuple& other_value);
boolean operator==(const ProtoTuple& other_value) const;
inline boolean operator!=(const ProtoTuple& other_value) const { return !(*this == other_value); }
UdpTuple& udp();
const UdpTuple& udp() const;
UdpLightTuple& udpLight();
const UdpLightTuple& udpLight() const;
TcpTuple& tcp();
const TcpTuple& tcp() const;
SctpTuple& sctp();
const SctpTuple& sctp() const;
SslTuple& ssl();
const SslTuple& ssl() const;
DtlsTuple& dtls();
const DtlsTuple& dtls() const;
UnspecifiedTuple& unspecified();
const UnspecifiedTuple& unspecified() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ProtoTuple_template : public Base_Template {
union {
struct {
ProtoTuple::union_selection_type union_selection;
union {
UdpTuple_template *field_udp;
UdpLightTuple_template *field_udpLight;
TcpTuple_template *field_tcp;
SctpTuple_template *field_sctp;
SslTuple_template *field_ssl;
DtlsTuple_template *field_dtls;
UnspecifiedTuple_template *field_unspecified;
};
} single_value;
struct {
unsigned int n_values;
ProtoTuple_template *list_value;
} value_list;
};
void copy_value(const ProtoTuple& other_value);

void copy_template(const ProtoTuple_template& other_value);

public:
ProtoTuple_template();
ProtoTuple_template(template_sel other_value);
ProtoTuple_template(const ProtoTuple& other_value);
ProtoTuple_template(const OPTIONAL<ProtoTuple>& other_value);
ProtoTuple_template(const ProtoTuple_template& other_value);
~ProtoTuple_template();
void clean_up();
ProtoTuple_template& operator=(template_sel other_value);
ProtoTuple_template& operator=(const ProtoTuple& other_value);
ProtoTuple_template& operator=(const OPTIONAL<ProtoTuple>& other_value);
ProtoTuple_template& operator=(const ProtoTuple_template& other_value);
boolean match(const ProtoTuple& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ProtoTuple valueof() const;
ProtoTuple_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
UdpTuple_template& udp();
const UdpTuple_template& udp() const;
UdpLightTuple_template& udpLight();
const UdpLightTuple_template& udpLight() const;
TcpTuple_template& tcp();
const TcpTuple_template& tcp() const;
SctpTuple_template& sctp();
const SctpTuple_template& sctp() const;
SslTuple_template& ssl();
const SslTuple_template& ssl() const;
DtlsTuple_template& dtls();
const DtlsTuple_template& dtls() const;
UnspecifiedTuple_template& unspecified();
const UnspecifiedTuple_template& unspecified() const;
boolean ischosen(ProtoTuple::union_selection_type checked_selection) const;
void log() const;
void log_match(const ProtoTuple& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PortError : public Base_Type { // enum
friend class PortError_template;
public:
enum enum_type { ERROR__GENERAL = 0, ERROR__INSUFFICIENT__MEMORY = 1, ERROR__INVALID__INPUT__PARAMETER = 2, ERROR__UNSUPPORTED__PROTOCOL = 3, ERROR__SOCKET = 4, ERROR__HOSTNAME = 5, ERROR__INVALID__CONNECTION = 6, ERROR__TEMPORARILY__UNAVAILABLE = 7, ERROR__AVAILABLE = 8, UNKNOWN_VALUE = 9, UNBOUND_VALUE = 10 };
private:
enum_type enum_value;

public:
PortError();
PortError(int other_value);
PortError(enum_type other_value);
PortError(const PortError& other_value);

PortError& operator=(int other_value);
PortError& operator=(enum_type other_value);
PortError& operator=(const PortError& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PortError& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PortError& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PortError& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PortError& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PortError& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PortError& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PortError& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class PortError_template : public Base_Template {
union {
PortError::enum_type single_value;
struct {
unsigned int n_values;
PortError_template *list_value;
} value_list;
};

void copy_template(const PortError_template& other_value);

public:
PortError_template();
PortError_template(template_sel other_value);
PortError_template(int other_value);
PortError_template(PortError::enum_type other_value);
PortError_template(const PortError& other_value);
PortError_template(const OPTIONAL<PortError>& other_value);
PortError_template(const PortError_template& other_value);
~PortError_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PortError_template& operator=(template_sel other_value);
PortError_template& operator=(int other_value);
PortError_template& operator=(PortError::enum_type other_value);
PortError_template& operator=(const PortError& other_value);
PortError_template& operator=(const OPTIONAL<PortError>& other_value);
PortError_template& operator=(const PortError_template& other_value);

boolean match(PortError::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PortError& other_value, boolean legacy = FALSE) const;
PortError::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PortError_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PortError& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Result {
  OPTIONAL<PortError> field_errorCode;
  OPTIONAL<INTEGER> field_connId;
  OPTIONAL<INTEGER> field_os__error__code;
  OPTIONAL<CHARSTRING> field_os__error__text;
public:
  Result();
  Result(const OPTIONAL<PortError>& par_errorCode,
    const OPTIONAL<INTEGER>& par_connId,
    const OPTIONAL<INTEGER>& par_os__error__code,
    const OPTIONAL<CHARSTRING>& par_os__error__text);
  Result(const Result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Result& operator=(const Result& other_value);
  boolean operator==(const Result& other_value) const;
  inline boolean operator!=(const Result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<PortError>& errorCode()
    {return field_errorCode;}
  inline const OPTIONAL<PortError>& errorCode() const
    {return field_errorCode;}
  inline OPTIONAL<INTEGER>& connId()
    {return field_connId;}
  inline const OPTIONAL<INTEGER>& connId() const
    {return field_connId;}
  inline OPTIONAL<INTEGER>& os__error__code()
    {return field_os__error__code;}
  inline const OPTIONAL<INTEGER>& os__error__code() const
    {return field_os__error__code;}
  inline OPTIONAL<CHARSTRING>& os__error__text()
    {return field_os__error__text;}
  inline const OPTIONAL<CHARSTRING>& os__error__text() const
    {return field_os__error__text;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Result_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Result& other_value);
void copy_template(const Result_template& other_value);

public:
Result_template();
Result_template(template_sel other_value);
Result_template(const Result& other_value);
Result_template(const OPTIONAL<Result>& other_value);
Result_template(const Result_template& other_value);
~Result_template();
Result_template& operator=(template_sel other_value);
Result_template& operator=(const Result& other_value);
Result_template& operator=(const OPTIONAL<Result>& other_value);
Result_template& operator=(const Result_template& other_value);
boolean match(const Result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Result_template& list_item(unsigned int list_index) const;
PortError_template& errorCode();
const PortError_template& errorCode() const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
INTEGER_template& os__error__code();
const INTEGER_template& os__error__code() const;
CHARSTRING_template& os__error__text();
const CHARSTRING_template& os__error__text() const;
int size_of() const;
void log() const;
void log_match(const Result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Extended__Result {
  OPTIONAL<PortError> field_errorCode;
  OPTIONAL<INTEGER> field_connId;
  OPTIONAL<INTEGER> field_os__error__code;
  OPTIONAL<CHARSTRING> field_os__error__text;
  OPTIONAL<OCTETSTRING> field_msg;
public:
  Extended__Result();
  Extended__Result(const OPTIONAL<PortError>& par_errorCode,
    const OPTIONAL<INTEGER>& par_connId,
    const OPTIONAL<INTEGER>& par_os__error__code,
    const OPTIONAL<CHARSTRING>& par_os__error__text,
    const OPTIONAL<OCTETSTRING>& par_msg);
  Extended__Result(const Extended__Result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Extended__Result& operator=(const Extended__Result& other_value);
  boolean operator==(const Extended__Result& other_value) const;
  inline boolean operator!=(const Extended__Result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<PortError>& errorCode()
    {return field_errorCode;}
  inline const OPTIONAL<PortError>& errorCode() const
    {return field_errorCode;}
  inline OPTIONAL<INTEGER>& connId()
    {return field_connId;}
  inline const OPTIONAL<INTEGER>& connId() const
    {return field_connId;}
  inline OPTIONAL<INTEGER>& os__error__code()
    {return field_os__error__code;}
  inline const OPTIONAL<INTEGER>& os__error__code() const
    {return field_os__error__code;}
  inline OPTIONAL<CHARSTRING>& os__error__text()
    {return field_os__error__text;}
  inline const OPTIONAL<CHARSTRING>& os__error__text() const
    {return field_os__error__text;}
  inline OPTIONAL<OCTETSTRING>& msg()
    {return field_msg;}
  inline const OPTIONAL<OCTETSTRING>& msg() const
    {return field_msg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Extended__Result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Extended__Result_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Extended__Result& other_value);
void copy_template(const Extended__Result_template& other_value);

public:
Extended__Result_template();
Extended__Result_template(template_sel other_value);
Extended__Result_template(const Extended__Result& other_value);
Extended__Result_template(const OPTIONAL<Extended__Result>& other_value);
Extended__Result_template(const Extended__Result_template& other_value);
~Extended__Result_template();
Extended__Result_template& operator=(template_sel other_value);
Extended__Result_template& operator=(const Extended__Result& other_value);
Extended__Result_template& operator=(const OPTIONAL<Extended__Result>& other_value);
Extended__Result_template& operator=(const Extended__Result_template& other_value);
boolean match(const Extended__Result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Extended__Result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Extended__Result_template& list_item(unsigned int list_index) const;
PortError_template& errorCode();
const PortError_template& errorCode() const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
INTEGER_template& os__error__code();
const INTEGER_template& os__error__code() const;
CHARSTRING_template& os__error__text();
const CHARSTRING_template& os__error__text() const;
OCTETSTRING_template& msg();
const OCTETSTRING_template& msg() const;
int size_of() const;
void log() const;
void log_match(const Extended__Result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ConnectionOpenedEvent {
  INTEGER field_connId;
  CHARSTRING field_remName;
  INTEGER field_remPort;
  CHARSTRING field_locName;
  INTEGER field_locPort;
  ProtoTuple field_proto;
  INTEGER field_userData;
public:
  ConnectionOpenedEvent();
  ConnectionOpenedEvent(const INTEGER& par_connId,
    const CHARSTRING& par_remName,
    const INTEGER& par_remPort,
    const CHARSTRING& par_locName,
    const INTEGER& par_locPort,
    const ProtoTuple& par_proto,
    const INTEGER& par_userData);
  ConnectionOpenedEvent(const ConnectionOpenedEvent& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ConnectionOpenedEvent& operator=(const ConnectionOpenedEvent& other_value);
  boolean operator==(const ConnectionOpenedEvent& other_value) const;
  inline boolean operator!=(const ConnectionOpenedEvent& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& connId()
    {return field_connId;}
  inline const INTEGER& connId() const
    {return field_connId;}
  inline CHARSTRING& remName()
    {return field_remName;}
  inline const CHARSTRING& remName() const
    {return field_remName;}
  inline INTEGER& remPort()
    {return field_remPort;}
  inline const INTEGER& remPort() const
    {return field_remPort;}
  inline CHARSTRING& locName()
    {return field_locName;}
  inline const CHARSTRING& locName() const
    {return field_locName;}
  inline INTEGER& locPort()
    {return field_locPort;}
  inline const INTEGER& locPort() const
    {return field_locPort;}
  inline ProtoTuple& proto()
    {return field_proto;}
  inline const ProtoTuple& proto() const
    {return field_proto;}
  inline INTEGER& userData()
    {return field_userData;}
  inline const INTEGER& userData() const
    {return field_userData;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ConnectionOpenedEvent_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ConnectionOpenedEvent_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ConnectionOpenedEvent& other_value);
void copy_template(const ConnectionOpenedEvent_template& other_value);

public:
ConnectionOpenedEvent_template();
ConnectionOpenedEvent_template(template_sel other_value);
ConnectionOpenedEvent_template(const ConnectionOpenedEvent& other_value);
ConnectionOpenedEvent_template(const OPTIONAL<ConnectionOpenedEvent>& other_value);
ConnectionOpenedEvent_template(const ConnectionOpenedEvent_template& other_value);
~ConnectionOpenedEvent_template();
ConnectionOpenedEvent_template& operator=(template_sel other_value);
ConnectionOpenedEvent_template& operator=(const ConnectionOpenedEvent& other_value);
ConnectionOpenedEvent_template& operator=(const OPTIONAL<ConnectionOpenedEvent>& other_value);
ConnectionOpenedEvent_template& operator=(const ConnectionOpenedEvent_template& other_value);
boolean match(const ConnectionOpenedEvent& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ConnectionOpenedEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ConnectionOpenedEvent_template& list_item(unsigned int list_index) const;
INTEGER_template& connId();
const INTEGER_template& connId() const;
CHARSTRING_template& remName();
const CHARSTRING_template& remName() const;
INTEGER_template& remPort();
const INTEGER_template& remPort() const;
CHARSTRING_template& locName();
const CHARSTRING_template& locName() const;
INTEGER_template& locPort();
const INTEGER_template& locPort() const;
ProtoTuple_template& proto();
const ProtoTuple_template& proto() const;
INTEGER_template& userData();
const INTEGER_template& userData() const;
int size_of() const;
void log() const;
void log_match(const ConnectionOpenedEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpEvent : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_sctpAssocChange = 1, ALT_sctpPeerAddrChange = 2, ALT_sctpSendFailed = 3, ALT_sctpRemoteError = 4, ALT_sctpShutDownEvent = 5, ALT_sctpPartialDeliveryEvent = 6, ALT_sctpAdaptationIndication = 7, ALT_sctpSenderDryEvent = 8 };
private:
union_selection_type union_selection;
union {
SctpAssocChange *field_sctpAssocChange;
SctpPeerAddrChange *field_sctpPeerAddrChange;
SctpSendFailed *field_sctpSendFailed;
SctpRemoteError *field_sctpRemoteError;
SctpShutDownEvent *field_sctpShutDownEvent;
SctpPartialDeliveryEvent *field_sctpPartialDeliveryEvent;
SctpAdaptationIndication *field_sctpAdaptationIndication;
SctpSenderDryEvent *field_sctpSenderDryEvent;
};
void copy_value(const SctpEvent& other_value);

public:
SctpEvent();
SctpEvent(const SctpEvent& other_value);
~SctpEvent();
SctpEvent& operator=(const SctpEvent& other_value);
boolean operator==(const SctpEvent& other_value) const;
inline boolean operator!=(const SctpEvent& other_value) const { return !(*this == other_value); }
SctpAssocChange& sctpAssocChange();
const SctpAssocChange& sctpAssocChange() const;
SctpPeerAddrChange& sctpPeerAddrChange();
const SctpPeerAddrChange& sctpPeerAddrChange() const;
SctpSendFailed& sctpSendFailed();
const SctpSendFailed& sctpSendFailed() const;
SctpRemoteError& sctpRemoteError();
const SctpRemoteError& sctpRemoteError() const;
SctpShutDownEvent& sctpShutDownEvent();
const SctpShutDownEvent& sctpShutDownEvent() const;
SctpPartialDeliveryEvent& sctpPartialDeliveryEvent();
const SctpPartialDeliveryEvent& sctpPartialDeliveryEvent() const;
SctpAdaptationIndication& sctpAdaptationIndication();
const SctpAdaptationIndication& sctpAdaptationIndication() const;
SctpSenderDryEvent& sctpSenderDryEvent();
const SctpSenderDryEvent& sctpSenderDryEvent() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SctpEvent_template : public Base_Template {
union {
struct {
SctpEvent::union_selection_type union_selection;
union {
SctpAssocChange_template *field_sctpAssocChange;
SctpPeerAddrChange_template *field_sctpPeerAddrChange;
SctpSendFailed_template *field_sctpSendFailed;
SctpRemoteError_template *field_sctpRemoteError;
SctpShutDownEvent_template *field_sctpShutDownEvent;
SctpPartialDeliveryEvent_template *field_sctpPartialDeliveryEvent;
SctpAdaptationIndication_template *field_sctpAdaptationIndication;
SctpSenderDryEvent_template *field_sctpSenderDryEvent;
};
} single_value;
struct {
unsigned int n_values;
SctpEvent_template *list_value;
} value_list;
};
void copy_value(const SctpEvent& other_value);

void copy_template(const SctpEvent_template& other_value);

public:
SctpEvent_template();
SctpEvent_template(template_sel other_value);
SctpEvent_template(const SctpEvent& other_value);
SctpEvent_template(const OPTIONAL<SctpEvent>& other_value);
SctpEvent_template(const SctpEvent_template& other_value);
~SctpEvent_template();
void clean_up();
SctpEvent_template& operator=(template_sel other_value);
SctpEvent_template& operator=(const SctpEvent& other_value);
SctpEvent_template& operator=(const OPTIONAL<SctpEvent>& other_value);
SctpEvent_template& operator=(const SctpEvent_template& other_value);
boolean match(const SctpEvent& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SctpEvent valueof() const;
SctpEvent_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
SctpAssocChange_template& sctpAssocChange();
const SctpAssocChange_template& sctpAssocChange() const;
SctpPeerAddrChange_template& sctpPeerAddrChange();
const SctpPeerAddrChange_template& sctpPeerAddrChange() const;
SctpSendFailed_template& sctpSendFailed();
const SctpSendFailed_template& sctpSendFailed() const;
SctpRemoteError_template& sctpRemoteError();
const SctpRemoteError_template& sctpRemoteError() const;
SctpShutDownEvent_template& sctpShutDownEvent();
const SctpShutDownEvent_template& sctpShutDownEvent() const;
SctpPartialDeliveryEvent_template& sctpPartialDeliveryEvent();
const SctpPartialDeliveryEvent_template& sctpPartialDeliveryEvent() const;
SctpAdaptationIndication_template& sctpAdaptationIndication();
const SctpAdaptationIndication_template& sctpAdaptationIndication() const;
SctpSenderDryEvent_template& sctpSenderDryEvent();
const SctpSenderDryEvent_template& sctpSenderDryEvent() const;
boolean ischosen(SctpEvent::union_selection_type checked_selection) const;
void log() const;
void log_match(const SctpEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SAC__STATE : public Base_Type { // enum
friend class SAC__STATE_template;
public:
enum enum_type { SCTP__COMM__UP = 0, SCTP__COMM__LOST = 1, SCTP__RESTART = 2, SCTP__SHUTDOWN__COMP = 3, SCTP__CANT__STR__ASSOC = 4, SCTP__UNKNOWN__SAC__STATE = 5, UNKNOWN_VALUE = 6, UNBOUND_VALUE = 7 };
private:
enum_type enum_value;

public:
SAC__STATE();
SAC__STATE(int other_value);
SAC__STATE(enum_type other_value);
SAC__STATE(const SAC__STATE& other_value);

SAC__STATE& operator=(int other_value);
SAC__STATE& operator=(enum_type other_value);
SAC__STATE& operator=(const SAC__STATE& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SAC__STATE& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SAC__STATE& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SAC__STATE& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SAC__STATE& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SAC__STATE& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SAC__STATE& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SAC__STATE& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SAC__STATE_template : public Base_Template {
union {
SAC__STATE::enum_type single_value;
struct {
unsigned int n_values;
SAC__STATE_template *list_value;
} value_list;
};

void copy_template(const SAC__STATE_template& other_value);

public:
SAC__STATE_template();
SAC__STATE_template(template_sel other_value);
SAC__STATE_template(int other_value);
SAC__STATE_template(SAC__STATE::enum_type other_value);
SAC__STATE_template(const SAC__STATE& other_value);
SAC__STATE_template(const OPTIONAL<SAC__STATE>& other_value);
SAC__STATE_template(const SAC__STATE_template& other_value);
~SAC__STATE_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SAC__STATE_template& operator=(template_sel other_value);
SAC__STATE_template& operator=(int other_value);
SAC__STATE_template& operator=(SAC__STATE::enum_type other_value);
SAC__STATE_template& operator=(const SAC__STATE& other_value);
SAC__STATE_template& operator=(const OPTIONAL<SAC__STATE>& other_value);
SAC__STATE_template& operator=(const SAC__STATE_template& other_value);

boolean match(SAC__STATE::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SAC__STATE& other_value, boolean legacy = FALSE) const;
SAC__STATE::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SAC__STATE_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SAC__STATE& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SctpAssocChange {
  INTEGER field_clientId;
  ProtoTuple field_proto;
  SAC__STATE field_sac__state;
public:
  SctpAssocChange();
  SctpAssocChange(const INTEGER& par_clientId,
    const ProtoTuple& par_proto,
    const SAC__STATE& par_sac__state);
  SctpAssocChange(const SctpAssocChange& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpAssocChange& operator=(const SctpAssocChange& other_value);
  boolean operator==(const SctpAssocChange& other_value) const;
  inline boolean operator!=(const SctpAssocChange& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline ProtoTuple& proto()
    {return field_proto;}
  inline const ProtoTuple& proto() const
    {return field_proto;}
  inline SAC__STATE& sac__state()
    {return field_sac__state;}
  inline const SAC__STATE& sac__state() const
    {return field_sac__state;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpAssocChange_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpAssocChange_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpAssocChange& other_value);
void copy_template(const SctpAssocChange_template& other_value);

public:
SctpAssocChange_template();
SctpAssocChange_template(template_sel other_value);
SctpAssocChange_template(const SctpAssocChange& other_value);
SctpAssocChange_template(const OPTIONAL<SctpAssocChange>& other_value);
SctpAssocChange_template(const SctpAssocChange_template& other_value);
~SctpAssocChange_template();
SctpAssocChange_template& operator=(template_sel other_value);
SctpAssocChange_template& operator=(const SctpAssocChange& other_value);
SctpAssocChange_template& operator=(const OPTIONAL<SctpAssocChange>& other_value);
SctpAssocChange_template& operator=(const SctpAssocChange_template& other_value);
boolean match(const SctpAssocChange& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpAssocChange valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpAssocChange_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
ProtoTuple_template& proto();
const ProtoTuple_template& proto() const;
SAC__STATE_template& sac__state();
const SAC__STATE_template& sac__state() const;
int size_of() const;
void log() const;
void log_match(const SctpAssocChange& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SPC__STATE : public Base_Type { // enum
friend class SPC__STATE_template;
public:
enum enum_type { SCTP__ADDR__AVAILABLE = 0, SCTP__ADDR__UNREACHABLE = 1, SCTP__ADDR__REMOVED = 2, SCTP__ADDR__ADDED = 3, SCTP__ADDR__MADE__PRIM = 4, SCTP__ADDR__CONFIRMED = 5, SCTP__UNKNOWN__SPC__STATE = 6, UNKNOWN_VALUE = 7, UNBOUND_VALUE = 8 };
private:
enum_type enum_value;

public:
SPC__STATE();
SPC__STATE(int other_value);
SPC__STATE(enum_type other_value);
SPC__STATE(const SPC__STATE& other_value);

SPC__STATE& operator=(int other_value);
SPC__STATE& operator=(enum_type other_value);
SPC__STATE& operator=(const SPC__STATE& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SPC__STATE& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SPC__STATE& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SPC__STATE& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SPC__STATE& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SPC__STATE& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SPC__STATE& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SPC__STATE& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SPC__STATE_template : public Base_Template {
union {
SPC__STATE::enum_type single_value;
struct {
unsigned int n_values;
SPC__STATE_template *list_value;
} value_list;
};

void copy_template(const SPC__STATE_template& other_value);

public:
SPC__STATE_template();
SPC__STATE_template(template_sel other_value);
SPC__STATE_template(int other_value);
SPC__STATE_template(SPC__STATE::enum_type other_value);
SPC__STATE_template(const SPC__STATE& other_value);
SPC__STATE_template(const OPTIONAL<SPC__STATE>& other_value);
SPC__STATE_template(const SPC__STATE_template& other_value);
~SPC__STATE_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SPC__STATE_template& operator=(template_sel other_value);
SPC__STATE_template& operator=(int other_value);
SPC__STATE_template& operator=(SPC__STATE::enum_type other_value);
SPC__STATE_template& operator=(const SPC__STATE& other_value);
SPC__STATE_template& operator=(const OPTIONAL<SPC__STATE>& other_value);
SPC__STATE_template& operator=(const SPC__STATE_template& other_value);

boolean match(SPC__STATE::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SPC__STATE& other_value, boolean legacy = FALSE) const;
SPC__STATE::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SPC__STATE_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SPC__STATE& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SctpPeerAddrChange {
  INTEGER field_clientId;
  SPC__STATE field_spc__state;
public:
  SctpPeerAddrChange();
  SctpPeerAddrChange(const INTEGER& par_clientId,
    const SPC__STATE& par_spc__state);
  SctpPeerAddrChange(const SctpPeerAddrChange& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpPeerAddrChange& operator=(const SctpPeerAddrChange& other_value);
  boolean operator==(const SctpPeerAddrChange& other_value) const;
  inline boolean operator!=(const SctpPeerAddrChange& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline SPC__STATE& spc__state()
    {return field_spc__state;}
  inline const SPC__STATE& spc__state() const
    {return field_spc__state;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpPeerAddrChange_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpPeerAddrChange_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpPeerAddrChange& other_value);
void copy_template(const SctpPeerAddrChange_template& other_value);

public:
SctpPeerAddrChange_template();
SctpPeerAddrChange_template(template_sel other_value);
SctpPeerAddrChange_template(const SctpPeerAddrChange& other_value);
SctpPeerAddrChange_template(const OPTIONAL<SctpPeerAddrChange>& other_value);
SctpPeerAddrChange_template(const SctpPeerAddrChange_template& other_value);
~SctpPeerAddrChange_template();
SctpPeerAddrChange_template& operator=(template_sel other_value);
SctpPeerAddrChange_template& operator=(const SctpPeerAddrChange& other_value);
SctpPeerAddrChange_template& operator=(const OPTIONAL<SctpPeerAddrChange>& other_value);
SctpPeerAddrChange_template& operator=(const SctpPeerAddrChange_template& other_value);
boolean match(const SctpPeerAddrChange& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpPeerAddrChange valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpPeerAddrChange_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
SPC__STATE_template& spc__state();
const SPC__STATE_template& spc__state() const;
int size_of() const;
void log() const;
void log_match(const SctpPeerAddrChange& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpSendFailed {
  INTEGER field_clientId;
public:
  SctpSendFailed();
  SctpSendFailed(const INTEGER& par_clientId);
  SctpSendFailed(const SctpSendFailed& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpSendFailed& operator=(const SctpSendFailed& other_value);
  boolean operator==(const SctpSendFailed& other_value) const;
  inline boolean operator!=(const SctpSendFailed& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpSendFailed_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpSendFailed_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpSendFailed& other_value);
void copy_template(const SctpSendFailed_template& other_value);

public:
SctpSendFailed_template();
SctpSendFailed_template(template_sel other_value);
SctpSendFailed_template(const SctpSendFailed& other_value);
SctpSendFailed_template(const OPTIONAL<SctpSendFailed>& other_value);
SctpSendFailed_template(const SctpSendFailed_template& other_value);
~SctpSendFailed_template();
SctpSendFailed_template& operator=(template_sel other_value);
SctpSendFailed_template& operator=(const SctpSendFailed& other_value);
SctpSendFailed_template& operator=(const OPTIONAL<SctpSendFailed>& other_value);
SctpSendFailed_template& operator=(const SctpSendFailed_template& other_value);
boolean match(const SctpSendFailed& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpSendFailed valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpSendFailed_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpSendFailed& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpRemoteError {
  INTEGER field_clientId;
public:
  SctpRemoteError();
  SctpRemoteError(const INTEGER& par_clientId);
  SctpRemoteError(const SctpRemoteError& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpRemoteError& operator=(const SctpRemoteError& other_value);
  boolean operator==(const SctpRemoteError& other_value) const;
  inline boolean operator!=(const SctpRemoteError& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpRemoteError_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpRemoteError_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpRemoteError& other_value);
void copy_template(const SctpRemoteError_template& other_value);

public:
SctpRemoteError_template();
SctpRemoteError_template(template_sel other_value);
SctpRemoteError_template(const SctpRemoteError& other_value);
SctpRemoteError_template(const OPTIONAL<SctpRemoteError>& other_value);
SctpRemoteError_template(const SctpRemoteError_template& other_value);
~SctpRemoteError_template();
SctpRemoteError_template& operator=(template_sel other_value);
SctpRemoteError_template& operator=(const SctpRemoteError& other_value);
SctpRemoteError_template& operator=(const OPTIONAL<SctpRemoteError>& other_value);
SctpRemoteError_template& operator=(const SctpRemoteError_template& other_value);
boolean match(const SctpRemoteError& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpRemoteError valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpRemoteError_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpRemoteError& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpShutDownEvent {
  INTEGER field_clientId;
public:
  SctpShutDownEvent();
  SctpShutDownEvent(const INTEGER& par_clientId);
  SctpShutDownEvent(const SctpShutDownEvent& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpShutDownEvent& operator=(const SctpShutDownEvent& other_value);
  boolean operator==(const SctpShutDownEvent& other_value) const;
  inline boolean operator!=(const SctpShutDownEvent& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpShutDownEvent_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpShutDownEvent_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpShutDownEvent& other_value);
void copy_template(const SctpShutDownEvent_template& other_value);

public:
SctpShutDownEvent_template();
SctpShutDownEvent_template(template_sel other_value);
SctpShutDownEvent_template(const SctpShutDownEvent& other_value);
SctpShutDownEvent_template(const OPTIONAL<SctpShutDownEvent>& other_value);
SctpShutDownEvent_template(const SctpShutDownEvent_template& other_value);
~SctpShutDownEvent_template();
SctpShutDownEvent_template& operator=(template_sel other_value);
SctpShutDownEvent_template& operator=(const SctpShutDownEvent& other_value);
SctpShutDownEvent_template& operator=(const OPTIONAL<SctpShutDownEvent>& other_value);
SctpShutDownEvent_template& operator=(const SctpShutDownEvent_template& other_value);
boolean match(const SctpShutDownEvent& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpShutDownEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpShutDownEvent_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpShutDownEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpPartialDeliveryEvent {
  INTEGER field_clientId;
public:
  SctpPartialDeliveryEvent();
  SctpPartialDeliveryEvent(const INTEGER& par_clientId);
  SctpPartialDeliveryEvent(const SctpPartialDeliveryEvent& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpPartialDeliveryEvent& operator=(const SctpPartialDeliveryEvent& other_value);
  boolean operator==(const SctpPartialDeliveryEvent& other_value) const;
  inline boolean operator!=(const SctpPartialDeliveryEvent& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpPartialDeliveryEvent_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpPartialDeliveryEvent_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpPartialDeliveryEvent& other_value);
void copy_template(const SctpPartialDeliveryEvent_template& other_value);

public:
SctpPartialDeliveryEvent_template();
SctpPartialDeliveryEvent_template(template_sel other_value);
SctpPartialDeliveryEvent_template(const SctpPartialDeliveryEvent& other_value);
SctpPartialDeliveryEvent_template(const OPTIONAL<SctpPartialDeliveryEvent>& other_value);
SctpPartialDeliveryEvent_template(const SctpPartialDeliveryEvent_template& other_value);
~SctpPartialDeliveryEvent_template();
SctpPartialDeliveryEvent_template& operator=(template_sel other_value);
SctpPartialDeliveryEvent_template& operator=(const SctpPartialDeliveryEvent& other_value);
SctpPartialDeliveryEvent_template& operator=(const OPTIONAL<SctpPartialDeliveryEvent>& other_value);
SctpPartialDeliveryEvent_template& operator=(const SctpPartialDeliveryEvent_template& other_value);
boolean match(const SctpPartialDeliveryEvent& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpPartialDeliveryEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpPartialDeliveryEvent_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpPartialDeliveryEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpAdaptationIndication {
  INTEGER field_clientId;
public:
  SctpAdaptationIndication();
  SctpAdaptationIndication(const INTEGER& par_clientId);
  SctpAdaptationIndication(const SctpAdaptationIndication& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpAdaptationIndication& operator=(const SctpAdaptationIndication& other_value);
  boolean operator==(const SctpAdaptationIndication& other_value) const;
  inline boolean operator!=(const SctpAdaptationIndication& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpAdaptationIndication_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpAdaptationIndication_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpAdaptationIndication& other_value);
void copy_template(const SctpAdaptationIndication_template& other_value);

public:
SctpAdaptationIndication_template();
SctpAdaptationIndication_template(template_sel other_value);
SctpAdaptationIndication_template(const SctpAdaptationIndication& other_value);
SctpAdaptationIndication_template(const OPTIONAL<SctpAdaptationIndication>& other_value);
SctpAdaptationIndication_template(const SctpAdaptationIndication_template& other_value);
~SctpAdaptationIndication_template();
SctpAdaptationIndication_template& operator=(template_sel other_value);
SctpAdaptationIndication_template& operator=(const SctpAdaptationIndication& other_value);
SctpAdaptationIndication_template& operator=(const OPTIONAL<SctpAdaptationIndication>& other_value);
SctpAdaptationIndication_template& operator=(const SctpAdaptationIndication_template& other_value);
boolean match(const SctpAdaptationIndication& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpAdaptationIndication valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpAdaptationIndication_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpAdaptationIndication& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SctpSenderDryEvent {
  INTEGER field_clientId;
public:
  SctpSenderDryEvent();
  SctpSenderDryEvent(const INTEGER& par_clientId);
  SctpSenderDryEvent(const SctpSenderDryEvent& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SctpSenderDryEvent& operator=(const SctpSenderDryEvent& other_value);
  boolean operator==(const SctpSenderDryEvent& other_value) const;
  inline boolean operator!=(const SctpSenderDryEvent& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientId()
    {return field_clientId;}
  inline const INTEGER& clientId() const
    {return field_clientId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SctpSenderDryEvent_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SctpSenderDryEvent_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SctpSenderDryEvent& other_value);
void copy_template(const SctpSenderDryEvent_template& other_value);

public:
SctpSenderDryEvent_template();
SctpSenderDryEvent_template(template_sel other_value);
SctpSenderDryEvent_template(const SctpSenderDryEvent& other_value);
SctpSenderDryEvent_template(const OPTIONAL<SctpSenderDryEvent>& other_value);
SctpSenderDryEvent_template(const SctpSenderDryEvent_template& other_value);
~SctpSenderDryEvent_template();
SctpSenderDryEvent_template& operator=(template_sel other_value);
SctpSenderDryEvent_template& operator=(const SctpSenderDryEvent& other_value);
SctpSenderDryEvent_template& operator=(const OPTIONAL<SctpSenderDryEvent>& other_value);
SctpSenderDryEvent_template& operator=(const SctpSenderDryEvent_template& other_value);
boolean match(const SctpSenderDryEvent& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SctpSenderDryEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SctpSenderDryEvent_template& list_item(unsigned int list_index) const;
INTEGER_template& clientId();
const INTEGER_template& clientId() const;
int size_of() const;
void log() const;
void log_match(const SctpSenderDryEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PortEvent : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_connOpened = 1, ALT_connClosed = 2, ALT_result = 3, ALT_extended__result = 4, ALT_sctpEvent = 5 };
private:
union_selection_type union_selection;
union {
ConnectionOpenedEvent *field_connOpened;
ConnectionOpenedEvent *field_connClosed;
Result *field_result;
Extended__Result *field_extended__result;
SctpEvent *field_sctpEvent;
};
void copy_value(const PortEvent& other_value);

public:
PortEvent();
PortEvent(const PortEvent& other_value);
~PortEvent();
PortEvent& operator=(const PortEvent& other_value);
boolean operator==(const PortEvent& other_value) const;
inline boolean operator!=(const PortEvent& other_value) const { return !(*this == other_value); }
ConnectionOpenedEvent& connOpened();
const ConnectionOpenedEvent& connOpened() const;
ConnectionOpenedEvent& connClosed();
const ConnectionOpenedEvent& connClosed() const;
Result& result();
const Result& result() const;
Extended__Result& extended__result();
const Extended__Result& extended__result() const;
SctpEvent& sctpEvent();
const SctpEvent& sctpEvent() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class PortEvent_template : public Base_Template {
union {
struct {
PortEvent::union_selection_type union_selection;
union {
ConnectionOpenedEvent_template *field_connOpened;
ConnectionOpenedEvent_template *field_connClosed;
Result_template *field_result;
Extended__Result_template *field_extended__result;
SctpEvent_template *field_sctpEvent;
};
} single_value;
struct {
unsigned int n_values;
PortEvent_template *list_value;
} value_list;
};
void copy_value(const PortEvent& other_value);

void copy_template(const PortEvent_template& other_value);

public:
PortEvent_template();
PortEvent_template(template_sel other_value);
PortEvent_template(const PortEvent& other_value);
PortEvent_template(const OPTIONAL<PortEvent>& other_value);
PortEvent_template(const PortEvent_template& other_value);
~PortEvent_template();
void clean_up();
PortEvent_template& operator=(template_sel other_value);
PortEvent_template& operator=(const PortEvent& other_value);
PortEvent_template& operator=(const OPTIONAL<PortEvent>& other_value);
PortEvent_template& operator=(const PortEvent_template& other_value);
boolean match(const PortEvent& other_value, boolean legacy = FALSE) const;
boolean is_value() const;PortEvent valueof() const;
PortEvent_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ConnectionOpenedEvent_template& connOpened();
const ConnectionOpenedEvent_template& connOpened() const;
ConnectionOpenedEvent_template& connClosed();
const ConnectionOpenedEvent_template& connClosed() const;
Result_template& result();
const Result_template& result() const;
Extended__Result_template& extended__result();
const Extended__Result_template& extended__result() const;
SctpEvent_template& sctpEvent();
const SctpEvent_template& sctpEvent() const;
boolean ischosen(PortEvent::union_selection_type checked_selection) const;
void log() const;
void log_match(const PortEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class f__getMsgLen : public Base_Type {
public:
typedef INTEGER (*function_pointer)(const OCTETSTRING& stream, ro__integer& args);
typedef void (*start_pointer)(const COMPONENT& component_reference, const OCTETSTRING& stream, ro__integer& args);
private:
friend class f__getMsgLen_template;
friend boolean operator==(f__getMsgLen::function_pointer value, const f__getMsgLen& other_value);
function_pointer referred_function;
public:
f__getMsgLen();
f__getMsgLen(function_pointer other_value);
f__getMsgLen(const f__getMsgLen& other_value);
f__getMsgLen& operator=(function_pointer other_value);
f__getMsgLen& operator=(const f__getMsgLen& other_value);
boolean operator==(function_pointer other_value) const;
boolean operator==(const f__getMsgLen& other_value) const;
inline boolean operator!=(function_pointer other_value) const
{ return !(*this == other_value); }
inline boolean operator!=(const f__getMsgLen& other_value) const
{ return !(*this == other_value); }

INTEGER invoke(const OCTETSTRING& stream, ro__integer& args) const;
inline boolean is_bound() const { return referred_function != NULL; }
inline boolean is_value() const { return referred_function != NULL; }
inline void clean_up() { referred_function = NULL; }
inline void must_bound(const char *err_msg) const
{ if (referred_function == NULL) TTCN_error("%s", err_msg); }

inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

extern boolean operator==(f__getMsgLen::function_pointer value, const f__getMsgLen& other_value);
inline boolean operator!=(f__getMsgLen::function_pointer value, const f__getMsgLen& other_value)
{ return !(value == other_value); } 

class f__getMsgLen_template : public Base_Template {
union {
f__getMsgLen::function_pointer single_value;
struct {
unsigned int n_values;
f__getMsgLen_template *list_value;
} value_list;
};

  void copy_template(const f__getMsgLen_template& other_value);
public:
f__getMsgLen_template();
f__getMsgLen_template(template_sel other_value);
f__getMsgLen_template(f__getMsgLen::function_pointer other_value);
f__getMsgLen_template(const f__getMsgLen& other_value);
f__getMsgLen_template(const OPTIONAL<f__getMsgLen>& other_value);
f__getMsgLen_template(const f__getMsgLen_template& other_value);
~f__getMsgLen_template();
void clean_up();
f__getMsgLen_template& operator=(template_sel other_value);
f__getMsgLen_template& operator=(f__getMsgLen::function_pointer other_value);
f__getMsgLen_template& operator=(const f__getMsgLen& other_value);
f__getMsgLen_template& operator=(const OPTIONAL<f__getMsgLen>& other_value);
f__getMsgLen_template& operator=(const f__getMsgLen_template& other_value);
boolean match(f__getMsgLen::function_pointer other_value, boolean legacy = FALSE) const;
boolean match(const f__getMsgLen& other_value, boolean legacy = FALSE) const;
f__getMsgLen valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
f__getMsgLen_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const f__getMsgLen& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const SocketList& other_value);
inline boolean operator!=(null_type null_value, const SocketList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UdpTuple& other_value);
inline boolean operator!=(null_type null_value, const UdpTuple& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UdpLightTuple& other_value);
inline boolean operator!=(null_type null_value, const UdpLightTuple& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const TcpTuple& other_value);
inline boolean operator!=(null_type null_value, const TcpTuple& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SslTuple& other_value);
inline boolean operator!=(null_type null_value, const SslTuple& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UnspecifiedTuple& other_value);
inline boolean operator!=(null_type null_value, const UnspecifiedTuple& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t ConnectionId_xer_;
extern const TTCN_Typedescriptor_t ConnectionId_descr_;
extern const TTCN_Typedescriptor_t ro__ConnectionId_descr_;
extern const XERdescriptor_t ro__ConnectionId_0_xer_;
extern const TTCN_Typedescriptor_t ro__ConnectionId_0_descr_;
extern const XERdescriptor_t AssociationId_xer_;
extern const TTCN_Typedescriptor_t AssociationId_descr_;
extern const TTCN_Typedescriptor_t ro__AssociationId_descr_;
extern const XERdescriptor_t ro__AssociationId_0_xer_;
extern const TTCN_Typedescriptor_t ro__AssociationId_0_descr_;
extern const XERdescriptor_t HostName_xer_;
extern const TTCN_Typedescriptor_t HostName_descr_;
extern const XERdescriptor_t PortNumber_xer_;
extern const TTCN_Typedescriptor_t PortNumber_descr_;
extern const XERdescriptor_t Socket_hostName_xer_;
extern const TTCN_Typedescriptor_t Socket_hostName_descr_;
extern const XERdescriptor_t Socket_portNumber_xer_;
extern const TTCN_Typedescriptor_t Socket_portNumber_descr_;
extern const TTCN_Typedescriptor_t Socket_descr_;
extern const TTCN_Typedescriptor_t SocketList_descr_;
extern const CHARSTRING& c__ipv4AnyAddr;
extern const CHARSTRING& c__ipv6AnyAddr;
extern const INTEGER& c__anyPort;
extern const CHARSTRING& c__defaultLocAddr;
extern const INTEGER& c__defaultLocPort;
extern const TTCN_Typedescriptor_t UdpTuple_descr_;
extern const TTCN_Typedescriptor_t UdpLightTuple_descr_;
extern const TTCN_Typedescriptor_t TcpTuple_descr_;
extern const TTCN_Typedescriptor_t SctpTuple_descr_;
extern const XERdescriptor_t SctpTuple_sinfo__stream_xer_;
extern const TTCN_Typedescriptor_t SctpTuple_sinfo__stream_descr_;
extern const XERdescriptor_t SctpTuple_sinfo__ppid_xer_;
extern const TTCN_Typedescriptor_t SctpTuple_sinfo__ppid_descr_;
extern const XERdescriptor_t SctpTuple_assocId_xer_;
extern const TTCN_Typedescriptor_t SctpTuple_assocId_descr_;
extern const TTCN_Typedescriptor_t SslTuple_descr_;
extern const TTCN_Typedescriptor_t DtlsTuple_descr_;
extern const TTCN_Typedescriptor_t UnspecifiedTuple_descr_;
extern const TTCN_Typedescriptor_t ProtoTuple_descr_;
extern const XERdescriptor_t UserData_xer_;
extern const TTCN_Typedescriptor_t UserData_descr_;
extern const TTCN_Typedescriptor_t PortError_descr_;
extern const TTCN_Typedescriptor_t Result_descr_;
extern const XERdescriptor_t Result_connId_xer_;
extern const TTCN_Typedescriptor_t Result_connId_descr_;
extern const XERdescriptor_t Result_os__error__code_xer_;
extern const TTCN_Typedescriptor_t Result_os__error__code_descr_;
extern const XERdescriptor_t Result_os__error__text_xer_;
extern const TTCN_Typedescriptor_t Result_os__error__text_descr_;
extern const TTCN_Typedescriptor_t Extended__Result_descr_;
extern const XERdescriptor_t Extended__Result_connId_xer_;
extern const TTCN_Typedescriptor_t Extended__Result_connId_descr_;
extern const XERdescriptor_t Extended__Result_os__error__code_xer_;
extern const TTCN_Typedescriptor_t Extended__Result_os__error__code_descr_;
extern const XERdescriptor_t Extended__Result_os__error__text_xer_;
extern const TTCN_Typedescriptor_t Extended__Result_os__error__text_descr_;
extern const XERdescriptor_t Extended__Result_msg_xer_;
extern const TTCN_Typedescriptor_t Extended__Result_msg_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_connId_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_connId_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_remName_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_remName_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_remPort_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_remPort_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_locName_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_locName_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_locPort_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_locPort_descr_;
extern const XERdescriptor_t ConnectionOpenedEvent_userData_xer_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_userData_descr_;
extern const TTCN_Typedescriptor_t ConnectionOpenedEvent_descr_;
extern const TTCN_Typedescriptor_t& ConnectionClosedEvent_descr_;
extern const TTCN_Typedescriptor_t SctpEvent_descr_;
extern const XERdescriptor_t SctpAssocChange_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpAssocChange_clientId_descr_;
extern const TTCN_Typedescriptor_t SAC__STATE_descr_;
extern const TTCN_Typedescriptor_t SctpAssocChange_descr_;
extern const XERdescriptor_t SctpPeerAddrChange_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpPeerAddrChange_clientId_descr_;
extern const TTCN_Typedescriptor_t SPC__STATE_descr_;
extern const TTCN_Typedescriptor_t SctpPeerAddrChange_descr_;
extern const XERdescriptor_t SctpSendFailed_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpSendFailed_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpSendFailed_descr_;
extern const XERdescriptor_t SctpRemoteError_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpRemoteError_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpRemoteError_descr_;
extern const XERdescriptor_t SctpShutDownEvent_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpShutDownEvent_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpShutDownEvent_descr_;
extern const XERdescriptor_t SctpPartialDeliveryEvent_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpPartialDeliveryEvent_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpPartialDeliveryEvent_descr_;
extern const XERdescriptor_t SctpAdaptationIndication_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpAdaptationIndication_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpAdaptationIndication_descr_;
extern const XERdescriptor_t SctpSenderDryEvent_clientId_xer_;
extern const TTCN_Typedescriptor_t SctpSenderDryEvent_clientId_descr_;
extern const TTCN_Typedescriptor_t SctpSenderDryEvent_descr_;
extern const TTCN_Typedescriptor_t PortEvent_descr_;
extern const TTCN_Typedescriptor_t ro__integer_descr_;
extern const XERdescriptor_t ro__integer_0_xer_;
extern const TTCN_Typedescriptor_t ro__integer_0_descr_;
extern const TTCN_Typedescriptor_t f__getMsgLen_descr_;
extern const TTCN_Typedescriptor_t ro__charstring_descr_;
extern const XERdescriptor_t ro__charstring_0_xer_;
extern const TTCN_Typedescriptor_t ro__charstring_0_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
