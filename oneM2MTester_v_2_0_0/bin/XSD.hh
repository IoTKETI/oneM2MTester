// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for oneM2MTester (martin@ubuntu) on Wed May 31 13:52:14 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef XSD_HH
#define XSD_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "UsefulTtcn3Types.hh"

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef XSD_HH
#endif

namespace XSD {

/* Forward declarations of classes */

typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING AnyType_elem__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template AnyType_elem__list_template;
class AnyType;
class AnyType_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING AnyType_embed__values;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template AnyType_embed__values_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING AnyType_attr;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template AnyType_attr_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING NMTOKENS;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template NMTOKENS_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING IDREFS;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template IDREFS_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING ENTITIES;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template ENTITIES_template;
class QName;
class QName_template;

} /* end of namespace */

#ifndef XSD_HH
#define XSD_HH

namespace XSD {

/* Type definitions */

typedef UNIVERSAL_CHARSTRING XMLCompatibleString;
typedef UNIVERSAL_CHARSTRING_template XMLCompatibleString_template;
typedef UNIVERSAL_CHARSTRING AnySimpleType;
typedef UNIVERSAL_CHARSTRING_template AnySimpleType_template;
typedef UNIVERSAL_CHARSTRING String;
typedef UNIVERSAL_CHARSTRING_template String_template;
typedef UNIVERSAL_CHARSTRING XMLStringWithNoCRLFHT;
typedef UNIVERSAL_CHARSTRING_template XMLStringWithNoCRLFHT_template;
typedef UNIVERSAL_CHARSTRING NormalizedString;
typedef UNIVERSAL_CHARSTRING_template NormalizedString_template;
typedef UNIVERSAL_CHARSTRING Token;
typedef UNIVERSAL_CHARSTRING_template Token_template;
typedef UNIVERSAL_CHARSTRING XMLStringWithNoWhitespace;
typedef UNIVERSAL_CHARSTRING_template XMLStringWithNoWhitespace_template;
typedef UNIVERSAL_CHARSTRING Name;
typedef UNIVERSAL_CHARSTRING_template Name_template;
typedef UNIVERSAL_CHARSTRING NMTOKEN;
typedef UNIVERSAL_CHARSTRING_template NMTOKEN_template;
typedef UNIVERSAL_CHARSTRING NCName;
typedef UNIVERSAL_CHARSTRING_template NCName_template;
typedef UNIVERSAL_CHARSTRING ID;
typedef UNIVERSAL_CHARSTRING_template ID_template;
typedef UNIVERSAL_CHARSTRING IDREF;
typedef UNIVERSAL_CHARSTRING_template IDREF_template;
typedef UNIVERSAL_CHARSTRING ENTITY;
typedef UNIVERSAL_CHARSTRING_template ENTITY_template;
typedef OCTETSTRING HexBinary;
typedef OCTETSTRING_template HexBinary_template;
typedef OCTETSTRING Base64Binary;
typedef OCTETSTRING_template Base64Binary_template;
typedef UNIVERSAL_CHARSTRING AnyURI;
typedef UNIVERSAL_CHARSTRING_template AnyURI_template;
typedef CHARSTRING Language;
typedef CHARSTRING_template Language_template;
typedef INTEGER Integer;
typedef INTEGER_template Integer_template;
typedef INTEGER PositiveInteger;
typedef INTEGER_template PositiveInteger_template;
typedef INTEGER NonPositiveInteger;
typedef INTEGER_template NonPositiveInteger_template;
typedef INTEGER NegativeInteger;
typedef INTEGER_template NegativeInteger_template;
typedef INTEGER NonNegativeInteger;
typedef INTEGER_template NonNegativeInteger_template;
typedef INTEGER Long;
typedef INTEGER_template Long_template;
typedef INTEGER UnsignedLong;
typedef INTEGER_template UnsignedLong_template;
typedef INTEGER Int;
typedef INTEGER_template Int_template;
typedef INTEGER UnsignedInt;
typedef INTEGER_template UnsignedInt_template;
typedef INTEGER Short;
typedef INTEGER_template Short_template;
typedef INTEGER UnsignedShort;
typedef INTEGER_template UnsignedShort_template;
typedef INTEGER Byte;
typedef INTEGER_template Byte_template;
typedef INTEGER UnsignedByte;
typedef INTEGER_template UnsignedByte_template;
typedef FLOAT Decimal;
typedef FLOAT_template Decimal_template;
typedef FLOAT Float;
typedef FLOAT_template Float_template;
typedef FLOAT Double;
typedef FLOAT_template Double_template;
typedef CHARSTRING Duration;
typedef CHARSTRING_template Duration_template;
typedef CHARSTRING DateTime;
typedef CHARSTRING_template DateTime_template;
typedef CHARSTRING Time;
typedef CHARSTRING_template Time_template;
typedef CHARSTRING Date;
typedef CHARSTRING_template Date_template;
typedef CHARSTRING GYearMonth;
typedef CHARSTRING_template GYearMonth_template;
typedef CHARSTRING GYear;
typedef CHARSTRING_template GYear_template;
typedef CHARSTRING GMonthDay;
typedef CHARSTRING_template GMonthDay_template;
typedef CHARSTRING GDay;
typedef CHARSTRING_template GDay_template;
typedef CHARSTRING GMonth;
typedef CHARSTRING_template GMonth_template;
typedef BOOLEAN Boolean;
typedef BOOLEAN_template Boolean_template;

/* Class definitions */

class AnyType : public Base_Type {
  OPTIONAL<AnyType_embed__values> field_embed__values;
  OPTIONAL<AnyType_attr> field_attr;
  AnyType_elem__list field_elem__list;
public:
  AnyType();
  AnyType(const OPTIONAL<AnyType_embed__values>& par_embed__values,
    const OPTIONAL<AnyType_attr>& par_attr,
    const AnyType_elem__list& par_elem__list);
  AnyType(const AnyType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AnyType& operator=(const AnyType& other_value);
  boolean operator==(const AnyType& other_value) const;
  inline boolean operator!=(const AnyType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<AnyType_embed__values>& embed__values()
    {return field_embed__values;}
  inline const OPTIONAL<AnyType_embed__values>& embed__values() const
    {return field_embed__values;}
  inline OPTIONAL<AnyType_attr>& attr()
    {return field_attr;}
  inline const OPTIONAL<AnyType_attr>& attr() const
    {return field_attr;}
  inline AnyType_elem__list& elem__list()
    {return field_elem__list;}
  inline const AnyType_elem__list& elem__list() const
    {return field_elem__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int,unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns, unsigned int flavor = 0) const;
};

class AnyType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AnyType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AnyType& other_value);
void copy_template(const AnyType_template& other_value);

public:
AnyType_template();
AnyType_template(template_sel other_value);
AnyType_template(const AnyType& other_value);
AnyType_template(const OPTIONAL<AnyType>& other_value);
AnyType_template(const AnyType_template& other_value);
~AnyType_template();
AnyType_template& operator=(template_sel other_value);
AnyType_template& operator=(const AnyType& other_value);
AnyType_template& operator=(const OPTIONAL<AnyType>& other_value);
AnyType_template& operator=(const AnyType_template& other_value);
boolean match(const AnyType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AnyType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AnyType_template& list_item(unsigned int list_index) const;
AnyType_embed__values_template& embed__values();
const AnyType_embed__values_template& embed__values() const;
AnyType_attr_template& attr();
const AnyType_attr_template& attr() const;
AnyType_elem__list_template& elem__list();
const AnyType_elem__list_template& elem__list() const;
int size_of() const;
void log() const;
void log_match(const AnyType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QName : public Base_Type {
  OPTIONAL<UNIVERSAL_CHARSTRING> field_uri;
  UNIVERSAL_CHARSTRING field_name;
public:
  QName();
  QName(const OPTIONAL<UNIVERSAL_CHARSTRING>& par_uri,
    const UNIVERSAL_CHARSTRING& par_name);
  QName(const QName& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QName& operator=(const QName& other_value);
  boolean operator==(const QName& other_value) const;
  inline boolean operator!=(const QName& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<UNIVERSAL_CHARSTRING>& uri()
    {return field_uri;}
  inline const OPTIONAL<UNIVERSAL_CHARSTRING>& uri() const
    {return field_uri;}
  inline UNIVERSAL_CHARSTRING& name()
    {return field_name;}
  inline const UNIVERSAL_CHARSTRING& name() const
    {return field_name;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int XER_encode(const XERdescriptor_t&, TTCN_Buffer&, unsigned int,unsigned int, int, embed_values_enc_struct_t*) const;
int XER_decode(const XERdescriptor_t&, XmlReaderWrap&, unsigned int, unsigned int, embed_values_dec_struct_t*);
static boolean can_start(const char *name, const char *uri, XERdescriptor_t const& xd, unsigned int, unsigned int);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
char **collect_ns(const XERdescriptor_t& p_td, size_t& num_ns, bool& def_ns, unsigned int flavor = 0) const;
};

class QName_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QName_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QName& other_value);
void copy_template(const QName_template& other_value);

public:
QName_template();
QName_template(template_sel other_value);
QName_template(const QName& other_value);
QName_template(const OPTIONAL<QName>& other_value);
QName_template(const QName_template& other_value);
~QName_template();
QName_template& operator=(template_sel other_value);
QName_template& operator=(const QName& other_value);
QName_template& operator=(const OPTIONAL<QName>& other_value);
QName_template& operator=(const QName_template& other_value);
boolean match(const QName& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QName valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QName_template& list_item(unsigned int list_index) const;
UNIVERSAL_CHARSTRING_template& uri();
const UNIVERSAL_CHARSTRING_template& uri() const;
UNIVERSAL_CHARSTRING_template& name();
const UNIVERSAL_CHARSTRING_template& name() const;
int size_of() const;
void log() const;
void log_match(const QName& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const XERdescriptor_t _T_dash_xer_;
extern const TTCN_Typedescriptor_t _T_dash_descr_;
extern const CHARSTRING& dash;
extern const CHARSTRING& cln;
extern const CHARSTRING& year;
extern const CHARSTRING& yearExpansion;
extern const CHARSTRING& month;
extern const CHARSTRING& dayOfMonth;
extern const CHARSTRING& hour;
extern const CHARSTRING& minute;
extern const CHARSTRING& second;
extern const CHARSTRING& sFraction;
extern const CHARSTRING& endOfDayExt;
extern const CHARSTRING& nums;
extern const CHARSTRING& ZorTimeZoneExt;
extern const CHARSTRING& durTime;
extern const XERdescriptor_t XMLCompatibleString_xer_;
extern const TTCN_Typedescriptor_t XMLCompatibleString_descr_;
extern const XERdescriptor_t AnySimpleType_xer_;
extern const TTCN_Typedescriptor_t AnySimpleType_descr_;
extern const XERdescriptor_t AnyType_elem__list_xer_;
extern const TTCN_JSONdescriptor_t AnyType_elem__list_json_;
extern const TTCN_Typedescriptor_t AnyType_elem__list_descr_;
extern const XERdescriptor_t String_xer_;
extern const TTCN_Typedescriptor_t String_descr_;
extern const XERdescriptor_t AnyType_elem__list_0_xer_;
extern const TTCN_Typedescriptor_t AnyType_elem__list_0_descr_;
extern const XERdescriptor_t AnyType_xer_;
extern const TTCN_JSONdescriptor_t AnyType_json_;
extern const TTCN_Typedescriptor_t AnyType_descr_;
extern const XERdescriptor_t AnyType_embed__values_xer_;
extern const TTCN_JSONdescriptor_t AnyType_embed__values_json_;
extern const TTCN_Typedescriptor_t AnyType_embed__values_descr_;
extern const XERdescriptor_t AnyType_embed__values_0_xer_;
extern const TTCN_Typedescriptor_t AnyType_embed__values_0_descr_;
extern const XERdescriptor_t AnyType_attr_xer_;
extern const TTCN_JSONdescriptor_t AnyType_attr_json_;
extern const TTCN_Typedescriptor_t AnyType_attr_descr_;
extern const XERdescriptor_t AnyType_attr_0_xer_;
extern const TTCN_Typedescriptor_t AnyType_attr_0_descr_;
extern const XERdescriptor_t XMLStringWithNoCRLFHT_xer_;
extern const TTCN_Typedescriptor_t XMLStringWithNoCRLFHT_descr_;
extern const XERdescriptor_t NormalizedString_xer_;
extern const TTCN_Typedescriptor_t NormalizedString_descr_;
extern const XERdescriptor_t Token_xer_;
extern const TTCN_Typedescriptor_t Token_descr_;
extern const XERdescriptor_t XMLStringWithNoWhitespace_xer_;
extern const TTCN_Typedescriptor_t XMLStringWithNoWhitespace_descr_;
extern const XERdescriptor_t Name_xer_;
extern const TTCN_Typedescriptor_t Name_descr_;
extern const XERdescriptor_t NMTOKEN_xer_;
extern const TTCN_Typedescriptor_t NMTOKEN_descr_;
extern const XERdescriptor_t NCName_xer_;
extern const TTCN_Typedescriptor_t NCName_descr_;
extern const XERdescriptor_t ID_xer_;
extern const TTCN_Typedescriptor_t ID_descr_;
extern const XERdescriptor_t IDREF_xer_;
extern const TTCN_Typedescriptor_t IDREF_descr_;
extern const XERdescriptor_t ENTITY_xer_;
extern const TTCN_Typedescriptor_t ENTITY_descr_;
extern const XERdescriptor_t HexBinary_xer_;
extern const TTCN_Typedescriptor_t HexBinary_descr_;
extern const XERdescriptor_t Base64Binary_xer_;
extern const TTCN_Typedescriptor_t Base64Binary_descr_;
extern const XERdescriptor_t AnyURI_xer_;
extern const TTCN_Typedescriptor_t AnyURI_descr_;
extern const XERdescriptor_t Language_xer_;
extern const TTCN_Typedescriptor_t Language_descr_;
extern const XERdescriptor_t Integer_xer_;
extern const TTCN_Typedescriptor_t Integer_descr_;
extern const XERdescriptor_t PositiveInteger_xer_;
extern const TTCN_Typedescriptor_t PositiveInteger_descr_;
extern const XERdescriptor_t NonPositiveInteger_xer_;
extern const TTCN_Typedescriptor_t NonPositiveInteger_descr_;
extern const XERdescriptor_t NegativeInteger_xer_;
extern const TTCN_Typedescriptor_t NegativeInteger_descr_;
extern const XERdescriptor_t NonNegativeInteger_xer_;
extern const TTCN_Typedescriptor_t NonNegativeInteger_descr_;
extern const XERdescriptor_t Long_xer_;
extern const TTCN_Typedescriptor_t Long_descr_;
extern const XERdescriptor_t UnsignedLong_xer_;
extern const TTCN_Typedescriptor_t UnsignedLong_descr_;
extern const XERdescriptor_t Int_xer_;
extern const TTCN_Typedescriptor_t Int_descr_;
extern const XERdescriptor_t UnsignedInt_xer_;
extern const TTCN_Typedescriptor_t UnsignedInt_descr_;
extern const XERdescriptor_t Short_xer_;
extern const TTCN_Typedescriptor_t Short_descr_;
extern const XERdescriptor_t UnsignedShort_xer_;
extern const TTCN_Typedescriptor_t UnsignedShort_descr_;
extern const XERdescriptor_t Byte_xer_;
extern const TTCN_Typedescriptor_t Byte_descr_;
extern const XERdescriptor_t UnsignedByte_xer_;
extern const TTCN_Typedescriptor_t UnsignedByte_descr_;
extern const XERdescriptor_t Decimal_xer_;
extern const TTCN_Typedescriptor_t Decimal_descr_;
extern const XERdescriptor_t Float_xer_;
extern const TTCN_Typedescriptor_t Float_descr_;
extern const XERdescriptor_t Double_xer_;
extern const TTCN_Typedescriptor_t Double_descr_;
extern const XERdescriptor_t Duration_xer_;
extern const TTCN_Typedescriptor_t Duration_descr_;
extern const XERdescriptor_t DateTime_xer_;
extern const TTCN_Typedescriptor_t DateTime_descr_;
extern const XERdescriptor_t Time_xer_;
extern const TTCN_Typedescriptor_t Time_descr_;
extern const XERdescriptor_t Date_xer_;
extern const TTCN_Typedescriptor_t Date_descr_;
extern const XERdescriptor_t GYearMonth_xer_;
extern const TTCN_Typedescriptor_t GYearMonth_descr_;
extern const XERdescriptor_t GYear_xer_;
extern const TTCN_Typedescriptor_t GYear_descr_;
extern const XERdescriptor_t GMonthDay_xer_;
extern const TTCN_Typedescriptor_t GMonthDay_descr_;
extern const XERdescriptor_t GDay_xer_;
extern const TTCN_Typedescriptor_t GDay_descr_;
extern const XERdescriptor_t GMonth_xer_;
extern const TTCN_Typedescriptor_t GMonth_descr_;
extern const XERdescriptor_t NMTOKENS_xer_;
extern const TTCN_Typedescriptor_t NMTOKENS_descr_;
extern const XERdescriptor_t NMTOKENS_0_xer_;
extern const TTCN_Typedescriptor_t NMTOKENS_0_descr_;
extern const XERdescriptor_t IDREFS_xer_;
extern const TTCN_Typedescriptor_t IDREFS_descr_;
extern const XERdescriptor_t IDREFS_0_xer_;
extern const TTCN_Typedescriptor_t IDREFS_0_descr_;
extern const XERdescriptor_t ENTITIES_xer_;
extern const TTCN_Typedescriptor_t ENTITIES_descr_;
extern const XERdescriptor_t ENTITIES_0_xer_;
extern const TTCN_Typedescriptor_t ENTITIES_0_descr_;
extern const XERdescriptor_t QName_name_xer_;
extern const TTCN_Typedescriptor_t QName_name_descr_;
extern const XERdescriptor_t QName_xer_;
extern const TTCN_JSONdescriptor_t QName_json_;
extern const TTCN_Typedescriptor_t QName_descr_;
extern const XERdescriptor_t QName_uri_xer_;
extern const TTCN_Typedescriptor_t QName_uri_descr_;
extern const XERdescriptor_t Boolean_xer_;
extern const TTCN_Typedescriptor_t Boolean_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
