// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for oneM2MTester (martin@ubuntu) on Wed May 31 13:52:13 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef CoAP__Types_HH
#define CoAP__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef CoAP__Types_HH
#endif

namespace CoAP__Types {

/* Forward declarations of classes */

class Code;
class Code_template;
class Type;
class Type_template;
class Header;
class Header_template;
class UnknownOption;
class UnknownOption_template;
class BlockOption;
class BlockOption_template;
class CoAP__Options;
class CoAP__Options_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING Charstring__List;
typedef PreGenRecordOf::PREGEN__RECORD__OF__UNIVERSAL__CHARSTRING_template Charstring__List_template;
class CoAP__OptionsList;
class CoAP__OptionsList_template;
class CoAP__ReqResp;
class CoAP__ReqResp_template;
class CoAP__Message;
class CoAP__Message_template;

} /* end of namespace */

#ifndef CoAP__Types_HH
#define CoAP__Types_HH

namespace CoAP__Types {

/* Type definitions */

typedef OCTETSTRING OCT0;
typedef OCTETSTRING_template OCT0_template;
typedef OCTETSTRING OCT0__8;
typedef OCTETSTRING_template OCT0__8_template;
typedef OCTETSTRING OCT1__8;
typedef OCTETSTRING_template OCT1__8_template;
typedef UNIVERSAL_CHARSTRING UCHAR15;
typedef UNIVERSAL_CHARSTRING_template UCHAR15_template;
typedef UNIVERSAL_CHARSTRING UCHAR0__255;
typedef UNIVERSAL_CHARSTRING_template UCHAR0__255_template;
typedef UNIVERSAL_CHARSTRING UCHAR1__255;
typedef UNIVERSAL_CHARSTRING_template UCHAR1__255_template;
typedef UNIVERSAL_CHARSTRING UCHAR1__1034;
typedef UNIVERSAL_CHARSTRING_template UCHAR1__1034_template;

/* Class definitions */

class Code {
  INTEGER field_class_;
  INTEGER field_detail;
public:
  Code();
  Code(const INTEGER& par_class_,
    const INTEGER& par_detail);
  Code(const Code& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Code& operator=(const Code& other_value);
  boolean operator==(const Code& other_value) const;
  inline boolean operator!=(const Code& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& class_()
    {return field_class_;}
  inline const INTEGER& class_() const
    {return field_class_;}
  inline INTEGER& detail()
    {return field_detail;}
  inline const INTEGER& detail() const
    {return field_detail;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Code_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Code_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Code& other_value);
void copy_template(const Code_template& other_value);

public:
Code_template();
Code_template(template_sel other_value);
Code_template(const Code& other_value);
Code_template(const OPTIONAL<Code>& other_value);
Code_template(const Code_template& other_value);
~Code_template();
Code_template& operator=(template_sel other_value);
Code_template& operator=(const Code& other_value);
Code_template& operator=(const OPTIONAL<Code>& other_value);
Code_template& operator=(const Code_template& other_value);
boolean match(const Code& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Code valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Code_template& list_item(unsigned int list_index) const;
INTEGER_template& class_();
const INTEGER_template& class_() const;
INTEGER_template& detail();
const INTEGER_template& detail() const;
int size_of() const;
void log() const;
void log_match(const Code& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Type : public Base_Type { // enum
friend class Type_template;
public:
enum enum_type { CONFIRMABLE = 0, NON__CONFIRMABLE = 1, ACKNOWLEDGEMENT = 2, RESET = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
Type();
Type(int other_value);
Type(enum_type other_value);
Type(const Type& other_value);

Type& operator=(int other_value);
Type& operator=(enum_type other_value);
Type& operator=(const Type& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Type& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Type& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Type& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Type& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Type& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Type& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Type& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class Type_template : public Base_Template {
union {
Type::enum_type single_value;
struct {
unsigned int n_values;
Type_template *list_value;
} value_list;
};

void copy_template(const Type_template& other_value);

public:
Type_template();
Type_template(template_sel other_value);
Type_template(int other_value);
Type_template(Type::enum_type other_value);
Type_template(const Type& other_value);
Type_template(const OPTIONAL<Type>& other_value);
Type_template(const Type_template& other_value);
~Type_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Type_template& operator=(template_sel other_value);
Type_template& operator=(int other_value);
Type_template& operator=(Type::enum_type other_value);
Type_template& operator=(const Type& other_value);
Type_template& operator=(const OPTIONAL<Type>& other_value);
Type_template& operator=(const Type_template& other_value);

boolean match(Type::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const Type& other_value, boolean legacy = FALSE) const;
Type::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Type_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Type& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Header {
  INTEGER field_version;
  Type field_msg__type;
  Code field_code;
  INTEGER field_message__id;
public:
  Header();
  Header(const INTEGER& par_version,
    const Type& par_msg__type,
    const Code& par_code,
    const INTEGER& par_message__id);
  Header(const Header& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Header& operator=(const Header& other_value);
  boolean operator==(const Header& other_value) const;
  inline boolean operator!=(const Header& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline Type& msg__type()
    {return field_msg__type;}
  inline const Type& msg__type() const
    {return field_msg__type;}
  inline Code& code()
    {return field_code;}
  inline const Code& code() const
    {return field_code;}
  inline INTEGER& message__id()
    {return field_message__id;}
  inline const INTEGER& message__id() const
    {return field_message__id;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Header_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Header_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Header& other_value);
void copy_template(const Header_template& other_value);

public:
Header_template();
Header_template(template_sel other_value);
Header_template(const Header& other_value);
Header_template(const OPTIONAL<Header>& other_value);
Header_template(const Header_template& other_value);
~Header_template();
Header_template& operator=(template_sel other_value);
Header_template& operator=(const Header& other_value);
Header_template& operator=(const OPTIONAL<Header>& other_value);
Header_template& operator=(const Header_template& other_value);
boolean match(const Header& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Header valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Header_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
Type_template& msg__type();
const Type_template& msg__type() const;
Code_template& code();
const Code_template& code() const;
INTEGER_template& message__id();
const INTEGER_template& message__id() const;
int size_of() const;
void log() const;
void log_match(const Header& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UnknownOption {
  INTEGER field_option__code;
  OCTETSTRING field_option__value;
public:
  UnknownOption();
  UnknownOption(const INTEGER& par_option__code,
    const OCTETSTRING& par_option__value);
  UnknownOption(const UnknownOption& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UnknownOption& operator=(const UnknownOption& other_value);
  boolean operator==(const UnknownOption& other_value) const;
  inline boolean operator!=(const UnknownOption& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& option__code()
    {return field_option__code;}
  inline const INTEGER& option__code() const
    {return field_option__code;}
  inline OCTETSTRING& option__value()
    {return field_option__value;}
  inline const OCTETSTRING& option__value() const
    {return field_option__value;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class UnknownOption_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UnknownOption_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UnknownOption& other_value);
void copy_template(const UnknownOption_template& other_value);

public:
UnknownOption_template();
UnknownOption_template(template_sel other_value);
UnknownOption_template(const UnknownOption& other_value);
UnknownOption_template(const OPTIONAL<UnknownOption>& other_value);
UnknownOption_template(const UnknownOption_template& other_value);
~UnknownOption_template();
UnknownOption_template& operator=(template_sel other_value);
UnknownOption_template& operator=(const UnknownOption& other_value);
UnknownOption_template& operator=(const OPTIONAL<UnknownOption>& other_value);
UnknownOption_template& operator=(const UnknownOption_template& other_value);
boolean match(const UnknownOption& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UnknownOption valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UnknownOption_template& list_item(unsigned int list_index) const;
INTEGER_template& option__code();
const INTEGER_template& option__code() const;
OCTETSTRING_template& option__value();
const OCTETSTRING_template& option__value() const;
int size_of() const;
void log() const;
void log_match(const UnknownOption& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BlockOption {
  INTEGER field_num;
  BOOLEAN field_m;
  INTEGER field_szx;
public:
  BlockOption();
  BlockOption(const INTEGER& par_num,
    const BOOLEAN& par_m,
    const INTEGER& par_szx);
  BlockOption(const BlockOption& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BlockOption& operator=(const BlockOption& other_value);
  boolean operator==(const BlockOption& other_value) const;
  inline boolean operator!=(const BlockOption& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& num()
    {return field_num;}
  inline const INTEGER& num() const
    {return field_num;}
  inline BOOLEAN& m()
    {return field_m;}
  inline const BOOLEAN& m() const
    {return field_m;}
  inline INTEGER& szx()
    {return field_szx;}
  inline const INTEGER& szx() const
    {return field_szx;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class BlockOption_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BlockOption_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BlockOption& other_value);
void copy_template(const BlockOption_template& other_value);

public:
BlockOption_template();
BlockOption_template(template_sel other_value);
BlockOption_template(const BlockOption& other_value);
BlockOption_template(const OPTIONAL<BlockOption>& other_value);
BlockOption_template(const BlockOption_template& other_value);
~BlockOption_template();
BlockOption_template& operator=(template_sel other_value);
BlockOption_template& operator=(const BlockOption& other_value);
BlockOption_template& operator=(const OPTIONAL<BlockOption>& other_value);
BlockOption_template& operator=(const BlockOption_template& other_value);
boolean match(const BlockOption& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BlockOption valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BlockOption_template& list_item(unsigned int list_index) const;
INTEGER_template& num();
const INTEGER_template& num() const;
BOOLEAN_template& m();
const BOOLEAN_template& m() const;
INTEGER_template& szx();
const INTEGER_template& szx() const;
int size_of() const;
void log() const;
void log_match(const BlockOption& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CoAP__Options : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_if__match = 1, ALT_uri__host = 2, ALT_etag = 3, ALT_if__none__match = 4, ALT_observe = 5, ALT_uri__port = 6, ALT_location__path = 7, ALT_uri__path = 8, ALT_content__format = 9, ALT_max__age = 10, ALT_uri__query = 11, ALT_accept = 12, ALT_location__query = 13, ALT_block1 = 14, ALT_block2 = 15, ALT_proxy__uri = 16, ALT_proxy__scheme = 17, ALT_size1 = 18, ALT_unknown__option = 19, ALT_oneM2M__FR = 20, ALT_oneM2M__RQI = 21, ALT_oneM2M__OT = 22, ALT_oneM2M__RQET = 23, ALT_oneM2M__RSET = 24, ALT_oneM2M__OET = 25, ALT_oneM2M__RTURI = 26, ALT_oneM2M__EC = 27, ALT_oneM2M__RSC = 28, ALT_oneM2M__GID = 29, ALT_oneM2M__TY = 30, ALT_oneM2M__CTO = 31, ALT_oneM2M__CTS = 32, ALT_oneM2M__ATI = 33 };
private:
union_selection_type union_selection;
union {
OCTETSTRING *field_if__match;
UNIVERSAL_CHARSTRING *field_uri__host;
OCTETSTRING *field_etag;
OCTETSTRING *field_if__none__match;
INTEGER *field_observe;
INTEGER *field_uri__port;
UNIVERSAL_CHARSTRING *field_location__path;
UNIVERSAL_CHARSTRING *field_uri__path;
INTEGER *field_content__format;
INTEGER *field_max__age;
UNIVERSAL_CHARSTRING *field_uri__query;
INTEGER *field_accept;
UNIVERSAL_CHARSTRING *field_location__query;
BlockOption *field_block1;
BlockOption *field_block2;
UNIVERSAL_CHARSTRING *field_proxy__uri;
UNIVERSAL_CHARSTRING *field_proxy__scheme;
INTEGER *field_size1;
UnknownOption *field_unknown__option;
UNIVERSAL_CHARSTRING *field_oneM2M__FR;
UNIVERSAL_CHARSTRING *field_oneM2M__RQI;
UNIVERSAL_CHARSTRING *field_oneM2M__OT;
UNIVERSAL_CHARSTRING *field_oneM2M__RQET;
UNIVERSAL_CHARSTRING *field_oneM2M__RSET;
UNIVERSAL_CHARSTRING *field_oneM2M__OET;
UNIVERSAL_CHARSTRING *field_oneM2M__RTURI;
INTEGER *field_oneM2M__EC;
INTEGER *field_oneM2M__RSC;
UNIVERSAL_CHARSTRING *field_oneM2M__GID;
INTEGER *field_oneM2M__TY;
INTEGER *field_oneM2M__CTO;
INTEGER *field_oneM2M__CTS;
UNIVERSAL_CHARSTRING *field_oneM2M__ATI;
};
void copy_value(const CoAP__Options& other_value);

public:
CoAP__Options();
CoAP__Options(const CoAP__Options& other_value);
~CoAP__Options();
CoAP__Options& operator=(const CoAP__Options& other_value);
boolean operator==(const CoAP__Options& other_value) const;
inline boolean operator!=(const CoAP__Options& other_value) const { return !(*this == other_value); }
OCTETSTRING& if__match();
const OCTETSTRING& if__match() const;
UNIVERSAL_CHARSTRING& uri__host();
const UNIVERSAL_CHARSTRING& uri__host() const;
OCTETSTRING& etag();
const OCTETSTRING& etag() const;
OCTETSTRING& if__none__match();
const OCTETSTRING& if__none__match() const;
INTEGER& observe();
const INTEGER& observe() const;
INTEGER& uri__port();
const INTEGER& uri__port() const;
UNIVERSAL_CHARSTRING& location__path();
const UNIVERSAL_CHARSTRING& location__path() const;
UNIVERSAL_CHARSTRING& uri__path();
const UNIVERSAL_CHARSTRING& uri__path() const;
INTEGER& content__format();
const INTEGER& content__format() const;
INTEGER& max__age();
const INTEGER& max__age() const;
UNIVERSAL_CHARSTRING& uri__query();
const UNIVERSAL_CHARSTRING& uri__query() const;
INTEGER& accept();
const INTEGER& accept() const;
UNIVERSAL_CHARSTRING& location__query();
const UNIVERSAL_CHARSTRING& location__query() const;
BlockOption& block1();
const BlockOption& block1() const;
BlockOption& block2();
const BlockOption& block2() const;
UNIVERSAL_CHARSTRING& proxy__uri();
const UNIVERSAL_CHARSTRING& proxy__uri() const;
UNIVERSAL_CHARSTRING& proxy__scheme();
const UNIVERSAL_CHARSTRING& proxy__scheme() const;
INTEGER& size1();
const INTEGER& size1() const;
UnknownOption& unknown__option();
const UnknownOption& unknown__option() const;
UNIVERSAL_CHARSTRING& oneM2M__FR();
const UNIVERSAL_CHARSTRING& oneM2M__FR() const;
UNIVERSAL_CHARSTRING& oneM2M__RQI();
const UNIVERSAL_CHARSTRING& oneM2M__RQI() const;
UNIVERSAL_CHARSTRING& oneM2M__OT();
const UNIVERSAL_CHARSTRING& oneM2M__OT() const;
UNIVERSAL_CHARSTRING& oneM2M__RQET();
const UNIVERSAL_CHARSTRING& oneM2M__RQET() const;
UNIVERSAL_CHARSTRING& oneM2M__RSET();
const UNIVERSAL_CHARSTRING& oneM2M__RSET() const;
UNIVERSAL_CHARSTRING& oneM2M__OET();
const UNIVERSAL_CHARSTRING& oneM2M__OET() const;
UNIVERSAL_CHARSTRING& oneM2M__RTURI();
const UNIVERSAL_CHARSTRING& oneM2M__RTURI() const;
INTEGER& oneM2M__EC();
const INTEGER& oneM2M__EC() const;
INTEGER& oneM2M__RSC();
const INTEGER& oneM2M__RSC() const;
UNIVERSAL_CHARSTRING& oneM2M__GID();
const UNIVERSAL_CHARSTRING& oneM2M__GID() const;
INTEGER& oneM2M__TY();
const INTEGER& oneM2M__TY() const;
INTEGER& oneM2M__CTO();
const INTEGER& oneM2M__CTO() const;
INTEGER& oneM2M__CTS();
const INTEGER& oneM2M__CTS() const;
UNIVERSAL_CHARSTRING& oneM2M__ATI();
const UNIVERSAL_CHARSTRING& oneM2M__ATI() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class CoAP__Options_template : public Base_Template {
union {
struct {
CoAP__Options::union_selection_type union_selection;
union {
OCTETSTRING_template *field_if__match;
UNIVERSAL_CHARSTRING_template *field_uri__host;
OCTETSTRING_template *field_etag;
OCTETSTRING_template *field_if__none__match;
INTEGER_template *field_observe;
INTEGER_template *field_uri__port;
UNIVERSAL_CHARSTRING_template *field_location__path;
UNIVERSAL_CHARSTRING_template *field_uri__path;
INTEGER_template *field_content__format;
INTEGER_template *field_max__age;
UNIVERSAL_CHARSTRING_template *field_uri__query;
INTEGER_template *field_accept;
UNIVERSAL_CHARSTRING_template *field_location__query;
BlockOption_template *field_block1;
BlockOption_template *field_block2;
UNIVERSAL_CHARSTRING_template *field_proxy__uri;
UNIVERSAL_CHARSTRING_template *field_proxy__scheme;
INTEGER_template *field_size1;
UnknownOption_template *field_unknown__option;
UNIVERSAL_CHARSTRING_template *field_oneM2M__FR;
UNIVERSAL_CHARSTRING_template *field_oneM2M__RQI;
UNIVERSAL_CHARSTRING_template *field_oneM2M__OT;
UNIVERSAL_CHARSTRING_template *field_oneM2M__RQET;
UNIVERSAL_CHARSTRING_template *field_oneM2M__RSET;
UNIVERSAL_CHARSTRING_template *field_oneM2M__OET;
UNIVERSAL_CHARSTRING_template *field_oneM2M__RTURI;
INTEGER_template *field_oneM2M__EC;
INTEGER_template *field_oneM2M__RSC;
UNIVERSAL_CHARSTRING_template *field_oneM2M__GID;
INTEGER_template *field_oneM2M__TY;
INTEGER_template *field_oneM2M__CTO;
INTEGER_template *field_oneM2M__CTS;
UNIVERSAL_CHARSTRING_template *field_oneM2M__ATI;
};
} single_value;
struct {
unsigned int n_values;
CoAP__Options_template *list_value;
} value_list;
};
void copy_value(const CoAP__Options& other_value);

void copy_template(const CoAP__Options_template& other_value);

public:
CoAP__Options_template();
CoAP__Options_template(template_sel other_value);
CoAP__Options_template(const CoAP__Options& other_value);
CoAP__Options_template(const OPTIONAL<CoAP__Options>& other_value);
CoAP__Options_template(const CoAP__Options_template& other_value);
~CoAP__Options_template();
void clean_up();
CoAP__Options_template& operator=(template_sel other_value);
CoAP__Options_template& operator=(const CoAP__Options& other_value);
CoAP__Options_template& operator=(const OPTIONAL<CoAP__Options>& other_value);
CoAP__Options_template& operator=(const CoAP__Options_template& other_value);
boolean match(const CoAP__Options& other_value, boolean legacy = FALSE) const;
boolean is_value() const;CoAP__Options valueof() const;
CoAP__Options_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OCTETSTRING_template& if__match();
const OCTETSTRING_template& if__match() const;
UNIVERSAL_CHARSTRING_template& uri__host();
const UNIVERSAL_CHARSTRING_template& uri__host() const;
OCTETSTRING_template& etag();
const OCTETSTRING_template& etag() const;
OCTETSTRING_template& if__none__match();
const OCTETSTRING_template& if__none__match() const;
INTEGER_template& observe();
const INTEGER_template& observe() const;
INTEGER_template& uri__port();
const INTEGER_template& uri__port() const;
UNIVERSAL_CHARSTRING_template& location__path();
const UNIVERSAL_CHARSTRING_template& location__path() const;
UNIVERSAL_CHARSTRING_template& uri__path();
const UNIVERSAL_CHARSTRING_template& uri__path() const;
INTEGER_template& content__format();
const INTEGER_template& content__format() const;
INTEGER_template& max__age();
const INTEGER_template& max__age() const;
UNIVERSAL_CHARSTRING_template& uri__query();
const UNIVERSAL_CHARSTRING_template& uri__query() const;
INTEGER_template& accept();
const INTEGER_template& accept() const;
UNIVERSAL_CHARSTRING_template& location__query();
const UNIVERSAL_CHARSTRING_template& location__query() const;
BlockOption_template& block1();
const BlockOption_template& block1() const;
BlockOption_template& block2();
const BlockOption_template& block2() const;
UNIVERSAL_CHARSTRING_template& proxy__uri();
const UNIVERSAL_CHARSTRING_template& proxy__uri() const;
UNIVERSAL_CHARSTRING_template& proxy__scheme();
const UNIVERSAL_CHARSTRING_template& proxy__scheme() const;
INTEGER_template& size1();
const INTEGER_template& size1() const;
UnknownOption_template& unknown__option();
const UnknownOption_template& unknown__option() const;
UNIVERSAL_CHARSTRING_template& oneM2M__FR();
const UNIVERSAL_CHARSTRING_template& oneM2M__FR() const;
UNIVERSAL_CHARSTRING_template& oneM2M__RQI();
const UNIVERSAL_CHARSTRING_template& oneM2M__RQI() const;
UNIVERSAL_CHARSTRING_template& oneM2M__OT();
const UNIVERSAL_CHARSTRING_template& oneM2M__OT() const;
UNIVERSAL_CHARSTRING_template& oneM2M__RQET();
const UNIVERSAL_CHARSTRING_template& oneM2M__RQET() const;
UNIVERSAL_CHARSTRING_template& oneM2M__RSET();
const UNIVERSAL_CHARSTRING_template& oneM2M__RSET() const;
UNIVERSAL_CHARSTRING_template& oneM2M__OET();
const UNIVERSAL_CHARSTRING_template& oneM2M__OET() const;
UNIVERSAL_CHARSTRING_template& oneM2M__RTURI();
const UNIVERSAL_CHARSTRING_template& oneM2M__RTURI() const;
INTEGER_template& oneM2M__EC();
const INTEGER_template& oneM2M__EC() const;
INTEGER_template& oneM2M__RSC();
const INTEGER_template& oneM2M__RSC() const;
UNIVERSAL_CHARSTRING_template& oneM2M__GID();
const UNIVERSAL_CHARSTRING_template& oneM2M__GID() const;
INTEGER_template& oneM2M__TY();
const INTEGER_template& oneM2M__TY() const;
INTEGER_template& oneM2M__CTO();
const INTEGER_template& oneM2M__CTO() const;
INTEGER_template& oneM2M__CTS();
const INTEGER_template& oneM2M__CTS() const;
UNIVERSAL_CHARSTRING_template& oneM2M__ATI();
const UNIVERSAL_CHARSTRING_template& oneM2M__ATI() const;
boolean ischosen(CoAP__Options::union_selection_type checked_selection) const;
void log() const;
void log_match(const CoAP__Options& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class CoAP__OptionsList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CoAP__Options **value_elements;
} *val_ptr;

static const CoAP__Options UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const CoAP__OptionsList& other_value);
static boolean compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index);

public:
  typedef CoAP__Options of_type;
CoAP__OptionsList();
CoAP__OptionsList(null_type other_value);
CoAP__OptionsList(const CoAP__OptionsList& other_value);
~CoAP__OptionsList();

void clean_up();
CoAP__OptionsList& operator=(null_type other_value);
CoAP__OptionsList& operator=(const CoAP__OptionsList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const CoAP__OptionsList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CoAP__OptionsList& other_value) const { return !(*this == other_value); }

CoAP__Options& operator[](int index_value);
CoAP__Options& operator[](const INTEGER& index_value);
const CoAP__Options& operator[](int index_value) const;
const CoAP__Options& operator[](const INTEGER& index_value) const;

CoAP__OptionsList operator<<=(int rotate_count) const;
CoAP__OptionsList operator<<=(const INTEGER& rotate_count) const;
CoAP__OptionsList operator>>=(int rotate_count) const;
CoAP__OptionsList operator>>=(const INTEGER& rotate_count) const;

CoAP__OptionsList operator+(const CoAP__OptionsList& other_value) const;

CoAP__OptionsList substr(int index, int returncount) const;

CoAP__OptionsList replace(int index, int len, const CoAP__OptionsList& repl) const;

CoAP__OptionsList replace(int index, int len, const CoAP__OptionsList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class CoAP__OptionsList_template : public Restricted_Length_Template {
union {
struct {
int n_elements;
CoAP__Options_template **value_elements;
} single_value;
struct {
unsigned int n_values;
CoAP__OptionsList_template *list_value;
} value_list;
struct {
unsigned int n_items;
CoAP__Options_template *set_items;
} value_set;
};
void copy_value(const CoAP__OptionsList& other_value);
void copy_template(const CoAP__OptionsList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static boolean match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);
static void log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy);

public:
CoAP__OptionsList_template();
CoAP__OptionsList_template(template_sel other_value);
CoAP__OptionsList_template(null_type other_value);
CoAP__OptionsList_template(const CoAP__OptionsList& other_value);
CoAP__OptionsList_template(const OPTIONAL<CoAP__OptionsList>& other_value);
CoAP__OptionsList_template(const CoAP__OptionsList_template& other_value);
~CoAP__OptionsList_template();

void clean_up();
CoAP__OptionsList_template& operator=(template_sel other_value);
CoAP__OptionsList_template& operator=(null_type other_value);
CoAP__OptionsList_template& operator=(const CoAP__OptionsList& other_value);
CoAP__OptionsList_template& operator=(const OPTIONAL<CoAP__OptionsList>& other_value);
CoAP__OptionsList_template& operator=(const CoAP__OptionsList_template& other_value);

CoAP__Options_template& operator[](int index_value);
CoAP__Options_template& operator[](const INTEGER& index_value);
const CoAP__Options_template& operator[](int index_value) const;
const CoAP__Options_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const CoAP__OptionsList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
CoAP__OptionsList valueof() const;
CoAP__OptionsList substr(int index, int returncount) const;

CoAP__OptionsList replace(int index, int len, const CoAP__OptionsList_template& repl) const;

CoAP__OptionsList replace(int index, int len, const CoAP__OptionsList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
CoAP__OptionsList_template& list_item(unsigned int list_index);
CoAP__Options_template& set_item(unsigned int set_index);
void log() const;
void log_match(const CoAP__OptionsList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class CoAP__ReqResp {
  Header field_header;
  OCTETSTRING field_token;
  OPTIONAL<CoAP__OptionsList> field_options;
  OPTIONAL<OCTETSTRING> field_payload;
public:
  CoAP__ReqResp();
  CoAP__ReqResp(const Header& par_header,
    const OCTETSTRING& par_token,
    const OPTIONAL<CoAP__OptionsList>& par_options,
    const OPTIONAL<OCTETSTRING>& par_payload);
  CoAP__ReqResp(const CoAP__ReqResp& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CoAP__ReqResp& operator=(const CoAP__ReqResp& other_value);
  boolean operator==(const CoAP__ReqResp& other_value) const;
  inline boolean operator!=(const CoAP__ReqResp& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Header& header()
    {return field_header;}
  inline const Header& header() const
    {return field_header;}
  inline OCTETSTRING& token()
    {return field_token;}
  inline const OCTETSTRING& token() const
    {return field_token;}
  inline OPTIONAL<CoAP__OptionsList>& options()
    {return field_options;}
  inline const OPTIONAL<CoAP__OptionsList>& options() const
    {return field_options;}
  inline OPTIONAL<OCTETSTRING>& payload()
    {return field_payload;}
  inline const OPTIONAL<OCTETSTRING>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class CoAP__ReqResp_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CoAP__ReqResp_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CoAP__ReqResp& other_value);
void copy_template(const CoAP__ReqResp_template& other_value);

public:
CoAP__ReqResp_template();
CoAP__ReqResp_template(template_sel other_value);
CoAP__ReqResp_template(const CoAP__ReqResp& other_value);
CoAP__ReqResp_template(const OPTIONAL<CoAP__ReqResp>& other_value);
CoAP__ReqResp_template(const CoAP__ReqResp_template& other_value);
~CoAP__ReqResp_template();
CoAP__ReqResp_template& operator=(template_sel other_value);
CoAP__ReqResp_template& operator=(const CoAP__ReqResp& other_value);
CoAP__ReqResp_template& operator=(const OPTIONAL<CoAP__ReqResp>& other_value);
CoAP__ReqResp_template& operator=(const CoAP__ReqResp_template& other_value);
boolean match(const CoAP__ReqResp& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CoAP__ReqResp valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CoAP__ReqResp_template& list_item(unsigned int list_index) const;
Header_template& header();
const Header_template& header() const;
OCTETSTRING_template& token();
const OCTETSTRING_template& token() const;
CoAP__OptionsList_template& options();
const CoAP__OptionsList_template& options() const;
OCTETSTRING_template& payload();
const OCTETSTRING_template& payload() const;
int size_of() const;
void log() const;
void log_match(const CoAP__ReqResp& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CoAP__Message : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_msg = 1, ALT_raw__message = 2 };
private:
union_selection_type union_selection;
union {
CoAP__ReqResp *field_msg;
OCTETSTRING *field_raw__message;
};
void copy_value(const CoAP__Message& other_value);

public:
CoAP__Message();
CoAP__Message(const CoAP__Message& other_value);
~CoAP__Message();
CoAP__Message& operator=(const CoAP__Message& other_value);
boolean operator==(const CoAP__Message& other_value) const;
inline boolean operator!=(const CoAP__Message& other_value) const { return !(*this == other_value); }
CoAP__ReqResp& msg();
const CoAP__ReqResp& msg() const;
OCTETSTRING& raw__message();
const OCTETSTRING& raw__message() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class CoAP__Message_template : public Base_Template {
union {
struct {
CoAP__Message::union_selection_type union_selection;
union {
CoAP__ReqResp_template *field_msg;
OCTETSTRING_template *field_raw__message;
};
} single_value;
struct {
unsigned int n_values;
CoAP__Message_template *list_value;
} value_list;
};
void copy_value(const CoAP__Message& other_value);

void copy_template(const CoAP__Message_template& other_value);

public:
CoAP__Message_template();
CoAP__Message_template(template_sel other_value);
CoAP__Message_template(const CoAP__Message& other_value);
CoAP__Message_template(const OPTIONAL<CoAP__Message>& other_value);
CoAP__Message_template(const CoAP__Message_template& other_value);
~CoAP__Message_template();
void clean_up();
CoAP__Message_template& operator=(template_sel other_value);
CoAP__Message_template& operator=(const CoAP__Message& other_value);
CoAP__Message_template& operator=(const OPTIONAL<CoAP__Message>& other_value);
CoAP__Message_template& operator=(const CoAP__Message_template& other_value);
boolean match(const CoAP__Message& other_value, boolean legacy = FALSE) const;
boolean is_value() const;CoAP__Message valueof() const;
CoAP__Message_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
CoAP__ReqResp_template& msg();
const CoAP__ReqResp_template& msg() const;
OCTETSTRING_template& raw__message();
const OCTETSTRING_template& raw__message() const;
boolean ischosen(CoAP__Message::union_selection_type checked_selection) const;
void log() const;
void log_match(const CoAP__Message& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern INTEGER f__CoAP__enc(const CoAP__Message& msg, OCTETSTRING& str);
extern INTEGER f__CoAP__dec(const OCTETSTRING& str, CoAP__Message& msg);
extern boolean operator==(null_type null_value, const CoAP__OptionsList& other_value);
inline boolean operator!=(null_type null_value, const CoAP__OptionsList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t Code_class__xer_;
extern const TTCN_Typedescriptor_t Code_class__descr_;
extern const XERdescriptor_t Code_detail_xer_;
extern const TTCN_Typedescriptor_t Code_detail_descr_;
extern const TTCN_Typedescriptor_t Code_descr_;
extern const Code& EMPTY__MESSAGE;
extern const Code& METHOD__GET;
extern const Code& METHOD__POST;
extern const Code& METHOD__PUT;
extern const Code& METHOD__DELETE;
extern const Code& RESPONSE__CODE__Created;
extern const Code& RESPONSE__CODE__Deleted;
extern const Code& RESPONSE__CODE__Valid;
extern const Code& RESPONSE__CODE__Changed;
extern const Code& RESPONSE__CODE__Content;
extern const Code& RESPONSE__CODE__BadRequest;
extern const Code& RESPONSE__CODE__Unauthorized;
extern const Code& RESPONSE__CODE__BadOption;
extern const Code& RESPONSE__CODE__Forbidden;
extern const Code& RESPONSE__CODE__NotFound;
extern const Code& RESPONSE__CODE__MethodNotAllowed;
extern const Code& RESPONSE__CODE__NotAcceptable;
extern const Code& RESPONSE__CODE__PreconditionFailed;
extern const Code& RESPONSE__CODE__RequestEntityTooLarge;
extern const Code& RESPONSE__CODE__UnsupportedContentFormat;
extern const Code& RESPONSE__CODE__InternalServerError;
extern const Code& RESPONSE__CODE__NotImplemented;
extern const Code& RESPONSE__CODE__BadGateway;
extern const Code& RESPONSE__CODE__ServiceUnavailable;
extern const Code& RESPONSE__CODE__GatewayTimeout;
extern const Code& RESPONSE__CODE__ProxyingNotSupported;
extern const TTCN_RAWdescriptor_t OCT0_raw_;
extern const XERdescriptor_t OCT0_xer_;
extern const TTCN_Typedescriptor_t OCT0_descr_;
extern const XERdescriptor_t OCT0__8_xer_;
extern const TTCN_Typedescriptor_t OCT0__8_descr_;
extern const XERdescriptor_t OCT1__8_xer_;
extern const TTCN_Typedescriptor_t OCT1__8_descr_;
extern const XERdescriptor_t UCHAR15_xer_;
extern const TTCN_Typedescriptor_t UCHAR15_descr_;
extern const XERdescriptor_t UCHAR0__255_xer_;
extern const TTCN_Typedescriptor_t UCHAR0__255_descr_;
extern const XERdescriptor_t UCHAR1__255_xer_;
extern const TTCN_Typedescriptor_t UCHAR1__255_descr_;
extern const XERdescriptor_t UCHAR1__1034_xer_;
extern const TTCN_Typedescriptor_t UCHAR1__1034_descr_;
extern const TTCN_Typedescriptor_t Type_descr_;
extern const XERdescriptor_t Header_version_xer_;
extern const TTCN_Typedescriptor_t Header_version_descr_;
extern const XERdescriptor_t Header_message__id_xer_;
extern const TTCN_Typedescriptor_t Header_message__id_descr_;
extern const TTCN_Typedescriptor_t Header_descr_;
extern const XERdescriptor_t UnknownOption_option__code_xer_;
extern const TTCN_Typedescriptor_t UnknownOption_option__code_descr_;
extern const XERdescriptor_t UnknownOption_option__value_xer_;
extern const TTCN_Typedescriptor_t UnknownOption_option__value_descr_;
extern const TTCN_Typedescriptor_t UnknownOption_descr_;
extern const XERdescriptor_t BlockOption_num_xer_;
extern const TTCN_Typedescriptor_t BlockOption_num_descr_;
extern const XERdescriptor_t BlockOption_m_xer_;
extern const TTCN_Typedescriptor_t BlockOption_m_descr_;
extern const XERdescriptor_t BlockOption_szx_xer_;
extern const TTCN_Typedescriptor_t BlockOption_szx_descr_;
extern const TTCN_Typedescriptor_t BlockOption_descr_;
extern const TTCN_Typedescriptor_t CoAP__Options_descr_;
extern const XERdescriptor_t CoAP__Options_if__match_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_if__match_descr_;
extern const XERdescriptor_t CoAP__Options_uri__host_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_uri__host_descr_;
extern const XERdescriptor_t CoAP__Options_etag_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_etag_descr_;
extern const XERdescriptor_t CoAP__Options_if__none__match_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_if__none__match_descr_;
extern const XERdescriptor_t CoAP__Options_observe_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_observe_descr_;
extern const XERdescriptor_t CoAP__Options_uri__port_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_uri__port_descr_;
extern const XERdescriptor_t CoAP__Options_location__path_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_location__path_descr_;
extern const XERdescriptor_t CoAP__Options_uri__path_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_uri__path_descr_;
extern const XERdescriptor_t CoAP__Options_content__format_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_content__format_descr_;
extern const XERdescriptor_t CoAP__Options_max__age_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_max__age_descr_;
extern const XERdescriptor_t CoAP__Options_uri__query_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_uri__query_descr_;
extern const XERdescriptor_t CoAP__Options_accept_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_accept_descr_;
extern const XERdescriptor_t CoAP__Options_location__query_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_location__query_descr_;
extern const XERdescriptor_t CoAP__Options_proxy__uri_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_proxy__uri_descr_;
extern const XERdescriptor_t CoAP__Options_proxy__scheme_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_proxy__scheme_descr_;
extern const XERdescriptor_t CoAP__Options_size1_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_size1_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__FR_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__FR_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__RQI_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RQI_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__OT_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__OT_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__RQET_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RQET_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__RSET_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RSET_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__OET_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__OET_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__RTURI_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RTURI_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__EC_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__EC_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__RSC_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__RSC_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__GID_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__GID_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__TY_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__TY_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__CTO_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__CTO_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__CTS_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__CTS_descr_;
extern const XERdescriptor_t CoAP__Options_oneM2M__ATI_xer_;
extern const TTCN_Typedescriptor_t CoAP__Options_oneM2M__ATI_descr_;
extern const TTCN_Typedescriptor_t Charstring__List_descr_;
extern const XERdescriptor_t Charstring__List_0_xer_;
extern const TTCN_Typedescriptor_t Charstring__List_0_descr_;
extern const TTCN_Typedescriptor_t CoAP__OptionsList_descr_;
extern const XERdescriptor_t CoAP__ReqResp_token_xer_;
extern const TTCN_Typedescriptor_t CoAP__ReqResp_token_descr_;
extern const TTCN_Typedescriptor_t CoAP__ReqResp_descr_;
extern const XERdescriptor_t CoAP__ReqResp_payload_xer_;
extern const TTCN_Typedescriptor_t CoAP__ReqResp_payload_descr_;
extern const TTCN_Typedescriptor_t CoAP__Message_descr_;
extern const XERdescriptor_t CoAP__Message_raw__message_xer_;
extern const TTCN_Typedescriptor_t CoAP__Message_raw__message_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
