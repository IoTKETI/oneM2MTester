// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for oneM2MTester (martin@ubuntu) on Wed May 31 13:52:13 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibCommon__Sync_HH
#define LibCommon__Sync_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "LibCommon_AbstractData.hh"
#include "LibCommon_VerdictControl.hh"

#if TTCN3_VERSION != 60100
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibCommon__Sync_HH
#endif

namespace LibCommon__Sync {

/* Forward declarations of classes */

class TestcaseStep;
class TestcaseStep_template;
class SyncPort;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING SyncPointList;
typedef PreGenRecordOf::PREGEN__RECORD__OF__CHARSTRING_template SyncPointList_template;
class ClientSyncCompList;
class ClientSyncCompList_template;
class SyncCmd;
class SyncCmd_template;
class ClientReady;
class ClientReady_template;
class ServerReady;
class ServerReady_template;
class ClientStop;
class ClientStop_template;
class ServerStop;
class ServerStop_template;

} /* end of namespace */

#ifndef LibCommon__Sync_HH
#define LibCommon__Sync_HH

namespace LibCommon__Sync {

/* Type definitions */

typedef COMPONENT BaseSyncComp;
typedef COMPONENT_template BaseSyncComp_template;
typedef COMPONENT ServerSyncComp;
typedef COMPONENT_template ServerSyncComp_template;
typedef COMPONENT ClientSyncComp;
typedef COMPONENT_template ClientSyncComp_template;
typedef COMPONENT SelfSyncComp;
typedef COMPONENT_template SelfSyncComp_template;

/* Class definitions */

class TestcaseStep : public Base_Type { // enum
friend class TestcaseStep_template;
public:
enum enum_type { e__preamble = 0, e__testBody = 1, e__postamble = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
TestcaseStep();
TestcaseStep(int other_value);
TestcaseStep(enum_type other_value);
TestcaseStep(const TestcaseStep& other_value);

TestcaseStep& operator=(int other_value);
TestcaseStep& operator=(enum_type other_value);
TestcaseStep& operator=(const TestcaseStep& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TestcaseStep& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TestcaseStep& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TestcaseStep& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TestcaseStep& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TestcaseStep& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TestcaseStep& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TestcaseStep& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class TestcaseStep_template : public Base_Template {
union {
TestcaseStep::enum_type single_value;
struct {
unsigned int n_values;
TestcaseStep_template *list_value;
} value_list;
};

void copy_template(const TestcaseStep_template& other_value);

public:
TestcaseStep_template();
TestcaseStep_template(template_sel other_value);
TestcaseStep_template(int other_value);
TestcaseStep_template(TestcaseStep::enum_type other_value);
TestcaseStep_template(const TestcaseStep& other_value);
TestcaseStep_template(const OPTIONAL<TestcaseStep>& other_value);
TestcaseStep_template(const TestcaseStep_template& other_value);
~TestcaseStep_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TestcaseStep_template& operator=(template_sel other_value);
TestcaseStep_template& operator=(int other_value);
TestcaseStep_template& operator=(TestcaseStep::enum_type other_value);
TestcaseStep_template& operator=(const TestcaseStep& other_value);
TestcaseStep_template& operator=(const OPTIONAL<TestcaseStep>& other_value);
TestcaseStep_template& operator=(const TestcaseStep_template& other_value);

boolean match(TestcaseStep::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TestcaseStep& other_value, boolean legacy = FALSE) const;
TestcaseStep::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TestcaseStep_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TestcaseStep& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SyncPort : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
SyncCmd *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
SyncPort(const char *par_port_name = NULL);
~SyncPort();
void send(const SyncCmd& send_par, const COMPONENT& destination_component);
void send(const SyncCmd& send_par);
void send(const SyncCmd_template& send_par, const COMPONENT& destination_component);
void send(const SyncCmd_template& send_par);
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const SyncCmd& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class ClientSyncCompList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
COMPONENT **value_elements;
} *val_ptr;

static const COMPONENT UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ClientSyncCompList& other_value);

public:
  typedef COMPONENT of_type;
ClientSyncCompList();
ClientSyncCompList(null_type other_value);
ClientSyncCompList(const ClientSyncCompList& other_value);
~ClientSyncCompList();

void clean_up();
ClientSyncCompList& operator=(null_type other_value);
ClientSyncCompList& operator=(const ClientSyncCompList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ClientSyncCompList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ClientSyncCompList& other_value) const { return !(*this == other_value); }

COMPONENT& operator[](int index_value);
COMPONENT& operator[](const INTEGER& index_value);
const COMPONENT& operator[](int index_value) const;
const COMPONENT& operator[](const INTEGER& index_value) const;

ClientSyncCompList operator<<=(int rotate_count) const;
ClientSyncCompList operator<<=(const INTEGER& rotate_count) const;
ClientSyncCompList operator>>=(int rotate_count) const;
ClientSyncCompList operator>>=(const INTEGER& rotate_count) const;

ClientSyncCompList operator+(const ClientSyncCompList& other_value) const;

ClientSyncCompList substr(int index, int returncount) const;

ClientSyncCompList replace(int index, int len, const ClientSyncCompList& repl) const;

ClientSyncCompList replace(int index, int len, const ClientSyncCompList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ClientSyncCompList_template : public Record_Of_Template {
union {
struct {
int n_elements;
COMPONENT_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ClientSyncCompList_template *list_value;
} value_list;
};
void copy_value(const ClientSyncCompList& other_value);
void copy_template(const ClientSyncCompList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ClientSyncCompList_template();
ClientSyncCompList_template(template_sel other_value);
ClientSyncCompList_template(null_type other_value);
ClientSyncCompList_template(const ClientSyncCompList& other_value);
ClientSyncCompList_template(const OPTIONAL<ClientSyncCompList>& other_value);
ClientSyncCompList_template(const ClientSyncCompList_template& other_value);
~ClientSyncCompList_template();

void clean_up();
ClientSyncCompList_template& operator=(template_sel other_value);
ClientSyncCompList_template& operator=(null_type other_value);
ClientSyncCompList_template& operator=(const ClientSyncCompList& other_value);
ClientSyncCompList_template& operator=(const OPTIONAL<ClientSyncCompList>& other_value);
ClientSyncCompList_template& operator=(const ClientSyncCompList_template& other_value);

COMPONENT_template& operator[](int index_value);
COMPONENT_template& operator[](const INTEGER& index_value);
const COMPONENT_template& operator[](int index_value) const;
const COMPONENT_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ClientSyncCompList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ClientSyncCompList valueof() const;
ClientSyncCompList substr(int index, int returncount) const;

ClientSyncCompList replace(int index, int len, const ClientSyncCompList_template& repl) const;

ClientSyncCompList replace(int index, int len, const ClientSyncCompList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ClientSyncCompList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ClientSyncCompList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class SyncCmd : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_clientReady = 1, ALT_serverReady = 2, ALT_clientStop = 3, ALT_serverStop = 4 };
private:
union_selection_type union_selection;
union {
ClientReady *field_clientReady;
ServerReady *field_serverReady;
ClientStop *field_clientStop;
ServerStop *field_serverStop;
};
void copy_value(const SyncCmd& other_value);

public:
SyncCmd();
SyncCmd(const SyncCmd& other_value);
~SyncCmd();
SyncCmd& operator=(const SyncCmd& other_value);
boolean operator==(const SyncCmd& other_value) const;
inline boolean operator!=(const SyncCmd& other_value) const { return !(*this == other_value); }
ClientReady& clientReady();
const ClientReady& clientReady() const;
ServerReady& serverReady();
const ServerReady& serverReady() const;
ClientStop& clientStop();
const ClientStop& clientStop() const;
ServerStop& serverStop();
const ServerStop& serverStop() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SyncCmd_template : public Base_Template {
union {
struct {
SyncCmd::union_selection_type union_selection;
union {
ClientReady_template *field_clientReady;
ServerReady_template *field_serverReady;
ClientStop_template *field_clientStop;
ServerStop_template *field_serverStop;
};
} single_value;
struct {
unsigned int n_values;
SyncCmd_template *list_value;
} value_list;
};
void copy_value(const SyncCmd& other_value);

void copy_template(const SyncCmd_template& other_value);

public:
SyncCmd_template();
SyncCmd_template(template_sel other_value);
SyncCmd_template(const SyncCmd& other_value);
SyncCmd_template(const OPTIONAL<SyncCmd>& other_value);
SyncCmd_template(const SyncCmd_template& other_value);
~SyncCmd_template();
void clean_up();
SyncCmd_template& operator=(template_sel other_value);
SyncCmd_template& operator=(const SyncCmd& other_value);
SyncCmd_template& operator=(const OPTIONAL<SyncCmd>& other_value);
SyncCmd_template& operator=(const SyncCmd_template& other_value);
boolean match(const SyncCmd& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SyncCmd valueof() const;
SyncCmd_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ClientReady_template& clientReady();
const ClientReady_template& clientReady() const;
ServerReady_template& serverReady();
const ServerReady_template& serverReady() const;
ClientStop_template& clientStop();
const ClientStop_template& clientStop() const;
ServerStop_template& serverStop();
const ServerStop_template& serverStop() const;
boolean ischosen(SyncCmd::union_selection_type checked_selection) const;
void log() const;
void log_match(const SyncCmd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ClientReady {
  CHARSTRING field_syncPointId;
public:
  ClientReady();
  ClientReady(const CHARSTRING& par_syncPointId);
  ClientReady(const ClientReady& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ClientReady& operator=(const ClientReady& other_value);
  boolean operator==(const ClientReady& other_value) const;
  inline boolean operator!=(const ClientReady& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& syncPointId()
    {return field_syncPointId;}
  inline const CHARSTRING& syncPointId() const
    {return field_syncPointId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ClientReady_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ClientReady_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ClientReady& other_value);
void copy_template(const ClientReady_template& other_value);

public:
ClientReady_template();
ClientReady_template(template_sel other_value);
ClientReady_template(const ClientReady& other_value);
ClientReady_template(const OPTIONAL<ClientReady>& other_value);
ClientReady_template(const ClientReady_template& other_value);
~ClientReady_template();
ClientReady_template& operator=(template_sel other_value);
ClientReady_template& operator=(const ClientReady& other_value);
ClientReady_template& operator=(const OPTIONAL<ClientReady>& other_value);
ClientReady_template& operator=(const ClientReady_template& other_value);
boolean match(const ClientReady& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ClientReady valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ClientReady_template& list_item(unsigned int list_index) const;
CHARSTRING_template& syncPointId();
const CHARSTRING_template& syncPointId() const;
int size_of() const;
void log() const;
void log_match(const ClientReady& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServerReady {
  CHARSTRING field_syncPointId;
public:
  ServerReady();
  ServerReady(const CHARSTRING& par_syncPointId);
  ServerReady(const ServerReady& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServerReady& operator=(const ServerReady& other_value);
  boolean operator==(const ServerReady& other_value) const;
  inline boolean operator!=(const ServerReady& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& syncPointId()
    {return field_syncPointId;}
  inline const CHARSTRING& syncPointId() const
    {return field_syncPointId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ServerReady_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServerReady_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServerReady& other_value);
void copy_template(const ServerReady_template& other_value);

public:
ServerReady_template();
ServerReady_template(template_sel other_value);
ServerReady_template(const ServerReady& other_value);
ServerReady_template(const OPTIONAL<ServerReady>& other_value);
ServerReady_template(const ServerReady_template& other_value);
~ServerReady_template();
ServerReady_template& operator=(template_sel other_value);
ServerReady_template& operator=(const ServerReady& other_value);
ServerReady_template& operator=(const OPTIONAL<ServerReady>& other_value);
ServerReady_template& operator=(const ServerReady_template& other_value);
boolean match(const ServerReady& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServerReady valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServerReady_template& list_item(unsigned int list_index) const;
CHARSTRING_template& syncPointId();
const CHARSTRING_template& syncPointId() const;
int size_of() const;
void log() const;
void log_match(const ServerReady& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ClientStop : public Base_Type {
boolean bound_flag;
public:
ClientStop();
ClientStop(null_type other_value);
ClientStop(const ClientStop& other_value);
ClientStop& operator=(null_type other_value);
ClientStop& operator=(const ClientStop& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const ClientStop& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ClientStop& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ClientStop_template : public Base_Template {
struct {
unsigned int n_values;
ClientStop_template *list_value;
} value_list;
void copy_template(const ClientStop_template& other_value);

public:
ClientStop_template();
ClientStop_template(template_sel other_value);
ClientStop_template(null_type other_value);
ClientStop_template(const ClientStop& other_value);
ClientStop_template(const OPTIONAL<ClientStop>& other_value);
ClientStop_template(const ClientStop_template& other_value);
~ClientStop_template();
void clean_up();
ClientStop_template& operator=(template_sel other_value);
ClientStop_template& operator=(null_type other_value);
ClientStop_template& operator=(const ClientStop& other_value);
ClientStop_template& operator=(const OPTIONAL<ClientStop>& other_value);
ClientStop_template& operator=(const ClientStop_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const ClientStop& other_value, boolean legacy = FALSE) const;
ClientStop valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ClientStop_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const ClientStop& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServerStop : public Base_Type {
boolean bound_flag;
public:
ServerStop();
ServerStop(null_type other_value);
ServerStop(const ServerStop& other_value);
ServerStop& operator=(null_type other_value);
ServerStop& operator=(const ServerStop& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const ServerStop& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ServerStop& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ServerStop_template : public Base_Template {
struct {
unsigned int n_values;
ServerStop_template *list_value;
} value_list;
void copy_template(const ServerStop_template& other_value);

public:
ServerStop_template();
ServerStop_template(template_sel other_value);
ServerStop_template(null_type other_value);
ServerStop_template(const ServerStop& other_value);
ServerStop_template(const OPTIONAL<ServerStop>& other_value);
ServerStop_template(const ServerStop_template& other_value);
~ServerStop_template();
void clean_up();
ServerStop_template& operator=(template_sel other_value);
ServerStop_template& operator=(null_type other_value);
ServerStop_template& operator=(const ServerStop& other_value);
ServerStop_template& operator=(const OPTIONAL<ServerStop>& other_value);
ServerStop_template& operator=(const ServerStop_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const ServerStop& other_value, boolean legacy = FALSE) const;
ServerStop valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServerStop_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const ServerStop& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern void f__connect4SelfOrClientSync();
extern void start_f__connect4SelfOrClientSync(const COMPONENT& component_reference);
extern void f__disconnect4SelfOrClientSync();
extern void start_f__disconnect4SelfOrClientSync(const COMPONENT& component_reference);
extern void f__serverSync2ClientsAndStop(const SyncPointList& p__syncPointIds);
extern void start_f__serverSync2ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds);
extern void f__serverSync3ClientsAndStop(const SyncPointList& p__syncPointIds);
extern void start_f__serverSync3ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds);
extern void f__serverSync4ClientsAndStop(const SyncPointList& p__syncPointIds);
extern void start_f__serverSync4ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds);
extern void f__serverSyncNClientsAndStop(const INTEGER& p__numClients, const SyncPointList& p__syncPointIds);
extern void start_f__serverSyncNClientsAndStop(const COMPONENT& component_reference, const INTEGER& p__numClients, const SyncPointList& p__syncPointIds);
extern void f__serverSync2ClientsUtAndStop(const SyncPointList& p__syncPointIds);
extern void start_f__serverSync2ClientsUtAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds);
extern void f__selfOrClientSyncAndVerdict(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfOrClientSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfOrClientSyncAndVerdictPreamble(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfOrClientSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfOrClientSyncAndVerdictTestBody(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfOrClientSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfOrClientSyncAndVerdictPR(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfOrClientSyncAndVerdictPR(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__addSyncCompState(const CHARSTRING& p__newSyncCompState, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__addSyncCompState(const COMPONENT& component_reference, const CHARSTRING& p__newSyncCompState, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern BOOLEAN f__getTopSyncCompState(CHARSTRING& p__state);
extern void f__popSyncCompState();
extern void start_f__popSyncCompState(const COMPONENT& component_reference);
extern BOOLEAN f__peekTopSyncCompState(CHARSTRING& p__state);
extern BOOLEAN f__isSyncCompStateStackEmpty();
extern void start_f__isSyncCompStateStackEmpty(const COMPONENT& component_reference);
extern alt_status a__dummyShutDown_instance();
extern void a__dummyShutDown();
extern Default_Base *activate_a__dummyShutDown();
extern alt_status a__shutdown_instance();
extern void a__shutdown();
extern Default_Base *activate_a__shutdown();
extern void f__serverSyncClients(const INTEGER& p__noOfClients, const CHARSTRING& p__syncId);
extern void start_f__serverSyncClients(const COMPONENT& component_reference, const INTEGER& p__noOfClients, const CHARSTRING& p__syncId);
extern void f__serverSyncClientsIntermediateSync(const INTEGER& p__noOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate);
extern void start_f__serverSyncClientsIntermediateSync(const COMPONENT& component_reference, const INTEGER& p__noOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate);
extern void f__serverSyncClientsTimed(const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const FLOAT& p__execTimeLimit);
extern void start_f__serverSyncClientsTimed(const COMPONENT& component_reference, const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const FLOAT& p__execTimeLimit);
extern void f__serverSyncClientsTimedIntermediateSync(const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate, const FLOAT& p__execTimeLimit);
extern void start_f__serverSyncClientsTimedIntermediateSync(const COMPONENT& component_reference, const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate, const FLOAT& p__execTimeLimit);
extern void f__serverWaitForAllClientsToStop();
extern void start_f__serverWaitForAllClientsToStop(const COMPONENT& component_reference);
extern void f__connect4ClientSync();
extern void start_f__connect4ClientSync(const COMPONENT& component_reference);
extern void f__disconnect4ClientSync();
extern void start_f__disconnect4ClientSync(const COMPONENT& component_reference);
extern void f__clientSyncAndVerdict(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__clientSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__clientSyncAndVerdictPreamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__clientSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__clientSyncAndVerdictTestBody(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__clientSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__clientSyncAndVerdictPostamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__clientSyncAndVerdictPostamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern LibCommon__VerdictControl::FncRetCode f__clientSync(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__clientSync(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__clientSendStop();
extern void start_f__clientSendStop(const COMPONENT& component_reference);
extern boolean operator==(null_type null_value, const ClientSyncCompList& other_value);
inline boolean operator!=(null_type null_value, const ClientSyncCompList& other_value) { return !(null_value == other_value); }
extern void f__connect4SelfSync();
extern void start_f__connect4SelfSync(const COMPONENT& component_reference);
extern void f__disconnect4SelfSync();
extern void start_f__disconnect4SelfSync(const COMPONENT& component_reference);
extern void f__selfSyncAndVerdict(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfSyncAndVerdictPreamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfSyncAndVerdictTestBody(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfSyncAndVerdictPostamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfSyncAndVerdictPostamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern LibCommon__VerdictControl::FncRetCode f__selfSync(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void start_f__selfSync(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret);
extern void f__selfSyncStop();
extern void start_f__selfSyncStop(const COMPONENT& component_reference);
extern boolean operator==(null_type null_value, const ClientStop& other_value);
inline boolean operator!=(null_type null_value, const ClientStop& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ServerStop& other_value);
inline boolean operator!=(null_type null_value, const ServerStop& other_value) { return !(null_value == other_value); }
extern SyncCmd_template m__syncClientReady(const CHARSTRING_template& p__syncId);
extern SyncCmd_template m__syncServerReady(const CHARSTRING_template& p__syncId);
extern void f__serverSendToAllClients(const ClientSyncCompList& p__clientRefs, const SyncCmd_template& p__syncCmd);
extern void start_f__serverSendToAllClients(const COMPONENT& component_reference, const ClientSyncCompList& p__clientRefs, const SyncCmd_template& p__syncCmd);
extern void f__serverWaitForAllClientsToShutDown();
extern void start_f__serverWaitForAllClientsToShutDown(const COMPONENT& component_reference);
extern BOOLEAN f__isPresentInArray(const COMPONENT& p__clientRef, const ClientSyncCompList& p__clientRefs);

/* Global variable declarations */

extern const TTCN_Typedescriptor_t& BaseSyncComp_descr_;
extern SyncPort BaseSyncComp_component_syncPort;
extern TIMER BaseSyncComp_component_tc__sync;
extern const TTCN_Typedescriptor_t& ServerSyncComp_descr_;
extern TIMER ServerSyncComp_component_tc__shutDown;
extern const TTCN_Typedescriptor_t& ClientSyncComp_descr_;
extern LibCommon__AbstractData::StringStack ClientSyncComp_component_v__stateStack;
extern const TTCN_Typedescriptor_t TestcaseStep_descr_;
extern TestcaseStep ClientSyncComp_component_vc__testcaseStep;
extern const TTCN_Typedescriptor_t& SelfSyncComp_descr_;
extern SyncPort SelfSyncComp_component_syncSendPort;
extern const CHARSTRING& c__prDone;
extern const CHARSTRING& c__poDone;
extern const CHARSTRING& c__tbDone;
extern const CHARSTRING& c__initDone;
extern const FLOAT& PX__TSYNC__TIME__LIMIT;
extern const FLOAT& PX__TSHUT__DOWN__TIME__LIMIT;
extern const TTCN_Typedescriptor_t SyncPointList_descr_;
extern const XERdescriptor_t SyncPointList_0_xer_;
extern const TTCN_Typedescriptor_t SyncPointList_0_descr_;
extern const TTCN_Typedescriptor_t ClientSyncCompList_descr_;
extern const TTCN_Typedescriptor_t SyncCmd_descr_;
extern const XERdescriptor_t ClientReady_syncPointId_xer_;
extern const TTCN_Typedescriptor_t ClientReady_syncPointId_descr_;
extern const TTCN_Typedescriptor_t ClientReady_descr_;
extern const XERdescriptor_t ServerReady_syncPointId_xer_;
extern const TTCN_Typedescriptor_t ServerReady_syncPointId_descr_;
extern const TTCN_Typedescriptor_t ServerReady_descr_;
extern const TTCN_Typedescriptor_t ClientStop_descr_;
extern const TTCN_Typedescriptor_t ServerStop_descr_;
extern const SyncCmd_template& m__syncClientStop;
extern const SyncCmd_template& m__syncServerStop;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
