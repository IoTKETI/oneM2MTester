// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R1A
// for oneM2MTester (martin@ubuntu) on Wed May 31 13:52:13 2017

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibCommon_Sync.hh"

namespace LibCommon__Sync {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean set_module_param(Module_Param& param);
static void log_module_param();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);

/* Literal string constants */

static const CHARSTRING cs_5(0, NULL),
cs_4(4, "IDLE"),
cs_3(8, "initDone"),
cs_1(13, "postambleDone"),
cs_0(12, "preambleDone"),
cs_2(12, "testBodyDone"),
cs_6('x'),
cs_7('y');
static const unsigned char module_checksum[] = { 0xdc, 0x36, 0x62, 0x56, 0xbd, 0xfd, 0x14, 0x67, 0xf1, 0x4c, 0x0c, 0x08, 0xb1, 0xd2, 0x70, 0x4d };

/* Class definitions for internal use */

class a__dummyShutDown_Default : public Default_Base {
public:
a__dummyShutDown_Default();
alt_status call_altstep();
};

class a__shutdown_Default : public Default_Base {
public:
a__shutdown_Default();
alt_status call_altstep();
};


/* Global variable definitions */

const TTCN_Typedescriptor_t& BaseSyncComp_descr_ = COMPONENT_descr_;
SyncPort BaseSyncComp_component_syncPort("syncPort");
TIMER BaseSyncComp_component_tc__sync("tc_sync");
const TTCN_Typedescriptor_t& ServerSyncComp_descr_ = COMPONENT_descr_;
TIMER ServerSyncComp_component_tc__shutDown("tc_shutDown");
const TTCN_Typedescriptor_t& ClientSyncComp_descr_ = COMPONENT_descr_;
LibCommon__AbstractData::StringStack ClientSyncComp_component_v__stateStack;
// No XER for TestcaseStep
const TTCN_Typedescriptor_t TestcaseStep_descr_ = { "@LibCommon_Sync.TestcaseStep", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
TestcaseStep ClientSyncComp_component_vc__testcaseStep;
const TTCN_Typedescriptor_t& SelfSyncComp_descr_ = COMPONENT_descr_;
SyncPort SelfSyncComp_component_syncSendPort("syncSendPort");
static CHARSTRING const_c__prDone;
const CHARSTRING& c__prDone = const_c__prDone;
static CHARSTRING const_c__poDone;
const CHARSTRING& c__poDone = const_c__poDone;
static CHARSTRING const_c__tbDone;
const CHARSTRING& c__tbDone = const_c__tbDone;
static CHARSTRING const_c__initDone;
const CHARSTRING& c__initDone = const_c__initDone;
static FLOAT modulepar_PX__TSYNC__TIME__LIMIT;
const FLOAT& PX__TSYNC__TIME__LIMIT = modulepar_PX__TSYNC__TIME__LIMIT;
static FLOAT modulepar_PX__TSHUT__DOWN__TIME__LIMIT;
const FLOAT& PX__TSHUT__DOWN__TIME__LIMIT = modulepar_PX__TSHUT__DOWN__TIME__LIMIT;
// No XER for SyncPointList
const TTCN_Typedescriptor_t SyncPointList_descr_ = { "@LibCommon_Sync.SyncPointList", NULL, NULL, NULL, NULL, NULL, &CHARSTRING_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SyncPointList_0_xer_ = { {"CHARSTRING>\n", "CHARSTRING>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t SyncPointList_0_descr_ = { "@LibCommon_Sync.SyncPointList.<oftype>", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &SyncPointList_0_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ClientSyncCompList
const TTCN_Typedescriptor_t ClientSyncCompList_descr_ = { "@LibCommon_Sync.ClientSyncCompList", NULL, NULL, NULL, NULL, NULL, &COMPONENT_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SyncCmd
const TTCN_Typedescriptor_t SyncCmd_descr_ = { "@LibCommon_Sync.SyncCmd", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ClientReady_syncPointId_xer_ = { {"syncPointId>\n", "syncPointId>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ClientReady_syncPointId_descr_ = { "@LibCommon_Sync.ClientReady.syncPointId", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ClientReady_syncPointId_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ClientReady
const TTCN_Typedescriptor_t ClientReady_descr_ = { "@LibCommon_Sync.ClientReady", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ServerReady_syncPointId_xer_ = { {"syncPointId>\n", "syncPointId>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL, -1, XSD_NONE };
const TTCN_Typedescriptor_t ServerReady_syncPointId_descr_ = { "@LibCommon_Sync.ServerReady.syncPointId", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &ServerReady_syncPointId_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ServerReady
const TTCN_Typedescriptor_t ServerReady_descr_ = { "@LibCommon_Sync.ServerReady", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ClientStop
const TTCN_Typedescriptor_t ClientStop_descr_ = { "@LibCommon_Sync.ClientStop", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ServerStop
const TTCN_Typedescriptor_t ServerStop_descr_ = { "@LibCommon_Sync.ServerStop", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static SyncCmd_template template_m__syncClientStop;
const SyncCmd_template& m__syncClientStop = template_m__syncClientStop;
static SyncCmd_template template_m__syncServerStop;
const SyncCmd_template& m__syncServerStop = template_m__syncServerStop;
static const size_t num_namespaces = 1;
static const namespace_t xml_namespaces[num_namespaces+1] = {
  { NULL, NULL },
  { "", "" }
};

TTCN_Module module_object("LibCommon_Sync", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 1LU, xml_namespaces, post_init_module, set_module_param, NULL, log_module_param, init_comp_type, start_ptc_function, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_1,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

TestcaseStep::TestcaseStep()
{
enum_value = UNBOUND_VALUE;
}

TestcaseStep::TestcaseStep(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibCommon_Sync.TestcaseStep with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

TestcaseStep::TestcaseStep(enum_type other_value)
{
enum_value = other_value;
}

TestcaseStep::TestcaseStep(const TestcaseStep& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
enum_value = other_value.enum_value;
}

TestcaseStep& TestcaseStep::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibCommon_Sync.TestcaseStep.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

TestcaseStep& TestcaseStep::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

TestcaseStep& TestcaseStep::operator=(const TestcaseStep& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
enum_value = other_value.enum_value;
return *this;
}

boolean TestcaseStep::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value == other_value;
}

boolean TestcaseStep::operator==(const TestcaseStep& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value == other_value.enum_value;
}

boolean TestcaseStep::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value < other_value;
}

boolean TestcaseStep::operator<(const TestcaseStep& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value < other_value.enum_value;
}

boolean TestcaseStep::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value > other_value;
}

boolean TestcaseStep::operator>(const TestcaseStep& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value > other_value.enum_value;
}

const char *TestcaseStep::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__preamble: return "e_preamble";
case e__testBody: return "e_testBody";
case e__postamble: return "e_postamble";
default: return "<unknown>";
}
}

TestcaseStep::enum_type TestcaseStep::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_preamble")) return e__preamble;
else if (!strcmp(str_par, "e_testBody")) return e__testBody;
else if (!strcmp(str_par, "e_postamble")) return e__postamble;
else return UNKNOWN_VALUE;
}

boolean TestcaseStep::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int TestcaseStep::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibCommon_Sync.TestcaseStep.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int TestcaseStep::enum2int(const TestcaseStep& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibCommon_Sync.TestcaseStep.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void TestcaseStep::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibCommon_Sync.TestcaseStep.", int_val);
enum_value = (enum_type)int_val;
}

TestcaseStep::operator TestcaseStep::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibCommon_Sync.TestcaseStep.");
return enum_value;
}

void TestcaseStep::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void TestcaseStep::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibCommon_Sync.TestcaseStep");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibCommon_Sync.TestcaseStep.");
  }
}

void TestcaseStep::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
text_buf.push_int(enum_value);
}

void TestcaseStep::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibCommon_Sync.TestcaseStep.", enum_value);
}

void TestcaseStep_template::copy_template(const TestcaseStep_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TestcaseStep_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibCommon_Sync.TestcaseStep.");
}
}

TestcaseStep_template::TestcaseStep_template()
{
}

TestcaseStep_template::TestcaseStep_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TestcaseStep_template::TestcaseStep_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!TestcaseStep::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibCommon_Sync.TestcaseStep with unknown numeric value %d.", other_value);
single_value = (TestcaseStep::enum_type)other_value;
}

TestcaseStep_template::TestcaseStep_template(TestcaseStep::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

TestcaseStep_template::TestcaseStep_template(const TestcaseStep& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == TestcaseStep::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibCommon_Sync.TestcaseStep.");
single_value = other_value.enum_value;
}

TestcaseStep_template::TestcaseStep_template(const OPTIONAL<TestcaseStep>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TestcaseStep::enum_type)(const TestcaseStep&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibCommon_Sync.TestcaseStep from an unbound optional field.");
}
}

TestcaseStep_template::TestcaseStep_template(const TestcaseStep_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

TestcaseStep_template::~TestcaseStep_template()
{
clean_up();
}

boolean TestcaseStep_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean TestcaseStep_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != TestcaseStep::UNBOUND_VALUE;
}

void TestcaseStep_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TestcaseStep_template& TestcaseStep_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TestcaseStep_template& TestcaseStep_template::operator=(int other_value)
{
if (!TestcaseStep::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibCommon_Sync.TestcaseStep.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (TestcaseStep::enum_type)other_value;
return *this;
}

TestcaseStep_template& TestcaseStep_template::operator=(TestcaseStep::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

TestcaseStep_template& TestcaseStep_template::operator=(const TestcaseStep& other_value)
{
if (other_value.enum_value == TestcaseStep::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibCommon_Sync.TestcaseStep to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

TestcaseStep_template& TestcaseStep_template::operator=(const OPTIONAL<TestcaseStep>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TestcaseStep::enum_type)(const TestcaseStep&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibCommon_Sync.TestcaseStep.");
}
return *this;
}

TestcaseStep_template& TestcaseStep_template::operator=(const TestcaseStep_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TestcaseStep_template::match(TestcaseStep::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibCommon_Sync.TestcaseStep.");
}
return FALSE;
}

boolean TestcaseStep_template::match(const TestcaseStep& other_value, boolean) const
{
if (other_value.enum_value == TestcaseStep::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibCommon_Sync.TestcaseStep with an unbound value.");
return match(other_value.enum_value);
}

TestcaseStep::enum_type TestcaseStep_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibCommon_Sync.TestcaseStep.");
return single_value;
}

void TestcaseStep_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibCommon_Sync.TestcaseStep.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TestcaseStep_template[list_length];
}

TestcaseStep_template& TestcaseStep_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibCommon_Sync.TestcaseStep.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibCommon_Sync.TestcaseStep.");
return value_list.list_value[list_index];
}

void TestcaseStep_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(TestcaseStep::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TestcaseStep_template::log_match(const TestcaseStep& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TestcaseStep_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibCommon_Sync.TestcaseStep.");
}
}

void TestcaseStep_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (TestcaseStep::enum_type)text_buf.pull_int().get_val();
if (!TestcaseStep::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibCommon_Sync.TestcaseStep.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TestcaseStep_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibCommon_Sync.TestcaseStep.");
}
}

boolean TestcaseStep_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TestcaseStep_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TestcaseStep_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TestcaseStep_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    TestcaseStep::enum_type enum_val = TestcaseStep::str_to_enum(m_p->get_enumerated());
    if (!TestcaseStep::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibCommon_Sync.TestcaseStep.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibCommon_Sync.TestcaseStep");
  }
  is_ifpresent = param.get_ifpresent();
}

void TestcaseStep_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.TestcaseStep");
}

void SyncPort::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void SyncPort::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

SyncPort::SyncPort(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

SyncPort::~SyncPort()
{
clear_queue();
}

void SyncPort::send(const SyncCmd& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibCommon_Sync.SyncCmd : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) TTCN_error("Message cannot be sent to system on internal port %s.", port_name);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibCommon_Sync.SyncCmd");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void SyncPort::send(const SyncCmd& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void SyncPort::send(const SyncCmd_template& send_par, const COMPONENT& destination_component)
{
const SyncCmd& send_par_value = SyncCmd(send_par.valueof());
send(send_par_value, destination_component);
}

void SyncPort::send(const SyncCmd_template& send_par)
{
const SyncCmd& send_par_value = SyncCmd(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status SyncPort::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status SyncPort::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status SyncPort::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status SyncPort::receive(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Receive operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibCommon_Sync.SyncCmd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_redirect != NULL) {
*value_redirect = *my_head->message_0;
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status SyncPort::check_receive(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Check-receive operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibCommon_Sync.SyncCmd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_redirect != NULL) {
*value_redirect = *my_head->message_0;
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status SyncPort::trigger(const SyncCmd_template& value_template, SyncCmd *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*)
{
if (value_template.get_selection() == ANY_OR_OMIT) TTCN_error("Trigger operation using '*' as matching template");
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibCommon_Sync.SyncCmd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_redirect != NULL) {
*value_redirect = *my_head->message_0;
}
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibCommon_Sync.SyncCmd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void SyncPort::incoming_message(const SyncCmd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibCommon_Sync.SyncCmd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new SyncCmd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean SyncPort::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@LibCommon_Sync.SyncCmd")) {
SyncCmd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

a__dummyShutDown_Default::a__dummyShutDown_Default()
 : Default_Base("a_dummyShutDown")
{
}

alt_status a__dummyShutDown_Default::call_altstep()
{
return a__dummyShutDown_instance();
}

a__shutdown_Default::a__shutdown_Default()
 : Default_Base("a_shutdown")
{
}

alt_status a__shutdown_Default::call_altstep()
{
return a__shutdown_instance();
}


const COMPONENT ClientSyncCompList::UNBOUND_ELEM;
ClientSyncCompList::ClientSyncCompList()
{
val_ptr = NULL;
}

ClientSyncCompList::ClientSyncCompList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ClientSyncCompList::ClientSyncCompList(const ClientSyncCompList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ClientSyncCompList::~ClientSyncCompList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ClientSyncCompList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ClientSyncCompList& ClientSyncCompList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ClientSyncCompList& ClientSyncCompList::operator=(const ClientSyncCompList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ClientSyncCompList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
return val_ptr->n_elements == 0 ;
}

boolean ClientSyncCompList::operator==(const ClientSyncCompList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

COMPONENT& ClientSyncCompList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibCommon_Sync.ClientSyncCompList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (COMPONENT**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new COMPONENT(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new COMPONENT;
}
return *val_ptr->value_elements[index_value];
}

COMPONENT& ClientSyncCompList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibCommon_Sync.ClientSyncCompList.");
return (*this)[(int)index_value];
}

const COMPONENT& ClientSyncCompList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibCommon_Sync.ClientSyncCompList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibCommon_Sync.ClientSyncCompList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const COMPONENT& ClientSyncCompList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibCommon_Sync.ClientSyncCompList.");
return (*this)[(int)index_value];
}

ClientSyncCompList ClientSyncCompList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ClientSyncCompList ClientSyncCompList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ClientSyncCompList ClientSyncCompList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ClientSyncCompList ClientSyncCompList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ClientSyncCompList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new COMPONENT(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ClientSyncCompList ClientSyncCompList::operator+(const ClientSyncCompList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibCommon_Sync.ClientSyncCompList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ClientSyncCompList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new COMPONENT(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new COMPONENT(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ClientSyncCompList ClientSyncCompList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibCommon_Sync.ClientSyncCompList","element");
ClientSyncCompList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new COMPONENT(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ClientSyncCompList ClientSyncCompList::replace(int index, int len, const ClientSyncCompList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibCommon_Sync.ClientSyncCompList","element");
ClientSyncCompList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new COMPONENT(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new COMPONENT(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new COMPONENT(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ClientSyncCompList ClientSyncCompList::replace(int index, int len, const ClientSyncCompList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ClientSyncCompList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibCommon_Sync.ClientSyncCompList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (COMPONENT**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new COMPONENT(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (COMPONENT**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibCommon_Sync.ClientSyncCompList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (COMPONENT**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ClientSyncCompList::is_value() const
{
if (val_ptr == NULL) return FALSE;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ClientSyncCompList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
return val_ptr->n_elements;
}

int ClientSyncCompList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ClientSyncCompList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ClientSyncCompList::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (param.get_type()==Module_Param::MP_Value_List && param.get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (param.get_type()) {
    case Module_Param::MP_Value_List:
      set_size(param.get_size());
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
          if (!(*this)[i].is_bound()) {
            delete val_ptr->value_elements[i];
            val_ptr->value_elements[i] = NULL;
          }
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
        if (!(*this)[curr->get_id()->get_index()].is_bound()) {
          delete val_ptr->value_elements[curr->get_id()->get_index()];
          val_ptr->value_elements[curr->get_id()->get_index()] = NULL;
        }
      }
      break;
    default:
      param.type_error("record of value", "@LibCommon_Sync.ClientSyncCompList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (param.get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<param.get_size(); ++i) {
        Module_Param* const curr = param.get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibCommon_Sync.ClientSyncCompList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

void ClientSyncCompList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ClientSyncCompList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ClientSyncCompList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibCommon_Sync.ClientSyncCompList.");
val_ptr->value_elements = (COMPONENT**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new COMPONENT;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ClientSyncCompList_template::copy_value(const ClientSyncCompList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibCommon_Sync.ClientSyncCompList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (COMPONENT_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new COMPONENT_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new COMPONENT_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ClientSyncCompList_template::copy_template(const ClientSyncCompList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (COMPONENT_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new COMPONENT_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new COMPONENT_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ClientSyncCompList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibCommon_Sync.ClientSyncCompList.");
break;
}
set_selection(other_value);
}

boolean ClientSyncCompList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ClientSyncCompList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ClientSyncCompList*)value_ptr)[value_index], legacy);
else return ((const ClientSyncCompList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ClientSyncCompList_template::ClientSyncCompList_template()
{
}

ClientSyncCompList_template::ClientSyncCompList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ClientSyncCompList_template::ClientSyncCompList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ClientSyncCompList_template::ClientSyncCompList_template(const ClientSyncCompList& other_value)
{
copy_value(other_value);
}

ClientSyncCompList_template::ClientSyncCompList_template(const OPTIONAL<ClientSyncCompList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClientSyncCompList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibCommon_Sync.ClientSyncCompList from an unbound optional field.");
}
}

ClientSyncCompList_template::ClientSyncCompList_template(const ClientSyncCompList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ClientSyncCompList_template::~ClientSyncCompList_template()
{
clean_up();
}

void ClientSyncCompList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ClientSyncCompList_template& ClientSyncCompList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ClientSyncCompList_template& ClientSyncCompList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ClientSyncCompList_template& ClientSyncCompList_template::operator=(const ClientSyncCompList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ClientSyncCompList_template& ClientSyncCompList_template::operator=(const OPTIONAL<ClientSyncCompList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClientSyncCompList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibCommon_Sync.ClientSyncCompList.");
}
return *this;
}

ClientSyncCompList_template& ClientSyncCompList_template::operator=(const ClientSyncCompList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

COMPONENT_template& ClientSyncCompList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibCommon_Sync.ClientSyncCompList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibCommon_Sync.ClientSyncCompList.");
    break;
}
return *single_value.value_elements[index_value];
}

COMPONENT_template& ClientSyncCompList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibCommon_Sync.ClientSyncCompList.");
return (*this)[(int)index_value];
}

const COMPONENT_template& ClientSyncCompList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibCommon_Sync.ClientSyncCompList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibCommon_Sync.ClientSyncCompList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibCommon_Sync.ClientSyncCompList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const COMPONENT_template& ClientSyncCompList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibCommon_Sync.ClientSyncCompList.");
return (*this)[(int)index_value];
}

void ClientSyncCompList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibCommon_Sync.ClientSyncCompList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (COMPONENT_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new COMPONENT_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new COMPONENT_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (COMPONENT_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ClientSyncCompList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ClientSyncCompList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibCommon_Sync.ClientSyncCompList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibCommon_Sync.ClientSyncCompList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibCommon_Sync.ClientSyncCompList");
}

boolean ClientSyncCompList_template::match(const ClientSyncCompList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibCommon_Sync.ClientSyncCompList.");
}
return FALSE;
}

boolean ClientSyncCompList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return FALSE;
return TRUE;
}

ClientSyncCompList ClientSyncCompList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibCommon_Sync.ClientSyncCompList.");
ClientSyncCompList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ClientSyncCompList ClientSyncCompList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ClientSyncCompList ClientSyncCompList_template::replace(int index, int len, const ClientSyncCompList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ClientSyncCompList ClientSyncCompList_template::replace(int index, int len, const ClientSyncCompList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ClientSyncCompList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ClientSyncCompList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibCommon_Sync.ClientSyncCompList.");
}
set_selection(template_type);
}

ClientSyncCompList_template& ClientSyncCompList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibCommon_Sync.ClientSyncCompList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibCommon_Sync.ClientSyncCompList.");
return value_list.list_value[list_index];
}

void ClientSyncCompList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ClientSyncCompList_template::log_match(const ClientSyncCompList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ClientSyncCompList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibCommon_Sync.ClientSyncCompList.");
}
}

void ClientSyncCompList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibCommon_Sync.ClientSyncCompList.");
single_value.value_elements = (COMPONENT_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new COMPONENT_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ClientSyncCompList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibCommon_Sync.ClientSyncCompList.");
}
}

boolean ClientSyncCompList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ClientSyncCompList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ClientSyncCompList_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ClientSyncCompList_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      (*this)[(int)(param.get_elem(p_i)->get_id()->get_index())].set_param(*param.get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(param.get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<param.get_size(); ++p_i) {
      switch (param.get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<param.get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(param.get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*param.get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibCommon_Sync.ClientSyncCompList");
  }
  is_ifpresent = param.get_ifpresent();
  set_length_range(param);
}

void ClientSyncCompList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.ClientSyncCompList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.ClientSyncCompList");
}

boolean ClientSyncCompList_template::get_istemplate_kind(const char* type) const {
if (!strcmp(type, "AnyElement")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_VALUE) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "AnyElementsOrNone")) {
  if (template_selection != SPECIFIC_VALUE) {
    return FALSE;
  }
  for (int i = 0; i < single_value.n_elements; i++) {
    if (single_value.value_elements[i]->get_selection() == ANY_OR_OMIT) {
      return TRUE;
    }
  }
  return FALSE;
} else if (!strcmp(type, "permutation")) {
  return number_of_permutations;
} else if (!strcmp(type, "length")) {
  return length_restriction_type != NO_LENGTH_RESTRICTION;
} else {
  return Base_Template::get_istemplate_kind(type);
}
}
void SyncCmd::copy_value(const SyncCmd& other_value)
{
switch (other_value.union_selection) {
case ALT_clientReady:
field_clientReady = new ClientReady(*other_value.field_clientReady);
break;
case ALT_serverReady:
field_serverReady = new ServerReady(*other_value.field_serverReady);
break;
case ALT_clientStop:
field_clientStop = new ClientStop(*other_value.field_clientStop);
break;
case ALT_serverStop:
field_serverStop = new ServerStop(*other_value.field_serverStop);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibCommon_Sync.SyncCmd.");
}
union_selection = other_value.union_selection;
}

SyncCmd::SyncCmd()
{
union_selection = UNBOUND_VALUE;
}

SyncCmd::SyncCmd(const SyncCmd& other_value)
: Base_Type(){
copy_value(other_value);
}

SyncCmd::~SyncCmd()
{
clean_up();
}

SyncCmd& SyncCmd::operator=(const SyncCmd& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SyncCmd::operator==(const SyncCmd& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibCommon_Sync.SyncCmd.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibCommon_Sync.SyncCmd.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_clientReady:
return *field_clientReady == *other_value.field_clientReady;
case ALT_serverReady:
return *field_serverReady == *other_value.field_serverReady;
case ALT_clientStop:
return *field_clientStop == *other_value.field_clientStop;
case ALT_serverStop:
return *field_serverStop == *other_value.field_serverStop;
default:
return FALSE;
}
}

ClientReady& SyncCmd::clientReady()
{
if (union_selection != ALT_clientReady) {
clean_up();
field_clientReady = new ClientReady;
union_selection = ALT_clientReady;
}
return *field_clientReady;
}

const ClientReady& SyncCmd::clientReady() const
{
if (union_selection != ALT_clientReady) TTCN_error("Using non-selected field clientReady in a value of union type @LibCommon_Sync.SyncCmd.");
return *field_clientReady;
}

ServerReady& SyncCmd::serverReady()
{
if (union_selection != ALT_serverReady) {
clean_up();
field_serverReady = new ServerReady;
union_selection = ALT_serverReady;
}
return *field_serverReady;
}

const ServerReady& SyncCmd::serverReady() const
{
if (union_selection != ALT_serverReady) TTCN_error("Using non-selected field serverReady in a value of union type @LibCommon_Sync.SyncCmd.");
return *field_serverReady;
}

ClientStop& SyncCmd::clientStop()
{
if (union_selection != ALT_clientStop) {
clean_up();
field_clientStop = new ClientStop;
union_selection = ALT_clientStop;
}
return *field_clientStop;
}

const ClientStop& SyncCmd::clientStop() const
{
if (union_selection != ALT_clientStop) TTCN_error("Using non-selected field clientStop in a value of union type @LibCommon_Sync.SyncCmd.");
return *field_clientStop;
}

ServerStop& SyncCmd::serverStop()
{
if (union_selection != ALT_serverStop) {
clean_up();
field_serverStop = new ServerStop;
union_selection = ALT_serverStop;
}
return *field_serverStop;
}

const ServerStop& SyncCmd::serverStop() const
{
if (union_selection != ALT_serverStop) TTCN_error("Using non-selected field serverStop in a value of union type @LibCommon_Sync.SyncCmd.");
return *field_serverStop;
}

boolean SyncCmd::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibCommon_Sync.SyncCmd.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibCommon_Sync.SyncCmd.");
return union_selection == checked_selection;
}

boolean SyncCmd::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SyncCmd::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_clientReady: return field_clientReady->is_value();
case ALT_serverReady: return field_serverReady->is_value();
case ALT_clientStop: return field_clientStop->is_value();
case ALT_serverStop: return field_serverStop->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SyncCmd::clean_up()
{
switch (union_selection) {
case ALT_clientReady:
  delete field_clientReady;
  break;
case ALT_serverReady:
  delete field_serverReady;
  break;
case ALT_clientStop:
  delete field_clientStop;
  break;
case ALT_serverStop:
  delete field_serverStop;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SyncCmd::log() const
{
switch (union_selection) {
case ALT_clientReady:
TTCN_Logger::log_event_str("{ clientReady := ");
field_clientReady->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_serverReady:
TTCN_Logger::log_event_str("{ serverReady := ");
field_serverReady->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_clientStop:
TTCN_Logger::log_event_str("{ clientStop := ");
field_clientStop->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_serverStop:
TTCN_Logger::log_event_str("{ serverStop := ");
field_serverStop->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SyncCmd::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr m_p = &param;
  if (m_p->get_type()==Module_Param::MP_Value_List && m_p->get_size()==0) return;
  if (m_p->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "clientReady")) {
    clientReady().set_param(*mp_last);
    if (!clientReady().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "serverReady")) {
    serverReady().set_param(*mp_last);
    if (!serverReady().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "clientStop")) {
    clientStop().set_param(*mp_last);
    if (!clientStop().is_bound()) clean_up();
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "serverStop")) {
    serverStop().set_param(*mp_last);
    if (!serverStop().is_bound()) clean_up();
    return;
  }
  mp_last->error("Field %s does not exist in type @LibCommon_Sync.SyncCmd.", mp_last->get_id()->get_name());
}

void SyncCmd::set_implicit_omit()
{
switch (union_selection) {
case ALT_clientReady:
field_clientReady->set_implicit_omit(); break;
case ALT_serverReady:
field_serverReady->set_implicit_omit(); break;
case ALT_clientStop:
field_clientStop->set_implicit_omit(); break;
case ALT_serverStop:
field_serverStop->set_implicit_omit(); break;
default: break;
}
}

void SyncCmd::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_clientReady:
field_clientReady->encode_text(text_buf);
break;
case ALT_serverReady:
field_serverReady->encode_text(text_buf);
break;
case ALT_clientStop:
field_clientStop->encode_text(text_buf);
break;
case ALT_serverStop:
field_serverStop->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibCommon_Sync.SyncCmd.");
}
}

void SyncCmd::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_clientReady:
clientReady().decode_text(text_buf);
break;
case ALT_serverReady:
serverReady().decode_text(text_buf);
break;
case ALT_clientStop:
clientStop().decode_text(text_buf);
break;
case ALT_serverStop:
serverStop().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibCommon_Sync.SyncCmd.");
}
}

void SyncCmd_template::copy_value(const SyncCmd& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
single_value.field_clientReady = new ClientReady_template(other_value.clientReady());
break;
case SyncCmd::ALT_serverReady:
single_value.field_serverReady = new ServerReady_template(other_value.serverReady());
break;
case SyncCmd::ALT_clientStop:
single_value.field_clientStop = new ClientStop_template(other_value.clientStop());
break;
case SyncCmd::ALT_serverStop:
single_value.field_serverStop = new ServerStop_template(other_value.serverStop());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibCommon_Sync.SyncCmd.");
}
set_selection(SPECIFIC_VALUE);
}

void SyncCmd_template::copy_template(const SyncCmd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
single_value.field_clientReady = new ClientReady_template(*other_value.single_value.field_clientReady);
break;
case SyncCmd::ALT_serverReady:
single_value.field_serverReady = new ServerReady_template(*other_value.single_value.field_serverReady);
break;
case SyncCmd::ALT_clientStop:
single_value.field_clientStop = new ClientStop_template(*other_value.single_value.field_clientStop);
break;
case SyncCmd::ALT_serverStop:
single_value.field_serverStop = new ServerStop_template(*other_value.single_value.field_serverStop);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibCommon_Sync.SyncCmd.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SyncCmd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibCommon_Sync.SyncCmd.");
}
set_selection(other_value);
}

SyncCmd_template::SyncCmd_template()
{
}

SyncCmd_template::SyncCmd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SyncCmd_template::SyncCmd_template(const SyncCmd& other_value)
{
copy_value(other_value);
}

SyncCmd_template::SyncCmd_template(const OPTIONAL<SyncCmd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SyncCmd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibCommon_Sync.SyncCmd from an unbound optional field.");
}
}

SyncCmd_template::SyncCmd_template(const SyncCmd_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SyncCmd_template::~SyncCmd_template()
{
clean_up();
}

void SyncCmd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
delete single_value.field_clientReady;
break;
case SyncCmd::ALT_serverReady:
delete single_value.field_serverReady;
break;
case SyncCmd::ALT_clientStop:
delete single_value.field_clientStop;
break;
case SyncCmd::ALT_serverStop:
delete single_value.field_serverStop;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SyncCmd_template& SyncCmd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SyncCmd_template& SyncCmd_template::operator=(const SyncCmd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SyncCmd_template& SyncCmd_template::operator=(const OPTIONAL<SyncCmd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SyncCmd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibCommon_Sync.SyncCmd.");
}
return *this;
}

SyncCmd_template& SyncCmd_template::operator=(const SyncCmd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SyncCmd_template::match(const SyncCmd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SyncCmd::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SyncCmd::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SyncCmd::ALT_clientReady:
return single_value.field_clientReady->match(other_value.clientReady(), legacy);
case SyncCmd::ALT_serverReady:
return single_value.field_serverReady->match(other_value.serverReady(), legacy);
case SyncCmd::ALT_clientStop:
return single_value.field_clientStop->match(other_value.clientStop(), legacy);
case SyncCmd::ALT_serverStop:
return single_value.field_serverStop->match(other_value.serverStop(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibCommon_Sync.SyncCmd.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibCommon_Sync.SyncCmd.");
}
return FALSE;
}

boolean SyncCmd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
return single_value.field_clientReady->is_value();
case SyncCmd::ALT_serverReady:
return single_value.field_serverReady->is_value();
case SyncCmd::ALT_clientStop:
return single_value.field_clientStop->is_value();
case SyncCmd::ALT_serverStop:
return single_value.field_serverStop->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibCommon_Sync.SyncCmd.");
}
}

SyncCmd SyncCmd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of union type @LibCommon_Sync.SyncCmd.");
SyncCmd ret_val;
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
ret_val.clientReady() = single_value.field_clientReady->valueof();
break;
case SyncCmd::ALT_serverReady:
ret_val.serverReady() = single_value.field_serverReady->valueof();
break;
case SyncCmd::ALT_clientStop:
ret_val.clientStop() = single_value.field_clientStop->valueof();
break;
case SyncCmd::ALT_serverStop:
ret_val.serverStop() = single_value.field_serverStop->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibCommon_Sync.SyncCmd.");
}
return ret_val;
}

SyncCmd_template& SyncCmd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibCommon_Sync.SyncCmd.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibCommon_Sync.SyncCmd.");
return value_list.list_value[list_index];
}
void SyncCmd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibCommon_Sync.SyncCmd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SyncCmd_template[list_length];
}

ClientReady_template& SyncCmd_template::clientReady()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SyncCmd::ALT_clientReady) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_clientReady = new ClientReady_template(ANY_VALUE);
else single_value.field_clientReady = new ClientReady_template;
single_value.union_selection = SyncCmd::ALT_clientReady;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_clientReady;
}

const ClientReady_template& SyncCmd_template::clientReady() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field clientReady in a non-specific template of union type @LibCommon_Sync.SyncCmd.");
if (single_value.union_selection != SyncCmd::ALT_clientReady) TTCN_error("Accessing non-selected field clientReady in a template of union type @LibCommon_Sync.SyncCmd.");
return *single_value.field_clientReady;
}

ServerReady_template& SyncCmd_template::serverReady()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SyncCmd::ALT_serverReady) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_serverReady = new ServerReady_template(ANY_VALUE);
else single_value.field_serverReady = new ServerReady_template;
single_value.union_selection = SyncCmd::ALT_serverReady;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_serverReady;
}

const ServerReady_template& SyncCmd_template::serverReady() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field serverReady in a non-specific template of union type @LibCommon_Sync.SyncCmd.");
if (single_value.union_selection != SyncCmd::ALT_serverReady) TTCN_error("Accessing non-selected field serverReady in a template of union type @LibCommon_Sync.SyncCmd.");
return *single_value.field_serverReady;
}

ClientStop_template& SyncCmd_template::clientStop()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SyncCmd::ALT_clientStop) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_clientStop = new ClientStop_template(ANY_VALUE);
else single_value.field_clientStop = new ClientStop_template;
single_value.union_selection = SyncCmd::ALT_clientStop;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_clientStop;
}

const ClientStop_template& SyncCmd_template::clientStop() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field clientStop in a non-specific template of union type @LibCommon_Sync.SyncCmd.");
if (single_value.union_selection != SyncCmd::ALT_clientStop) TTCN_error("Accessing non-selected field clientStop in a template of union type @LibCommon_Sync.SyncCmd.");
return *single_value.field_clientStop;
}

ServerStop_template& SyncCmd_template::serverStop()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SyncCmd::ALT_serverStop) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_serverStop = new ServerStop_template(ANY_VALUE);
else single_value.field_serverStop = new ServerStop_template;
single_value.union_selection = SyncCmd::ALT_serverStop;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_serverStop;
}

const ServerStop_template& SyncCmd_template::serverStop() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field serverStop in a non-specific template of union type @LibCommon_Sync.SyncCmd.");
if (single_value.union_selection != SyncCmd::ALT_serverStop) TTCN_error("Accessing non-selected field serverStop in a template of union type @LibCommon_Sync.SyncCmd.");
return *single_value.field_serverStop;
}

boolean SyncCmd_template::ischosen(SyncCmd::union_selection_type checked_selection) const
{
if (checked_selection == SyncCmd::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibCommon_Sync.SyncCmd.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SyncCmd::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibCommon_Sync.SyncCmd.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibCommon_Sync.SyncCmd containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibCommon_Sync.SyncCmd, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibCommon_Sync.SyncCmd");
}
return FALSE;
}

void SyncCmd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
TTCN_Logger::log_event_str("{ clientReady := ");
single_value.field_clientReady->log();
TTCN_Logger::log_event_str(" }");
break;
case SyncCmd::ALT_serverReady:
TTCN_Logger::log_event_str("{ serverReady := ");
single_value.field_serverReady->log();
TTCN_Logger::log_event_str(" }");
break;
case SyncCmd::ALT_clientStop:
TTCN_Logger::log_event_str("{ clientStop := ");
single_value.field_clientStop->log();
TTCN_Logger::log_event_str(" }");
break;
case SyncCmd::ALT_serverStop:
TTCN_Logger::log_event_str("{ serverStop := ");
single_value.field_serverStop->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SyncCmd_template::log_match(const SyncCmd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".clientReady");
single_value.field_clientReady->log_match(match_value.clientReady(), legacy);
} else {
TTCN_Logger::log_event_str("{ clientReady := ");
single_value.field_clientReady->log_match(match_value.clientReady(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SyncCmd::ALT_serverReady:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".serverReady");
single_value.field_serverReady->log_match(match_value.serverReady(), legacy);
} else {
TTCN_Logger::log_event_str("{ serverReady := ");
single_value.field_serverReady->log_match(match_value.serverReady(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SyncCmd::ALT_clientStop:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".clientStop");
single_value.field_clientStop->log_match(match_value.clientStop(), legacy);
} else {
TTCN_Logger::log_event_str("{ clientStop := ");
single_value.field_clientStop->log_match(match_value.clientStop(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SyncCmd::ALT_serverStop:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".serverStop");
single_value.field_serverStop->log_match(match_value.serverStop(), legacy);
} else {
TTCN_Logger::log_event_str("{ serverStop := ");
single_value.field_serverStop->log_match(match_value.serverStop(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SyncCmd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
single_value.field_clientReady->encode_text(text_buf);
break;
case SyncCmd::ALT_serverReady:
single_value.field_serverReady->encode_text(text_buf);
break;
case SyncCmd::ALT_clientStop:
single_value.field_clientStop->encode_text(text_buf);
break;
case SyncCmd::ALT_serverStop:
single_value.field_serverStop->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibCommon_Sync.SyncCmd.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibCommon_Sync.SyncCmd.");
}
}

void SyncCmd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SyncCmd::UNBOUND_VALUE;
SyncCmd::union_selection_type new_selection = (SyncCmd::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SyncCmd::ALT_clientReady:
single_value.field_clientReady = new ClientReady_template;
single_value.field_clientReady->decode_text(text_buf);
break;
case SyncCmd::ALT_serverReady:
single_value.field_serverReady = new ServerReady_template;
single_value.field_serverReady->decode_text(text_buf);
break;
case SyncCmd::ALT_clientStop:
single_value.field_clientStop = new ClientStop_template;
single_value.field_clientStop->decode_text(text_buf);
break;
case SyncCmd::ALT_serverStop:
single_value.field_serverStop = new ServerStop_template;
single_value.field_serverStop->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibCommon_Sync.SyncCmd.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SyncCmd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibCommon_Sync.SyncCmd.");
}
}

boolean SyncCmd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SyncCmd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SyncCmd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibCommon_Sync.SyncCmd'");
    }
    if (strcmp("clientReady", param_field) == 0) {
      clientReady().set_param(param);
      return;
    } else if (strcmp("serverReady", param_field) == 0) {
      serverReady().set_param(param);
      return;
    } else if (strcmp("clientStop", param_field) == 0) {
      clientStop().set_param(param);
      return;
    } else if (strcmp("serverStop", param_field) == 0) {
      serverStop().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibCommon_Sync.SyncCmd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SyncCmd_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (m_p->get_size()==0) break;
    param.type_error("union template", "@LibCommon_Sync.SyncCmd");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = m_p->get_elem(m_p->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "clientReady")) {
      clientReady().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "serverReady")) {
      serverReady().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "clientStop")) {
      clientStop().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "serverStop")) {
      serverStop().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibCommon_Sync.SyncCmd.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibCommon_Sync.SyncCmd");
  }
  is_ifpresent = param.get_ifpresent();
}

void SyncCmd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SyncCmd::ALT_clientReady:
single_value.field_clientReady->check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.SyncCmd");
return;
case SyncCmd::ALT_serverReady:
single_value.field_serverReady->check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.SyncCmd");
return;
case SyncCmd::ALT_clientStop:
single_value.field_clientStop->check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.SyncCmd");
return;
case SyncCmd::ALT_serverStop:
single_value.field_serverStop->check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.SyncCmd");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibCommon_Sync.SyncCmd.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.SyncCmd");
}

ClientReady::ClientReady()
{
}

ClientReady::ClientReady(const CHARSTRING& par_syncPointId)
  :   field_syncPointId(par_syncPointId)
{
}

ClientReady::ClientReady(const ClientReady& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibCommon_Sync.ClientReady.");
if (other_value.syncPointId().is_bound()) field_syncPointId = other_value.syncPointId();
else field_syncPointId.clean_up();
}

void ClientReady::clean_up()
{
field_syncPointId.clean_up();
}

ClientReady& ClientReady::operator=(const ClientReady& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibCommon_Sync.ClientReady.");
  if (other_value.syncPointId().is_bound()) field_syncPointId = other_value.syncPointId();
  else field_syncPointId.clean_up();
}
return *this;
}

boolean ClientReady::operator==(const ClientReady& other_value) const
{
return field_syncPointId==other_value.field_syncPointId;
}

boolean ClientReady::is_bound() const
{
if(field_syncPointId.is_bound()) return TRUE;
return FALSE;
}
boolean ClientReady::is_value() const
{
if(!field_syncPointId.is_value()) return FALSE;
return TRUE;
}
void ClientReady::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ syncPointId := ");
field_syncPointId.log();
TTCN_Logger::log_event_str(" }");
}

void ClientReady::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @LibCommon_Sync.ClientReady has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) syncPointId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "syncPointId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          syncPointId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @LibCommon_Sync.ClientReady: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibCommon_Sync.ClientReady");
  }
}

void ClientReady::set_implicit_omit()
{
if (syncPointId().is_bound()) syncPointId().set_implicit_omit();
}

void ClientReady::encode_text(Text_Buf& text_buf) const
{
field_syncPointId.encode_text(text_buf);
}

void ClientReady::decode_text(Text_Buf& text_buf)
{
field_syncPointId.decode_text(text_buf);
}

struct ClientReady_template::single_value_struct {
CHARSTRING_template field_syncPointId;
};

void ClientReady_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_syncPointId = ANY_VALUE;
}
}
}

void ClientReady_template::copy_value(const ClientReady& other_value)
{
single_value = new single_value_struct;
if (other_value.syncPointId().is_bound()) {
  single_value->field_syncPointId = other_value.syncPointId();
} else {
  single_value->field_syncPointId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ClientReady_template::copy_template(const ClientReady_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.syncPointId().get_selection()) {
single_value->field_syncPointId = other_value.syncPointId();
} else {
single_value->field_syncPointId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ClientReady_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibCommon_Sync.ClientReady.");
break;
}
set_selection(other_value);
}

ClientReady_template::ClientReady_template()
{
}

ClientReady_template::ClientReady_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ClientReady_template::ClientReady_template(const ClientReady& other_value)
{
copy_value(other_value);
}

ClientReady_template::ClientReady_template(const OPTIONAL<ClientReady>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClientReady&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibCommon_Sync.ClientReady from an unbound optional field.");
}
}

ClientReady_template::ClientReady_template(const ClientReady_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ClientReady_template::~ClientReady_template()
{
clean_up();
}

ClientReady_template& ClientReady_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ClientReady_template& ClientReady_template::operator=(const ClientReady& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ClientReady_template& ClientReady_template::operator=(const OPTIONAL<ClientReady>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ClientReady&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibCommon_Sync.ClientReady.");
}
return *this;
}

ClientReady_template& ClientReady_template::operator=(const ClientReady_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ClientReady_template::match(const ClientReady& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.syncPointId().is_bound()) return FALSE;
if(!single_value->field_syncPointId.match(other_value.syncPointId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibCommon_Sync.ClientReady.");
}
return FALSE;
}

boolean ClientReady_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_syncPointId.is_bound()) return TRUE;
return FALSE;
}

boolean ClientReady_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_syncPointId.is_value()) return FALSE;
return TRUE;
}

void ClientReady_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ClientReady ClientReady_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibCommon_Sync.ClientReady.");
ClientReady ret_val;
if (single_value->field_syncPointId.is_bound()) {
ret_val.syncPointId() = single_value->field_syncPointId.valueof();
}
return ret_val;
}

void ClientReady_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibCommon_Sync.ClientReady.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ClientReady_template[list_length];
}

ClientReady_template& ClientReady_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibCommon_Sync.ClientReady.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibCommon_Sync.ClientReady.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ClientReady_template::syncPointId()
{
set_specific();
return single_value->field_syncPointId;
}

const CHARSTRING_template& ClientReady_template::syncPointId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field syncPointId of a non-specific template of type @LibCommon_Sync.ClientReady.");
return single_value->field_syncPointId;
}

int ClientReady_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ClientReady containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibCommon_Sync.ClientReady.");
  }
  return 0;
}

void ClientReady_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ syncPointId := ");
single_value->field_syncPointId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ClientReady_template::log_match(const ClientReady& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_syncPointId.match(match_value.syncPointId(), legacy)){
TTCN_Logger::log_logmatch_info(".syncPointId");
single_value->field_syncPointId.log_match(match_value.syncPointId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ syncPointId := ");
single_value->field_syncPointId.log_match(match_value.syncPointId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ClientReady_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_syncPointId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibCommon_Sync.ClientReady.");
}
}

void ClientReady_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_syncPointId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ClientReady_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibCommon_Sync.ClientReady.");
}
}

void ClientReady_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ClientReady_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @LibCommon_Sync.ClientReady has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) syncPointId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "syncPointId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          syncPointId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @LibCommon_Sync.ClientReady: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibCommon_Sync.ClientReady");
  }
  is_ifpresent = param.get_ifpresent();
}

void ClientReady_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_syncPointId.check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.ClientReady");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.ClientReady");
}

boolean ClientReady_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ClientReady_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ServerReady::ServerReady()
{
}

ServerReady::ServerReady(const CHARSTRING& par_syncPointId)
  :   field_syncPointId(par_syncPointId)
{
}

ServerReady::ServerReady(const ServerReady& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibCommon_Sync.ServerReady.");
if (other_value.syncPointId().is_bound()) field_syncPointId = other_value.syncPointId();
else field_syncPointId.clean_up();
}

void ServerReady::clean_up()
{
field_syncPointId.clean_up();
}

ServerReady& ServerReady::operator=(const ServerReady& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibCommon_Sync.ServerReady.");
  if (other_value.syncPointId().is_bound()) field_syncPointId = other_value.syncPointId();
  else field_syncPointId.clean_up();
}
return *this;
}

boolean ServerReady::operator==(const ServerReady& other_value) const
{
return field_syncPointId==other_value.field_syncPointId;
}

boolean ServerReady::is_bound() const
{
if(field_syncPointId.is_bound()) return TRUE;
return FALSE;
}
boolean ServerReady::is_value() const
{
if(!field_syncPointId.is_value()) return FALSE;
return TRUE;
}
void ServerReady::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ syncPointId := ");
field_syncPointId.log();
TTCN_Logger::log_event_str(" }");
}

void ServerReady::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "record value");
  switch (param.get_type()) {
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record value of type @LibCommon_Sync.ServerReady has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) syncPointId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "syncPointId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          syncPointId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @LibCommon_Sync.ServerReady: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibCommon_Sync.ServerReady");
  }
}

void ServerReady::set_implicit_omit()
{
if (syncPointId().is_bound()) syncPointId().set_implicit_omit();
}

void ServerReady::encode_text(Text_Buf& text_buf) const
{
field_syncPointId.encode_text(text_buf);
}

void ServerReady::decode_text(Text_Buf& text_buf)
{
field_syncPointId.decode_text(text_buf);
}

struct ServerReady_template::single_value_struct {
CHARSTRING_template field_syncPointId;
};

void ServerReady_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_syncPointId = ANY_VALUE;
}
}
}

void ServerReady_template::copy_value(const ServerReady& other_value)
{
single_value = new single_value_struct;
if (other_value.syncPointId().is_bound()) {
  single_value->field_syncPointId = other_value.syncPointId();
} else {
  single_value->field_syncPointId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ServerReady_template::copy_template(const ServerReady_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.syncPointId().get_selection()) {
single_value->field_syncPointId = other_value.syncPointId();
} else {
single_value->field_syncPointId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ServerReady_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibCommon_Sync.ServerReady.");
break;
}
set_selection(other_value);
}

ServerReady_template::ServerReady_template()
{
}

ServerReady_template::ServerReady_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ServerReady_template::ServerReady_template(const ServerReady& other_value)
{
copy_value(other_value);
}

ServerReady_template::ServerReady_template(const OPTIONAL<ServerReady>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServerReady&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibCommon_Sync.ServerReady from an unbound optional field.");
}
}

ServerReady_template::ServerReady_template(const ServerReady_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ServerReady_template::~ServerReady_template()
{
clean_up();
}

ServerReady_template& ServerReady_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ServerReady_template& ServerReady_template::operator=(const ServerReady& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ServerReady_template& ServerReady_template::operator=(const OPTIONAL<ServerReady>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServerReady&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibCommon_Sync.ServerReady.");
}
return *this;
}

ServerReady_template& ServerReady_template::operator=(const ServerReady_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ServerReady_template::match(const ServerReady& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.syncPointId().is_bound()) return FALSE;
if(!single_value->field_syncPointId.match(other_value.syncPointId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibCommon_Sync.ServerReady.");
}
return FALSE;
}

boolean ServerReady_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_syncPointId.is_bound()) return TRUE;
return FALSE;
}

boolean ServerReady_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_syncPointId.is_value()) return FALSE;
return TRUE;
}

void ServerReady_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ServerReady ServerReady_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibCommon_Sync.ServerReady.");
ServerReady ret_val;
if (single_value->field_syncPointId.is_bound()) {
ret_val.syncPointId() = single_value->field_syncPointId.valueof();
}
return ret_val;
}

void ServerReady_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibCommon_Sync.ServerReady.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ServerReady_template[list_length];
}

ServerReady_template& ServerReady_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibCommon_Sync.ServerReady.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibCommon_Sync.ServerReady.");
return value_list.list_value[list_index];
}

CHARSTRING_template& ServerReady_template::syncPointId()
{
set_specific();
return single_value->field_syncPointId;
}

const CHARSTRING_template& ServerReady_template::syncPointId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field syncPointId of a non-specific template of type @LibCommon_Sync.ServerReady.");
return single_value->field_syncPointId;
}

int ServerReady_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibCommon_Sync.ServerReady containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibCommon_Sync.ServerReady.");
  }
  return 0;
}

void ServerReady_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ syncPointId := ");
single_value->field_syncPointId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ServerReady_template::log_match(const ServerReady& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_syncPointId.match(match_value.syncPointId(), legacy)){
TTCN_Logger::log_logmatch_info(".syncPointId");
single_value->field_syncPointId.log_match(match_value.syncPointId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ syncPointId := ");
single_value->field_syncPointId.log_match(match_value.syncPointId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ServerReady_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_syncPointId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibCommon_Sync.ServerReady.");
}
}

void ServerReady_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_syncPointId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ServerReady_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibCommon_Sync.ServerReady.");
}
}

void ServerReady_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ServerReady_template new_temp;
    new_temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<param.get_size()) {
      param.error("record template of type @LibCommon_Sync.ServerReady has 1 fields but list value has %d fields", (int)param.get_size());
    }
    if (param.get_size()>0 && param.get_elem(0)->get_type()!=Module_Param::MP_NotUsed) syncPointId().set_param(*param.get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(param.get_size());
    value_used.resize(param.get_size(), FALSE);
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) {
      Module_Param* const curr_param = param.get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "syncPointId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          syncPointId().set_param(*curr_param);
        }
        value_used[val_idx]=TRUE;
      }
    }
    for (size_t val_idx=0; val_idx<param.get_size(); val_idx++) if (!value_used[val_idx]) {
      param.get_elem(val_idx)->error("Non existent field name in type @LibCommon_Sync.ServerReady: %s", param.get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibCommon_Sync.ServerReady");
  }
  is_ifpresent = param.get_ifpresent();
}

void ServerReady_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_syncPointId.check_restriction(t_res, t_name ? t_name : "@LibCommon_Sync.ServerReady");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.ServerReady");
}

boolean ServerReady_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ServerReady_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ClientStop::ClientStop()
{
bound_flag = FALSE;
}

ClientStop::ClientStop(null_type)
{
bound_flag = TRUE;
}

ClientStop::ClientStop(const ClientStop& other_value)
{
other_value.must_bound("Copying an unbound value of type @LibCommon_Sync.ClientStop.");
bound_flag = TRUE;
}

ClientStop& ClientStop::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

ClientStop& ClientStop::operator=(const ClientStop& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibCommon_Sync.ClientStop.");
bound_flag = TRUE;
return *this;
}

boolean ClientStop::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @LibCommon_Sync.ClientStop.");
return TRUE;
}

boolean ClientStop::operator==(const ClientStop& other_value) const
{
must_bound("Comparison of an unbound value of type @LibCommon_Sync.ClientStop.");
other_value.must_bound("Comparison of an unbound value of type @LibCommon_Sync.ClientStop.");
return TRUE;
}

void ClientStop::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void ClientStop::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@LibCommon_Sync.ClientStop");
  }
  bound_flag = TRUE;
}

void ClientStop::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @LibCommon_Sync.ClientStop.");
}

void ClientStop::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void ClientStop_template::copy_template(const ClientStop_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ClientStop_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibCommon_Sync.ClientStop.");
break;
}
}

ClientStop_template::ClientStop_template()
{
}

ClientStop_template::ClientStop_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ClientStop_template::ClientStop_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

ClientStop_template::ClientStop_template(const ClientStop& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @LibCommon_Sync.ClientStop.");
}

ClientStop_template::ClientStop_template(const OPTIONAL<ClientStop>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibCommon_Sync.ClientStop from an unbound optional field.");
}
}

ClientStop_template::ClientStop_template(const ClientStop_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ClientStop_template::~ClientStop_template()
{
clean_up();
}

void ClientStop_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ClientStop_template& ClientStop_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ClientStop_template& ClientStop_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ClientStop_template& ClientStop_template::operator=(const ClientStop& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibCommon_Sync.ClientStop to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ClientStop_template& ClientStop_template::operator=(const OPTIONAL<ClientStop>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibCommon_Sync.ClientStop.");
}
return *this;
}

ClientStop_template& ClientStop_template::operator=(const ClientStop_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean ClientStop_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibCommon_Sync.ClientStop.");
}
return FALSE;
}

boolean ClientStop_template::match(const ClientStop& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

ClientStop ClientStop_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibCommon_Sync.ClientStop.");
return NULL_VALUE;
}

void ClientStop_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibCommon_Sync.ClientStop.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ClientStop_template[list_length];
}

ClientStop_template& ClientStop_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibCommon_Sync.ClientStop.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibCommon_Sync.ClientStop.");
return value_list.list_value[list_index];
}

void ClientStop_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ClientStop_template::log_match(const ClientStop& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ClientStop_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibCommon_Sync.ClientStop.");
}
}

void ClientStop_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ClientStop_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibCommon_Sync.ClientStop.");
}
}

void ClientStop_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ClientStop_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@LibCommon_Sync.ClientStop");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@LibCommon_Sync.ClientStop");
  }
  is_ifpresent = param.get_ifpresent();
}

void ClientStop_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.ClientStop");
}

boolean ClientStop_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ClientStop_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ServerStop::ServerStop()
{
bound_flag = FALSE;
}

ServerStop::ServerStop(null_type)
{
bound_flag = TRUE;
}

ServerStop::ServerStop(const ServerStop& other_value)
{
other_value.must_bound("Copying an unbound value of type @LibCommon_Sync.ServerStop.");
bound_flag = TRUE;
}

ServerStop& ServerStop::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

ServerStop& ServerStop::operator=(const ServerStop& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibCommon_Sync.ServerStop.");
bound_flag = TRUE;
return *this;
}

boolean ServerStop::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @LibCommon_Sync.ServerStop.");
return TRUE;
}

boolean ServerStop::operator==(const ServerStop& other_value) const
{
must_bound("Comparison of an unbound value of type @LibCommon_Sync.ServerStop.");
other_value.must_bound("Comparison of an unbound value of type @LibCommon_Sync.ServerStop.");
return TRUE;
}

void ServerStop::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void ServerStop::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  if (param.get_type()!=Module_Param::MP_Value_List || param.get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@LibCommon_Sync.ServerStop");
  }
  bound_flag = TRUE;
}

void ServerStop::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @LibCommon_Sync.ServerStop.");
}

void ServerStop::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void ServerStop_template::copy_template(const ServerStop_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ServerStop_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibCommon_Sync.ServerStop.");
break;
}
}

ServerStop_template::ServerStop_template()
{
}

ServerStop_template::ServerStop_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ServerStop_template::ServerStop_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

ServerStop_template::ServerStop_template(const ServerStop& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @LibCommon_Sync.ServerStop.");
}

ServerStop_template::ServerStop_template(const OPTIONAL<ServerStop>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibCommon_Sync.ServerStop from an unbound optional field.");
}
}

ServerStop_template::ServerStop_template(const ServerStop_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ServerStop_template::~ServerStop_template()
{
clean_up();
}

void ServerStop_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ServerStop_template& ServerStop_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ServerStop_template& ServerStop_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ServerStop_template& ServerStop_template::operator=(const ServerStop& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibCommon_Sync.ServerStop to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

ServerStop_template& ServerStop_template::operator=(const OPTIONAL<ServerStop>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibCommon_Sync.ServerStop.");
}
return *this;
}

ServerStop_template& ServerStop_template::operator=(const ServerStop_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean ServerStop_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibCommon_Sync.ServerStop.");
}
return FALSE;
}

boolean ServerStop_template::match(const ServerStop& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

ServerStop ServerStop_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibCommon_Sync.ServerStop.");
return NULL_VALUE;
}

void ServerStop_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibCommon_Sync.ServerStop.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ServerStop_template[list_length];
}

ServerStop_template& ServerStop_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibCommon_Sync.ServerStop.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibCommon_Sync.ServerStop.");
return value_list.list_value[list_index];
}

void ServerStop_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ServerStop_template::log_match(const ServerStop& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ServerStop_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibCommon_Sync.ServerStop.");
}
}

void ServerStop_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ServerStop_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibCommon_Sync.ServerStop.");
}
}

void ServerStop_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  switch (param.get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ServerStop_template temp;
    temp.set_type(param.get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, param.get_size());
    for (size_t p_i=0; p_i<param.get_size(); p_i++) {
      temp.list_item(p_i).set_param(*param.get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (param.get_size()>0) param.type_error("empty record/set template", "@LibCommon_Sync.ServerStop");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@LibCommon_Sync.ServerStop");
  }
  is_ifpresent = param.get_ifpresent();
}

void ServerStop_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibCommon_Sync.ServerStop");
}

boolean ServerStop_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ServerStop_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

void f__connect4SelfOrClientSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 194, TTCN_Location::LOCATION_FUNCTION, "f_connect4SelfOrClientSync");
current_location.update_lineno(196);
/* LibCommon_Sync.ttcn, line 196 */
if ((self == MTC_COMPREF)) {
current_location.update_lineno(197);
/* LibCommon_Sync.ttcn, line 197 */
f__connect4SelfSync();
}
else {
current_location.update_lineno(199);
/* LibCommon_Sync.ttcn, line 199 */
f__connect4ClientSync();
}
}

void start_f__connect4SelfOrClientSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_connect4SelfOrClientSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_connect4SelfOrClientSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__disconnect4SelfOrClientSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 216, TTCN_Location::LOCATION_FUNCTION, "f_disconnect4SelfOrClientSync");
current_location.update_lineno(218);
/* LibCommon_Sync.ttcn, line 218 */
if ((self == MTC_COMPREF)) {
current_location.update_lineno(219);
/* LibCommon_Sync.ttcn, line 219 */
f__disconnect4SelfSync();
}
else {
current_location.update_lineno(221);
/* LibCommon_Sync.ttcn, line 221 */
f__disconnect4ClientSync();
}
}

void start_f__disconnect4SelfOrClientSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_disconnect4SelfOrClientSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_disconnect4SelfOrClientSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSync2ClientsAndStop(const SyncPointList& p__syncPointIds)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 249, TTCN_Location::LOCATION_FUNCTION, "f_serverSync2ClientsAndStop");
current_location.update_lineno(251);
/* LibCommon_Sync.ttcn, line 251 */
f__serverSyncNClientsAndStop(2, p__syncPointIds);
}

void start_f__serverSync2ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync2ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSync2ClientsAndStop", text_buf);
p__syncPointIds.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSync3ClientsAndStop(const SyncPointList& p__syncPointIds)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 274, TTCN_Location::LOCATION_FUNCTION, "f_serverSync3ClientsAndStop");
current_location.update_lineno(276);
/* LibCommon_Sync.ttcn, line 276 */
f__serverSyncNClientsAndStop(3, p__syncPointIds);
}

void start_f__serverSync3ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync3ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSync3ClientsAndStop", text_buf);
p__syncPointIds.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSync4ClientsAndStop(const SyncPointList& p__syncPointIds)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 299, TTCN_Location::LOCATION_FUNCTION, "f_serverSync4ClientsAndStop");
current_location.update_lineno(301);
/* LibCommon_Sync.ttcn, line 301 */
f__serverSyncNClientsAndStop(4, p__syncPointIds);
}

void start_f__serverSync4ClientsAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync4ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSync4ClientsAndStop", text_buf);
p__syncPointIds.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSyncNClientsAndStop(const INTEGER& p__numClients, const SyncPointList& p__syncPointIds)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 325, TTCN_Location::LOCATION_FUNCTION, "f_serverSyncNClientsAndStop");
current_location.update_lineno(329);
/* LibCommon_Sync.ttcn, line 329 */
INTEGER i;
current_location.update_lineno(329);
/* LibCommon_Sync.ttcn, line 329 */
INTEGER v__noOfSyncIds(p__syncPointIds.size_of());
current_location.update_lineno(330);
/* LibCommon_Sync.ttcn, line 330 */
i = 0;
current_location.update_lineno(330);
/* LibCommon_Sync.ttcn, line 330 */
for ( ; ; ) {
current_location.update_lineno(330);
/* LibCommon_Sync.ttcn, line 330 */
if (!(i < v__noOfSyncIds)) break;
current_location.update_lineno(331);
/* LibCommon_Sync.ttcn, line 331 */
f__serverSyncClientsTimed(p__numClients, const_cast< const SyncPointList&>(p__syncPointIds)[i], PX__TSYNC__TIME__LIMIT);
current_location.update_lineno(330);
/* LibCommon_Sync.ttcn, line 330 */
{
INTEGER tmp_1;
++i;
}
}
current_location.update_lineno(336);
/* LibCommon_Sync.ttcn, line 336 */
f__serverWaitForAllClientsToStop();
}

void start_f__serverSyncNClientsAndStop(const COMPONENT& component_reference, const INTEGER& p__numClients, const SyncPointList& p__syncPointIds)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncNClientsAndStop(");
p__numClients.log();
TTCN_Logger::log_event_str(", ");
p__syncPointIds.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSyncNClientsAndStop", text_buf);
p__numClients.encode_text(text_buf);
p__syncPointIds.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSync2ClientsUtAndStop(const SyncPointList& p__syncPointIds)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 359, TTCN_Location::LOCATION_FUNCTION, "f_serverSync2ClientsUtAndStop");
current_location.update_lineno(361);
/* LibCommon_Sync.ttcn, line 361 */
INTEGER i;
current_location.update_lineno(361);
/* LibCommon_Sync.ttcn, line 361 */
INTEGER v__noOfSyncIds(p__syncPointIds.size_of());
current_location.update_lineno(362);
/* LibCommon_Sync.ttcn, line 362 */
i = 0;
current_location.update_lineno(362);
/* LibCommon_Sync.ttcn, line 362 */
for ( ; ; ) {
current_location.update_lineno(362);
/* LibCommon_Sync.ttcn, line 362 */
if (!(i < v__noOfSyncIds)) break;
current_location.update_lineno(363);
/* LibCommon_Sync.ttcn, line 363 */
f__serverSyncClientsTimed(3, const_cast< const SyncPointList&>(p__syncPointIds)[i], PX__TSYNC__TIME__LIMIT);
current_location.update_lineno(362);
/* LibCommon_Sync.ttcn, line 362 */
{
INTEGER tmp_3;
++i;
}
}
current_location.update_lineno(365);
/* LibCommon_Sync.ttcn, line 365 */
f__serverWaitForAllClientsToStop();
}

void start_f__serverSync2ClientsUtAndStop(const COMPONENT& component_reference, const SyncPointList& p__syncPointIds)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync2ClientsUtAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSync2ClientsUtAndStop", text_buf);
p__syncPointIds.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfOrClientSyncAndVerdict(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 385, TTCN_Location::LOCATION_FUNCTION, "f_selfOrClientSyncAndVerdict");
current_location.update_lineno(388);
/* LibCommon_Sync.ttcn, line 388 */
if ((self == MTC_COMPREF)) {
current_location.update_lineno(390);
/* LibCommon_Sync.ttcn, line 390 */
f__selfSyncAndVerdict(p__syncPoint, p__ret);
}
else {
current_location.update_lineno(392);
/* LibCommon_Sync.ttcn, line 392 */
f__clientSyncAndVerdict(p__syncPoint, p__ret);
}
}

void start_f__selfOrClientSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdict(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfOrClientSyncAndVerdict", text_buf);
p__syncPoint.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfOrClientSyncAndVerdictPreamble(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 414, TTCN_Location::LOCATION_FUNCTION, "f_selfOrClientSyncAndVerdictPreamble");
current_location.update_lineno(417);
/* LibCommon_Sync.ttcn, line 417 */
if ((self == MTC_COMPREF)) {
current_location.update_lineno(419);
/* LibCommon_Sync.ttcn, line 419 */
f__selfSyncAndVerdictPreamble(p__syncPoint, p__ret);
}
else {
current_location.update_lineno(421);
/* LibCommon_Sync.ttcn, line 421 */
f__clientSyncAndVerdictPreamble(p__syncPoint, p__ret);
}
}

void start_f__selfOrClientSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictPreamble(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfOrClientSyncAndVerdictPreamble", text_buf);
p__syncPoint.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfOrClientSyncAndVerdictTestBody(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 443, TTCN_Location::LOCATION_FUNCTION, "f_selfOrClientSyncAndVerdictTestBody");
current_location.update_lineno(446);
/* LibCommon_Sync.ttcn, line 446 */
if ((self == MTC_COMPREF)) {
current_location.update_lineno(448);
/* LibCommon_Sync.ttcn, line 448 */
f__selfSyncAndVerdictTestBody(p__syncPoint, p__ret);
}
else {
current_location.update_lineno(450);
/* LibCommon_Sync.ttcn, line 450 */
f__clientSyncAndVerdictTestBody(p__syncPoint, p__ret);
}
}

void start_f__selfOrClientSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictTestBody(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfOrClientSyncAndVerdictTestBody", text_buf);
p__syncPoint.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfOrClientSyncAndVerdictPR(const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 459, TTCN_Location::LOCATION_FUNCTION, "f_selfOrClientSyncAndVerdictPR");
current_location.update_lineno(462);
/* LibCommon_Sync.ttcn, line 462 */
f__selfOrClientSyncAndVerdictPreamble(p__syncPoint, p__ret);
}

void start_f__selfOrClientSyncAndVerdictPR(const COMPONENT& component_reference, const CHARSTRING& p__syncPoint, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictPR(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfOrClientSyncAndVerdictPR", text_buf);
p__syncPoint.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__addSyncCompState(const CHARSTRING& p__newSyncCompState, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 488, TTCN_Location::LOCATION_FUNCTION, "f_addSyncCompState");
current_location.update_lineno(491);
/* LibCommon_Sync.ttcn, line 491 */
if ((p__ret == LibCommon__VerdictControl::FncRetCode::e__success)) {
current_location.update_lineno(492);
/* LibCommon_Sync.ttcn, line 492 */
if (LibCommon__AbstractData::f__isItemOnStringStack(ClientSyncComp_component_v__stateStack, p__newSyncCompState)) {
current_location.update_lineno(493);
/* LibCommon_Sync.ttcn, line 493 */
TTCN_Logger::log_str(TTCN_USER, "**** f_addSyncCompState: WARNING: Attempt to add state which is already on sync state stack! No additition done.****");
}
else {
current_location.update_lineno(495);
/* LibCommon_Sync.ttcn, line 495 */
LibCommon__AbstractData::f__pushStringStack(ClientSyncComp_component_v__stateStack, p__newSyncCompState);
}
}
}

void start_f__addSyncCompState(const COMPONENT& component_reference, const CHARSTRING& p__newSyncCompState, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_addSyncCompState(");
p__newSyncCompState.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_addSyncCompState", text_buf);
p__newSyncCompState.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

BOOLEAN f__getTopSyncCompState(CHARSTRING& p__state)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 512, TTCN_Location::LOCATION_FUNCTION, "f_getTopSyncCompState");
p__state.clean_up();
current_location.update_lineno(515);
/* LibCommon_Sync.ttcn, line 515 */
if ((!(LibCommon__AbstractData::f__peekStringStackTop(ClientSyncComp_component_v__stateStack, p__state)))) {
current_location.update_lineno(516);
/* LibCommon_Sync.ttcn, line 516 */
p__state = cs_4;
current_location.update_lineno(517);
/* LibCommon_Sync.ttcn, line 517 */
return FALSE;
}
current_location.update_lineno(519);
/* LibCommon_Sync.ttcn, line 519 */
LibCommon__AbstractData::f__popStringStack(ClientSyncComp_component_v__stateStack);
current_location.update_lineno(520);
/* LibCommon_Sync.ttcn, line 520 */
return TRUE;
}

void f__popSyncCompState()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 530, TTCN_Location::LOCATION_FUNCTION, "f_popSyncCompState");
current_location.update_lineno(532);
/* LibCommon_Sync.ttcn, line 532 */
LibCommon__AbstractData::f__popStringStack(ClientSyncComp_component_v__stateStack);
}

void start_f__popSyncCompState(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_popSyncCompState(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_popSyncCompState", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

BOOLEAN f__peekTopSyncCompState(CHARSTRING& p__state)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 546, TTCN_Location::LOCATION_FUNCTION, "f_peekTopSyncCompState");
p__state.clean_up();
current_location.update_lineno(549);
/* LibCommon_Sync.ttcn, line 549 */
return LibCommon__AbstractData::f__peekStringStackTop(ClientSyncComp_component_v__stateStack, p__state);
}

BOOLEAN f__isSyncCompStateStackEmpty()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 559, TTCN_Location::LOCATION_FUNCTION, "f_isSyncCompStateStackEmpty");
current_location.update_lineno(562);
/* LibCommon_Sync.ttcn, line 562 */
return LibCommon__AbstractData::f__isStringStackEmpty(ClientSyncComp_component_v__stateStack);
}

void start_f__isSyncCompStateStackEmpty(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_isSyncCompStateStackEmpty(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_isSyncCompStateStackEmpty", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

alt_status a__dummyShutDown_instance()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 602, TTCN_Location::LOCATION_ALTSTEP, "a_dummyShutDown");
alt_status ret_val = ALT_NO;
current_location.update_lineno(604);
/* LibCommon_Sync.ttcn, line 604 */
switch (BaseSyncComp_component_syncPort.receive(m__syncServerStop, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
current_location.update_lineno(605);
/* LibCommon_Sync.ttcn, line 605 */
CHARSTRING v__state(cs_5);
current_location.update_lineno(606);
/* LibCommon_Sync.ttcn, line 606 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(607);
/* LibCommon_Sync.ttcn, line 607 */
TTCN_Logger::log_str(TTCN_USER, "**** a_dummyShutDown: Test component received STOP signal from sync server - going to IDLE state ****");
for ( ; ; ) {
current_location.update_lineno(608);
/* LibCommon_Sync.ttcn, line 608 */
if (!f__getTopSyncCompState(v__state)) break;
current_location.update_lineno(609);
/* LibCommon_Sync.ttcn, line 609 */
if ((v__state == cs_6)) {
}
else {
current_location.update_lineno(611);
/* LibCommon_Sync.ttcn, line 611 */
if ((v__state == cs_7)) {
}
}
}
current_location.update_lineno(615);
/* LibCommon_Sync.ttcn, line 615 */
f__disconnect4SelfOrClientSync();
current_location.update_lineno(617);
/* LibCommon_Sync.ttcn, line 617 */
TTCN_Logger::log_str(TTCN_USER, "**** a_dummyShutDown: -> Test component stopping itself now! ****");
current_location.update_lineno(618);
/* LibCommon_Sync.ttcn, line 618 */
TTCN_Runtime::stop_execution();
}
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void a__dummyShutDown()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = a__dummyShutDown_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep a_dummyShutDown.");
else block_flag = TRUE;
}
}

Default_Base *activate_a__dummyShutDown()
{
return new a__dummyShutDown_Default();
}

alt_status a__shutdown_instance()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 627, TTCN_Location::LOCATION_ALTSTEP, "a_shutdown");
alt_status ret_val = ALT_NO;
current_location.update_lineno(629);
/* LibCommon_Sync.ttcn, line 629 */
switch (BaseSyncComp_component_syncPort.receive(m__syncServerStop, NULL, any_compref, NULL, NULL)) {
case ALT_YES:
{
current_location.update_lineno(630);
/* LibCommon_Sync.ttcn, line 630 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(631);
/* LibCommon_Sync.ttcn, line 631 */
TTCN_Logger::log_str(TTCN_USER, "**** a_shutdown: Test component received STOP signal from MTC **** ");
}
return ALT_YES;
case ALT_MAYBE:
ret_val = ALT_MAYBE;
default:
break;
}
return ret_val;
}

void a__shutdown()
{
altstep_begin:
boolean block_flag = FALSE;
alt_status altstep_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
for ( ; ; ) {
TTCN_Snapshot::take_new(block_flag);
if (altstep_flag != ALT_NO) {
altstep_flag = a__shutdown_instance();
if (altstep_flag == ALT_YES || altstep_flag == ALT_BREAK) return;
else if (altstep_flag == ALT_REPEAT) goto altstep_begin;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) return;
else if (default_flag == ALT_REPEAT) goto altstep_begin;
}
if (altstep_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in altstep a_shutdown.");
else block_flag = TRUE;
}
}

Default_Base *activate_a__shutdown()
{
return new a__shutdown_Default();
}

void f__serverSyncClients(const INTEGER& p__noOfClients, const CHARSTRING& p__syncId)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 659, TTCN_Location::LOCATION_FUNCTION, "f_serverSyncClients");
current_location.update_lineno(661);
/* LibCommon_Sync.ttcn, line 661 */
f__serverSyncClientsTimed(p__noOfClients, p__syncId, PX__TSYNC__TIME__LIMIT);
}

void start_f__serverSyncClients(const COMPONENT& component_reference, const INTEGER& p__noOfClients, const CHARSTRING& p__syncId)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClients(");
p__noOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSyncClients", text_buf);
p__noOfClients.encode_text(text_buf);
p__syncId.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSyncClientsIntermediateSync(const INTEGER& p__noOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 681, TTCN_Location::LOCATION_FUNCTION, "f_serverSyncClientsIntermediateSync");
current_location.update_lineno(683);
/* LibCommon_Sync.ttcn, line 683 */
f__serverSyncClientsTimedIntermediateSync(p__noOfClients, p__syncId, p__NoOfClientIntermediate, p__syncIdIntermediate, PX__TSYNC__TIME__LIMIT);
}

void start_f__serverSyncClientsIntermediateSync(const COMPONENT& component_reference, const INTEGER& p__noOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsIntermediateSync(");
p__noOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__NoOfClientIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__syncIdIntermediate.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSyncClientsIntermediateSync", text_buf);
p__noOfClients.encode_text(text_buf);
p__syncId.encode_text(text_buf);
p__NoOfClientIntermediate.encode_text(text_buf);
p__syncIdIntermediate.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSyncClientsTimed(const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const FLOAT& p__execTimeLimit)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 698, TTCN_Location::LOCATION_FUNCTION, "f_serverSyncClientsTimed");
current_location.update_lineno(702);
/* LibCommon_Sync.ttcn, line 702 */
f__serverSyncClientsTimedIntermediateSync(p__NoOfClients, p__syncId, 0, CHARSTRING_template(ANY_VALUE), p__execTimeLimit);
}

void start_f__serverSyncClientsTimed(const COMPONENT& component_reference, const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const FLOAT& p__execTimeLimit)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsTimed(");
p__NoOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__execTimeLimit.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSyncClientsTimed", text_buf);
p__NoOfClients.encode_text(text_buf);
p__syncId.encode_text(text_buf);
p__execTimeLimit.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverSyncClientsTimedIntermediateSync(const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate, const FLOAT& p__execTimeLimit)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 718, TTCN_Location::LOCATION_FUNCTION, "f_serverSyncClientsTimedIntermediateSync");
current_location.update_lineno(723);
/* LibCommon_Sync.ttcn, line 723 */
INTEGER v__noOfRecvdSyncMsgs(0);
current_location.update_lineno(723);
/* LibCommon_Sync.ttcn, line 723 */
INTEGER v__noOfRecvdSyncMsgsIntermediate(0);
current_location.update_lineno(724);
/* LibCommon_Sync.ttcn, line 724 */
BOOLEAN v__stopClients(FALSE);
current_location.update_lineno(725);
/* LibCommon_Sync.ttcn, line 725 */
ClientSyncCompList v__clientRefs(NULL_VALUE);
current_location.update_lineno(725);
/* LibCommon_Sync.ttcn, line 725 */
ClientSyncCompList v__clientRefsIntermediate(NULL_VALUE);
current_location.update_lineno(726);
/* LibCommon_Sync.ttcn, line 726 */
COMPONENT v__clientRef;
current_location.update_lineno(728);
/* LibCommon_Sync.ttcn, line 728 */
if ((p__syncId == cs_0)) {
current_location.update_lineno(729);
/* LibCommon_Sync.ttcn, line 729 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server now starting PREAMBLE synchronization ... ****");
}
else {
current_location.update_lineno(730);
/* LibCommon_Sync.ttcn, line 730 */
if ((p__syncId == cs_2)) {
current_location.update_lineno(731);
/* LibCommon_Sync.ttcn, line 731 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server now starting TEST BODY synchronization ... ****");
}
else {
current_location.update_lineno(732);
/* LibCommon_Sync.ttcn, line 732 */
if ((p__syncId == cs_3)) {
current_location.update_lineno(733);
/* LibCommon_Sync.ttcn, line 733 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server now starting UPPER TESTER synchronization ... ****");
}
else {
current_location.update_lineno(735);
/* LibCommon_Sync.ttcn, line 735 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server now starting handling of next synchronization point ... ****");
}
}
}
current_location.update_lineno(737);
/* LibCommon_Sync.ttcn, line 737 */
BaseSyncComp_component_tc__sync.start(p__execTimeLimit);
current_location.update_lineno(738);
/* LibCommon_Sync.ttcn, line 738 */
{
tmp_5:
alt_status tmp_5_alt_flag_0 = ALT_UNCHECKED;
alt_status tmp_5_alt_flag_1 = ALT_MAYBE;
alt_status tmp_5_alt_flag_2 = ALT_MAYBE;
alt_status tmp_5_alt_flag_3 = ALT_MAYBE;
alt_status tmp_5_alt_flag_4 = ALT_MAYBE;
alt_status tmp_5_alt_flag_5 = ALT_MAYBE;
alt_status tmp_5_alt_flag_6 = ALT_MAYBE;
alt_status tmp_5_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_5_alt_flag_0 == ALT_UNCHECKED) {
current_location.update_lineno(739);
/* LibCommon_Sync.ttcn, line 739 */
if ((v__noOfRecvdSyncMsgsIntermediate != p__NoOfClientIntermediate)) tmp_5_alt_flag_0 = ALT_MAYBE;
else tmp_5_alt_flag_0 = ALT_NO;
}
if (tmp_5_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(739);
/* LibCommon_Sync.ttcn, line 739 */
tmp_5_alt_flag_0 = BaseSyncComp_component_syncPort.receive(m__syncClientReady(p__syncIdIntermediate), NULL, any_compref, &(v__clientRef), NULL);
if (tmp_5_alt_flag_0 == ALT_YES) {
current_location.update_lineno(740);
/* LibCommon_Sync.ttcn, line 740 */
if ((!(f__isPresentInArray(v__clientRef, v__clientRefsIntermediate)))) {
current_location.update_lineno(741);
/* LibCommon_Sync.ttcn, line 741 */
v__clientRefsIntermediate[v__noOfRecvdSyncMsgsIntermediate] = v__clientRef;
current_location.update_lineno(742);
/* LibCommon_Sync.ttcn, line 742 */
{
INTEGER tmp_7;
++v__noOfRecvdSyncMsgsIntermediate;
}
current_location.update_lineno(743);
/* LibCommon_Sync.ttcn, line 743 */
if ((v__noOfRecvdSyncMsgsIntermediate == p__NoOfClientIntermediate)) {
current_location.update_lineno(744);
/* LibCommon_Sync.ttcn, line 744 */
{
SyncCmd_template tmp_8;
tmp_8 = m__syncServerReady(p__syncIdIntermediate);
tmp_8.check_restriction(TR_VALUE);
f__serverSendToAllClients(v__clientRefsIntermediate, tmp_8);
}
}
}
current_location.update_lineno(747);
/* LibCommon_Sync.ttcn, line 747 */
goto tmp_5;
}
}
if (tmp_5_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(749);
/* LibCommon_Sync.ttcn, line 749 */
tmp_5_alt_flag_1 = BaseSyncComp_component_syncPort.receive(m__syncClientReady(CHARSTRING_template(p__syncId)), NULL, any_compref, &(v__clientRef), NULL);
if (tmp_5_alt_flag_1 == ALT_YES) {
current_location.update_lineno(750);
/* LibCommon_Sync.ttcn, line 750 */
if ((!(f__isPresentInArray(v__clientRef, v__clientRefs)))) {
current_location.update_lineno(751);
/* LibCommon_Sync.ttcn, line 751 */
v__clientRefs[v__noOfRecvdSyncMsgs] = v__clientRef;
current_location.update_lineno(752);
/* LibCommon_Sync.ttcn, line 752 */
{
INTEGER tmp_10;
++v__noOfRecvdSyncMsgs;
}
}
current_location.update_lineno(754);
/* LibCommon_Sync.ttcn, line 754 */
if ((v__noOfRecvdSyncMsgs != p__NoOfClients)) {
current_location.update_lineno(754);
/* LibCommon_Sync.ttcn, line 754 */
goto tmp_5;
}
break;
}
}
if (tmp_5_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(756);
/* LibCommon_Sync.ttcn, line 756 */
tmp_5_alt_flag_2 = BaseSyncComp_component_syncPort.receive(m__syncClientStop, NULL, any_compref, &(v__clientRef), NULL);
if (tmp_5_alt_flag_2 == ALT_YES) {
current_location.update_lineno(757);
/* LibCommon_Sync.ttcn, line 757 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server received STOP signal from a client - server will wait for all clients to reach their next synchronization point and then stop them! ****");
current_location.update_lineno(758);
/* LibCommon_Sync.ttcn, line 758 */
v__stopClients = TRUE;
current_location.update_lineno(759);
/* LibCommon_Sync.ttcn, line 759 */
if ((!(f__isPresentInArray(v__clientRef, v__clientRefs)))) {
current_location.update_lineno(760);
/* LibCommon_Sync.ttcn, line 760 */
v__clientRefs[v__noOfRecvdSyncMsgs] = v__clientRef;
current_location.update_lineno(761);
/* LibCommon_Sync.ttcn, line 761 */
{
INTEGER tmp_13;
++v__noOfRecvdSyncMsgs;
}
}
current_location.update_lineno(763);
/* LibCommon_Sync.ttcn, line 763 */
if ((v__noOfRecvdSyncMsgs != p__NoOfClients)) {
current_location.update_lineno(763);
/* LibCommon_Sync.ttcn, line 763 */
goto tmp_5;
}
break;
}
}
if (tmp_5_alt_flag_3 == ALT_MAYBE) {
current_location.update_lineno(766);
/* LibCommon_Sync.ttcn, line 766 */
tmp_5_alt_flag_3 = BaseSyncComp_component_syncPort.receive(m__syncClientReady(CHARSTRING_template(ANY_VALUE)), NULL, any_compref, &(v__clientRef), NULL);
if (tmp_5_alt_flag_3 == ALT_YES) {
current_location.update_lineno(767);
/* LibCommon_Sync.ttcn, line 767 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server received client sync message with incorrect synchronization point id which is currently not handled - server will stop all clients! ****");
current_location.update_lineno(768);
/* LibCommon_Sync.ttcn, line 768 */
v__stopClients = TRUE;
current_location.update_lineno(769);
/* LibCommon_Sync.ttcn, line 769 */
if ((!(f__isPresentInArray(v__clientRef, v__clientRefs)))) {
current_location.update_lineno(770);
/* LibCommon_Sync.ttcn, line 770 */
v__clientRefs[v__noOfRecvdSyncMsgs] = v__clientRef;
}
break;
}
}
if (tmp_5_alt_flag_4 == ALT_MAYBE) {
current_location.update_lineno(773);
/* LibCommon_Sync.ttcn, line 773 */
tmp_5_alt_flag_4 = BaseSyncComp_component_syncPort.receive(SyncCmd_template(ANY_VALUE), NULL, any_compref, NULL, NULL);
if (tmp_5_alt_flag_4 == ALT_YES) {
current_location.update_lineno(774);
/* LibCommon_Sync.ttcn, line 774 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server received (invalid) sync message from other sync server - server will stop all clients! ****");
current_location.update_lineno(775);
/* LibCommon_Sync.ttcn, line 775 */
v__stopClients = TRUE;
break;
}
}
if (tmp_5_alt_flag_5 == ALT_MAYBE) {
current_location.update_lineno(776);
/* LibCommon_Sync.ttcn, line 776 */
tmp_5_alt_flag_5 = PORT::any_receive(any_compref, NULL);
if (tmp_5_alt_flag_5 == ALT_YES) break;
}
if (tmp_5_alt_flag_6 == ALT_MAYBE) {
current_location.update_lineno(781);
/* LibCommon_Sync.ttcn, line 781 */
tmp_5_alt_flag_6 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_5_alt_flag_6 == ALT_YES) {
current_location.update_lineno(782);
/* LibCommon_Sync.ttcn, line 782 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: A client is not responding within specified time limit - sync server is sending stop to all clients! ****");
current_location.update_lineno(783);
/* LibCommon_Sync.ttcn, line 783 */
v__stopClients = TRUE;
break;
}
}
if (tmp_5_default_flag == ALT_MAYBE) {
tmp_5_default_flag = TTCN_Default::try_altsteps();
if (tmp_5_default_flag == ALT_YES || tmp_5_default_flag == ALT_BREAK) break;
else if (tmp_5_default_flag == ALT_REPEAT) goto tmp_5;
}
current_location.update_lineno(738);
/* LibCommon_Sync.ttcn, line 738 */
if (tmp_5_alt_flag_0 == ALT_NO && tmp_5_alt_flag_1 == ALT_NO && tmp_5_alt_flag_2 == ALT_NO && tmp_5_alt_flag_3 == ALT_NO && tmp_5_alt_flag_4 == ALT_NO && tmp_5_alt_flag_5 == ALT_NO && tmp_5_alt_flag_6 == ALT_NO && tmp_5_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 738 and 784.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(785);
/* LibCommon_Sync.ttcn, line 785 */
if ((v__noOfRecvdSyncMsgsIntermediate != p__NoOfClientIntermediate)) {
current_location.update_lineno(786);
/* LibCommon_Sync.ttcn, line 786 */
v__stopClients = TRUE;
}
current_location.update_lineno(788);
/* LibCommon_Sync.ttcn, line 788 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(789);
/* LibCommon_Sync.ttcn, line 789 */
if (v__stopClients) {
current_location.update_lineno(790);
/* LibCommon_Sync.ttcn, line 790 */
TTCN_Runtime::setverdict(INCONC);
current_location.update_lineno(792);
/* LibCommon_Sync.ttcn, line 792 */
f__serverSendToAllClients(v__clientRefs, m__syncServerStop);
current_location.update_lineno(793);
/* LibCommon_Sync.ttcn, line 793 */
f__serverWaitForAllClientsToShutDown();
}
else {
current_location.update_lineno(795);
/* LibCommon_Sync.ttcn, line 795 */
TTCN_Runtime::setverdict(PASS);
current_location.update_lineno(797);
/* LibCommon_Sync.ttcn, line 797 */
{
SyncCmd_template tmp_19;
tmp_19 = m__syncServerReady(CHARSTRING_template(p__syncId));
tmp_19.check_restriction(TR_VALUE);
f__serverSendToAllClients(v__clientRefs, tmp_19);
}
current_location.update_lineno(798);
/* LibCommon_Sync.ttcn, line 798 */
if ((p__syncId == cs_0)) {
current_location.update_lineno(799);
/* LibCommon_Sync.ttcn, line 799 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server successfully passed PREAMBLE synchronization point. ****");
}
else {
current_location.update_lineno(800);
/* LibCommon_Sync.ttcn, line 800 */
if ((p__syncId == cs_2)) {
current_location.update_lineno(801);
/* LibCommon_Sync.ttcn, line 801 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server successfully passed TEST BODY synchronization point. ****");
}
else {
current_location.update_lineno(803);
/* LibCommon_Sync.ttcn, line 803 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverSyncClientsTimed: Sync server successfully passed synchronization point. ****");
}
}
}
}

void start_f__serverSyncClientsTimedIntermediateSync(const COMPONENT& component_reference, const INTEGER& p__NoOfClients, const CHARSTRING& p__syncId, const INTEGER& p__NoOfClientIntermediate, const CHARSTRING_template& p__syncIdIntermediate, const FLOAT& p__execTimeLimit)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsTimedIntermediateSync(");
p__NoOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__NoOfClientIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__syncIdIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__execTimeLimit.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSyncClientsTimedIntermediateSync", text_buf);
p__NoOfClients.encode_text(text_buf);
p__syncId.encode_text(text_buf);
p__NoOfClientIntermediate.encode_text(text_buf);
p__syncIdIntermediate.encode_text(text_buf);
p__execTimeLimit.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverWaitForAllClientsToStop()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 816, TTCN_Location::LOCATION_FUNCTION, "f_serverWaitForAllClientsToStop");
current_location.update_lineno(818);
/* LibCommon_Sync.ttcn, line 818 */
BaseSyncComp_component_tc__sync.start();
current_location.update_lineno(819);
/* LibCommon_Sync.ttcn, line 819 */
{
tmp_20:
alt_status tmp_20_alt_flag_0 = ALT_MAYBE;
alt_status tmp_20_alt_flag_1 = ALT_MAYBE;
alt_status tmp_20_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_20_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(820);
/* LibCommon_Sync.ttcn, line 820 */
tmp_20_alt_flag_0 = TTCN_Runtime::component_done(ALL_COMPREF);
if (tmp_20_alt_flag_0 == ALT_REPEAT) goto tmp_20;
if (tmp_20_alt_flag_0 == ALT_YES) {
current_location.update_lineno(821);
/* LibCommon_Sync.ttcn, line 821 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(822);
/* LibCommon_Sync.ttcn, line 822 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverWaitForAllClientsToStop: All sync clients have finished their execution. Sync server now terminating test case. ****");
break;
}
}
if (tmp_20_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(824);
/* LibCommon_Sync.ttcn, line 824 */
tmp_20_alt_flag_1 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_20_alt_flag_1 == ALT_YES) {
current_location.update_lineno(825);
/* LibCommon_Sync.ttcn, line 825 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverWaitForAllClientsToStop: Not all sync clients have finshed execution within the sync time limit. Sync server will stop test case! ****");
current_location.update_lineno(826);
/* LibCommon_Sync.ttcn, line 826 */
TTCN_Runtime::stop_execution();
}
}
if (tmp_20_default_flag == ALT_MAYBE) {
tmp_20_default_flag = TTCN_Default::try_altsteps();
if (tmp_20_default_flag == ALT_YES || tmp_20_default_flag == ALT_BREAK) break;
else if (tmp_20_default_flag == ALT_REPEAT) goto tmp_20;
}
current_location.update_lineno(819);
/* LibCommon_Sync.ttcn, line 819 */
if (tmp_20_alt_flag_0 == ALT_NO && tmp_20_alt_flag_1 == ALT_NO && tmp_20_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 819 and 828.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(829);
/* LibCommon_Sync.ttcn, line 829 */
TTCN_Runtime::setverdict(PASS);
}

void start_f__serverWaitForAllClientsToStop(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverWaitForAllClientsToStop(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverWaitForAllClientsToStop", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__connect4ClientSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 842, TTCN_Location::LOCATION_FUNCTION, "f_connect4ClientSync");
current_location.update_lineno(844);
/* LibCommon_Sync.ttcn, line 844 */
TTCN_Runtime::connect_port(self, BaseSyncComp_component_syncPort.get_name(), MTC_COMPREF, "syncPort");
}

void start_f__connect4ClientSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_connect4ClientSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_connect4ClientSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__disconnect4ClientSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 853, TTCN_Location::LOCATION_FUNCTION, "f_disconnect4ClientSync");
current_location.update_lineno(855);
/* LibCommon_Sync.ttcn, line 855 */
TTCN_Runtime::disconnect_port(self, BaseSyncComp_component_syncPort.get_name(), MTC_COMPREF, "syncPort");
}

void start_f__disconnect4ClientSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_disconnect4ClientSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_disconnect4ClientSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__clientSyncAndVerdict(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 875, TTCN_Location::LOCATION_FUNCTION, "f_clientSyncAndVerdict");
current_location.update_lineno(878);
/* LibCommon_Sync.ttcn, line 878 */
if ((ClientSyncComp_component_vc__testcaseStep == TestcaseStep::e__preamble)) {
current_location.update_lineno(879);
/* LibCommon_Sync.ttcn, line 879 */
f__clientSyncAndVerdictPreamble(p__syncId, p__ret);
}
else {
current_location.update_lineno(880);
/* LibCommon_Sync.ttcn, line 880 */
if ((ClientSyncComp_component_vc__testcaseStep == TestcaseStep::e__testBody)) {
current_location.update_lineno(881);
/* LibCommon_Sync.ttcn, line 881 */
f__clientSyncAndVerdictTestBody(p__syncId, p__ret);
}
else {
current_location.update_lineno(884);
/* LibCommon_Sync.ttcn, line 884 */
f__clientSyncAndVerdictPostamble(p__syncId, p__ret);
}
}
}

void start_f__clientSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdict(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSyncAndVerdict", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__clientSyncAndVerdictPreamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 903, TTCN_Location::LOCATION_FUNCTION, "f_clientSyncAndVerdictPreamble");
current_location.update_lineno(906);
/* LibCommon_Sync.ttcn, line 906 */
LibCommon__VerdictControl::f__setVerdictPreamble(p__ret);
current_location.update_lineno(907);
/* LibCommon_Sync.ttcn, line 907 */
f__clientSync(p__syncId, p__ret);
current_location.update_lineno(908);
/* LibCommon_Sync.ttcn, line 908 */
ClientSyncComp_component_vc__testcaseStep = TestcaseStep::e__testBody;
}

void start_f__clientSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictPreamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSyncAndVerdictPreamble", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__clientSyncAndVerdictTestBody(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 928, TTCN_Location::LOCATION_FUNCTION, "f_clientSyncAndVerdictTestBody");
current_location.update_lineno(931);
/* LibCommon_Sync.ttcn, line 931 */
LibCommon__VerdictControl::f__setVerdict(p__ret);
current_location.update_lineno(932);
/* LibCommon_Sync.ttcn, line 932 */
f__clientSync(p__syncId, p__ret);
current_location.update_lineno(933);
/* LibCommon_Sync.ttcn, line 933 */
ClientSyncComp_component_vc__testcaseStep = TestcaseStep::e__postamble;
}

void start_f__clientSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictTestBody(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSyncAndVerdictTestBody", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__clientSyncAndVerdictPostamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 951, TTCN_Location::LOCATION_FUNCTION, "f_clientSyncAndVerdictPostamble");
current_location.update_lineno(954);
/* LibCommon_Sync.ttcn, line 954 */
LibCommon__VerdictControl::f__setVerdictPostamble(p__ret);
current_location.update_lineno(955);
/* LibCommon_Sync.ttcn, line 955 */
f__clientSync(p__syncId, p__ret);
}

void start_f__clientSyncAndVerdictPostamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictPostamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSyncAndVerdictPostamble", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

LibCommon__VerdictControl::FncRetCode f__clientSync(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 984, TTCN_Location::LOCATION_FUNCTION, "f_clientSync");
current_location.update_lineno(989);
/* LibCommon_Sync.ttcn, line 989 */
if ((p__ret == LibCommon__VerdictControl::FncRetCode::e__success)) {
current_location.update_lineno(990);
/* LibCommon_Sync.ttcn, line 990 */
BaseSyncComp_component_syncPort.send(m__syncClientReady(CHARSTRING_template(p__syncId)));
current_location.update_lineno(991);
/* LibCommon_Sync.ttcn, line 991 */
BaseSyncComp_component_tc__sync.start();
current_location.update_lineno(992);
/* LibCommon_Sync.ttcn, line 992 */
{
tmp_23:
alt_status tmp_23_alt_flag_0 = ALT_MAYBE;
alt_status tmp_23_alt_flag_1 = ALT_MAYBE;
alt_status tmp_23_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_23_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(993);
/* LibCommon_Sync.ttcn, line 993 */
tmp_23_alt_flag_0 = BaseSyncComp_component_syncPort.receive(m__syncServerReady(CHARSTRING_template(p__syncId)), NULL, any_compref, NULL, NULL);
if (tmp_23_alt_flag_0 == ALT_YES) {
current_location.update_lineno(994);
/* LibCommon_Sync.ttcn, line 994 */
BaseSyncComp_component_tc__sync.stop();
break;
}
}
if (tmp_23_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(995);
/* LibCommon_Sync.ttcn, line 995 */
tmp_23_alt_flag_1 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_23_alt_flag_1 == ALT_YES) {
current_location.update_lineno(996);
/* LibCommon_Sync.ttcn, line 996 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSync: Sync client did not receive message from sync server within the specified time limit - sync client will ask sync server to stop test case! ****");
current_location.update_lineno(997);
/* LibCommon_Sync.ttcn, line 997 */
f__clientSendStop();
break;
}
}
if (tmp_23_default_flag == ALT_MAYBE) {
tmp_23_default_flag = TTCN_Default::try_altsteps();
if (tmp_23_default_flag == ALT_YES || tmp_23_default_flag == ALT_BREAK) break;
else if (tmp_23_default_flag == ALT_REPEAT) goto tmp_23;
}
current_location.update_lineno(992);
/* LibCommon_Sync.ttcn, line 992 */
if (tmp_23_alt_flag_0 == ALT_NO && tmp_23_alt_flag_1 == ALT_NO && tmp_23_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 992 and 998.");
TTCN_Snapshot::take_new(TRUE);
}
}
}
else {
current_location.update_lineno(1001);
/* LibCommon_Sync.ttcn, line 1001 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSync: Execution status indicates that execution of test component behavior was not successful - sync client will ask sync server to stop test case! ****");
current_location.update_lineno(1002);
/* LibCommon_Sync.ttcn, line 1002 */
f__clientSendStop();
}
current_location.update_lineno(1004);
/* LibCommon_Sync.ttcn, line 1004 */
if ((p__syncId == cs_0)) {
current_location.update_lineno(1005);
/* LibCommon_Sync.ttcn, line 1005 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSync: Sync client successfully passed PREAMBLE synchronization point. ****");
}
else {
current_location.update_lineno(1006);
/* LibCommon_Sync.ttcn, line 1006 */
if ((p__syncId == cs_2)) {
current_location.update_lineno(1007);
/* LibCommon_Sync.ttcn, line 1007 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSync: Sync client successfully passed TEST BODY synchronization point. ****");
}
else {
current_location.update_lineno(1009);
/* LibCommon_Sync.ttcn, line 1009 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSync: Sync client successfully passed synchronization point. ****");
}
}
current_location.update_lineno(1011);
/* LibCommon_Sync.ttcn, line 1011 */
return LibCommon__VerdictControl::FncRetCode::e__success;
}

void start_f__clientSync(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSync(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSync", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__clientSendStop()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1035, TTCN_Location::LOCATION_FUNCTION, "f_clientSendStop");
current_location.update_lineno(1037);
/* LibCommon_Sync.ttcn, line 1037 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSendStop: Sync client requesting from server to stop test case (including itself). ****");
current_location.update_lineno(1038);
/* LibCommon_Sync.ttcn, line 1038 */
BaseSyncComp_component_syncPort.send(m__syncClientStop);
current_location.update_lineno(1039);
/* LibCommon_Sync.ttcn, line 1039 */
BaseSyncComp_component_tc__sync.start();
current_location.update_lineno(1040);
/* LibCommon_Sync.ttcn, line 1040 */
{
tmp_24:
alt_status tmp_24_alt_flag_0 = ALT_MAYBE;
alt_status tmp_24_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_24_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(1041);
/* LibCommon_Sync.ttcn, line 1041 */
tmp_24_alt_flag_0 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_24_alt_flag_0 == ALT_YES) {
current_location.update_lineno(1042);
/* LibCommon_Sync.ttcn, line 1042 */
TTCN_Logger::log_str(TTCN_USER, "**** f_clientSendStop: Stopping sync client without shutdown - either no shutdown default active or no stop received from server. ****");
current_location.update_lineno(1043);
/* LibCommon_Sync.ttcn, line 1043 */
TTCN_Runtime::setverdict(INCONC);
current_location.update_lineno(1044);
/* LibCommon_Sync.ttcn, line 1044 */
TTCN_Runtime::stop_execution();
}
}
if (tmp_24_default_flag == ALT_MAYBE) {
tmp_24_default_flag = TTCN_Default::try_altsteps();
if (tmp_24_default_flag == ALT_YES || tmp_24_default_flag == ALT_BREAK) break;
else if (tmp_24_default_flag == ALT_REPEAT) goto tmp_24;
}
current_location.update_lineno(1040);
/* LibCommon_Sync.ttcn, line 1040 */
if (tmp_24_alt_flag_0 == ALT_NO && tmp_24_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 1040 and 1046.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(1047);
/* LibCommon_Sync.ttcn, line 1047 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(1048);
/* LibCommon_Sync.ttcn, line 1048 */
TTCN_Runtime::stop_execution();
}

void start_f__clientSendStop(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSendStop(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_clientSendStop", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

boolean operator==(null_type, const ClientSyncCompList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibCommon_Sync.ClientSyncCompList.");
return other_value.val_ptr->n_elements == 0;
}

void f__connect4SelfSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1088, TTCN_Location::LOCATION_FUNCTION, "f_connect4SelfSync");
current_location.update_lineno(1090);
/* LibCommon_Sync.ttcn, line 1090 */
TTCN_Runtime::connect_port(self, SelfSyncComp_component_syncSendPort.get_name(), self, BaseSyncComp_component_syncPort.get_name());
}

void start_f__connect4SelfSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_connect4SelfSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_connect4SelfSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__disconnect4SelfSync()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1099, TTCN_Location::LOCATION_FUNCTION, "f_disconnect4SelfSync");
current_location.update_lineno(1101);
/* LibCommon_Sync.ttcn, line 1101 */
TTCN_Runtime::disconnect_port(self, SelfSyncComp_component_syncSendPort.get_name(), self, BaseSyncComp_component_syncPort.get_name());
}

void start_f__disconnect4SelfSync(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_disconnect4SelfSync(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_disconnect4SelfSync", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfSyncAndVerdict(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1113, TTCN_Location::LOCATION_FUNCTION, "f_selfSyncAndVerdict");
current_location.update_lineno(1116);
/* LibCommon_Sync.ttcn, line 1116 */
if ((ClientSyncComp_component_vc__testcaseStep == TestcaseStep::e__preamble)) {
current_location.update_lineno(1117);
/* LibCommon_Sync.ttcn, line 1117 */
f__selfSyncAndVerdictPreamble(p__syncId, p__ret);
}
else {
current_location.update_lineno(1118);
/* LibCommon_Sync.ttcn, line 1118 */
if ((ClientSyncComp_component_vc__testcaseStep == TestcaseStep::e__testBody)) {
current_location.update_lineno(1119);
/* LibCommon_Sync.ttcn, line 1119 */
f__selfSyncAndVerdictTestBody(p__syncId, p__ret);
}
else {
current_location.update_lineno(1122);
/* LibCommon_Sync.ttcn, line 1122 */
f__selfSyncAndVerdictPostamble(p__syncId, p__ret);
}
}
}

void start_f__selfSyncAndVerdict(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdict(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSyncAndVerdict", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfSyncAndVerdictPreamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1134, TTCN_Location::LOCATION_FUNCTION, "f_selfSyncAndVerdictPreamble");
current_location.update_lineno(1137);
/* LibCommon_Sync.ttcn, line 1137 */
LibCommon__VerdictControl::f__setVerdictPreOrPostamble(p__ret);
current_location.update_lineno(1138);
/* LibCommon_Sync.ttcn, line 1138 */
f__selfSync(p__syncId, p__ret);
current_location.update_lineno(1139);
/* LibCommon_Sync.ttcn, line 1139 */
ClientSyncComp_component_vc__testcaseStep = TestcaseStep::e__testBody;
}

void start_f__selfSyncAndVerdictPreamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictPreamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSyncAndVerdictPreamble", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfSyncAndVerdictTestBody(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1150, TTCN_Location::LOCATION_FUNCTION, "f_selfSyncAndVerdictTestBody");
current_location.update_lineno(1153);
/* LibCommon_Sync.ttcn, line 1153 */
LibCommon__VerdictControl::f__setVerdict(p__ret);
current_location.update_lineno(1154);
/* LibCommon_Sync.ttcn, line 1154 */
f__selfSync(p__syncId, p__ret);
current_location.update_lineno(1155);
/* LibCommon_Sync.ttcn, line 1155 */
ClientSyncComp_component_vc__testcaseStep = TestcaseStep::e__postamble;
}

void start_f__selfSyncAndVerdictTestBody(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictTestBody(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSyncAndVerdictTestBody", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfSyncAndVerdictPostamble(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1166, TTCN_Location::LOCATION_FUNCTION, "f_selfSyncAndVerdictPostamble");
current_location.update_lineno(1169);
/* LibCommon_Sync.ttcn, line 1169 */
LibCommon__VerdictControl::f__setVerdictPreOrPostamble(p__ret);
current_location.update_lineno(1170);
/* LibCommon_Sync.ttcn, line 1170 */
f__selfSync(p__syncId, p__ret);
}

void start_f__selfSyncAndVerdictPostamble(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictPostamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSyncAndVerdictPostamble", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

LibCommon__VerdictControl::FncRetCode f__selfSync(const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1189, TTCN_Location::LOCATION_FUNCTION, "f_selfSync");
current_location.update_lineno(1193);
/* LibCommon_Sync.ttcn, line 1193 */
if ((p__ret != LibCommon__VerdictControl::FncRetCode::e__success)) {
current_location.update_lineno(1194);
/* LibCommon_Sync.ttcn, line 1194 */
f__selfSyncStop();
}
current_location.update_lineno(1196);
/* LibCommon_Sync.ttcn, line 1196 */
if ((p__syncId == cs_0)) {
current_location.update_lineno(1197);
/* LibCommon_Sync.ttcn, line 1197 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSync: Successfully passed PREAMBLE synchronization point. ****");
}
else {
current_location.update_lineno(1198);
/* LibCommon_Sync.ttcn, line 1198 */
if ((p__syncId == cs_2)) {
current_location.update_lineno(1199);
/* LibCommon_Sync.ttcn, line 1199 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSync: Successfully passed TEST BODY synchronization point. ****");
}
else {
current_location.update_lineno(1201);
/* LibCommon_Sync.ttcn, line 1201 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSync: Successfully passed synchronization point. ****");
}
}
current_location.update_lineno(1203);
/* LibCommon_Sync.ttcn, line 1203 */
return LibCommon__VerdictControl::FncRetCode::e__success;
}

void start_f__selfSync(const COMPONENT& component_reference, const CHARSTRING& p__syncId, const LibCommon__VerdictControl::FncRetCode& p__ret)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSync(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSync", text_buf);
p__syncId.encode_text(text_buf);
p__ret.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__selfSyncStop()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1218, TTCN_Location::LOCATION_FUNCTION, "f_selfSyncStop");
current_location.update_lineno(1221);
/* LibCommon_Sync.ttcn, line 1221 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSyncStop: MTC requests to stop test case (itself). ****");
current_location.update_lineno(1222);
/* LibCommon_Sync.ttcn, line 1222 */
SelfSyncComp_component_syncSendPort.send(m__syncServerStop);
current_location.update_lineno(1223);
/* LibCommon_Sync.ttcn, line 1223 */
BaseSyncComp_component_tc__sync.start(PX__TSYNC__TIME__LIMIT);
current_location.update_lineno(1224);
/* LibCommon_Sync.ttcn, line 1224 */
{
tmp_27:
alt_status tmp_27_alt_flag_0 = ALT_MAYBE;
alt_status tmp_27_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_27_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(1225);
/* LibCommon_Sync.ttcn, line 1225 */
tmp_27_alt_flag_0 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_27_alt_flag_0 == ALT_YES) {
current_location.update_lineno(1226);
/* LibCommon_Sync.ttcn, line 1226 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSyncStop: Stopping MTC without shutdown - either no shutdown default active or missing syncPort connection ****");
current_location.update_lineno(1227);
/* LibCommon_Sync.ttcn, line 1227 */
TTCN_Runtime::setverdict(INCONC);
current_location.update_lineno(1228);
/* LibCommon_Sync.ttcn, line 1228 */
TTCN_Runtime::stop_execution();
}
}
if (tmp_27_default_flag == ALT_MAYBE) {
tmp_27_default_flag = TTCN_Default::try_altsteps();
if (tmp_27_default_flag == ALT_YES || tmp_27_default_flag == ALT_BREAK) break;
else if (tmp_27_default_flag == ALT_REPEAT) goto tmp_27;
}
current_location.update_lineno(1224);
/* LibCommon_Sync.ttcn, line 1224 */
if (tmp_27_alt_flag_0 == ALT_NO && tmp_27_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 1224 and 1230.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(1231);
/* LibCommon_Sync.ttcn, line 1231 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(1232);
/* LibCommon_Sync.ttcn, line 1232 */
TTCN_Runtime::stop_execution();
}

void start_f__selfSyncStop(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncStop(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_selfSyncStop", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

boolean operator==(null_type, const ClientStop& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @LibCommon_Sync.ClientStop.");
return TRUE;
}

boolean operator==(null_type, const ServerStop& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @LibCommon_Sync.ServerStop.");
return TRUE;
}

SyncCmd_template m__syncClientReady(const CHARSTRING_template& p__syncId)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1270, TTCN_Location::LOCATION_TEMPLATE, "m_syncClientReady");
SyncCmd_template ret_val;
ret_val.clientReady().syncPointId() = p__syncId;
return ret_val;
}

SyncCmd_template m__syncServerReady(const CHARSTRING_template& p__syncId)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1274, TTCN_Location::LOCATION_TEMPLATE, "m_syncServerReady");
SyncCmd_template ret_val;
ret_val.serverReady().syncPointId() = p__syncId;
return ret_val;
}

void f__serverSendToAllClients(const ClientSyncCompList& p__clientRefs, const SyncCmd_template& p__syncCmd)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1295, TTCN_Location::LOCATION_FUNCTION, "f_serverSendToAllClients");
current_location.update_lineno(1298);
/* LibCommon_Sync.ttcn, line 1298 */
INTEGER i(0);
current_location.update_lineno(1299);
/* LibCommon_Sync.ttcn, line 1299 */
i = 0;
current_location.update_lineno(1299);
/* LibCommon_Sync.ttcn, line 1299 */
for ( ; ; ) {
current_location.update_lineno(1299);
/* LibCommon_Sync.ttcn, line 1299 */
if (!(i < p__clientRefs.size_of())) break;
current_location.update_lineno(1300);
/* LibCommon_Sync.ttcn, line 1300 */
BaseSyncComp_component_syncPort.send(p__syncCmd, const_cast< const ClientSyncCompList&>(p__clientRefs)[i]);
current_location.update_lineno(1299);
/* LibCommon_Sync.ttcn, line 1299 */
{
INTEGER tmp_29;
++i;
}
}
}

void start_f__serverSendToAllClients(const COMPONENT& component_reference, const ClientSyncCompList& p__clientRefs, const SyncCmd_template& p__syncCmd)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSendToAllClients(");
p__clientRefs.log();
TTCN_Logger::log_event_str(", ");
p__syncCmd.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverSendToAllClients", text_buf);
p__clientRefs.encode_text(text_buf);
p__syncCmd.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__serverWaitForAllClientsToShutDown()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1312, TTCN_Location::LOCATION_FUNCTION, "f_serverWaitForAllClientsToShutDown");
current_location.update_lineno(1315);
/* LibCommon_Sync.ttcn, line 1315 */
ServerSyncComp_component_tc__shutDown.start(PX__TSHUT__DOWN__TIME__LIMIT);
current_location.update_lineno(1316);
/* LibCommon_Sync.ttcn, line 1316 */
{
tmp_30:
alt_status tmp_30_alt_flag_0 = ALT_MAYBE;
alt_status tmp_30_alt_flag_1 = ALT_MAYBE;
alt_status tmp_30_alt_flag_2 = ALT_MAYBE;
alt_status tmp_30_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_30_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(1317);
/* LibCommon_Sync.ttcn, line 1317 */
tmp_30_alt_flag_0 = BaseSyncComp_component_syncPort.receive(any_compref, NULL, NULL);
if (tmp_30_alt_flag_0 == ALT_YES) break;
}
if (tmp_30_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(1320);
/* LibCommon_Sync.ttcn, line 1320 */
tmp_30_alt_flag_1 = TTCN_Runtime::component_done(ALL_COMPREF);
if (tmp_30_alt_flag_1 == ALT_REPEAT) goto tmp_30;
if (tmp_30_alt_flag_1 == ALT_YES) {
current_location.update_lineno(1321);
/* LibCommon_Sync.ttcn, line 1321 */
ServerSyncComp_component_tc__shutDown.stop();
current_location.update_lineno(1322);
/* LibCommon_Sync.ttcn, line 1322 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverWaitForAllClientsToShutDown: All components have properly shut down. Sync server will now terminate the test case. ****");
break;
}
}
if (tmp_30_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(1324);
/* LibCommon_Sync.ttcn, line 1324 */
tmp_30_alt_flag_2 = ServerSyncComp_component_tc__shutDown.timeout(NULL);
if (tmp_30_alt_flag_2 == ALT_YES) {
current_location.update_lineno(1325);
/* LibCommon_Sync.ttcn, line 1325 */
TTCN_Logger::log_str(TTCN_USER, "**** f_serverWaitForAllClientsToShutDown: Not all clients have properly shutdown within the shut down time limit. Sync server will now terminate test case! ****");
break;
}
}
if (tmp_30_default_flag == ALT_MAYBE) {
tmp_30_default_flag = TTCN_Default::try_altsteps();
if (tmp_30_default_flag == ALT_YES || tmp_30_default_flag == ALT_BREAK) break;
else if (tmp_30_default_flag == ALT_REPEAT) goto tmp_30;
}
current_location.update_lineno(1316);
/* LibCommon_Sync.ttcn, line 1316 */
if (tmp_30_alt_flag_0 == ALT_NO && tmp_30_alt_flag_1 == ALT_NO && tmp_30_alt_flag_2 == ALT_NO && tmp_30_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 1316 and 1327.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(1329);
/* LibCommon_Sync.ttcn, line 1329 */
TTCN_Runtime::setverdict(INCONC);
current_location.update_lineno(1331);
/* LibCommon_Sync.ttcn, line 1331 */
BaseSyncComp_component_syncPort.send(m__syncServerStop, self);
current_location.update_lineno(1332);
/* LibCommon_Sync.ttcn, line 1332 */
BaseSyncComp_component_tc__sync.start(PX__TSYNC__TIME__LIMIT);
current_location.update_lineno(1333);
/* LibCommon_Sync.ttcn, line 1333 */
{
tmp_31:
alt_status tmp_31_alt_flag_0 = ALT_MAYBE;
alt_status tmp_31_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_31_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(1334);
/* LibCommon_Sync.ttcn, line 1334 */
tmp_31_alt_flag_0 = BaseSyncComp_component_tc__sync.timeout(NULL);
if (tmp_31_alt_flag_0 == ALT_YES) {
current_location.update_lineno(1335);
/* LibCommon_Sync.ttcn, line 1335 */
TTCN_Logger::log_str(TTCN_USER, "**** f_selfSyncStop: Stopping MTC without shutdown - either no shutdown default active or missing syncPort connection ****");
current_location.update_lineno(1336);
/* LibCommon_Sync.ttcn, line 1336 */
TTCN_Runtime::setverdict(INCONC);
current_location.update_lineno(1337);
/* LibCommon_Sync.ttcn, line 1337 */
TTCN_Runtime::stop_execution();
}
}
if (tmp_31_default_flag == ALT_MAYBE) {
tmp_31_default_flag = TTCN_Default::try_altsteps();
if (tmp_31_default_flag == ALT_YES || tmp_31_default_flag == ALT_BREAK) break;
else if (tmp_31_default_flag == ALT_REPEAT) goto tmp_31;
}
current_location.update_lineno(1333);
/* LibCommon_Sync.ttcn, line 1333 */
if (tmp_31_alt_flag_0 == ALT_NO && tmp_31_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file LibCommon_Sync.ttcn between lines 1333 and 1339.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(1340);
/* LibCommon_Sync.ttcn, line 1340 */
BaseSyncComp_component_tc__sync.stop();
current_location.update_lineno(1341);
/* LibCommon_Sync.ttcn, line 1341 */
TTCN_Runtime::stop_execution();
}

void start_f__serverWaitForAllClientsToShutDown(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverWaitForAllClientsToShutDown(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "LibCommon_Sync", "f_serverWaitForAllClientsToShutDown", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

BOOLEAN f__isPresentInArray(const COMPONENT& p__clientRef, const ClientSyncCompList& p__clientRefs)
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 1344, TTCN_Location::LOCATION_FUNCTION, "f_isPresentInArray");
current_location.update_lineno(1346);
/* LibCommon_Sync.ttcn, line 1346 */
INTEGER i;
current_location.update_lineno(1347);
/* LibCommon_Sync.ttcn, line 1347 */
i = 0;
current_location.update_lineno(1347);
/* LibCommon_Sync.ttcn, line 1347 */
for ( ; ; ) {
current_location.update_lineno(1347);
/* LibCommon_Sync.ttcn, line 1347 */
if (!(i < p__clientRefs.size_of())) break;
current_location.update_lineno(1348);
/* LibCommon_Sync.ttcn, line 1348 */
if ((const_cast< const ClientSyncCompList&>(p__clientRefs)[i] == p__clientRef)) {
current_location.update_lineno(1349);
/* LibCommon_Sync.ttcn, line 1349 */
return TRUE;
}
current_location.update_lineno(1347);
/* LibCommon_Sync.ttcn, line 1347 */
{
INTEGER tmp_33;
++i;
}
}
current_location.update_lineno(1352);
/* LibCommon_Sync.ttcn, line 1352 */
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibCommon_Sync");
LibCommon__AbstractData::module_object.pre_init_module();
LibCommon__VerdictControl::module_object.pre_init_module();
current_location.update_lineno(170);
/* LibCommon_Sync.ttcn, line 170 */
const_c__prDone = cs_0;
current_location.update_lineno(171);
/* LibCommon_Sync.ttcn, line 171 */
const_c__poDone = cs_1;
current_location.update_lineno(172);
/* LibCommon_Sync.ttcn, line 172 */
const_c__tbDone = cs_2;
current_location.update_lineno(173);
/* LibCommon_Sync.ttcn, line 173 */
const_c__initDone = cs_3;
module_object.add_function("f_connect4SelfOrClientSync", (genericfunc_t)&f__connect4SelfOrClientSync, (genericfunc_t)&start_f__connect4SelfOrClientSync);
module_object.add_function("f_disconnect4SelfOrClientSync", (genericfunc_t)&f__disconnect4SelfOrClientSync, (genericfunc_t)&start_f__disconnect4SelfOrClientSync);
module_object.add_function("f_serverSync2ClientsAndStop", (genericfunc_t)&f__serverSync2ClientsAndStop, (genericfunc_t)&start_f__serverSync2ClientsAndStop);
module_object.add_function("f_serverSync3ClientsAndStop", (genericfunc_t)&f__serverSync3ClientsAndStop, (genericfunc_t)&start_f__serverSync3ClientsAndStop);
module_object.add_function("f_serverSync4ClientsAndStop", (genericfunc_t)&f__serverSync4ClientsAndStop, (genericfunc_t)&start_f__serverSync4ClientsAndStop);
module_object.add_function("f_serverSyncNClientsAndStop", (genericfunc_t)&f__serverSyncNClientsAndStop, (genericfunc_t)&start_f__serverSyncNClientsAndStop);
module_object.add_function("f_serverSync2ClientsUtAndStop", (genericfunc_t)&f__serverSync2ClientsUtAndStop, (genericfunc_t)&start_f__serverSync2ClientsUtAndStop);
module_object.add_function("f_selfOrClientSyncAndVerdict", (genericfunc_t)&f__selfOrClientSyncAndVerdict, (genericfunc_t)&start_f__selfOrClientSyncAndVerdict);
module_object.add_function("f_selfOrClientSyncAndVerdictPreamble", (genericfunc_t)&f__selfOrClientSyncAndVerdictPreamble, (genericfunc_t)&start_f__selfOrClientSyncAndVerdictPreamble);
module_object.add_function("f_selfOrClientSyncAndVerdictTestBody", (genericfunc_t)&f__selfOrClientSyncAndVerdictTestBody, (genericfunc_t)&start_f__selfOrClientSyncAndVerdictTestBody);
module_object.add_function("f_selfOrClientSyncAndVerdictPR", (genericfunc_t)&f__selfOrClientSyncAndVerdictPR, (genericfunc_t)&start_f__selfOrClientSyncAndVerdictPR);
module_object.add_function("f_addSyncCompState", (genericfunc_t)&f__addSyncCompState, (genericfunc_t)&start_f__addSyncCompState);
module_object.add_function("f_getTopSyncCompState", (genericfunc_t)&f__getTopSyncCompState, NULL);
module_object.add_function("f_popSyncCompState", (genericfunc_t)&f__popSyncCompState, (genericfunc_t)&start_f__popSyncCompState);
module_object.add_function("f_peekTopSyncCompState", (genericfunc_t)&f__peekTopSyncCompState, NULL);
module_object.add_function("f_isSyncCompStateStackEmpty", (genericfunc_t)&f__isSyncCompStateStackEmpty, (genericfunc_t)&start_f__isSyncCompStateStackEmpty);
module_object.add_altstep("a_dummyShutDown", (genericfunc_t)&a__dummyShutDown_instance, (genericfunc_t )&activate_a__dummyShutDown, (genericfunc_t )&a__dummyShutDown);
module_object.add_altstep("a_shutdown", (genericfunc_t)&a__shutdown_instance, (genericfunc_t )&activate_a__shutdown, (genericfunc_t )&a__shutdown);
module_object.add_function("f_serverSyncClients", (genericfunc_t)&f__serverSyncClients, (genericfunc_t)&start_f__serverSyncClients);
module_object.add_function("f_serverSyncClientsIntermediateSync", (genericfunc_t)&f__serverSyncClientsIntermediateSync, (genericfunc_t)&start_f__serverSyncClientsIntermediateSync);
module_object.add_function("f_serverSyncClientsTimed", (genericfunc_t)&f__serverSyncClientsTimed, (genericfunc_t)&start_f__serverSyncClientsTimed);
module_object.add_function("f_serverSyncClientsTimedIntermediateSync", (genericfunc_t)&f__serverSyncClientsTimedIntermediateSync, (genericfunc_t)&start_f__serverSyncClientsTimedIntermediateSync);
module_object.add_function("f_serverWaitForAllClientsToStop", (genericfunc_t)&f__serverWaitForAllClientsToStop, (genericfunc_t)&start_f__serverWaitForAllClientsToStop);
module_object.add_function("f_connect4ClientSync", (genericfunc_t)&f__connect4ClientSync, (genericfunc_t)&start_f__connect4ClientSync);
module_object.add_function("f_disconnect4ClientSync", (genericfunc_t)&f__disconnect4ClientSync, (genericfunc_t)&start_f__disconnect4ClientSync);
module_object.add_function("f_clientSyncAndVerdict", (genericfunc_t)&f__clientSyncAndVerdict, (genericfunc_t)&start_f__clientSyncAndVerdict);
module_object.add_function("f_clientSyncAndVerdictPreamble", (genericfunc_t)&f__clientSyncAndVerdictPreamble, (genericfunc_t)&start_f__clientSyncAndVerdictPreamble);
module_object.add_function("f_clientSyncAndVerdictTestBody", (genericfunc_t)&f__clientSyncAndVerdictTestBody, (genericfunc_t)&start_f__clientSyncAndVerdictTestBody);
module_object.add_function("f_clientSyncAndVerdictPostamble", (genericfunc_t)&f__clientSyncAndVerdictPostamble, (genericfunc_t)&start_f__clientSyncAndVerdictPostamble);
module_object.add_function("f_clientSync", (genericfunc_t)&f__clientSync, (genericfunc_t)&start_f__clientSync);
module_object.add_function("f_clientSendStop", (genericfunc_t)&f__clientSendStop, (genericfunc_t)&start_f__clientSendStop);
current_location.update_lineno(1063);
/* LibCommon_Sync.ttcn, line 1063 */
modulepar_PX__TSYNC__TIME__LIMIT = 1.2e2;
current_location.update_lineno(1069);
/* LibCommon_Sync.ttcn, line 1069 */
modulepar_PX__TSHUT__DOWN__TIME__LIMIT = 1.2e2;
module_object.add_function("f_connect4SelfSync", (genericfunc_t)&f__connect4SelfSync, (genericfunc_t)&start_f__connect4SelfSync);
module_object.add_function("f_disconnect4SelfSync", (genericfunc_t)&f__disconnect4SelfSync, (genericfunc_t)&start_f__disconnect4SelfSync);
module_object.add_function("f_selfSyncAndVerdict", (genericfunc_t)&f__selfSyncAndVerdict, (genericfunc_t)&start_f__selfSyncAndVerdict);
module_object.add_function("f_selfSyncAndVerdictPreamble", (genericfunc_t)&f__selfSyncAndVerdictPreamble, (genericfunc_t)&start_f__selfSyncAndVerdictPreamble);
module_object.add_function("f_selfSyncAndVerdictTestBody", (genericfunc_t)&f__selfSyncAndVerdictTestBody, (genericfunc_t)&start_f__selfSyncAndVerdictTestBody);
module_object.add_function("f_selfSyncAndVerdictPostamble", (genericfunc_t)&f__selfSyncAndVerdictPostamble, (genericfunc_t)&start_f__selfSyncAndVerdictPostamble);
module_object.add_function("f_selfSync", (genericfunc_t)&f__selfSync, (genericfunc_t)&start_f__selfSync);
module_object.add_function("f_selfSyncStop", (genericfunc_t)&f__selfSyncStop, (genericfunc_t)&start_f__selfSyncStop);
module_object.add_function("f_serverSendToAllClients", (genericfunc_t)&f__serverSendToAllClients, (genericfunc_t)&start_f__serverSendToAllClients);
module_object.add_function("f_serverWaitForAllClientsToShutDown", (genericfunc_t)&f__serverWaitForAllClientsToShutDown, (genericfunc_t)&start_f__serverWaitForAllClientsToShutDown);
module_object.add_function("f_isPresentInArray", (genericfunc_t)&f__isPresentInArray, NULL);
}

static void post_init_module()
{
TTCN_Location current_location("LibCommon_Sync.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibCommon_Sync");
LibCommon__AbstractData::module_object.post_init_module();
LibCommon__VerdictControl::module_object.post_init_module();
BaseSyncComp_component_tc__sync.set_default_duration(PX__TSYNC__TIME__LIMIT);
ServerSyncComp_component_tc__shutDown.set_default_duration(PX__TSHUT__DOWN__TIME__LIMIT);
current_location.update_lineno(1278);
/* LibCommon_Sync.ttcn, line 1278 */
template_m__syncClientStop.clientStop() = NULL_VALUE;
current_location.update_lineno(1282);
/* LibCommon_Sync.ttcn, line 1282 */
template_m__syncServerStop.serverStop() = NULL_VALUE;
}

static boolean set_module_param(Module_Param& param)
{
const char* const par_name = param.get_id()->get_current_name();
if (!strcmp(par_name, "PX_TSYNC_TIME_LIMIT")) {
modulepar_PX__TSYNC__TIME__LIMIT.set_param(param);
return TRUE;
} else if (!strcmp(par_name, "PX_TSHUT_DOWN_TIME_LIMIT")) {
modulepar_PX__TSHUT__DOWN__TIME__LIMIT.set_param(param);
return TRUE;
} else return FALSE;
}

static void log_module_param()
{
TTCN_Logger::log_event_str("PX_TSYNC_TIME_LIMIT := ");
PX__TSYNC__TIME__LIMIT.log();
TTCN_Logger::log_event_str(", PX_TSHUT_DOWN_TIME_LIMIT := ");
PX__TSHUT__DOWN__TIME__LIMIT.log();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "BaseSyncComp")) {
BaseSyncComp_component_syncPort.activate_port();
return TRUE;
} else if (!strcmp(component_type, "ServerSyncComp")) {
if (init_base_comps) {
init_comp_type("BaseSyncComp", FALSE);
}
return TRUE;
} else if (!strcmp(component_type, "ClientSyncComp")) {
if (init_base_comps) {
init_comp_type("BaseSyncComp", FALSE);
}
ClientSyncComp_component_v__stateStack = LibCommon__AbstractData::c__initStringStack;
ClientSyncComp_component_vc__testcaseStep = TestcaseStep::e__preamble;
return TRUE;
} else if (!strcmp(component_type, "SelfSyncComp")) {
if (init_base_comps) {
init_comp_type("BaseSyncComp", FALSE);
init_comp_type("ClientSyncComp", FALSE);
}
SelfSyncComp_component_syncSendPort.activate_port();
return TRUE;
} else return FALSE;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_connect4SelfOrClientSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_connect4SelfOrClientSync().");
TTCN_Runtime::function_started(function_arguments);
f__connect4SelfOrClientSync();
TTCN_Runtime::function_finished("f_connect4SelfOrClientSync");
return TRUE;
} else if (!strcmp(function_name, "f_disconnect4SelfOrClientSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_disconnect4SelfOrClientSync().");
TTCN_Runtime::function_started(function_arguments);
f__disconnect4SelfOrClientSync();
TTCN_Runtime::function_finished("f_disconnect4SelfOrClientSync");
return TRUE;
} else if (!strcmp(function_name, "f_serverSync2ClientsAndStop")) {
SyncPointList p__syncPointIds;
p__syncPointIds.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync2ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSync2ClientsAndStop(p__syncPointIds);
TTCN_Runtime::function_finished("f_serverSync2ClientsAndStop");
return TRUE;
} else if (!strcmp(function_name, "f_serverSync3ClientsAndStop")) {
SyncPointList p__syncPointIds;
p__syncPointIds.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync3ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSync3ClientsAndStop(p__syncPointIds);
TTCN_Runtime::function_finished("f_serverSync3ClientsAndStop");
return TRUE;
} else if (!strcmp(function_name, "f_serverSync4ClientsAndStop")) {
SyncPointList p__syncPointIds;
p__syncPointIds.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync4ClientsAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSync4ClientsAndStop(p__syncPointIds);
TTCN_Runtime::function_finished("f_serverSync4ClientsAndStop");
return TRUE;
} else if (!strcmp(function_name, "f_serverSyncNClientsAndStop")) {
INTEGER p__numClients;
SyncPointList p__syncPointIds;
p__numClients.decode_text(function_arguments);
p__syncPointIds.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncNClientsAndStop(");
p__numClients.log();
TTCN_Logger::log_event_str(", ");
p__syncPointIds.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSyncNClientsAndStop(p__numClients, p__syncPointIds);
TTCN_Runtime::function_finished("f_serverSyncNClientsAndStop");
return TRUE;
} else if (!strcmp(function_name, "f_serverSync2ClientsUtAndStop")) {
SyncPointList p__syncPointIds;
p__syncPointIds.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSync2ClientsUtAndStop(");
p__syncPointIds.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSync2ClientsUtAndStop(p__syncPointIds);
TTCN_Runtime::function_finished("f_serverSync2ClientsUtAndStop");
return TRUE;
} else if (!strcmp(function_name, "f_selfOrClientSyncAndVerdict")) {
CHARSTRING p__syncPoint;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncPoint.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdict(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfOrClientSyncAndVerdict(p__syncPoint, p__ret);
TTCN_Runtime::function_finished("f_selfOrClientSyncAndVerdict");
return TRUE;
} else if (!strcmp(function_name, "f_selfOrClientSyncAndVerdictPreamble")) {
CHARSTRING p__syncPoint;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncPoint.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictPreamble(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfOrClientSyncAndVerdictPreamble(p__syncPoint, p__ret);
TTCN_Runtime::function_finished("f_selfOrClientSyncAndVerdictPreamble");
return TRUE;
} else if (!strcmp(function_name, "f_selfOrClientSyncAndVerdictTestBody")) {
CHARSTRING p__syncPoint;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncPoint.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictTestBody(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfOrClientSyncAndVerdictTestBody(p__syncPoint, p__ret);
TTCN_Runtime::function_finished("f_selfOrClientSyncAndVerdictTestBody");
return TRUE;
} else if (!strcmp(function_name, "f_selfOrClientSyncAndVerdictPR")) {
CHARSTRING p__syncPoint;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncPoint.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfOrClientSyncAndVerdictPR(");
p__syncPoint.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfOrClientSyncAndVerdictPR(p__syncPoint, p__ret);
TTCN_Runtime::function_finished("f_selfOrClientSyncAndVerdictPR");
return TRUE;
} else if (!strcmp(function_name, "f_addSyncCompState")) {
CHARSTRING p__newSyncCompState;
LibCommon__VerdictControl::FncRetCode p__ret;
p__newSyncCompState.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_addSyncCompState(");
p__newSyncCompState.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__addSyncCompState(p__newSyncCompState, p__ret);
TTCN_Runtime::function_finished("f_addSyncCompState");
return TRUE;
} else if (!strcmp(function_name, "f_popSyncCompState")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_popSyncCompState().");
TTCN_Runtime::function_started(function_arguments);
f__popSyncCompState();
TTCN_Runtime::function_finished("f_popSyncCompState");
return TRUE;
} else if (!strcmp(function_name, "f_isSyncCompStateStackEmpty")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_isSyncCompStateStackEmpty().");
TTCN_Runtime::function_started(function_arguments);
f__isSyncCompStateStackEmpty();
TTCN_Runtime::function_finished("f_isSyncCompStateStackEmpty");
return TRUE;
} else if (!strcmp(function_name, "f_serverSyncClients")) {
INTEGER p__noOfClients;
CHARSTRING p__syncId;
p__noOfClients.decode_text(function_arguments);
p__syncId.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClients(");
p__noOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSyncClients(p__noOfClients, p__syncId);
TTCN_Runtime::function_finished("f_serverSyncClients");
return TRUE;
} else if (!strcmp(function_name, "f_serverSyncClientsIntermediateSync")) {
INTEGER p__noOfClients;
CHARSTRING p__syncId;
INTEGER p__NoOfClientIntermediate;
CHARSTRING_template p__syncIdIntermediate;
p__noOfClients.decode_text(function_arguments);
p__syncId.decode_text(function_arguments);
p__NoOfClientIntermediate.decode_text(function_arguments);
p__syncIdIntermediate.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsIntermediateSync(");
p__noOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__NoOfClientIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__syncIdIntermediate.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSyncClientsIntermediateSync(p__noOfClients, p__syncId, p__NoOfClientIntermediate, p__syncIdIntermediate);
TTCN_Runtime::function_finished("f_serverSyncClientsIntermediateSync");
return TRUE;
} else if (!strcmp(function_name, "f_serverSyncClientsTimed")) {
INTEGER p__NoOfClients;
CHARSTRING p__syncId;
FLOAT p__execTimeLimit;
p__NoOfClients.decode_text(function_arguments);
p__syncId.decode_text(function_arguments);
p__execTimeLimit.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsTimed(");
p__NoOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__execTimeLimit.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSyncClientsTimed(p__NoOfClients, p__syncId, p__execTimeLimit);
TTCN_Runtime::function_finished("f_serverSyncClientsTimed");
return TRUE;
} else if (!strcmp(function_name, "f_serverSyncClientsTimedIntermediateSync")) {
INTEGER p__NoOfClients;
CHARSTRING p__syncId;
INTEGER p__NoOfClientIntermediate;
CHARSTRING_template p__syncIdIntermediate;
FLOAT p__execTimeLimit;
p__NoOfClients.decode_text(function_arguments);
p__syncId.decode_text(function_arguments);
p__NoOfClientIntermediate.decode_text(function_arguments);
p__syncIdIntermediate.decode_text(function_arguments);
p__execTimeLimit.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSyncClientsTimedIntermediateSync(");
p__NoOfClients.log();
TTCN_Logger::log_event_str(", ");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__NoOfClientIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__syncIdIntermediate.log();
TTCN_Logger::log_event_str(", ");
p__execTimeLimit.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSyncClientsTimedIntermediateSync(p__NoOfClients, p__syncId, p__NoOfClientIntermediate, p__syncIdIntermediate, p__execTimeLimit);
TTCN_Runtime::function_finished("f_serverSyncClientsTimedIntermediateSync");
return TRUE;
} else if (!strcmp(function_name, "f_serverWaitForAllClientsToStop")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_serverWaitForAllClientsToStop().");
TTCN_Runtime::function_started(function_arguments);
f__serverWaitForAllClientsToStop();
TTCN_Runtime::function_finished("f_serverWaitForAllClientsToStop");
return TRUE;
} else if (!strcmp(function_name, "f_connect4ClientSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_connect4ClientSync().");
TTCN_Runtime::function_started(function_arguments);
f__connect4ClientSync();
TTCN_Runtime::function_finished("f_connect4ClientSync");
return TRUE;
} else if (!strcmp(function_name, "f_disconnect4ClientSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_disconnect4ClientSync().");
TTCN_Runtime::function_started(function_arguments);
f__disconnect4ClientSync();
TTCN_Runtime::function_finished("f_disconnect4ClientSync");
return TRUE;
} else if (!strcmp(function_name, "f_clientSyncAndVerdict")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdict(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__clientSyncAndVerdict(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_clientSyncAndVerdict");
return TRUE;
} else if (!strcmp(function_name, "f_clientSyncAndVerdictPreamble")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictPreamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__clientSyncAndVerdictPreamble(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_clientSyncAndVerdictPreamble");
return TRUE;
} else if (!strcmp(function_name, "f_clientSyncAndVerdictTestBody")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictTestBody(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__clientSyncAndVerdictTestBody(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_clientSyncAndVerdictTestBody");
return TRUE;
} else if (!strcmp(function_name, "f_clientSyncAndVerdictPostamble")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSyncAndVerdictPostamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__clientSyncAndVerdictPostamble(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_clientSyncAndVerdictPostamble");
return TRUE;
} else if (!strcmp(function_name, "f_clientSync")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_clientSync(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__clientSync(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_clientSync");
return TRUE;
} else if (!strcmp(function_name, "f_clientSendStop")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_clientSendStop().");
TTCN_Runtime::function_started(function_arguments);
f__clientSendStop();
TTCN_Runtime::function_finished("f_clientSendStop");
return TRUE;
} else if (!strcmp(function_name, "f_connect4SelfSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_connect4SelfSync().");
TTCN_Runtime::function_started(function_arguments);
f__connect4SelfSync();
TTCN_Runtime::function_finished("f_connect4SelfSync");
return TRUE;
} else if (!strcmp(function_name, "f_disconnect4SelfSync")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_disconnect4SelfSync().");
TTCN_Runtime::function_started(function_arguments);
f__disconnect4SelfSync();
TTCN_Runtime::function_finished("f_disconnect4SelfSync");
return TRUE;
} else if (!strcmp(function_name, "f_selfSyncAndVerdict")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdict(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfSyncAndVerdict(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_selfSyncAndVerdict");
return TRUE;
} else if (!strcmp(function_name, "f_selfSyncAndVerdictPreamble")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictPreamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfSyncAndVerdictPreamble(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_selfSyncAndVerdictPreamble");
return TRUE;
} else if (!strcmp(function_name, "f_selfSyncAndVerdictTestBody")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictTestBody(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfSyncAndVerdictTestBody(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_selfSyncAndVerdictTestBody");
return TRUE;
} else if (!strcmp(function_name, "f_selfSyncAndVerdictPostamble")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSyncAndVerdictPostamble(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfSyncAndVerdictPostamble(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_selfSyncAndVerdictPostamble");
return TRUE;
} else if (!strcmp(function_name, "f_selfSync")) {
CHARSTRING p__syncId;
LibCommon__VerdictControl::FncRetCode p__ret;
p__syncId.decode_text(function_arguments);
p__ret.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_selfSync(");
p__syncId.log();
TTCN_Logger::log_event_str(", ");
p__ret.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__selfSync(p__syncId, p__ret);
TTCN_Runtime::function_finished("f_selfSync");
return TRUE;
} else if (!strcmp(function_name, "f_selfSyncStop")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_selfSyncStop().");
TTCN_Runtime::function_started(function_arguments);
f__selfSyncStop();
TTCN_Runtime::function_finished("f_selfSyncStop");
return TRUE;
} else if (!strcmp(function_name, "f_serverSendToAllClients")) {
ClientSyncCompList p__clientRefs;
SyncCmd_template p__syncCmd;
p__clientRefs.decode_text(function_arguments);
p__syncCmd.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_serverSendToAllClients(");
p__clientRefs.log();
TTCN_Logger::log_event_str(", ");
p__syncCmd.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__serverSendToAllClients(p__clientRefs, p__syncCmd);
TTCN_Runtime::function_finished("f_serverSendToAllClients");
return TRUE;
} else if (!strcmp(function_name, "f_serverWaitForAllClientsToShutDown")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_serverWaitForAllClientsToShutDown().");
TTCN_Runtime::function_started(function_arguments);
f__serverWaitForAllClientsToShutDown();
TTCN_Runtime::function_finished("f_serverWaitForAllClientsToShutDown");
return TRUE;
} else return FALSE;
}


} /* end of namespace */
