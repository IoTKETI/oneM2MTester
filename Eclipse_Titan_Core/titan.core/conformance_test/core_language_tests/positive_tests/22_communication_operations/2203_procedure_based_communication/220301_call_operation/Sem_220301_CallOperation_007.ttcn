/******************************************************************************
 * Copyright (C) 2017 ETSI  All Rights Reserved.
 *
 * Adrien Kirjak
 *
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles broadcast/multicast procedure call 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_007 {

    type charstring address;
    const address c_server1Addr := "server1Addr";
    const address c_server2Addr := "server2Addr";
    const address c_clientAddr := "clientAddr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_007(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_007 s_returnTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_007 s_wrongTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_007 s_callTemplate := {
        p_par1 := 1,
        p_par2 := 0, // p_par2 := -, core dump
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_007;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        timer t_timer:=5.0;

        v_myAddress := p_myAddress;
	
        //  validate multicast calling
        PCO.call(p_Sem_220301_CallOperation_007:s_callTemplate, nowait) to (c_server1Addr,c_server2Addr);
        t_timer.start;
        
        alt {
            //check that we get a reply from first server
            [] PCO.getreply(p_Sem_220301_CallOperation_007:s_returnTemplate value 1) from c_server1Addr {
                alt {
                    //check that we get a reply from second server
                    [] PCO.getreply(p_Sem_220301_CallOperation_007:s_returnTemplate value 1) from c_server2Addr {
                        setverdict(pass);
                    }
                    [] t_timer.timeout {
                        setverdict(fail);
                    }
                }
            }
            [] t_timer.timeout {
                setverdict(fail);
            }
        }
    }

    template p_Sem_220301_CallOperation_007 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

    function f_ServerResponses(address p_myAddress) runs on GeneralComp {
        var address v_clientAddress;
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
        v_myAddress := p_myAddress;
		
		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_007:s_acceptTemplate) -> param(v_par1, v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220301_CallOperation_007:{p_par1 := 0, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress; // p_par1 := -, core dump
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    function f_setAddress(address p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
    }
	
    testcase TC_Sem_220301_CallOperation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service") alive;
        var GeneralComp server2 := GeneralComp.create("RemoteProcedure Service2") alive;
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client") alive;
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server2:PCO, client:PCO);

        // set server address and start operation
        server.start(f_ServerResponses(c_server1Addr));
        server2.start(f_ServerResponses(c_server2Addr));
       
        client.start(f_ClientQuery(c_clientAddr));

        alt {
            [] client.done {
                server.stop;
                server2.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO, client:PCO);
        disconnect(server2:PCO, client:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_007());
    }

}
