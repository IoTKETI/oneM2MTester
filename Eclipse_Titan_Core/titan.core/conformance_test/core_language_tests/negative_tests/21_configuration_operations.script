.******************************************************************************
.* Copyright (C) 2017 ETSI  All Rights Reserved.
.*
.* Contributors:
.*   Adrien Kirjak 
.*
.******************************************************************************/
text.
:lang eng.
.*
:docname.Test Description
:docno.xz/152 91-CRL 113 200 Uen
:rev.PA1
:date.2016-04-04
.*
:prep.ETH/XZ EADRKIR
:subresp.EADRKIR
:appr.ETH/XZ (Elemer Lelik)
:checked.
.*
:title.ETSI TTCN3 Negative Conformance Test
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*	
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains negative tests from ETSI TTCN3 Conformance Test's 21_configuration_operations folder. 

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester.pl

:exmp.
:np.

.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2. 2101_connection_operations folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_2101_TopLevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2101_001 Verify that connect operation cannot contain a system port >

<COMPILE>

<MODULE TTCN NegSem_2101_TopLevel_001 NegSem_2101_TopLevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1, Verify that connect operation cannot contain a system port
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// In the case of connections between two test components, the connect operation shall be used.

module NegSem_2101_TopLevel_001 { 
	type port P message {
		inout integer;
	} with {extension "internal"}
	
	type component GeneralComp {
		port P p;
	}

	testcase TC_NegSem_210101_TopLevel_001() runs on GeneralComp system GeneralComp {
		connect(self:p, system:p); // error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_TopLevel_001());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The `system' component reference shall not be used in `connect' operation
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2101_TopLevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2101_002 Verify that map operation fails if both operands are component ports >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2101_TopLevel_002 NegSem_2101_TopLevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1, Verify that map operation fails if both operands are component ports
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// When connecting a test component to a test system interface the map operation shall be used.

module NegSem_2101_TopLevel_002 { 
	type port P message {
		inout integer;
	} with {extension "internal"}
	
	type component GeneralComp {
		port P p;
	}

	testcase TC_NegSem_210101_TopLevel_002() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		map(self:p, v_ptc:p); // error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_TopLevel_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Both arguments of map operation refer to test component ports.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_001 Verify that connect operation rejects ports with incompatible message type lists >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_001 NegSem_210101_connect_and_map_operations_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Verify that connect operation rejects ports with incompatible message type lists
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1 Ã¢ÂÂ inlist-PORT2 and outlist-PORT2 Ã¢ÂÂ inlist-PORT1.
//
// In this test, inlists and outlists are completely incompatible

module NegSem_210101_connect_and_map_operations_001 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		in R;
	} with {extension "internal"}
	
	type port P2 message {
	  	out bitstring;
	  	in boolean;
	} with {extension "internal"}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}

	testcase TC_NegSem_210101_connect_and_map_operations_001() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		connect(v_ptc1:p, v_ptc2:p); // incompatible message types: error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_001());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The connection between port types `@NegSem_210101_connect_and_map_operations_001.P1' and `@NegSem_210101_connect_and_map_operations_001.P2' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_002 Verify that connect operation rejects ports with only partially compatible message type lists >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_002 NegSem_210101_connect_and_map_operations_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Verify that connect operation rejects ports with only partially compatible message type lists
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1 Ã¢ÂÂ inlist-PORT2 and outlist-PORT2 Ã¢ÂÂ inlist-PORT1.
//
// In this test, one pair in outlist-PORT1 and inlist-PORT2 is incompatible (using 
// strong typing rules)

module NegSem_210101_connect_and_map_operations_002 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type record R2 {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R;
	} with {extension "internal"}
	
	type port P2 message {
	  	in R2, integer;
	  	out integer;
	} with {extension "internal"}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}

	testcase TC_NegSem_210101_connect_and_map_operations_002() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		// R2 and R are compatible types, but strong typing is required in case of connection operation
		connect(v_ptc1:p, v_ptc2:p); // incompatible message types: error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The connection between port types `@NegSem_210101_connect_and_map_operations_002.P1' and `@NegSem_210101_connect_and_map_operations_002.P2' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_003 Verify that map operation rejects ports with incompatible message type lists >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_003 NegSem_210101_connect_and_map_operations_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Verify that map operation rejects ports with incompatible message type lists
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1 Ã¢ÂÂ outlist-PORT2 and inlist-PORT2 Ã¢ÂÂ inlist-PORT1.
//
// In this test, inlists and outlists are completely incompatible

module NegSem_210101_connect_and_map_operations_003 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R;
	} with {extension "internal"}
	
	type port P2 message {
	  	out boolean;
	  	in bitstring;
	} with {extension "internal"}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_NegSem_210101_connect_and_map_operations_003() runs on GeneralComp system SystemComp {
		map(system:p, self:p);  // incompatible message types: error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The mapping between system port type `@NegSem_210101_connect_and_map_operations_003.P2' and test component port type `@NegSem_210101_connect_and_map_operations_003.P1' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_004 Verify that connect operation rejects ports with only partially compatible message type lists >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_004 NegSem_210101_connect_and_map_operations_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Verify that connect operation rejects ports with only partially compatible message type lists
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1 Ã¢ÂÂ outlist-PORT2 and inlist-PORT2 Ã¢ÂÂ inlist-PORT1.
//
// In this test, one pair in outlist-PORT1 and inlist-PORT2 is incompatible (using 
// strong typing rules)

module NegSem_210101_connect_and_map_operations_004 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type record R2 {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		in integer;
		inout R;
	} with {extension "internal"}
	
	type port P2 message {
	  in integer, R;		
	  out R2;
	} with {extension "internal"}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_NegSem_210101_connect_and_map_operations_004() runs on GeneralComp system SystemComp {
		// R2 and R are compatible types, but strong typing is required in case of connection operation
		map(system:p, self:p);  // incompatible message types: error expected
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_004());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The mapping between system port type `@NegSem_210101_connect_and_map_operations_004.P2' and test component port type `@NegSem_210101_connect_and_map_operations_004.P1' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_008 violation of strong typing rules for local ports in connect operations >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_008 NegSem_210101_connect_and_map_operations_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, violation of strong typing rules for local ports in connect operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined in the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210101_connect_and_map_operations_008 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }
    
    function f_connect() runs on GeneralComp {
        connect(self:p, self:p2); // although the actual instance of self contains the p2 port,
          // it cannot be referenced as the "runs on" clause contains the GeneralComp type and 
          // not GeneralCompEx
    }

	testcase TC_NegSem_210101_connect_and_map_operations_008() runs on GeneralCompEx system GeneralComp {
		f_connect();
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_008());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210101_connect_and_map_operations_008.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_010 violation of strong typing rules for PTC ports in connect operations >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_010 NegSem_210101_connect_and_map_operations_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, violation of strong typing rules for PTC ports in connect operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined in the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210101_connect_and_map_operations_010 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }

	testcase TC_NegSem_210101_connect_and_map_operations_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralCompEx.create;
		connect(self:p, v_ptc:p2); // although the actual PTC instance contains the p2 port,
          // it cannot be referenced as the variable v_ptc is of the GeneralComp type and 
          // not GeneralCompEx
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_010());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210101_connect_and_map_operations_010.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_and_map_operations_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_013 violation of strong typing rules for PTC ports in map operations >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_and_map_operations_013 NegSem_210101_connect_and_map_operations_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, violation of strong typing rules for PTC ports in map operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined in the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210101_connect_and_map_operations_013 { 

	type port P message {
		inout integer;
		//map param (integer p_par1); // map param not implemented
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }

	testcase TC_NegSem_210101_connect_and_map_operations_013() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralCompEx.create;
		map(system:p, v_ptc:p2); // although the actual PTC instance contains the p2 port,
          // it cannot be referenced as the variable v_ptc is of the GeneralComp type and 
          // not GeneralCompEx
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210101_connect_and_map_operations_013());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210101_connect_and_map_operations_013.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_001 Ensure that the the IUT does not allows two output port connection >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_operation_001 NegSem_210101_connect_operation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Ensure that the the IUT does not allows two output port connection
 ** @verdict  pass reject
 ***************************************************/
//Test the two output port cannot connect 
module NegSem_210101_connect_operation_001{ 
  
	type port myport message {
	  	out integer
	} with {extension "internal"}
	
	type component Mysystem
	{
		port myport messagePort;
	}
	
	testcase TC_NegSem_210101_connect_operation_001() runs on Mysystem system Mysystem {
	   	var Mysystem MyCompA;
	   	var Mysystem MyCompB;
	
		MyCompA:=Mysystem.create;
		MyCompB:=Mysystem.create;

		connect(MyCompA:messagePort, MyCompB:messagePort); //not allowed messageports are output

	}

	control{
		execute(TC_NegSem_210101_connect_operation_001());
	}
}

<END_MODULE>

<RESULT COUNT 1>
error: The connection between port types `@NegSem_210101_connect_operation_001.myport' and `@NegSem_210101_connect_operation_001.myport' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_connect_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_001 Ensure that the the IUT does not allow connecting incompatible ports >

<COMPILE>

<MODULE TTCN NegSem_210101_connect_operation_002 NegSem_210101_connect_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Ensure that the the IUT does not allow connecting incompatible ports
 ** @verdict  pass reject
 ***************************************************/
//Test the two input port cannot connect 
module NegSem_210101_connect_operation_002{ 
  
	type port myport message {
	  in integer
	} with {extension "internal"}
	
	type component Mysystem
	{
	 	port myport messagePort;
	}
	
	testcase TC_NegSem_210101_connect_operation_002() runs on Mysystem system Mysystem {
	   	var Mysystem MyCompA;
	   	var Mysystem MyCompB;
	
		MyCompA:=Mysystem.create;
		MyCompB:=Mysystem.create;

		connect(MyCompB:messagePort, MyCompA:messagePort); //not allowed messageports are output
		//connect(self:messagePort, self:messagePort);

		messagePort.send(5);

	}

	control{
		execute(TC_NegSem_210101_connect_operation_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Port type `@NegSem_210101_connect_operation_002.myport' does not have any outgoing message types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210101_map_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210101_002 Ensure that IUT cannot map input port with output port >

<COMPILE>

<MODULE TTCN NegSem_210101_map_operation_002 NegSem_210101_map_operation_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Ensure that IUT cannot map input port with output port
 ** @verdict  pass reject
 ***************************************************/
 
// Mycompport A P1 is output port mapped to SUT in port
module NegSem_210101_map_operation_002{ 

    type port loopbackPort message {
	  	in integer
	} with {extension "internal"}

	type port IntegerOutputPortType message {
	  	out integer
	} with {extension "internal"}
	
	type component GeneralComp
	{
		port IntegerOutputPortType MycomportA
	}

	type component MyTestSystemInterface
	{
	 	port loopbackPort messagePort
	}

	// MyTestSystemInterface is the test system interface
	testcase TC_NegSem_210101_map_operation_002() runs on GeneralComp system MyTestSystemInterface {
	
		// establishing the port connections
		map(mtc:MycomportA, system:messagePort); 
		//not allowed: MycomportA is out port, meanwhile MySysteminterface port is input

		setverdict(fail);

	}

	control{
		execute(TC_NegSem_210101_map_operation_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: The mapping between test component port type `@NegSem_210101_map_operation_002.IntegerOutputPortType' and system port type `@NegSem_210101_map_operation_002.loopbackPort' is not consistent
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210102_disconnect_and_unmap_operations_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210102_001 Verify that unmap operation cannot contain a system port reference >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210102_disconnect_and_unmap_operations_001 NegSem_210102_disconnect_and_unmap_operations_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Verify that unmap operation cannot contain a system port reference
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// The disconnect and unmap operations are the opposite operations of connect and map.
// (21.1) The ports of a test component can be connected to other components or to the 
// ports of the test system interface. When connecting a test component to a test system 
// interface the map operation shall be used.

module NegSem_210102_disconnect_and_unmap_operations_001 {
  
    type port P message {
        inout integer
    } with {extension "internal"}

    type component GeneralComp
    {
        port P p;
    }
	
    testcase TC_NegSem_210102_disconnect_and_unmap_operations_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
	
        connect(self:p, v_ptc:p);
        unmap(self:p, v_ptc:p); // no system port reference: error expected
    }

    control{
        execute(TC_NegSem_210102_disconnect_and_unmap_operations_001());
    }
}

<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Both arguments of unmap operation refer to test component ports. 
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210102_disconnect_and_unmap_operations_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210102_008 violation of strong typing rules for local ports in disconnect operations >

<COMPILE>

<MODULE TTCN NegSem_210102_disconnect_and_unmap_operations_008 NegSem_210102_disconnect_and_unmap_operations_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.2, violation of strong typing rules for local ports in disconnect operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210102_disconnect_and_unmap_operations_008 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }
    
    function f_disconnect() runs on GeneralComp {
        disconnect(self:p, self:p2); // although the actual instance of self contains the p2 port,
          // it cannot be referenced as the "runs on" clause contains the GeneralComp type and 
          // not GeneralCompEx
    }

	testcase TC_NegSem_210102_disconnect_and_unmap_operations_008() runs on GeneralCompEx system GeneralComp {
        connect(self:p, self:p2);
		f_disconnect();
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210102_disconnect_and_unmap_operations_008());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210102_disconnect_and_unmap_operations_008.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210102_disconnect_and_unmap_operations_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210102_010 violation of strong typing rules for PTC ports in disconnect operations >

<COMPILE>

<MODULE TTCN NegSem_210102_disconnect_and_unmap_operations_010 NegSem_210102_disconnect_and_unmap_operations_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.2, violation of strong typing rules for PTC ports in disconnect operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210102_disconnect_and_unmap_operations_010 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }

	testcase TC_NegSem_210102_disconnect_and_unmap_operations_010() runs on GeneralComp system GeneralComp {
        var GeneralCompEx v_ptc := GeneralCompEx.create;
        var GeneralComp v_ptcAlias := v_ptc;
		connect(self:p, v_ptc:p2);
        disconnect(self:p, v_ptcAlias:p2);// although the actual PTC instance contains the p2 port,
          // it cannot be referenced as the variable v_ptc is of the GeneralComp type and 
          // not GeneralCompEx
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210102_disconnect_and_unmap_operations_010());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210102_disconnect_and_unmap_operations_010.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210102_disconnect_and_unmap_operations_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210102_013 violation of strong typing rules for PTC ports in disconnect operations >

<COMPILE>

<MODULE TTCN NegSem_210102_disconnect_and_unmap_operations_013 NegSem_210102_disconnect_and_unmap_operations_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.2, violation of strong typing rules for PTC ports in unmap operations
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// If the type of the component referenced in a connection operation is known (either 
// when the component reference is a variable or value returned from a function or the 
// type is defined the runs on, mtc or system clause of the calling function), the 
// referenced port declaration shall be present in this component type.

module NegSem_210102_disconnect_and_unmap_operations_013 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		port P p;
	}
    
    type component GeneralCompEx extends GeneralComp {
        port P p2;
    }

	testcase TC_NegSem_210102_disconnect_and_unmap_operations_013() runs on GeneralComp system GeneralComp {
        var GeneralCompEx v_ptc := GeneralCompEx.create;
        var GeneralComp v_ptcAlias := v_ptc;
		map(system:p, v_ptc:p2);
        unmap(system:p, v_ptcAlias:p2);// although the actual PTC instance contains the p2 port,
          // it cannot be referenced as the variable v_ptc is of the GeneralComp type and 
          // not GeneralCompEx
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210102_disconnect_and_unmap_operations_013());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type `@NegSem_210102_disconnect_and_unmap_operations_013.GeneralComp' does not have port with name `p2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210102_disconnect_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210102_001 Ensure that mapped port cannot disconnect >

<COMPILE>

<MODULE TTCN NegSem_210102_disconnect_operation_001 NegSem_210102_disconnect_operation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that mapped port cannot disconnect
 ** @verdict  pass reject
 ***************************************************/
// System and component interface cannot disconnect
module NegSem_210102_disconnect_operation_001{
  
    type port myport message {
        inout integer
    } with {extension "internal"}

    type component Mysystem
    {
        port myport messagePort;
    }

    function f() runs on Mysystem {}
	
    testcase TC_NegSem_210102_disconnect_operation_001() runs on Mysystem system Mysystem {
        var Mysystem MyCompA;
	
        MyCompA:=Mysystem.create;

        map(MyCompA:messagePort,system:messagePort);

        MyCompA.start(f());

        disconnect(MyCompA:messagePort,system:messagePort); // system interface cannot disconnect

    }
    control{
        execute(TC_NegSem_210102_disconnect_operation_001());
    }
}

<END_MODULE>

<RESULT COUNT 1>
 error: The `system' component reference shall not be used in `disconnect' operation
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 2102_test_case_operations folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_2102_testcase_stop_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2102_001 Stopping test case >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2102_testcase_stop_001 NegSem_2102_testcase_stop_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.2, Stopping test case
 ** @verdict  pass reject
 ***************************************************/
// Explicit test case termination test
module NegSem_2102_testcase_stop_001 {
    type component GeneralComp {}
    
	testcase TC_NegSem_2102_testcase_stop_001() runs on GeneralComp {
        var boolean v_b := true;
		
		setverdict(pass, "Unexpected termination with verdict pass");

        testcase.stop("Expected Termination with verdict error"); 
		// stop runing test case now with verdict error
	}
    
    control {
        execute(TC_NegSem_2102_testcase_stop_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: testcase.stop
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 2103_test_component_operations folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_210301_CreateOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210301_001 Ensure that named components on hosts are accepted >

<COMPILE>

<MODULE TTCN NegSem_210301_CreateOperation_001 NegSem_210301_CreateOperation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named components on hosts are accepted
 ** @verdict  pass reject
 *****************************************************************/
module NegSem_210301_CreateOperation_001 {

    type component GeneralComp { }

    testcase TC_NegSem_210301_CreateOperation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create(5); // it should expect charstring
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210301_CreateOperation_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: First operand of operation `create\(\)' should be charstring value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210301_CreateOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210301_002 Ensure that named components on hosts are accepted >

<COMPILE>

<MODULE TTCN NegSem_210301_CreateOperation_002 NegSem_210301_CreateOperation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named components on hosts are accepted
 ** @verdict  pass reject
 *****************************************************************/
module NegSem_210301_CreateOperation_002 {

    type component GeneralComp { }

    testcase TC_NegSem_210301_CreateOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create(true); // it should expect charstring
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210301_CreateOperation_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: First operand of operation `create\(\)' should be charstring value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210301_CreateOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210301_003 Ensure that named components on hosts are accepted >

<COMPILE>

<MODULE TTCN NegSem_210301_CreateOperation_003 NegSem_210301_CreateOperation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named components on hosts are accepted
 ** @verdict  pass reject
 *****************************************************************/
module NegSem_210301_CreateOperation_003 {

    type component GeneralComp { }

    testcase TC_NegSem_210301_CreateOperation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create(-, 'CAFFEE'O); // it should expect charstring
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210301_CreateOperation_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Second operand of operation `create\(\)' should be charstring value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_001 Ensure that non-alive ptc cannot start again >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210302_Start_test_component_001 NegSem_210302_Start_test_component_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, Ensure that non-alive ptc cannot start again
 ** @verdict  pass reject
 *****************************************************************/
//Non alive test component cannot start another function behavior
module NegSem_210302_Start_test_component_001 {

    type component GeneralComp { }
	function f() runs on GeneralComp {}
	function f2() runs on GeneralComp {}
	
    testcase TC_NegSem_210302_Start_test_component_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
		ptc:=GeneralComp.create;
		
		ptc.start(f()); 
		ptc.done; 
		ptc.start(f2()); // test case error, ptc is non-alive
	
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210302_Start_test_component_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: 
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_002 Ensure that only component type is allowed for ptc declaration >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_002 NegSem_210302_Start_test_component_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, Ensure that only component type is allowed for ptc declaration
 ** @verdict  pass reject
 *****************************************************************/
// VariableRef (being a component type variable, a component type parameter
module NegSem_210302_Start_test_component_002 {

    type component GeneralComp { }

	type  record Rectype{}

	function f() runs on GeneralComp {} 

    testcase TC_NegSem_210302_Start_test_component_002() runs on GeneralComp system GeneralComp {
        var Rectype ptc; 
		ptc:= GeneralComp.create; 
		// VariableRef (being a component type variable, a component type parameter
		
		ptc.start(f()); 
	
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210302_Start_test_component_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210302_Start_test_component_002.Rectype'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_003 Ensure that only component type is allowed for ptc declaration >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_003 NegSem_210302_Start_test_component_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, altstep in test component start operation
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// The start operation shall bind the required behaviour to the test component. This 
// behaviour is defined by reference to an already defined function.

module NegSem_210302_Start_test_component_003 { 

	type port P message {
		inout integer;
	}

	type component GeneralComp {
        port P p;
	}
    
    altstep a_test() runs on GeneralComp {
        [] p.receive(integer:?) {
            setverdict(pass);
        }
    }
    
	testcase TC_NegSem_210302_Start_test_component_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
		p.send(1);
        v_ptc.start(a_test());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a function was expected in the argument instead of altstep `@NegSem_210302_Start_test_component_003.a_test'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_004 starting behaviour on already running non-alive component >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210302_Start_test_component_004 NegSem_210302_Start_test_component_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, starting behaviour on already running non-alive component
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Starting a second behaviour function on a non-alive PTC or starting a function 
// on a PTC that is still running results in a test case error.

module NegSem_210302_Start_test_component_004 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        timer t_tmr := 10.0;
        t_tmr.start;
        t_tmr.timeout;
    }
    
	testcase TC_NegSem_210302_Start_test_component_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.start(f_ptcBehaviour());
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_004());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Error message was received from MC: PTC with component reference 3 cannot be started because it is already executing function NegSem_210302_Start_test_component_004.f_ptcBehaviour.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_005 starting behaviour on already running non-alive component >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210302_Start_test_component_005 NegSem_210302_Start_test_component_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, starting behaviour on already running non-alive component
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Starting a second behaviour function on a non-alive PTC or starting a function 
// on a PTC that is still running results in a test case error.

module NegSem_210302_Start_test_component_005 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        timer t_tmr := 10.0;
        t_tmr.start;
        t_tmr.timeout;
    }
    
	testcase TC_NegSem_210302_Start_test_component_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        v_ptc.start(f_ptcBehaviour());
        v_ptc.start(f_ptcBehaviour());
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_005());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Error message was received from MC: PTC with component reference 3 cannot be started because it is already executing function NegSem_210302_Start_test_component_005.f_ptcBehaviour.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_006 function invocation in the start operation doesn't return a component >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_006 NegSem_210302_Start_test_component_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, function invocation in the start operation doesn't return a component
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// The variable associated with VariableRef (being a component type variable, 
// a component type parameter, etc.) or the return type associated with 
// FunctionInstance shall be of component type.

module NegSem_210302_Start_test_component_006 { 

	type component GeneralComp {
	}
    
    type record R {
        GeneralComp comp
    }
    
    function f_create() return R {
        var R v_rec := { GeneralComp.create("PTC") }
        return v_rec;
    }
    
    function f_ptcBehaviour() runs on GeneralComp {
    }
    
	testcase TC_NegSem_210302_Start_test_component_006() runs on GeneralComp system GeneralComp {
        f_create().start(f_ptcBehaviour());
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_006());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210302_Start_test_component_006.R'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_007 starting function with incompatible "runs on" clause >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_007 NegSem_210302_Start_test_component_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, starting function with incompatible "runs on" clause
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// The function invoked in a start test component operation shall have a runs on 
// definition referencing a component type that is compatible with the newly 
// created component (see clause 6.3.3).

module NegSem_210302_Start_test_component_007 { 

	type component GeneralComp {
        var charstring vc_str := "abc";
	}

  	type component DifferentComp {
          var integer vc_int := 0;
	}

    
    function f_ptcBehaviour() runs on DifferentComp {
        setverdict(pass, "Executing PTC behaviour...");
    }
    
	testcase TC_NegSem_210302_Start_test_component_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_007());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Component type mismatch: The component reference is of type `@NegSem_210302_Start_test_component_007.GeneralComp', but function `@NegSem_210302_Start_test_component_007.f_ptcBehaviour' runs on `@NegSem_210302_Start_test_component_007.DifferentComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_008 passing port to started component function >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_008 NegSem_210302_Start_test_component_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, passing port to started component function
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Ports, defaults and timers shall not be passed into a function invoked in a start 
// test component operation.

module NegSem_210302_Start_test_component_008 { 

	type port P message {
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
        port P p;
	}
    
    function f_behaviour(P p_port) runs on GeneralComp {
        p_port.receive(integer:?);
        setverdict(pass);
    }
    
	testcase TC_NegSem_210302_Start_test_component_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, self:p);
		p.send(1);
        v_ptc.start(f_behaviour(p));
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_008());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Function `@NegSem_210302_Start_test_component_008.f_behaviour' cannot be started on a parallel test component because it has port parameter `p_port'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_009 passing default to started component function >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_009 NegSem_210302_Start_test_component_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, passing default to started component function
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Ports, defaults and timers shall not be passed into a function invoked in a start 
// test component operation.

module NegSem_210302_Start_test_component_009 { 

	type component GeneralComp {
	}
    
    function f_behaviour(default p_default) runs on GeneralComp {
        setverdict(pass);
    }
    
    altstep a_timeout() {
        [] any timer.timeout { }
    }
    
	testcase TC_NegSem_210302_Start_test_component_009() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        var default v_def := activate(a_timeout());
        v_ptc.start(f_behaviour(v_def));
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_009());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Default type cannot be a parameter or embedded in a parameter of a function used in a start operation. Function `@NegSem_210302_Start_test_component_009.f_behaviour' cannot be started on a parallel test component because of `value parameter `p_default''
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_010 passing timer to started component function >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_010 NegSem_210302_Start_test_component_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, passing timer to started component function
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Ports, defaults and timers shall not be passed into a function invoked in a start 
// test component operation.

module NegSem_210302_Start_test_component_010 { 

    type component GeneralComp {
	}
    
    function f_behaviour(timer t_tmr) runs on GeneralComp {
        t_tmr.timeout;
        setverdict(pass);
    }
    
	testcase TC_NegSem_210302_Start_test_component_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        timer t_tmr := 0.0;
        t_tmr.start;
        v_ptc.start(f_behaviour(t_tmr));
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_010());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Function `@NegSem_210302_Start_test_component_010.f_behaviour' cannot be started on a parallel test component because it has timer parameter `t_tmr'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_011 passing structured value containing ports to started component function >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_011 NegSem_210302_Start_test_component_011.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, passing structured value containing ports to started component function
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// All formal parameter types of the function shall neither be of port or default type
// or should contain a direct or indirect element or field of port or default type.

module NegSem_210302_Start_test_component_011 { 

	type port P message {
		inout integer;
	}
    
    type P PortArray[2];

	type component GeneralComp {
        port P p[2];
	}
    
    function f_behaviour(PortArray p_ports) runs on GeneralComp {
        p_ports[0].receive(integer:?);
        setverdict(pass);
    }
    
	testcase TC_NegSem_210302_Start_test_component_011() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p[0], self:p[0]);
		p[0].send(1);
        v_ptc.start(f_behaviour(p));
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_011());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Port type `@NegSem_210302_Start_test_component_011.P' cannot be a parameter or embedded in a parameter of a function used in a start operation. Function `@NegSem_210302_Start_test_component_011.f_behaviour' cannot be started on a parallel test component because of `value parameter `p_ports''
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210302_Start_test_component_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210302_012 passing structured value containing ports to started component function >

<COMPILE>

<MODULE TTCN NegSem_210302_Start_test_component_012 NegSem_210302_Start_test_component_012.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.2, passing default to started component function
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// All formal parameter types of the function shall neither be of port or default type
// or should contain a direct or indirect element or field of port or default type.

module NegSem_210302_Start_test_component_012 { 

    type record R {
        default def
    }
    
	type component GeneralComp {
	}
    
    function f_behaviour(R p_def) runs on GeneralComp {
        setverdict(pass);
    }
    
    altstep a_timeout() {
        [] any timer.timeout { }
    }
    
	testcase TC_NegSem_210302_Start_test_component_012() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        var R v_def := { def := activate(a_timeout()) };
        v_ptc.start(f_behaviour(v_def));
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_NegSem_210302_Start_test_component_012());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Default type cannot be a parameter or embedded in a parameter of a function used in a start operation. Function `@NegSem_210302_Start_test_component_012.f_behaviour' cannot be started on a parallel test component because of `value parameter `p_def''
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210303_Stop_test_component_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210303_001 restarting explicitly stopped non-alive component >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210303_Stop_test_component_001 NegSem_210303_Stop_test_component_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.3, restarting explicitly stopped non-alive component
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Stopping a non-alive-type test component (implicitly or explicitly) shall destroy 
// it and all resources associated with the test component shall be released.

module NegSem_210303_Stop_test_component_001 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        p.receive(integer:?);
	}
	
    testcase TC_NegSem_210303_Stop_test_component_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;
		ptc.start(f());
        ptc.stop;
        ptc.start(f());
		setverdict(pass);
    }

    control {
        execute(TC_NegSem_210303_Stop_test_component_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Error message was received from MC: PTC with component reference 3 cannot be started because it is not alive anymore.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210303_Stop_test_component_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210303_002 stopping all PTCs from a PTC >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210303_Stop_test_component_002 NegSem_210303_Stop_test_component_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.3, stopping all PTCs from a PTC
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The all keyword can be used by the MTC only in order to stop all running PTCs but 
// the MTC itself.

module NegSem_210303_Stop_test_component_002 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        all component.stop;
	}
	
    testcase TC_NegSem_210303_Stop_test_component_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;
		ptc.start(f()); 
        ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210303_Stop_test_component_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Operation 'all component.stop' can only be performed on the MTC.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210303_Stop_test_component_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210303_003 applying stop operation to a variable of a different than component type >

<COMPILE>

<MODULE TTCN NegSem_210303_Stop_test_component_003 NegSem_210303_Stop_test_component_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.3, applying stop operation to a variable of a different than component type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable associated with VariableRef (being a component type variable, a component
// type parameter, etc.) or the return type associated with FunctionInstance shall be of
// component type.

module NegSem_210303_Stop_test_component_003 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f_behaviour() runs on GeneralComp {
        p.receive(integer:?); // infinite blocking
	}
	
    testcase TC_NegSem_210303_Stop_test_component_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc[2];
        v_ptc[0] := GeneralComp.create;
        v_ptc[1] := GeneralComp.create;
        v_ptc[0].start(f_behaviour());
        v_ptc[1].start(f_behaviour());
		v_ptc.stop;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210303_Stop_test_component_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210303_Stop_test_component_003.GeneralComp\[2\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210303_Stop_test_component_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210303_004 applying stop operation to a variable of a different than component type >

<COMPILE>

<MODULE TTCN NegSem_210303_Stop_test_component_004 NegSem_210303_Stop_test_component_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.3, applying stop operation to a function call result of a different than component type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable associated with VariableRef (being a component type variable, a component
// type parameter, etc.) or the return type associated with FunctionInstance shall be of
// component type.

module NegSem_210303_Stop_test_component_004 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
    type GeneralComp CompArray[2];
    
	function f_behaviour() runs on GeneralComp {
        p.receive(integer:?); // infinite blocking
	}
       
    function f_createComponents() return CompArray {
        var CompArray v_ptc;
        v_ptc[0] := GeneralComp.create;
        v_ptc[1] := GeneralComp.create;
        v_ptc[0].start(f_behaviour());
        v_ptc[1].start(f_behaviour());
        return v_ptc;
    }
	
    testcase TC_NegSem_210303_Stop_test_component_004() runs on GeneralComp system GeneralComp {
        f_createComponents().stop;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210303_Stop_test_component_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210303_Stop_test_component_004.GeneralComp\[2\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210304_kill_test_component_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210304_001 restarting explicitly killed non-alive component >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210304_kill_test_component_001 NegSem_210304_kill_test_component_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.4, restarting explicitly killed non-alive component
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The kill operation applied on a test component stops the execution of the currently
// running behaviour - if any - of that component and frees all resources associated 
// to it (including all port connections of the killed component) and removes the 
// component from the test system.

module NegSem_210304_kill_test_component_001 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        p.receive(integer:?);
	}
	
    testcase TC_NegSem_210304_kill_test_component_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;
		ptc.start(f());
        ptc.kill;
        ptc.start(f());
		setverdict(pass);
    }

    control {
        execute(TC_NegSem_210304_kill_test_component_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: PTC with component reference 3 is not alive anymore. Start operation cannot be performed on it.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210304_kill_test_component_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210304_002 restarting explicitly killed alive component >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210304_kill_test_component_002 NegSem_210304_kill_test_component_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.3, restarting explicitly killed alive component
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The kill operation applied on a test component stops the execution of the currently
// running behaviour - if any - of that component and frees all resources associated 
// to it (including all port connections of the killed component) and removes the 
// component from the test system.

module NegSem_210304_kill_test_component_002 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        p.receive(integer:?);
	}
	
    testcase TC_NegSem_210304_kill_test_component_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create alive;
		ptc.start(f());
        ptc.kill;
        ptc.start(f());
		setverdict(pass);
    }

    control {
        execute(TC_NegSem_210304_kill_test_component_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: PTC with component reference 3 is not alive anymore. Start operation cannot be performed on it.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210304_kill_test_component_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210304_003 killing all PTCs from a PTC >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210304_kill_test_component_003 NegSem_210304_kill_test_component_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.4, killing all PTCs from a PTC
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The all keyword can be used by the MTC only in order to stop and kill all running PTCs
// but the MTC itself.

module NegSem_210304_kill_test_component_003 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        all component.kill;
	}
	
    testcase TC_NegSem_210304_kill_test_component_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;
		ptc.start(f()); 
        ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210304_kill_test_component_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Operation 'all component.kill' can only be performed on the MTC.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210304_kill_test_component_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210304_004 applying kill operation to a variable of a different than component type >

<COMPILE>

<MODULE TTCN NegSem_210304_kill_test_component_004 NegSem_210304_kill_test_component_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.4, applying kill operation to a variable of a different than component type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable associated with VariableRef (being a component type variable, a component
// type parameter, etc.) or the return type associated with FunctionInstance shall be of
// component type.

module NegSem_210304_kill_test_component_004 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
	function f_behaviour() runs on GeneralComp {
        p.receive(integer:?); // infinite blocking
	}
	
    testcase TC_NegSem_210304_kill_test_component_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc[2];
        v_ptc[0] := GeneralComp.create;
        v_ptc[1] := GeneralComp.create;
        v_ptc[0].start(f_behaviour());
        v_ptc[1].start(f_behaviour());
		v_ptc.kill;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210304_kill_test_component_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210304_kill_test_component_004.GeneralComp\[2\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210304_kill_test_component_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210304_005 applying kill operation to a function call result of a different than component type >

<COMPILE>

<MODULE TTCN NegSem_210304_kill_test_component_005 NegSem_210304_kill_test_component_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.4, applying kill operation to a function call result of a different than component type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable associated with VariableRef (being a component type variable, a component
// type parameter, etc.) or the return type associated with FunctionInstance shall be of
// component type.

module NegSem_210304_kill_test_component_005 {

    type port P message {
        inout integer;
    } with {extension "internal"}
    
    type component GeneralComp {
        port P p;
    }
    
    type GeneralComp CompArray[2];
    
	function f_behaviour() runs on GeneralComp {
        p.receive(integer:?); // infinite blocking
	}
       
    function f_createComponents() return CompArray {
        var CompArray v_ptc;
        v_ptc[0] := GeneralComp.create;
        v_ptc[1] := GeneralComp.create;
        v_ptc[0].start(f_behaviour());
        v_ptc[1].start(f_behaviour());
        return v_ptc;
    }
	
    testcase TC_NegSem_210304_kill_test_component_005() runs on GeneralComp system GeneralComp {
        f_createComponents().kill;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_210304_kill_test_component_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component type instead of `@NegSem_210304_kill_test_component_005.GeneralComp\[2\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210305_alive_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_001 Verify that error occurs when any from alive is applied to single component >

<COMPILE>

<MODULE TTCN NegSem_210305_alive_operation_001 NegSem_210305_alive_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when any from alive is applied to single component
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction b 
// The ComponentArrayRef shall be a reference to a component array variable identifier.
module NegSem_210305_alive_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210305_alive_operation_001() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());
        v_isAlive := any from v_ptc.alive;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSem_210305_alive_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The operand of operation `alive': Type mismatch: component array reference was expected instead of `@NegSem_210305_alive_operation_001.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210305_alive_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_003 Verify that error occurs when any from alive is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_210305_alive_operation_003 NegSem_210305_alive_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when any from alive is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210305_alive_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}

	function f_done() runs on GeneralComp {}
	
    testcase TC_NegSem_210305_alive_operation_003() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var float v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].start(f_done()); } //quick done components on even indices
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isAlive := any from v_ptc.alive -> @index value v_index;
        if(v_index == 1.0){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSem_210305_alive_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of component arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210305_alive_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_004 Verify that any from alive index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_210305_alive_operation_004 NegSem_210305_alive_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210305_alive_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}

	function f_done() runs on GeneralComp {}
	
    testcase TC_NegSem_210305_alive_operation_004() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[1];
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].start(f_done()); } //quick done components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}
        v_isAlive := any from v_ptc.alive -> @index value v_index;
        if(v_index[0] == 1 and v_index[1] == 0){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_NegSem_210305_alive_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the component array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210305_alive_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_005 Verify that any from alive index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_210305_alive_operation_005 NegSem_210305_alive_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210305_alive_operation_005 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}

	function f_done() runs on GeneralComp {}
	
    testcase TC_NegSem_210305_alive_operation_005() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].start(f_done()); } //quick done components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}
        v_isAlive := any from v_ptc.alive -> @index value v_index;
        if(v_index == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_NegSem_210305_alive_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional component arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210305_alive_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_001 Verify that error occurs when using index redirection in component.alive operation >

<COMPILE>

<MODULE TTCN NegSyn_210305_alive_operation_001 NegSyn_210305_alive_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when using index redirection in component.alive operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210305_alive_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210305_alive_operation_001() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isAlive := v_ptc.alive -> @index value v_index;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSyn_210305_alive_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210305_alive_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_002 Verify that error occurs when using index redirection in any component.alive operation >

<COMPILE>

<MODULE TTCN NegSyn_210305_alive_operation_002 NegSyn_210305_alive_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when using index redirection in any component.alive operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210305_alive_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210305_alive_operation_002() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isAlive := any component.alive -> @index value v_index;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSyn_210305_alive_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210305_alive_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_003 Verify that error occurs when using index redirection in all component.alive operation >

<COMPILE>

<MODULE TTCN NegSyn_210305_alive_operation_003 NegSyn_210305_alive_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when using index redirection in all component.alive operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210305_alive_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210305_alive_operation_003() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isAlive := all component.alive -> @index value v_index;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSyn_210305_alive_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210305_alive_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210305_004 Verify that error occurs when using index redirection in function instance.alive operation >

<COMPILE>

<MODULE TTCN NegSyn_210305_alive_operation_004 NegSyn_210305_alive_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that error occurs when using index redirection in function instance.alive operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210305_alive_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
	function initComp() return GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
		return v_ptc;
	}
	
    testcase TC_NegSyn_210305_alive_operation_004() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		var integer v_index;
        v_isAlive := initComp().alive -> @index value v_index;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_NegSyn_210305_alive_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210306_running_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_001 Verify that error occurs when any from running is applied to single component >

<COMPILE>

<MODULE TTCN NegSem_210306_running_operation_001 NegSem_210306_running_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when any from running is applied to single component
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction b 
// The ComponentArrayRef shall be a reference to a component array variable identifier.
module NegSem_210306_running_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210306_running_operation_001() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());
        v_isRunning := any from v_ptc.running;

        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSem_210306_running_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The operand of operation `component running': Type mismatch: component array reference was expected instead of `@NegSem_210306_running_operation_001.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210306_running_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_002 Verify that error occurs when any from running is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_210306_running_operation_002 NegSem_210306_running_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when any from running is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210306_running_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210306_running_operation_002() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

        v_isRunning := any from v_ptc.running -> @index value v_index;

        if(v_index[0] == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSem_210306_running_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional component arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210306_running_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_003 Verify that error occurs when any from running is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_210306_running_operation_003 NegSem_210306_running_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when any from running is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210306_running_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210306_running_operation_003() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var float v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

        v_isRunning := any from v_ptc.running -> @index value v_index;

        if(v_index == 1.0){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSem_210306_running_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of component arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210306_running_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_004 Verify that any from running index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_210306_running_operation_004 NegSem_210306_running_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210306_running_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210306_running_operation_004() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

        v_isRunning := any from v_ptc.running -> @index value v_index;
        if(v_index[0] == 1 and v_index[1] == 0){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_NegSem_210306_running_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the component array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210306_running_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_005 Verify that any from running index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_210306_running_operation_005 NegSem_210306_running_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210306_running_operation_005 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210306_running_operation_005() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

        v_isRunning := any from v_ptc.running -> @index value v_index;

        if(v_index == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_NegSem_210306_running_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional component arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210306_running_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_001 Verify that error occurs when using index redirection in component.running operation >

<COMPILE>

<MODULE TTCN NegSyn_210306_running_operation_001 NegSyn_210306_running_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when using index redirection in component.running operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210306_running_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210306_running_operation_001() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isRunning := v_ptc.running -> @index value v_index;

        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSyn_210306_running_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210306_running_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_002 Verify that error occurs when using index redirection in any component.running operation >

<COMPILE>

<MODULE TTCN NegSyn_210306_running_operation_002 NegSyn_210306_running_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when using index redirection in any component.running operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210306_running_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210306_running_operation_002() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isRunning := any component.running -> @index value v_index;

        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSyn_210306_running_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210306_running_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_003 Verify that error occurs when using index redirection in all component.running operation >

<COMPILE>

<MODULE TTCN NegSyn_210306_running_operation_003 NegSyn_210306_running_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when using index redirection in all component.running operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210306_running_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210306_running_operation_003() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        v_isRunning := all component.running -> @index value v_index;

        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSyn_210306_running_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210306_running_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210306_004 Verify that error occurs when using index redirection in function instance.running operation >

<COMPILE>

<MODULE TTCN NegSyn_210306_running_operation_004 NegSyn_210306_running_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that error occurs when using index redirection in function instance.running operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210306_running_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
	function initComp() return GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
		return v_ptc;
	}
	
    testcase TC_NegSyn_210306_running_operation_004() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		var integer v_index;
        v_isRunning := initComp().running -> @index value v_index;

        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_NegSyn_210306_running_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_001 Ensure that done operator can be used only for ptcs. >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_001 NegSem_210307_done_operation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Ensure that done operator can be used only for ptcs.
 ** @verdict  pass reject
 *****************************************************************/
// Done operator can be used only for ptcs, not for mtcs.

module NegSem_210307_done_operation_001 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_NegSem_210307_done_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1());  
        
		GeneralComp.done; // not allowed. Done only allowed for ptcs.
		
    }

    control {
        execute(TC_NegSem_210307_done_operation_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a value was expected instead of type `@NegSem_210307_done_operation_001.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_002 Verify that error occurs when any from done is applied to single component >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_002 NegSem_210307_done_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when any from done is applied to single component
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c 
// The ComponentArrayRef shall be a reference to a component array variable identifier.
module NegSem_210307_done_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210307_done_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());
		alt
		{
        	[] any from v_ptc.done { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}
    }

    control {
        execute(TC_NegSem_210307_done_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component array type instead of `@NegSem_210307_done_operation_002.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_003 Verify that error occurs when any from done is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_003 NegSem_210307_done_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when any from done is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210307_done_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210307_done_operation_003() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

		alt
		{
        	[] any from v_ptc.done -> @index value v_index 
			{ 
				if(v_index[0] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}       
    }

    control {
        execute(TC_NegSem_210307_done_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional component arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_004 Verify that error occurs when any from done is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_004 NegSem_210307_done_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when any from done is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210307_done_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210307_done_operation_004() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var float v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

		alt
		{
        	[] any from v_ptc.done -> @index value v_index 
			{ 
				if(v_index == 1.0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210307_done_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of component arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_005 Verify that any from done index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_005 NegSem_210307_done_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction f:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210307_done_operation_005 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210307_done_operation_005() runs on GeneralComp system GeneralComp {
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

        alt
		{
        	[] any from v_ptc.done -> @index value v_index 
			{ 
				if(v_index[0] == 1 and v_index[1] == 0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210307_done_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the component array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_006 Verify that any from done index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_210307_done_operation_006 NegSem_210307_done_operation_006.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction f:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210307_done_operation_006 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210307_done_operation_006() runs on GeneralComp system GeneralComp {
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

		alt
		{
        	[] any from v_ptc.done -> @index value v_index 
			{ 
				if(v_index == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210307_done_operation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional component arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210307_done_operation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_010 partially initialized array in any from ComponentArrayRef.done >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210307_done_operation_010 NegSem_210307_done_operation_010.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, partially initialized array in any from ComponentArrayRef.done
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The ComponentArrayRef shall be a reference to a completely initialized component array.

module NegSem_210307_done_operation_010 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_NegSem_210307_done_operation_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[2];
        var verdicttype v_verdict;
        v_ptcs[0] := GeneralComp.create;
        v_ptcs[0].start(f());
		alt {
			[] any from v_ptcs.done { 
                setverdict(pass);
            }
		}
    }

    control {
        execute(TC_NegSem_210307_done_operation_010(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Performing done operation on an unbound component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210307_done_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_001 Verify that error occurs when using index redirection in component.done operation >

<COMPILE>

<MODULE TTCN NegSyn_210307_done_operation_001 NegSyn_210307_done_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when using index redirection in component.done operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210307_done_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210307_done_operation_001() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());	
		alt
		{
        	[] v_ptc.done -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210307_done_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210307_done_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_002 Verify that error occurs when using index redirection in any component.done operation >

<COMPILE>

<MODULE TTCN NegSyn_210307_done_operation_002 NegSyn_210307_done_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when using index redirection in any component.done operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210307_done_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210307_done_operation_002() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        alt
		{
        	[] any component.done -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210307_done_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->, expecting '{'
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210307_done_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_003 Verify that error occurs when using index redirection in all component.done operation >

<COMPILE>

<MODULE TTCN NegSyn_210307_done_operation_003 NegSyn_210307_done_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when using index redirection in all component.done operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210307_done_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210307_done_operation_003() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
		alt
		{
        	[] all component.done -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210307_done_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->, expecting '{'
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210307_done_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210307_004 Verify that error occurs when using index redirection in function instance.done operation >

<COMPILE>

<MODULE TTCN NegSyn_210307_done_operation_004 NegSyn_210307_done_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that error occurs when using index redirection in function instance.done operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210307_done_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
	function f_getComp(GeneralComp p_ptc) return GeneralComp {
		return p_ptc;
	}
	
    testcase TC_NegSyn_210307_done_operation_004() runs on GeneralComp system GeneralComp {
		var integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		alt
		{
        	[] any from f_getComp(v_ptc).done -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't find done components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210307_done_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component array type instead of `@NegSyn_210307_done_operation_004.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_001 Ensure that killed operator is only valid for ptcs. >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_001 NegSem_210308_killed_operation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Ensure that killed operator is only valid for ptcs.
 ** @verdict  pass reject
 *****************************************************************/
// killed operator is not allowed for mtc check.

module NegSem_210308_killed_operation_001 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_NegSem_210308_killed_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1());  
        
        mtc.killed; // not allowed. killed only allowed for ptcs.
        
		alt {
			[] any component.killed {setverdict(pass);} 
		}
    }

    control {
        execute(TC_NegSem_210308_killed_operation_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `killed': syntax error, unexpected DotKilledKeyword, expecting DotKillKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_002 Verify that error occurs when any from killed is applied to single component >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_002 NegSem_210308_killed_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when any from killed is applied to single component
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction b 
// The ComponentArrayRef shall be a reference to a component array variable identifier.
module NegSem_210308_killed_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210308_killed_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.kill;
		alt
		{
        	[] any from v_ptc.killed { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}
    }

    control {
        execute(TC_NegSem_210308_killed_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component array type instead of `@NegSem_210308_killed_operation_002.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_003 Verify that error occurs when any from killed is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_003 NegSem_210308_killed_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when any from killed is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210308_killed_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210308_killed_operation_003() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

		alt
		{
        	[] any from v_ptc.killed -> @index value v_index 
			{ 
				if(v_index[0] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}       
    }

    control {
        execute(TC_NegSem_210308_killed_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional component arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_004 Verify that error occurs when any from killed is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_004 NegSem_210308_killed_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when any from killed is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction d
// If the index redirection is used for single-dimensional component arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_210308_killed_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210308_killed_operation_004() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var float v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}

		alt
		{
        	[] any from v_ptc.killed -> @index value v_index 
			{ 
				if(v_index == 1.0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210308_killed_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of component arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_005 Verify that any from killed index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_005 NegSem_210308_killed_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210308_killed_operation_005 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210308_killed_operation_005() runs on GeneralComp system GeneralComp {
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[1];

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

        alt
		{
        	[] any from v_ptc.killed -> @index value v_index 
			{ 
				if(v_index[0] == 1 and v_index[1] == 0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210308_killed_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the component array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_006 Verify that any from killed index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_210308_killed_operation_006 NegSem_210308_killed_operation_006.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_210308_killed_operation_006 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSem_210308_killed_operation_006() runs on GeneralComp system GeneralComp {
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index;

		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}

		alt
		{
        	[] any from v_ptc.killed -> @index value v_index 
			{ 
				if(v_index == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Invalid index value");
		        }
				setverdict(pass); 
			}
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		} 
    }

    control {
        execute(TC_NegSem_210308_killed_operation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional component arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_210308_killed_operation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_010 partially initialized array in any from ComponentArrayRef.killed >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_210308_killed_operation_010 NegSem_210308_killed_operation_010.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.7, partially initialized array in any from ComponentArrayRef.killed
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The ComponentArrayRef shall be a reference to a completely initialized component array.

module NegSem_210308_killed_operation_010 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_NegSem_210308_killed_operation_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[2];
        var verdicttype v_verdict;
        v_ptcs[0] := GeneralComp.create;
        v_ptcs[0].start(f());
		alt {
			[] any from v_ptcs.killed { 
                setverdict(pass);
            }
		}
    }

    control {
        execute(TC_NegSem_210308_killed_operation_010(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Performing killed operation on an unbound component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210308_killed_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_001 Verify that error occurs when using index redirection in component.killed operation >

<COMPILE>

<MODULE TTCN NegSyn_210308_killed_operation_001 NegSyn_210308_killed_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when using index redirection in component.killed operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210308_killed_operation_001 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210308_killed_operation_001() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());	
		alt
		{
        	[] v_ptc.killed -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210308_killed_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->, expecting '{'
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210308_killed_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_002 Verify that error occurs when using index redirection in any component.killed operation >

<COMPILE>

<MODULE TTCN NegSyn_210308_killed_operation_002 NegSyn_210308_killed_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when using index redirection in any component.killed operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210308_killed_operation_002 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210308_killed_operation_002() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
        alt
		{
        	[] any component.killed -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210308_killed_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->, expecting '{'
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210308_killed_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_003 Verify that error occurs when using index redirection in all component.killed operation >

<COMPILE>

<MODULE TTCN NegSyn_210308_killed_operation_003 NegSyn_210308_killed_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when using index redirection in all component.killed operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210308_killed_operation_003 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_NegSyn_210308_killed_operation_003() runs on GeneralComp system GeneralComp {
		var integer v_index;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f());		
		alt
		{
        	[] all component.killed -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210308_killed_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `->': syntax error, unexpected ->, expecting '{'
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_210308_killed_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 210308_004 Verify that error occurs when using index redirection in function instance.killed operation >

<COMPILE>

<MODULE TTCN NegSyn_210308_killed_operation_004 NegSyn_210308_killed_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that error occurs when using index redirection in function instance.killed operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction c
// The index redirection shall only be used when the operation is used on an any from 
// component array construct.
module NegSyn_210308_killed_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}
	
	function f_getComp(GeneralComp p_ptc) return GeneralComp {
		return p_ptc;
	}
	
    testcase TC_NegSyn_210308_killed_operation_004() runs on GeneralComp system GeneralComp {
		var integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		alt
		{
        	[] any from f_getComp(v_ptc).killed -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't find killed components"); } 
		}
    }

    control {
        execute(TC_NegSyn_210308_killed_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: The type of the operand should be a component array type instead of `@NegSyn_210308_killed_operation_004.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.1/174 02-CRL 113 200/5 Uen
:nl.Statement of Compliance for TITAN project
:li D='[2]'.ETSI ES 201 873-1, v4.7.1 Mockup v1 (2015-06):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

