.******************************************************************************
.* Copyright (C) 2017 ETSI  All Rights Reserved.
.*
.* Contributors:
.*   Adrien Kirjak 
.*
.******************************************************************************/
text.
:lang eng.
.*
:docname.Test Description
:docno.xz/152 91-CRL 113 200 Uen
:rev.PA1
:date.2016-04-04
.*
:prep.ETH/XZ EADRKIR
:subresp.EADRKIR
:appr.ETH/XZ (Elemer Lelik)
:checked.
.*
:title.ETSI TTCN3 Negative Conformance Test
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*	
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains negative tests from ETSI TTCN3 Conformance Test's 22_communication_operations folder. 

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester.pl

:exmp.
:np.

.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2. 2202_message_based_communication folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_001 Ensure that the IUT correctly handles message sending operations >

<COMPILE>

<MODULE TTCN NegSem_220201_SendOperation_001 NegSem_220201_SendOperation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220201_SendOperation_001 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
	 	integer  a optional, 
	 	integer  b optional, 
	 	boolean  c 
	} 

	type set SetType { 
	 	integer  a optional, 
	 	integer  b optional, 
	 	boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
	  	integer  		field1, 
	  	charstring  	field2, 
	  	boolean  		field3, 
	  	integer  		field4[4],
	  	EnumeratedType field5,
	  	RecordType		field6,
	  	SetType		field7,
	  	UnionType		field8,
	  	IntegerList	field9,
	  	IntegerUList	field10
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_220201_SendOperation_001() runs on GeneralComp {

    	var MessageType v_testMessage;

		template MessageType mw_matchingTemplate:= 
		{  
		  	field1 := 1,
		  	field2 := "test string", 
		  	field3 := true, 
		  	field4 := {1,2,3,4},
		  	field5 := e_black,
		  	field6 := {a:=1,b:=2,c:=true}, 
		  	field7 := {a:=1,b:=2,c:=true}, 
		  	field8 := {a:=1},
		  	field9 := {1},
		  	field10 := {1,2}
		 } 

		 template MessageType mw_sendingTemplate:= 
		 {  
		  	field1 := 1,
		  	field2 := "test string", 
		  	field3 := true, 
		  	field4 := {1,2,3,4},
		  	field5 := e_black,
		  	field6 := {a:=*,b:=2,c:=true}, 
		  	field7 := {a:=1,b:=*,c:=true}, 
		  	field8 := {a:=1},
		  	field9 := {1},
		  	field10 := {1,2}
		 } 

		connect(self:messagePort, self:messagePort);

	 	messagePort.send(mw_sendingTemplate);  //can only send specific values

		alt {
		 	[] messagePort.receive(mw_matchingTemplate) {
		    	setverdict(pass);
		 	}
		 	[] messagePort.receive {
		    	setverdict(fail);
		 	}
		}
	}

	control{
		execute(TC_NegSem_220201_SendOperation_001());
	}

}
<END_MODULE>

<RESULT COUNT 2>
error: A specific value was expected instead of any or omit
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_002 Ensure that the IUT correctly handles message sending operations  >

<COMPILE>

<MODULE TTCN NegSem_220201_SendOperation_002 NegSem_220201_SendOperation_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220201_SendOperation_002 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type set SetType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2, 
  	 	boolean  		field3, 
  	 	integer  		field4[4],
  	 	EnumeratedType field5,
  	 	RecordType		field6,
  	 	SetType		field7,
  	 	UnionType		field8,
  	 	IntegerList	field9,
  	 	IntegerUList	field10
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_220201_SendOperation_002() runs on GeneralComp {

    	var MessageType v_testMessage;

 		template MessageType mw_matchingTemplate:= 
 		{  
  			field1 := 1,
  			field2 := "test string", 
  			field3 := true, 
  			field4 := {1,2,3,4},
  			field5 := e_black,
  			field6 := {a:=1,b:=2,c:=true}, 
  			field7 := {a:=1,b:=2,c:=true}, 
  			field8 := {a:=1},
  			field9 := {1},
  			field10 := {1,2}
 		} 

		template MessageType mw_sendingTemplate:= 
		{  
		  	field1 := 1,
		  	field2 := "test string", 
		  	field3 := true, 
		  	field4 := {1,2,3,4},
		  	field5 := e_black,
		  	field6 := {a:=?,b:=2,c:=true}, 
		  	field7 := {a:=1,b:=?,c:=true}, 
		  	field8 := {a:=1},
		  	field9 := {1},
		  	field10 := {1,2}
		} 

		connect(self:messagePort, self:messagePort);

 		messagePort.send(mw_sendingTemplate);  //can only send specific values

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}	
	}

	control{
		execute(TC_NegSem_220201_SendOperation_002());
	}

}
<END_MODULE>

<RESULT COUNT 2>
error: A specific value was expected instead of any value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_003 Ensure that the IUT correctly handles message sending operations  >

<COMPILE>

<MODULE TTCN NegSem_220201_SendOperation_003 NegSem_220201_SendOperation_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220201_SendOperation_003 { 


    type port loopbackPort message {
	  	inout integer
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
		port loopbackPort messagePort
	}	

	testcase TC_NegSem_220201_SendOperation_003() runs on GeneralComp {

		connect(self:messagePort, self:messagePort);

	 	messagePort.send(float:2.0);  //sent type does not match port specification

		alt {
		 	[] messagePort.receive(2) {
		    	setverdict(pass);
		 	}
		 	[] messagePort.receive {
		    	setverdict(fail);
		 	}
		}
	}

	control{
		execute(TC_NegSem_220201_SendOperation_003());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Incompatible explicit type specification: `integer' was expected instead of `float'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_004 Ensure that the IUT correctly handles message sending operations  >

<COMPILE>

<MODULE TTCN NegSem_220201_SendOperation_004 NegSem_220201_SendOperation_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220201_SendOperation_004 {
 
signature p_NegSem_220201_SendOperation_004(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

	/*template p_NegSem_220201_SendOperation_004 s_baseTemplate := { 
		p_par1 := -,
		p_par2 := 4,
		p_par3 := ?
	}

	template p_NegSem_220201_SendOperation_004 s_returnTemplate modifies s_baseTemplate := { 
		p_par3 := 5
	}

	template p_NegSem_220201_SendOperation_004 s_wrongTemplate modifies s_baseTemplate := { 
		p_par3 := 3
	}*/

	template p_NegSem_220201_SendOperation_004 s_callTemplate := { 
		p_par1 := 1,
		p_par2 := -,
		p_par3 := 3
	}

	type port remotePort procedure {
		out p_NegSem_220201_SendOperation_004;
	} with {extension "internal"}

	type component GeneralComp {	    	    
		  port remotePort PCO;
	}	

	testcase NegSem_220201_SendOperation_004() runs on GeneralComp {

		//connect(self:PCO,self:PCO);
	
		PCO.send(p_NegSem_220201_SendOperation_004:s_callTemplate); 
	
		//cannot use send operation on a procedure based port
	 	/*PCO.send(p_NegSem_220201_SendOperation_004:s_callTemplate, 5.0) {  
			[] PCO.getreply(p_NegSem_220201_SendOperation_004:s_wrongTemplate value 1) {		
				setverdict(fail);
			} 
			[] PCO.getreply(p_NegSem_220201_SendOperation_004:s_returnTemplate value 2) {		
				setverdict(fail);
			} 
			[] PCO.getreply(p_NegSem_220201_SendOperation_004:s_returnTemplate value 1) {	
				setverdict(pass);
			} 
			[] PCO.catch (timeout) {
				setverdict(fail);
			}
	 	}*/
	}

	control{
		execute(NegSem_220201_SendOperation_004());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Message-based operation `send' is not applicable to a procedure-based port of type `@NegSem_220201_SendOperation_004.remotePort'
<END_RESULT>
<RESULT COUNT 1>
error: The type of send parameter is signature `@NegSem_220201_SendOperation_004.p_NegSem_220201_SendOperation_004', which cannot be a message type
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_005 missing to clause in case of one-to-many connections  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220201_SendOperation_005 NegSem_220201_SendOperation_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, missing to clause in case of one-to-many connections
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Unicast, multicast and broadcast communication can be determined by the optional to clause
// in the send operation.  A to clause can be omitted in case of a one-to-one connection where
// unicast communication is used and the message receiver is uniquely determined by the test
// system structure.
// A to clause shall be present in case of one-to-many connections.

module NegSem_220201_SendOperation_005 {
	
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        alt {
            [] p.receive(p_expected) { setverdict(pass); }
            [] p.receive { setverdict(fail); }
        }
	}
    
    const integer c_ptcCount := 2;
	
    testcase TC_NegSem_220201_SendOperation_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];

        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(0));
        }

		p.send(0);
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220201_SendOperation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Port p has more than one active connections. Message can be sent on it only with explicit addressing.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_006 partially initialized template  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220201_SendOperation_006 NegSem_220201_SendOperation_006.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, partially initialized template
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The TemplateInstance (and all parts of it) shall have a specific value i.e. the use 
// of matching mechanisms such as AnyValue is not allowed.

module NegSem_220201_SendOperation_006 {
	
    type record of integer RoI;    
    
	type port P message {
		inout RoI;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
		
    testcase TC_NegSem_220201_SendOperation_006() runs on GeneralComp {
        var template RoI vm_msg := {1, -, 2};

		connect(self:p,self:p);

        p.send(vm_msg);
        p.receive;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220201_SendOperation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Performing a valueof or send operation on a non-specific integer template.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_007 no type prefix in inline template  >

<COMPILE>

<MODULE TTCN NegSem_220201_SendOperation_007 NegSem_220201_SendOperation_007.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, no type prefix in inline template
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When defining the message in-line, the optional type part shall be used if there is 
// ambiguity of the type of the message being sent.


module NegSem_220201_SendOperation_007 {
	
    type record R1 
    {
        integer field1,
        integer field2
    }
    
    type record of integer RoI;    
    
	type port P message {
		inout R1, RoI;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_NegSem_220201_SendOperation_007() runs on GeneralComp {

		connect(self:p,self:p);

        p.send({1, 2});
        p.receive;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220201_SendOperation_007(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Cannot determine the type of the outgoing message
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_010 null component in the to clause of send operation  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220201_SendOperation_010 NegSem_220201_SendOperation_010.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, null component in the to clause of send operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220201_SendOperation_010 {
	
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_NegSem_220201_SendOperation_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_comp := null;
        connect(self:p, v_comp:p);
		
		p.send(0) to v_comp;
        p.receive(integer:?);

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220201_SendOperation_010(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220201_SendOperation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220201_011 send operation on disconnected and unmapped ports  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220201_SendOperation_011 NegSem_220201_SendOperation_011.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.1, send operation on disconnected and unmapped ports
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Applying a send operation to an unmapped or disconnected port shall cause a test case 
// error.

module NegSem_220201_SendOperation_011 {
	
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_NegSem_220201_SendOperation_011() runs on GeneralComp system GeneralComp {
		p.send(0);
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220201_SendOperation_011(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Port p has neither connections nor mappings. Message cannot be sent on it.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_001 Ensure that the IUT correctly handles message receiving operations  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_001 NegSem_220202_ReceiveOperation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220202_ReceiveOperation_001 {
 
signature p_NegSem_220202_ReceiveOperation_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

	template p_NegSem_220202_ReceiveOperation_001 s_baseTemplate := { 
		p_par1 := -,
		p_par2 := 4,
		p_par3 := ?
	}

	template p_NegSem_220202_ReceiveOperation_001 s_returnTemplate modifies s_baseTemplate := { 
		p_par3 := 5
	}

	/*template p_NegSem_220202_ReceiveOperation_001 s_wrongTemplate modifies s_baseTemplate := { 
		p_par3 := 3
	}

	template p_NegSem_220202_ReceiveOperation_001 s_callTemplate := { 
		p_par1 := 1,
		p_par2 := -,
		p_par3 := 3
	}*/

    type port remotePort procedure {
    	out p_NegSem_220202_ReceiveOperation_001;
	} with {extension "internal"}

	type component GeneralComp {	    	    
	  	port remotePort PCO;
	}	

	testcase NegSem_220202_ReceiveOperation_001() runs on GeneralComp {

		PCO.receive(s_returnTemplate);
	
 	/*	PCO.call(p_NegSem_220202_ReceiveOperation_001:s_callTemplate, 5.0) {
			[] PCO.receive(p_NegSem_220202_ReceiveOperation_001:s_wrongTemplate value 1) {	 
			//cannot receive from procedure based port	
				setverdict(fail);
			} 
			[] PCO.receive(p_NegSem_220202_ReceiveOperation_001:s_returnTemplate value 2) {		
				setverdict(fail);
			} 
			[] PCO.receive(p_NegSem_220202_ReceiveOperation_001:s_returnTemplate value 1) {	
				setverdict(pass);
			} 
			[] PCO.catch (timeout) {
				setverdict(fail);
			}
 		}*/
	}

	control{
		execute(NegSem_220202_ReceiveOperation_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Message-based operation `receive' is not applicable to a procedure-based port of type `@NegSem_220202_ReceiveOperation_001.remotePort'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_002 no type prefix in ambiguous inline template  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_002 NegSem_220202_ReceiveOperation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, no type prefix in ambiguous inline template
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// An optional type field in the matching criteria to the receive operation shall 
// be used to avoid any ambiguity of the type of the value being received.

module NegSem_220202_ReceiveOperation_002 {
	
    type record of integer RoI;
    type record R {
        integer field1,
        integer field2
    }
    
	type port P message {
		inout R, RoI;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
		
    testcase TC_NegSem_220202_ReceiveOperation_002() runs on GeneralComp {

		connect(self:p, self:p);

        p.send(R:{1, 2});
        alt {
            [] p.receive({?, 2}) { setverdict(pass); } // error (ambiguous type)
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Cannot determine the type of the incoming message
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_003 type mismatch in redirect value assignment  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_003 NegSem_220202_ReceiveOperation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, type mismatch in redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable or formal parameter shall be type compatible with the received message.

module NegSem_220202_ReceiveOperation_003 {
	    
	type port P message {
		inout integer, charstring;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
		
    testcase TC_NegSem_220202_ReceiveOperation_003() runs on GeneralComp {
        var charstring v_str;

		connect(self:p, self:p);

        p.send(1);
        alt {
            [] p.receive(integer:?) -> value v_str { setverdict(pass); } 
			// error (type mismatch in redirect assignment)
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch in value redirect: A variable of type `integer' or of a compatible type was expected instead of `charstring'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_004 type mismatch in redirect assignment of message fields >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_004 NegSem_220202_ReceiveOperation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, type mismatch in redirect assignment of message fields
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The variable or formal parameter shall be type compatible with the type on the 
// right hand side of the assignment symbol.

module NegSem_220202_ReceiveOperation_004 {
	type record R
    {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_004() runs on GeneralComp {
        var integer v_int;
        var bitstring v_str;

		connect(self:p, self:p);

        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });
        alt {
            [] p.receive(R:?) -> value ( v_int := field1[1], v_str := field2) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch in value redirect: A variable of type `charstring' or of a compatible type was expected instead of `bitstring'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_005 applying @decoded to a forbidden field  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_005 NegSem_220202_ReceiveOperation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, applying @decoded to a forbidden field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220202_ReceiveOperation_005 {
	type record R {
        integer id,
        record of integer payload (0..255)
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_005() runs on GeneralComp {
        var integer v_res;

		connect(self:p, self:p);

        p.send(R:{ id := 1, payload := {0, 0, 0, 0} });

        alt {
            [] p.receive(R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_005(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: The '@decoded' modifier is only available to value redirects of string types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_006 decoding error in @decoded redirect assignment  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220202_ReceiveOperation_006 NegSem_220202_ReceiveOperation_006.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, decoding error in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Failure of this decoding shall cause a test case error. 

module NegSem_220202_ReceiveOperation_006 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_006() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res ;
        var charstring v_str := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij";

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });

        alt {
            [] p.receive(R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_006(), 5.0);
    }

} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT>
Dynamic test case error: Value redirect #1 failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_007 invalid format value in @decoded redirect assignment  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_007 NegSem_220202_ReceiveOperation_007.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, invalid format value in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220202_ReceiveOperation_007 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_007() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res;
        var universal charstring v_str := encvalue_unichar(v_src);

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });

        alt {
            [] p.receive(R:?) -> value (v_res := @decoded("proprietary") payload) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_007(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: 'proprietary' is not a valid encoding format
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_008 value of wrong type in @decoded redirect assignment  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_008 NegSem_220202_ReceiveOperation_008.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, value of wrong type in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220202_ReceiveOperation_008 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_008() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res;
        var universal charstring v_str := encvalue_unichar(v_src);

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });

        alt {
            [] p.receive(R:?) -> value (v_res := @decoded(v_src) payload) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_008(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: Type mismatch: a value of type `charstring' was expected instead of `integer'  
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_009 value of wrong type in @decoded redirect assignment  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_009 NegSem_220202_ReceiveOperation_009.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, encoding parameter of @decoded redirect assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220202_ReceiveOperation_009 {

	type charstring CS with { variant ""};

	type record R {
        integer id,
        octetstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220202_ReceiveOperation_009() runs on GeneralComp {
        var CS v_src := "abc";
		var CS v_res;
        var octetstring v_os := bit2oct(encvalue(v_src));

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_os });

        alt {
            [] p.receive(R:?) -> value (v_res := @decoded("UTF-8") payload) { 
                setverdict (pass);
            }
            [] p.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_009(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: The encoding format parameter for the '@decoded' modifier is only available to value redirects of universal charstrings  
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_010 attempting to store component name in redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_010 NegSem_220202_ReceiveOperation_010.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, attempting to store component name in redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When the message is received on a connected port, only the component reference is 
// stored in the following the sender keyword, but the test system shall internally 
// store the component name too, if any (to be used in logging).

module NegSem_220202_ReceiveOperation_010 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_010() runs on GeneralComp system GeneralComp {
        var charstring v_name;
        connect(self:p, self:p);
        p.send(10);
        p.receive(integer:?) -> sender v_name;
        if (v_name == "MTC") { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_010(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_011 attempting to receive a type missing from the port list >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_011 NegSem_220202_ReceiveOperation_011.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, attempting to receive a type missing from the port list
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The receive operation shall only be used on message-based ports and the type of the 
// value to be received shall be included in the list of incoming types of the port type 
// definition.


module NegSem_220202_ReceiveOperation_011 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_011() runs on GeneralComp {
        var integer v_index;

		connect(self:p, self:p);
        p.send(10);

        alt {
            [] p.receive(charstring:?) { setverdict(pass); }
            [] any port.receive { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_011(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Incompatible explicit type specification: `integer' was expected instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_012 value redirect assignment in receive any message statement >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_012 NegSem_220202_ReceiveOperation_012.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, value redirect assignment in receive any message statement
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// AddressRef for retrieving the sending entity shall be of type address, component or 
// of the type provided in the address declaration of the port type of the port instance 
// referenced in the receive operation.

module NegSem_220202_ReceiveOperation_012 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_012() runs on GeneralComp {
        var integer v_val;

		connect(self:p, self:p);
        p.send(10);

        p.receive -> value v_val;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_012(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Value redirect cannot be used without receive parameter
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_014 type mismatch in sender redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_014 NegSem_220202_ReceiveOperation_014.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, type mismatch in sender redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// AddressRef for retrieving the sending entity shall be of type address, component or 
// of the type provided in the address declaration of the port type of the port instance 
// referenced in the receive operation.

module NegSem_220202_ReceiveOperation_014 {

	type port P message {
		inout integer;
       // address integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_014() runs on GeneralComp {
        var charstring v_addr;
		connect(self:p, self:p);
        p.send(10);
        p.receive -> sender v_addr;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_014(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_015 null component reference in from clause of receive operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220202_ReceiveOperation_015 NegSem_220202_ReceiveOperation_015.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, null component reference in from clause of receive operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220202_ReceiveOperation_015 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_015() runs on GeneralComp system GeneralComp {
        var GeneralComp v_comp := null;
        connect(self:p, v_comp:p);
        p.send(10);
        alt {
            [] p.receive from v_comp {}
            [] p.receive {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_015(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_017 index redirection in standard port.receive >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_017 NegSem_220202_ReceiveOperation_017.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, index redirection in standard port.receive
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The index redirection shall only be used when the operation is used on an any from port
// array construct.

module NegSem_220202_ReceiveOperation_017 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_017() runs on GeneralComp {
        var integer v_int;
		connect(self:p, self:p);

        p.send(10);
        p.receive(integer:?) -> @index value v_int;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_017(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_019 insufficient value range of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_019 NegSem_220202_ReceiveOperation_019.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, insufficient value range of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for single-dimensional port arrays, the type of the 
// integer variable shall allow storing the highest index of the respective array.

module NegSem_220202_ReceiveOperation_019 {
    type integer RestrInt(0..2);
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[10];
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_019() runs on GeneralComp {
        var RestrInt v_int;

		connect(self:p[5], self:p[5]);
        p[5].send(100);
        any from p.receive(integer:?) -> @index value v_int;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_019(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 3 is not a valid value for type `integer' which has subtype \(0..2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_020 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_020 insufficient array dimension of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_020 NegSem_220202_ReceiveOperation_020.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, insufficient array dimension of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for multi-dimensional port arrays, the size of the 
// integer array or record of integer type shall exactly be the same as the dimension of
// the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.

module NegSem_220202_ReceiveOperation_020 {
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[3][2][3];
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_020() runs on GeneralComp {
        var integer v_indices[2];
		connect(self:p[0][1][2],self:p[0][1][2]);
        p[0][1][2].send(100);
        any from p.receive(integer:?) -> @index value v_indices;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_020(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the port array has 3 dimensions, but the integer array has 2 elements
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_021 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_021 insufficient array dimension of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_021 NegSem_220202_ReceiveOperation_021.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, insufficient element value range of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for multi-dimensional port arrays, the size of the 
// integer array or record of integer type shall exactly be the same as the dimension of
// the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.

module NegSem_220202_ReceiveOperation_021 {
	type integer RestrInt(0..2);
    type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[4][2][3];
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_021() runs on GeneralComp {
        var RestrInt v_indices[3];

		connect(self:p[3][1][2],self:p[3][1][2]);

        p[3][1][2].send(100);
        any from p.receive(integer:?) -> @index value v_indices;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_021(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 3 is not a valid value for type `integer' which has subtype \(0..2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220202_ReceiveOperation_022 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220202_022 incompatible from and sender clause  >

<COMPILE>

<MODULE TTCN NegSem_220202_ReceiveOperation_022 NegSem_220202_ReceiveOperation_022.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.2, incompatible from and sender clause 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the receive operation contains both from and sender clause, the variable or parameter
// referenced in the sender clause shall be type compatible with the template in the from 
// clause.

module NegSem_220202_ReceiveOperation_022 {

    type integer address;
    
    type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220202_ReceiveOperation_022() runs on GeneralComp {
        var address v_addr;

		connect(self:p, self:p);
        p.send(100);
        alt {
            [] p.receive(integer:?) from GeneralComp:? -> sender v_addr { }
            [] p.receive {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220202_ReceiveOperation_022(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `integer'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_001 Ensure that the IUT correctly handles message trigger operations >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_001 NegSem_220203_TriggerOperation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220203_TriggerOperation_001 {
 
signature p_NegSem_220203_TriggerOperation_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

	template p_NegSem_220203_TriggerOperation_001 s_baseTemplate := { 
		p_par1 := -,
		p_par2 := 4,
		p_par3 := ?
	}

	/*template p_NegSem_220203_TriggerOperation_001 s_returnTemplate modifies s_baseTemplate := { 
		p_par3 := 5
	}*/

	template p_NegSem_220203_TriggerOperation_001 s_wrongTemplate modifies s_baseTemplate := { 
		p_par3 := 3
	}

	/*template p_NegSem_220203_TriggerOperation_001 s_callTemplate := { 
		p_par1 := 1,
		p_par2 := -,
		p_par3 := 3
	}*/

    type port remotePort procedure {
    	out p_NegSem_220203_TriggerOperation_001;
	}

	type component GeneralComp {	    	    
	  	port remotePort PCO;
	}	

	testcase NegSem_220203_TriggerOperation_001() runs on GeneralComp {

		PCO.trigger(p_NegSem_220203_TriggerOperation_001:s_wrongTemplate);
	
 		/*PCO.call(p_NegSem_220203_TriggerOperation_001:s_callTemplate, 5.0) {
	
			[] PCO.trigger(p_NegSem_220203_TriggerOperation_001:s_wrongTemplate value 1) {	 
				//cannot trigger from procedure based port	
				setverdict(fail);
			} 
			[] PCO.trigger(p_NegSem_220203_TriggerOperation_001:s_returnTemplate value 2) {		
				setverdict(fail);
			} 
			[] PCO.trigger(p_NegSem_220203_TriggerOperation_001:s_returnTemplate value 1) {	
				setverdict(pass);
			} 
			[] PCO.catch (timeout) {
				setverdict(fail);
			}
 		}*/
	}

	control{
		execute(NegSem_220203_TriggerOperation_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Message-based operation `trigger' is not applicable to a procedure-based port of type `@NegSem_220203_TriggerOperation_001.remotePort'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_002 no type prefix in ambiguous inline template >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_002 NegSem_220203_TriggerOperation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, no type prefix in ambiguous inline template
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The matching criteria as defined in clause 22.2.2 apply also to the trigger operation.
// An optional type field in the matching criteria to the [trigger] operation shall 
// be used to avoid any ambiguity of the type of the value being received.

module NegSem_220203_TriggerOperation_002 {
	
    type record of integer RoI;
    type record R {
        integer field1,
        integer field2
    }
    
	type port P message {
		inout R, RoI;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
		
    testcase TC_NegSem_220203_TriggerOperation_002() runs on GeneralComp {

		connect(self:p, self:p);
        p.send(R:{1, 2});

        alt {
            [] p.trigger({?, 2}) { setverdict(pass); } // error (ambiguous type)
            [else] { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Cannot determine the type of the incoming message
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_003 type mismatch in redirect value assignment >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_003 NegSem_220203_TriggerOperation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, type mismatch in redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// The variable or formal parameter shall be type compatible with the received message.

module NegSem_220203_TriggerOperation_003 {
	    
	type port P message {
		inout integer, charstring;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
		
    testcase TC_NegSem_220203_TriggerOperation_003() runs on GeneralComp {
        var charstring v_str;

		connect(self:p, self:p);
        p.send(1);
        alt {
            [] p.trigger(integer:?) -> value v_str { setverdict(pass); } 
			// error (type mismatch in redirect assignment)
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch in value redirect: A variable of type `integer' or of a compatible type was expected instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_004 type mismatch in redirect assignment of message fields >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_004 NegSem_220203_TriggerOperation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, type mismatch in redirect assignment of message fields
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// The variable or formal parameter shall be type compatible with the type on the 
// right hand side of the assignment symbol.

module NegSem_220203_TriggerOperation_004 {
	type record R {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_004() runs on GeneralComp {
        var integer v_int;
        var bitstring v_str;

		connect(self:p, self:p);
        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });

        alt {
            [] p.trigger(R:?) -> value ( v_int := field1[1], v_str := field2) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch in value redirect: A variable of type `charstring' or of a compatible type was expected instead of `bitstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_005 applying @decoded to a forbidden field >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_005 NegSem_220203_TriggerOperation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, applying @decoded to a forbidden field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220203_TriggerOperation_005 {
	type record R {
        integer id,
        record of integer payload (0..255)
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_005() runs on GeneralComp {
        var integer v_res;

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := {0, 0, 0, 0} });
        alt {
            [] p.trigger(R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_005(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT 1>
error: The '@decoded' modifier is only available to value redirects of string types
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_006 decoding error in @decoded redirect assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220203_TriggerOperation_006 NegSem_220203_TriggerOperation_006.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, decoding error in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// Failure of this decoding shall cause a test case error. 

module NegSem_220203_TriggerOperation_006 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_006() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res;
        var charstring v_str := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij";

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_006(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Value redirect #1 failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_007 invalid format value in @decoded redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_007 NegSem_220203_TriggerOperation_007.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, invalid format value in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// Any other value shall cause an error.

module NegSem_220203_TriggerOperation_007 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_007() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res;
        var universal charstring v_str := encvalue_unichar(v_src);

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := @decoded("proprietary") payload) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_007(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: 'proprietary' is not a valid encoding format
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_008 value of wrong type in @decoded redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_008 NegSem_220203_TriggerOperation_008.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, value of wrong type in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// Any other value shall cause an error.

module NegSem_220203_TriggerOperation_008 {

	type integer I with { variant "32 bit"};

	type record R {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_008() runs on GeneralComp {
        var I v_src := 1953719668;
		var I v_res;
        var universal charstring v_str := encvalue_unichar(v_src);

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := @decoded(v_src) payload) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_008(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: Type mismatch: a value of type `charstring' was expected instead of `integer'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_009 encoding parameter of @decoded redirect assignment applied to incorrect type >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_009 NegSem_220203_TriggerOperation_009.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, encoding parameter of @decoded redirect assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220203_TriggerOperation_009 {

	type charstring CS with { variant ""};

	type record R {
        integer id,
        octetstring payload
    }
    
	type port P message {
		inout R;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
    testcase TC_NegSem_220203_TriggerOperation_009() runs on GeneralComp {
        var CS v_src := "abc";
		var CS v_res;
        var octetstring v_os := bit2oct(encvalue(v_src));

		connect(self:p, self:p);
        p.send(R:{ id := 1, payload := v_os });
        alt {
            [] p.trigger(R:?) -> value (v_res := @decoded("UTF-8") payload) { 
                setverdict (pass);
            }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_009(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The encoding format parameter for the '@decoded' modifier is only available to value redirects of universal charstrings
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_010 attempting to store component name in redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_010 NegSem_220203_TriggerOperation_010.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, attempting to store component name in redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When the message is received on a connected port, only the component reference is 
// stored in the following the sender keyword, but the test system shall internally 
// store the component name too, if any (to be used in logging).

module NegSem_220203_TriggerOperation_010 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_010() runs on GeneralComp system GeneralComp {
        var charstring v_name;

        connect(self:p, self:p);
        p.send(10);
        p.trigger(integer:?) -> sender v_name;

        if (v_name == "MTC") { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_010(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_011 attempting to receive a type missing from the port list >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_011 NegSem_220203_TriggerOperation_011.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, attempting to receive a type missing from the port list
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The trigger operation shall only be used on message-based ports and the type of the 
// value to be received shall be included in the list of incoming types of the port type 
// definition.


module NegSem_220203_TriggerOperation_011 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_011() runs on GeneralComp {
        var integer v_index;

		connect(self:p, self:p);
        p.send(10);
        alt {
            [] p.trigger(charstring:?) { setverdict(pass); }
            [else] { setverdict(pass); }
        }
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_011(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Incompatible explicit type specification: `integer' was expected instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_012 value redirect assignment in receive any message statement >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_012 NegSem_220203_TriggerOperation_012.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, value redirect assignment in receive any message statement
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// AddressRef for retrieving the sending entity shall be of type address, component or 
// of the type provided in the address declaration of the port type of the port instance 
// referenced in the receive operation.

module NegSem_220203_TriggerOperation_012 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_012() runs on GeneralComp {
        var integer v_val;

		connect(self:p, self:p);
        p.send(10);
        p.trigger -> value v_val;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_012(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Value redirect cannot be used without receive parameter
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_014 type mismatch in sender redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_014 NegSem_220203_TriggerOperation_014.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, type mismatch in sender redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// AddressRef for retrieving the sending entity shall be of type address, component or 
// of the type provided in the address declaration of the port type of the port instance 
// referenced in the receive operation.


module NegSem_220203_TriggerOperation_014 {

	type port P message {
		inout integer;
        //address integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_014() runs on GeneralComp {
        var charstring v_addr;

		connect(self:p, self:p);
        p.send(10);
        p.trigger -> sender v_addr;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_014(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `charstring'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_015 null component reference in from clause of trigger operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220203_TriggerOperation_015 NegSem_220203_TriggerOperation_015.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, null component reference in from clause of trigger operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220203_TriggerOperation_015 {

	type port P message {
		inout integer;
        //address integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_015() runs on GeneralComp system GeneralComp {
        var GeneralComp v_comp := null;

        connect(self:p, v_comp:p);
        p.send(10);
        alt {
            [] p.trigger from v_comp {}
            [else] {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_015(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_017 index redirection in standard port.trigger >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_017 NegSem_220203_TriggerOperation_017.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, index redirection in standard port.trigger
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// The index redirection shall only be used when the operation is used on an any from port
// array construct.

module NegSem_220203_TriggerOperation_017 {

	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_017() runs on GeneralComp {
        var integer v_int;

		connect(self:p, self:p);
        p.send(10);
        p.trigger(integer:?) -> @index value v_int;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_017(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_019 insufficient value range of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_019 NegSem_220203_TriggerOperation_019.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, insufficient value range of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for single-dimensional port arrays, the type of the 
// integer variable shall allow storing the highest index of the respective array.

module NegSem_220203_TriggerOperation_019 {
    type integer RestrInt(0..2);
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[10];
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_019() runs on GeneralComp {
        var RestrInt v_int;

		connect(self:p[5], self:p[5]);
        p[5].send(100);
        any from p.trigger(integer:?) -> @index value v_int;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_019(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 3 is not a valid value for type `integer' which has subtype \(0..2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_020 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_020 insufficient array dimension of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_020 NegSem_220203_TriggerOperation_020.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, insufficient array dimension of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for multi-dimensional port arrays, the size of the 
// integer array or record of integer type shall exactly be the same as the dimension of
// the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.

module NegSem_220203_TriggerOperation_020 {
	type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[3][2][3];
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_020() runs on GeneralComp {
        var integer v_indices[2];

		connect(self:p[0][1][2], self:p[0][1][2]);
        p[0][1][2].send(100);
        any from p.trigger(integer:?) -> @index value v_indices;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_020(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the port array has 3 dimensions, but the integer array has 2 elements
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_021 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_021 insufficient element value range of variable in index redirection >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_021 NegSem_220203_TriggerOperation_0201ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, insufficient element value range of variable in index redirection 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the index redirection is used for multi-dimensional port arrays, the size of the 
// integer array or record of integer type shall exactly be the same as the dimension of
// the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.

module NegSem_220203_TriggerOperation_021 {
	type integer RestrInt(0..2);
    type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p[4][2][3];
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_021() runs on GeneralComp {
        var RestrInt v_indices[3];

		connect(self:p[3][1][2], self:p[3][1][2]);
        p[3][1][2].send(100);
        any from p.trigger(integer:?) -> @index value v_indices;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_021(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 3 is not a valid value for type `integer' which has subtype \(0..2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220203_TriggerOperation_022 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220203_022 incompatible from and sender clause  >

<COMPILE>

<MODULE TTCN NegSem_220203_TriggerOperation_022 NegSem_220203_TriggerOperation_022.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.2.3, incompatible from and sender clause 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the trigger operation contains both from and sender clause, the variable or parameter
// referenced in the sender clause shall be type compatible with the template in the from 
// clause.

module NegSem_220203_TriggerOperation_022 {

    type integer address;
    
    type port P message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_220203_TriggerOperation_022() runs on GeneralComp {
        var address v_addr;

		connect(self:p, self:p);
        p.send(100);
        alt {
            [] p.trigger(integer:?) from GeneralComp:? -> sender v_addr { }
            [else] {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220203_TriggerOperation_022(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The type of the variable should be a component type instead of `integer'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 2203_procedure_based_communication folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_220301_CallOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220301_001 Ensure that the IUT correctly handles procedure call operations  >

<COMPILE>

<MODULE TTCN NegSem_220301_CallOperation_001 NegSem_220301_CallOperation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles procedure call operations 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220301_CallOperation_001 {

    type port loopbackPort message {
        inout integer
    } with {extension "internal"}
	

    type component GeneralComp {
        port loopbackPort messagePort
    }

    testcase TC_NegSem_220301_CallOperation_001() runs on GeneralComp {

		connect(self:messagePort, self:messagePort);

        messagePort.call(2);   //cannot use call on a message based port

        alt {
            [] messagePort.receive {
                setverdict(pass);
            }
            [] messagePort.receive {
                setverdict(fail);
            }
        }
    }

    control{
        execute(TC_NegSem_220301_CallOperation_001());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Procedure-based operation `call' is not applicable to a message-based port of type `@NegSem_220301_CallOperation_001.loopbackPort'
<END_RESULT>


<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220301_CallOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220301_002 Ensure that the IUT correctly procedure calls >

<COMPILE>

<MODULE TTCN NegSem_220301_CallOperation_002 NegSem_220301_CallOperation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly procedure calls
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220301_CallOperation_002 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_NegSem_220301_CallOperation_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_NegSem_220301_CallOperation_002 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_NegSem_220301_CallOperation_002 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_NegSem_220301_CallOperation_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_NegSem_220301_CallOperation_002;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	  	var integer v_zero:=0;
	  	var integer v_one:=1;
	
        //nowait cannot be used in this construct with timeout checking
        PCO.call(p_NegSem_220301_CallOperation_002:s_callTemplate, nowait) { 
	
            [] PCO.getreply(p_NegSem_220301_CallOperation_002:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_NegSem_220301_CallOperation_002:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_NegSem_220301_CallOperation_002:s_returnTemplate value 1) {	
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
		var integer v_par1;
		var integer v_par3;
		timer t_timeout:=30.0;
		
		template p_NegSem_220301_CallOperation_002 s_acceptTemplate := {
        	p_par1 := ?,
        	p_par2 := ?,
        	p_par3 := ?
    	};

		
		t_timeout.start;
	
	 	alt {
      		[] PCO.getcall(p_NegSem_220301_CallOperation_002:s_acceptTemplate) -> param(v_par1, v_par3) 			{
        		PCO.reply(p_NegSem_220301_CallOperation_002:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
				repeat;
	  		}
      		[] t_timeout.timeout {
        		setverdict(fail);
      		}
	 	}
	 
    }

	
	testcase TC_NegSem_220301_CallOperation_002() runs on GeneralComp system GeneralComp {
       	var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       	var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       	// map the PTCs to the system port
       	connect(server:PCO, client:PCO);

       	server.start(f_ServerResponses());
       	client.start(f_ClientQuery());

       	alt {
           	[] client.done {
               	server.stop;
           	}
       	}

       	alt {
           	[] all component.done {}
       	}

       	disconnect(server:PCO, client:PCO);
   	}

    control{
        execute(TC_NegSem_220301_CallOperation_002());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: A call with `nowait' keyword cannot have response and exception handling part
<END_RESULT>
<RESULT COUNT 1>
error: Catching of `timeout' exception is not allowed because the previous `call' operation does not have timer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220301_CallOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220301_003 null component in the to clause of the call operation >

<COMPILE>
<EXECUTE_PARALLEL>


<MODULE TTCN NegSem_220301_CallOperation_003 NegSem_220301_CallOperation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.1, null component in the to clause of the call operation 
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220301_CallOperation_003 {

    signature S();

    type port P procedure {
        inout S;
    } with {extension "internal"}

    type component GeneralComp {
        port P p;
    }

    testcase TC_NegSem_220301_CallOperation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC"), v_compRef := null;
        connect(self:p, v_compRef:p);
        p.call(S:{}, nowait) to v_compRef;
        setverdict(pass);
    }

    control{
        execute(TC_NegSem_220301_CallOperation_003(), 5.0);
    }

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_001 Ensure that getcall operations are only used on procedure based ports  >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_001 NegSem_220302_GetcallOperation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall operations are only used on procedure based ports 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220302_GetcallOperation_001 {

    type port loopbackPort message {
        inout integer
    } with {extension "internal"}
	
    type component GeneralComp {
        port loopbackPort messagePort
    }

    testcase TC_NegSem_220302_GetcallOperation_001() runs on GeneralComp {

		connect(self:messagePort, self:messagePort);

        messagePort.send(2);

        alt {
            [] messagePort.getcall {		//cannot use getcall on a message based port
                setverdict(pass);
            }
            [] messagePort.receive {
                setverdict(fail);
            }
        }
    }

    control{
        execute(TC_NegSem_220302_GetcallOperation_001());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Procedure-based operation `getcall' is not applicable to a message-based port of type `@NegSem_220302_GetcallOperation_001.loopbackPort'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_002 Ensure that getcall operation does not allow value assignment >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_002 NegSem_220302_GetcallOperation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall operation does not allow value assignment
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220302_GetcallOperation_002 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_NegSem_220302_GetcallOperation_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_NegSem_220302_GetcallOperation_002 s_returnTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 4,
        p_par3 := 5
    }

    template p_NegSem_220302_GetcallOperation_002 s_wrongTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 2,
        p_par3 := 3
    }

    template p_NegSem_220302_GetcallOperation_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := 0, // p_par2 := -, core dump
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_NegSem_220302_GetcallOperation_002;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
    } 

    function f_ClientQuery() runs on GeneralComp {
	  	var integer v_zero:=0;
	  	var integer v_one:=1;
	
        PCO.call(p_NegSem_220302_GetcallOperation_002:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_NegSem_220302_GetcallOperation_002:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_NegSem_220302_GetcallOperation_002:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [v_one>v_zero] PCO.getreply(p_NegSem_220302_GetcallOperation_002:s_returnTemplate value 1) 				{ //check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
		var integer v_par1;
		var integer v_par3;
		var integer v_return;
		timer t_timeout:=30.0;

 		template p_NegSem_220302_GetcallOperation_002 s_acceptTemplate := {
        	p_par1 := ?,
        	p_par2 := ?,
        	p_par3 := ?
    	};

			
		t_timeout.start;
	
		alt {
     		[] PCO.getcall(p_NegSem_220302_GetcallOperation_001:s_acceptTemplate) -> value v_return { 
				//not allowed assignment
      		}
      		[] t_timeout.timeout {
      		}
	 	}	
	 
    }

	
	testcase TC_NegSem_220302_GetcallOperation_002() runs on GeneralComp system GeneralComp {
       	var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       	var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       	timer t_wait:=1.0;
       

       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
             t_wait.start;
             while(t_wait.running) {	
				//this gives a chance for server to still test for second getcall match
             }
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO, client:PCO);
   }

    control{
        execute(TC_NegSem_220302_GetcallOperation_002());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `value': syntax error, unexpected ValueKeyword, expecting ParamKeyword or SenderKeyword
<END_RESULT>
<RESULT COUNT 1>
error: at or before token `testcase': syntax error, unexpected TestcaseKeyword, expecting \$end
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_003 Ensure that getcall for any call does not allow param assignment >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_003 NegSem_220302_GetcallOperation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall for any call does not allow param assignment
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_220302_GetcallOperation_003 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_NegSem_220302_GetcallOperation_003(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_NegSem_220302_GetcallOperation_003 s_returnTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 4,
        p_par3 := 5
    }

    template p_NegSem_220302_GetcallOperation_003 s_wrongTemplate := {
        p_par1 := 0, // p_par1 := -, core dump
        p_par2 := 2,
        p_par3 := 3
    }

    template p_NegSem_220302_GetcallOperation_003 s_callTemplate := {
        p_par1 := 1,
        p_par2 := 0, // p_par2 := -, core dump
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_NegSem_220302_GetcallOperation_003;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	  var integer v_zero:=0;
	  var integer v_one:=1;
	
        PCO.call(p_NegSem_220302_GetcallOperation_003:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_NegSem_220302_GetcallOperation_003:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_NegSem_220302_GetcallOperation_003:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [v_one>v_zero] PCO.getreply(p_NegSem_220302_GetcallOperation_003:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
		var integer v_par1;
		var integer v_par3;
		timer t_timeout:=30.0;

 		template p_NegSem_220302_GetcallOperation_003 s_acceptTemplate := {
        	p_par1 := ?,
        	p_par2 := ?,
        	p_par3 := ?
    	};

			
		t_timeout.start;
	
	 	alt {
      		[] PCO.getcall -> param(v_par1, v_par3) {  //not allowed param assignment for any call
      		}
      		[] t_timeout.timeout {
      		}
	 	}
	 
    }

	
	testcase TC_NegSem_220302_GetcallOperation_003() runs on GeneralComp system GeneralComp {
       	var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       	var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       	timer t_wait:=1.0;
       
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
             t_wait.start;
             while(t_wait.running) {	
				//this gives a chance for server to still test for second getcall match
             }
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO, client:PCO);
   }

    control{
        execute(TC_NegSem_220302_GetcallOperation_003());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Parameter redirect cannot be used without signature template
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_004 Verify that error occurs when any from getcall is applied to single port >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_004 NegSem_220302_GetcallOperation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that error occurs when any from getcall is applied to single port
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction g 
// The PortArrayRef shall be a reference to a port array variable identifier.
module NegSem_220302_GetcallOperation_004 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index;
        alt
		{
        	[] any from p.getcall { setverdict(pass); }
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason"); } 
		}		
	}
	
    testcase TC_NegSem_220302_GetcallOperation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a port array was expected instead of a port
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_005 Verify that error occurs when any from getcall is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_005 NegSem_220302_GetcallOperation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that error occurs when any from getcall is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220302_GetcallOperation_005 {

	signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;

    type component GeneralComp {
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index[1];
        alt
		{
        	[] any from p.getcall(S:{}) -> @index value v_index { 
				if(v_index[0] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}		
	}
	
    testcase TC_NegSem_220302_GetcallOperation_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{}, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	    
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional port arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_006 Verify that error occurs when any from getcall is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_006 NegSem_220302_GetcallOperation_006.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that error occurs when any from getcall is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220302_GetcallOperation_006 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 4;

    type component GeneralComp {
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var float v_index;
        alt
		{
        	[] any from p.getcall(S:{}) -> @index value v_index { 
				if(v_index == 1.0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}		
	}
	
    testcase TC_NegSem_220302_GetcallOperation_006() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{}, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of port arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_007 Verify that any from getcall index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_007 NegSem_220302_GetcallOperation_007.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220302_GetcallOperation_007 {

	signature S(integer p_par);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp {
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index[1], v_parValue;
		var GeneralComp v_src;
        alt
		{
        	[] any from p.getcall(S:{p_par := (0..c_portCount)}) -> sender v_src @index value v_index { 
				if(v_index[0] == 1 and v_index[1] == 2 and v_parValue == v_index[0] + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}
	}
	
	
    testcase TC_NegSem_220302_GetcallOperation_007() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].call(S:{ p_par := i + 1 }, nowait); }
			}
		}
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_007(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the port array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_008 Verify that any from getcall index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_008 NegSem_220302_GetcallOperation_008.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220302_GetcallOperation_008 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp {
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index, v_parValue;
		var GeneralComp v_src;
        alt
		{
        	[] any from p.getcall(S:{p_par := (0..c_portCount)}) -> param (v_parValue := p_par) sender v_src @index value v_index { 
				if(v_index == 1 and v_parValue == v_index + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}
	}
	
    testcase TC_NegSem_220302_GetcallOperation_008() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].call(S:{ p_par := i + 1 }, nowait); }
			}
		}
		v_ptc.start(f());
		v_ptc.done;	 
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_008(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional port arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_009 null component in the from clause of the getcall operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220302_GetcallOperation_009 NegSem_220302_GetcallOperation_009.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, null component in the from clause of the getcall operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220302_GetcallOperation_009 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        var GeneralComp v_compRef := null;
		connect(self:p, v_compRef:p);

        alt {
	        [] p.getcall(S:{}) from v_compRef { setverdict(pass, "first branch");} // error expected
            [] p.getcall(S:{}) { setverdict(fail, "second branch"); }
        }
	}
	
    testcase TC_NegSem_220302_GetcallOperation_009() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_009(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_011 applying @decoded to a forbidden field >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_011 NegSem_220302_GetcallOperation_011.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, applying @decoded to a forbidden field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220302_GetcallOperation_011 {
    type record of integer RoI (0..255);
    
	signature S(RoI p_par);
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_res;      
        alt {
            [] p.getcall(S: {p_par := ?} ) -> param (v_res := @decoded p_par) { 
                setverdict (pass);
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
    
    testcase TC_NegSem_220302_GetcallOperation_011() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := { 0, 0, 0, 0 } }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_011(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: The '@decoded' modifier is only available to parameter redirects of string types.
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_012 decoding error in @decoded redirect assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220302_GetcallOperation_012 NegSem_220302_GetcallOperation_012.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, decoding error in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Failure of this decoding shall cause a test case error. 

module NegSem_220302_GetcallOperation_012 {
	signature S(charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_res;        
        alt {
            [] p.getcall(S:{ p_par := ?}) -> param (v_res := @decoded p_par) { 
                setverdict (pass);
            }
            [] p.getcall { setverdict(pass); }
        }        
    }
	
    testcase TC_NegSem_220302_GetcallOperation_012() runs on GeneralComp system GeneralComp {
        var I v_src := 1953719668;
        var charstring v_str := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij";

        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := v_str }, nowait);

        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_012(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT>
Dynamic test case error: Parameter redirect \(for parameter 'p__par'\) failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_013 invalid format value in @decoded redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_013 NegSem_220302_GetcallOperation_013.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, invalid format value in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220302_GetcallOperation_013 {
	signature S(universal charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_res;        
        alt {
            [] p.getcall(S:{ p_par := ?}) -> param (v_res := @decoded("proprietary") p_par) { 
                setverdict(pass);
            }
            [] p.getcall { setverdict(pass); }
        }        
    }
	
    testcase TC_NegSem_220302_GetcallOperation_013() runs on GeneralComp system GeneralComp {
        var I v_src := 1953719668;
        var universal charstring v_str := encvalue_unichar(v_src);

        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := v_str }, nowait);
        v_ptc.done;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_013(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: 'proprietary' is not a valid encoding format
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_014 value of wrong type in @decoded redirect assignment >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_014 NegSem_220302_GetcallOperation_014.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, value of wrong type in @decoded redirect assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220302_GetcallOperation_014 {
	signature S(universal charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_res, v_enc := 32;        
        alt {
            [] p.getcall(S:{ p_par := ?}) -> param (v_res := @decoded(v_enc) p_par) { 
                setverdict (pass);
            }
            [] p.getcall { setverdict(pass); }
        }        
    }
	
    testcase TC_NegSem_220302_GetcallOperation_014() runs on GeneralComp system GeneralComp {
        var I v_src := 1953719668;
        var universal charstring v_str := encvalue_unichar(v_src);

        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := v_str }, nowait);
        v_ptc.done;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_014(), 5.0);
    }
}  with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: Type mismatch: a value of type `charstring' was expected instead of `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_015 encoding parameter of @decoded redirect assignment applied to incorrect type >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_015 NegSem_220302_GetcallOperation_015.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, encoding parameter of @decoded redirect assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220302_GetcallOperation_015 {
	signature S(octetstring p_par);

	type charstring CS with { variant ""};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	} 
    
    function f_server() runs on GeneralComp {
        var CS v_res;        
        alt {
            [] p.getcall(S:{ p_par := ?}) -> param (v_res := @decoded("UTF-8") p_par) { 
                setverdict(pass);
            }
            [] p.getcall { setverdict(pass); }
        }        
    }
	
    testcase TC_NegSem_220302_GetcallOperation_015() runs on GeneralComp system GeneralComp {
        var CS v_src := "abc";
        var octetstring v_os := bit2oct(encvalue(v_src));

        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := v_os }, nowait);
        v_ptc.done;

        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_015(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The encoding format parameter for the '@decoded' modifier is only available to parameter redirects of universal charstrings
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220302_GetcallOperation_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_016 incompatible from and sender clause in getcall operation >

<COMPILE>

<MODULE TTCN NegSem_220302_GetcallOperation_016 NegSem_220302_GetcallOperation_016.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, incompatible from and sender clause in getcall operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the getcall operation contains both from and sender clause, the variable or parameter 
// referenced in the sender clause shall be type compatible with the template in the from 
// clause.

module NegSem_220302_GetcallOperation_016 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
        var integer vc_int;
		port P p;
	}
    
    type component AltComp {
		var charstring vc_str;
        port P px;
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_compRef := null;
        alt {
	        [] p.getcall(S:{}) from AltComp:? -> sender v_compRef { } // error expected
            [] p.getcall(S:{}) { }
        }
        setverdict (pass);
	}
	
    testcase TC_NegSem_220302_GetcallOperation_016() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220302_GetcallOperation_016(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The types in `from' clause and `sender' redirect are not the same: `@NegSem_220302_GetcallOperation_016.AltComp' was expected instead of `@NegSem_220302_GetcallOperation_016.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_220302_GetcallOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220302_001 Verify that error occurs when using index redirection in port.getcall operation >

<COMPILE>

<MODULE TTCN NegSyn_220302_GetcallOperation_001 NegSyn_220302_GetcallOperation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that error occurs when using index redirection in port.getcall operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction h
// The index redirection shall only be used when the operation is used on an any from 
// port array construct.
module NegSyn_220302_GetcallOperation_001 {
	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index;
        alt
		{
        	[] p.getcall -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason"); } 
		}		
	}
	
    testcase TC_NegSyn_220302_GetcallOperation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_NegSyn_220302_GetcallOperation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220303_ReplyOperation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220303_001 Ensure that reply operations are only used on procedure based ports >

<COMPILE>

<MODULE TTCN NegSem_220303_ReplyOperation_001 NegSem_220303_ReplyOperation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.3, Ensure that reply operations are only used on procedure based ports 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_220303_ReplyOperation_001 { 

    type port loopbackPort message {
	  	inout integer
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_220303_ReplyOperation_001() runs on GeneralComp {

		connect(self:messagePort, self:messagePort);

 		messagePort.send(2);  

    	alt {
     		[] messagePort.receive(2) {	 
        		messagePort.reply(3);		//cannot use reply on a message based port
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_220303_ReplyOperation_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Procedure-based operation `reply' is not applicable to a message-based port of type `@NegSem_220303_ReplyOperation_001.loopbackPort'
<END_RESULT>
<RESULT COUNT 1>
error: The type of parameter is `integer', which is not a signature
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220303_ReplyOperation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220303_002 null component in the to clause of the reply operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220303_ReplyOperation_002 NegSem_220303_ReplyOperation_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.3, null component in the to clause of the reply operation
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220303_ReplyOperation_002 { 


    signature S();

    type port P procedure {
        inout S;
    } with {extension "internal"}

    type component GeneralComp {
        port P p;
    }

    function f_server() runs on GeneralComp {
        var GeneralComp v_compRef := null;
		connect(self:p, v_compRef:p);
        p.getcall(S:{});
        p.reply(S:{}) to v_compRef;
    }
    
    testcase TC_NegSem_220303_ReplyOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");        
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}, 1.0) {
            [] p.getreply(S:{}) { }
            [] p.catch(timeout) { }
        }
        setverdict(pass);
    }

    control{
        execute(TC_NegSem_220303_ReplyOperation_002(), 5.0);
    }

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_001 Verify that error occurs when any from getreply is applied to single port >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_001 NegSem_220304_getreply_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that error occurs when any from getreply is applied to single port
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction e 
// The PortArrayRef shall be a reference to a port array variable identifier.
module NegSem_220304_getreply_operation_001 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.reply(S:{});
	}
	
    testcase TC_NegSem_220304_getreply_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        alt
		{
        	[] any from p.getreply { setverdict(pass); }
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason"); } 
		}
	}

    control {
        execute(TC_NegSem_220304_getreply_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a port array was expected instead of a port
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_002 Verify that error occurs when any from getreply is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_002 NegSem_220304_getreply_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that error occurs when any from getreply is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction g
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220304_getreply_operation_002 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	} 
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{}) };
		}
	}
	
    testcase TC_NegSem_220304_getreply_operation_002() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index[1];

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}

		v_ptc.start(f());
		v_ptc.done;	
    
        alt
		{
        	[] any from p.getreply(S:{}) -> @index value v_index { 
				if(v_index[0] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}		
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional port arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_003 Verify that error occurs when any from getreply is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_003 NegSem_220304_getreply_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that error occurs when any from getreply is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction g
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220304_getreply_operation_003 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{}) };
		}	
	}
	
    testcase TC_NegSem_220304_getreply_operation_003() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var float v_index;

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}

		v_ptc.start(f());
		v_ptc.done;

        alt
		{
        	[] any from p.getreply(S:{}) -> @index value v_index { 
				if(v_index == 1.0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_NegSem_220304_getreply_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of port arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_004 Verify that any from getreply index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_004 NegSem_220304_getreply_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction h:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220304_getreply_operation_004 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall(S:{});
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].reply(S:{}); }
			}
		}
	}
	
	
    testcase TC_NegSem_220304_getreply_operation_004() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index[1];

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{}, nowait);
			}
		}

		v_ptc.start(f());
		v_ptc.done;

        alt
		{
        	[] any from p.getreply(S:{}) -> sender v_src @index value v_index { 
				if(v_index[0] == 1 and v_index[1] == 2){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}    
	}

    control {
        execute(TC_NegSem_220304_getreply_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the port array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_005 Verify that any from getreply index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_005 NegSem_220304_getreply_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction h:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220304_getreply_operation_005 {

    signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall(S:{});
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].reply(S:{}); }
			}
		}
	}
	
    testcase TC_NegSem_220304_getreply_operation_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index;

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{}, nowait);
			}
		}

		v_ptc.start(f());
		v_ptc.done;	
 
        alt
		{
        	[] any from p.getreply(S:{}) -> @index value v_index { 
				if(v_index == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_NegSem_220304_getreply_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional port arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_006 null component in the from clause of the getreply operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220304_getreply_operation_006 NegSem_220304_getreply_operation_006.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, null component in the from clause of the getreply operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220304_getreply_operation_006 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.getcall(S:{});
        p.reply(S:{});
	}
	
    testcase TC_NegSem_220304_getreply_operation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		connect(self:p, v_compRef:p);
 
		v_ptc.start(f());
		p.call(S:{}) {
            [] p.getreply(S:{}) from v_compRef {} // error expected
            [] p.getreply(S:{}) {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_007 null component in the multicast list of the from clause of the getreply operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220304_getreply_operation_007 NegSem_220304_getreply_operation_007.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, null component in the multicast list of the from clause of the getreply operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220304_getreply_operation_007 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        p.getcall(S:{});
        p.reply(S:{});
	}
	
    testcase TC_NegSem_220304_getreply_operation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		connect(self:p, v_compRef:p);

		v_ptc.start(f());
		p.call(S:{}) {
            [] p.getreply(S:{}) from (mtc, v_compRef) {} // error expected
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_007(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_008 applying @decoded to a forbidden parameter field >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_008 NegSem_220304_getreply_operation_008.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, applying @decoded to a forbidden parameter field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220304_getreply_operation_008 {
    type record of integer RoI (0..255);
    
	signature S(out RoI p_par);

	type integer I with { variant "32 bit" };
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        p.getcall(S:{ p_par := {} });
        p.reply(S:{ p_par := { 0, 0, 0, 0 } });
    }
    
    testcase TC_NegSem_220304_getreply_operation_008() runs on GeneralComp system GeneralComp {
        var I v_res;      
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := { 0, 0, 0, 0 } }) {
            [] p.getreply(S: {p_par := ?}) -> param (v_res := @decoded p_par) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(fail); }
            
        }
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_008(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The '@decoded' modifier is only available to parameter redirects of string types.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_009 decoding error in @decoded redirect parameter assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220304_getreply_operation_009 NegSem_220304_getreply_operation_009.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, decoding error in @decoded redirect parameter assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Failure of this decoding shall cause a test case error. 

module NegSem_220304_getreply_operation_009 {
	signature S(out charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var charstring v_str := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij";
        p.getcall( S: { p_par := ?} );
        p.reply(S:{ p_par := v_str });
    }
	
    testcase TC_NegSem_220304_getreply_operation_009() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := - }) {
            [] p.getreply(S: { p_par := ?}) -> param (v_res := @decoded p_par) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(pass); }            
        }
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_009(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
Dynamic test case error: Parameter redirect \(for parameter 'p__par'\) failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_010 invalid format value in @decoded redirect parameter assignment >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_010 NegSem_220304_getreply_operation_010.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, invalid format value in @decoded redirect parameter assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220304_getreply_operation_010 {
	signature S(out universal charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var universal charstring v_str := encvalue_unichar(v_src);
        p.getcall(S: {p_par := ?});
        p.reply(S:{ p_par := v_str }); 
    }
	
    testcase TC_NegSem_220304_getreply_operation_010() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := - }) {
            [] p.getreply(S: { p_par := ? }) -> param (v_res := @decoded("proprietary") p_par) { 
                setverdict(pass);
            }
            [] p.getreply { setverdict(pass); }
        }   
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_010(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: 'proprietary' is not a valid encoding format
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_011 value of wrong type in @decoded redirect parameter assignment >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_011 NegSem_220304_getreply_operation_011.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, value of wrong type in @decoded redirect parameter assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220304_getreply_operation_011 {
	signature S(out universal charstring p_par);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var universal charstring v_str := encvalue_unichar(v_src);
        p.getcall(S: {p_par := ?});
        p.reply(S:{ p_par := v_str });
    }
	
    testcase TC_NegSem_220304_getreply_operation_011() runs on GeneralComp system GeneralComp {
        var I v_res, v_enc := 32;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := - }) {
            [] p.getreply(S: {p_par := ?}) -> param (v_res := @decoded(v_enc) p_par) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220304_getreply_operation_011(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: Type mismatch: a value of type `charstring' was expected instead of `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_012 encoding parameter of @decoded redirect parameter assignment applied to incorrect type >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_012 NegSem_220304_getreply_operation_012.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, encoding parameter of @decoded redirect parameter assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220304_getreply_operation_012 {
	signature S(out octetstring p_par);

	type charstring CS with { variant ""};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var CS v_src := "abc";
        var octetstring v_os := bit2oct(encvalue(v_src));
        p.getcall(S: {p_par := ?});
        p.reply(S:{ p_par := v_os });
    }
	
    testcase TC_NegSem_220304_getreply_operation_012() runs on GeneralComp system GeneralComp {
        var CS v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{ p_par := - }) {
            [] p.getreply(S: {p_par := ?}) -> param (v_res := @decoded("UTF-8") p_par) { 
                setverdict(pass);
            }
            [] p.getreply { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220304_getreply_operation_012(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The encoding format parameter for the '@decoded' modifier is only available to parameter redirects of universal charstrings
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_013 incompatible from and sender clause in getreply operation >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_013 NegSem_220304_getreply_operation_013.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, incompatible from and sender clause in getreply operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the getreply operation contains both from and sender clause, the variable or parameter 
// referenced in the sender clause shall be type compatible with the template in the from 
// clause.

module NegSem_220304_getreply_operation_013 {

	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
        var integer vc_int;
		port P p;
	}
    
    type component AltComp {
		var charstring vc_str;
        port P px;
	}
	
	function f() runs on GeneralComp {
        p.getcall(S:{});
        p.reply(S:{});
	}
	
    testcase TC_NegSem_220304_getreply_operation_013() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}) {
	        [] p.getreply(S:{}) from AltComp:? -> sender v_compRef { } // error expected
            [] p.getreply(S:{}) { }
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_013(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The types in `from' clause and `sender' redirect are not the same: `@NegSem_220304_getreply_operation_013.AltComp' was expected instead of `@NegSem_220304_getreply_operation_013.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_015 applying @decoded to a forbidden parameter field >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_015 NegSem_220304_getreply_operation_015.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, applying @decoded to a forbidden parameter field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220304_getreply_operation_015 {
    type record R {
        integer id,
        record of integer payload(0..255)
    }    
    
	signature S() return R;

	type integer I with {variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var R v_rec := { id := 6, payload := { 0, 0, 0, 0 }}
        p.getcall(S: {});
        p.reply(S:{} value v_rec);
    }
    
    testcase TC_NegSem_220304_getreply_operation_015() runs on GeneralComp system GeneralComp {
        var I v_res;      
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.getreply(S: {} value R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(fail); }
            
        }
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_015(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The '@decoded' modifier is only available to value redirects of string types.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_016 decoding error in @decoded redirect value assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220304_getreply_operation_016 NegSem_220304_getreply_operation_016.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, decoding error in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Failure of this decoding shall cause a test case error. 

module NegSem_220304_getreply_operation_016 {
	type record R {
        integer id,
        charstring payload
    }
    
    signature S() return R;

	type integer I with {variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 4, payload := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij" };
        p.getcall(S:{});
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_NegSem_220304_getreply_operation_016() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.getreply(S: {} value R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(pass); }            
        }
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_016(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
Dynamic test case error: Value redirect #1 failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_017 invalid format value in @decoded redirect value assignment >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_017 NegSem_220304_getreply_operation_017.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, invalid format value in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220304_getreply_operation_017 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() return R;

	type integer I with {variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S: {});
        p.reply(S:{} value v_rec); 
    }
	
    testcase TC_NegSem_220304_getreply_operation_017() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.getreply(S: {} value R:?) -> value (v_res := @decoded("proprietary") payload) { 
                setverdict(pass);
            }
            [] p.getreply { setverdict(pass); }
        }   
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220304_getreply_operation_017(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
 error: 'proprietary' is not a valid encoding format
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_018 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_018 value of wrong type in @decoded redirect value assignment >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_018 NegSem_220304_getreply_operation_018.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, value of wrong type in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220304_getreply_operation_018 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() return R;

	type integer I with {variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S: {});
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_NegSem_220304_getreply_operation_018() runs on GeneralComp system GeneralComp {
        var I v_res, v_enc := 32;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S: {} value R:?) -> value (v_res := @decoded(v_enc) payload) { 
                setverdict (pass);
            }
            [] p.getreply { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220304_getreply_operation_018(), 5.0);
    }
}  with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: Type mismatch: a value of type `charstring' was expected instead of `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220304_getreply_operation_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_019 encoding parameter of @decoded redirect value assignment applied to incorrect type >

<COMPILE>

<MODULE TTCN NegSem_220304_getreply_operation_019 NegSem_220304_getreply_operation_019.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, encoding parameter of @decoded redirect value assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220304_getreply_operation_019 {
	type record R {
        integer id,
        octetstring payload
    }
    
    signature S() return R;

	type charstring CS with {variant ""};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var CS v_src := "abc";
        var R v_rec := { id := 3, payload := bit2oct(encvalue(v_src)) };
        p.getcall(S: {});
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_NegSem_220304_getreply_operation_019() runs on GeneralComp system GeneralComp {
        var CS v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.getreply(S:{} value R:?) -> value (v_res := @decoded("UTF-8") payload) { 
                setverdict(pass);
            }
            [] p.getreply { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220304_getreply_operation_019(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The encoding format parameter for the '@decoded' modifier is only available to value redirects of universal charstrings
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_220304_getreply_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220304_001 Verify that error occurs when using index redirection in port.getreply operation >

<COMPILE>

<MODULE TTCN NegSyn_220304_getreply_operation_001 NegSyn_220304_getreply_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that error occurs when using index redirection in port.getreply operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// The index redirection shall only be used when the operation is used on an any from 
// port array construct.
module NegSyn_220304_getreply_operation_001 {
	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.reply(S:{});
	}
	
    testcase TC_NegSyn_220304_getreply_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        alt
		{
        	[] p.getreply -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason"); } 
		}		
	}

    control {
        execute(TC_NegSyn_220304_getreply_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT >
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_001 raised exception type not in the list of available exceptions >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_001 NegSem_220305_raise_operation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, raised exception type not in the list of available exceptions
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Exceptions are specified as types. Therefore the exception value may either be derived 
// from a template or be the value resulting from an expression (which of course can be 
// an explicit value). The optional type field in the value specification to the raise 
// operation shall be used in cases where it is necessary to avoid any ambiguity of the type
// of the value being sent.

module NegSem_220305_raise_operation_001 {
	signature S() exception(charstring, octetstring);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type `integer' is not present on the exception list of signature `@NegSem_220305_raise_operation_001.S'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_002 exception raised for a signature with no exception list >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_002 NegSem_220305_raise_operation_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, exception raised for a signature with no exception list
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Exceptions are specified as types. Therefore the exception value may either be derived 
// from a template or be the value resulting from an expression (which of course can be 
// an explicit value). The optional type field in the value specification to the raise 
// operation shall be used in cases where it is necessary to avoid any ambiguity of the type
// of the value being sent.

module NegSem_220305_raise_operation_002 {
	signature S();
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Signature `@NegSem_220305_raise_operation_002.S' does not have exceptions
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_003 raised exception type is ambiguous >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_003 NegSem_220305_raise_operation_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, raised exception type is ambiguous
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Exceptions are specified as types. Therefore the exception value may either be derived 
// from a template or be the value resulting from an expression (which of course can be 
// an explicit value). The optional type field in the value specification to the raise 
// operation shall be used in cases where it is necessary to avoid any ambiguity of the type
// of the value being sent.

module NegSem_220305_raise_operation_003 {
    type integer MyInt1 (1..10);
    type integer MyInt2 (1..20);
    
	signature S() exception(MyInt1, MyInt2);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type of the exception is ambiguous: `integer' is compatible with more than one exception types of signature `@NegSem_220305_raise_operation_003.S'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_004 missing to clause in case of 1 to n connection >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220305_raise_operation_004 NegSem_220305_raise_operation_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, missing to clause in case of 1 to n connection
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// In case of one-to-one connections, the to clause may be omitted, because the receiving 
// entity is uniquely identified by the system structure.

module NegSem_220305_raise_operation_004 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        p.call(S:{}) {
            [] p.catch(S, p_expected) { setverdict(pass); }
            [] p.catch { setverdict(fail); }
        }
	}
	
    testcase TC_NegSem_220305_raise_operation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create, v_ptc2 := GeneralComp.create;
		connect(self:p, v_ptc1:p);
        connect(self:p, v_ptc2:p);
        v_ptc1.start(f(1));
        v_ptc2.start(f(1));
        p.getcall(S:{});
        p.getcall(S:{}); // call from both components expected
		p.raise(S, 1); // missing to clause: error expected
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220305_raise_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Port p has more than one active connections. Message can be sent on it only with explicit addressing.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_005 exception on a message port >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_005 NegSem_220305_raise_operation_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, exception on a message port
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// An exception shall only be raised at a procedure-based port. An exception is a reaction 
// to an accepted procedure call the result of which leads to an exceptional event.

module NegSem_220305_raise_operation_005 {
	signature S() exception(integer);
	
	type port PSig procedure {
		inout S;
	} with {extension "internal"}
    
    type port PMsg message {
		inout integer;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port PSig p1;
        port PMsg p2;
	}
	
	function f() runs on GeneralComp
	{
		p1.getcall(S:{});
		p2.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
        connect(self:p2, v_ptc:p2);
        v_ptc.start(f());
	    p1.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Procedure-based operation `raise' is not applicable to a message-based port of type `@NegSem_220305_raise_operation_005.PMsg'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_006 exception procedure signature not in the port list >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_006 NegSem_220305_raise_operation_006.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, exception procedure signature not in the port list
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// The type definition of the port shall include in its list of accepted procedure calls the
// name of the procedure to which the exception belongs.

module NegSem_220305_raise_operation_006 {
	signature S1() exception(integer);
    signature S2() exception(integer);
	
	type port P procedure {
		inout S1;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S1:{});
		p.raise(S2, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S1:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Signature `@NegSem_220305_raise_operation_006.S2' is not present on the incoming list of port type `@NegSem_220305_raise_operation_006.P'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_007 value of incorrect type in the to clause of the raise operation >

<COMPILE>

<MODULE TTCN NegSem_220305_raise_operation_007 NegSem_220305_raise_operation_007.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, value of incorrect type in the to clause of the raise operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// AddressRef shall be of type address, component or of the type provided in the address 
// declaration of the port type of the port instance referenced in the raise operation.

module NegSem_220305_raise_operation_007 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    const charstring c_ptcName := "PTC";
    
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 1) to c_ptcName;
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create(c_ptcName);
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_007(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A component reference was expected as operand
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_008 null in the to clause of the raise operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220305_raise_operation_008 NegSem_220305_raise_operation_008.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, null in the to clause of the raise operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220305_raise_operation_008 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        var GeneralComp v_compRef := null;
		connect(self:p, v_compRef:p);
		p.getcall(S:{});
		p.raise(S, 1) to v_compRef;
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_008(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220305_raise_operation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220305_009 raise operation on disconnected and unmapped ports >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220305_raise_operation_009 NegSem_220305_raise_operation_009.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.5, raise operation on disconnected and unmapped ports
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Applying a raise operation to an unmapped or disconnected port shall cause a test case 
// error.

module NegSem_220305_raise_operation_009 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
        disconnect(self:p, mtc:p);
		p.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_NegSem_220305_raise_operation_009() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); 
		// no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_NegSem_220305_raise_operation_009(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Port p has neither connections nor mappings. Message cannot be sent on it.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_001 Verify that error occurs when any from catch is applied to single port >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_001 NegSem_220306_catch_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that error occurs when any from catch is applied to single port
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction g 
// The PortArrayRef shall be a reference to a port array variable identifier.
module NegSem_220306_catch_operation_001 {

	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 10);
	}
	
    testcase TC_NegSem_220306_catch_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        alt
		{
        	[] any from p.catch { setverdict(pass); }
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason"); } 
		}
	}

    control {
        execute(TC_NegSem_220306_catch_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a port array was expected instead of a port
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_002 Verify that error occurs when any from catch is applied to 1D array and index target is array >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_002 NegSem_220306_catch_operation_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that error occurs when any from catch is applied to 1D array and index target is array
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220306_catch_operation_002 {

	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, 10) };
		}
	}
	
    testcase TC_NegSem_220306_catch_operation_002() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;

		var integer v_index[1];
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}

		v_ptc.start(f());
		v_ptc.done;	 
   
        alt
		{
        	[] any from p.catch(S, integer:?) -> @index value v_index { 
				if(v_index[0] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}		
    }

    control {
        execute(TC_NegSem_220306_catch_operation_002(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of one-dimensional port arrays can only be redirected to an integer
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_003 Verify that error occurs when any from catch is applied to 1D array and index target has wrong type >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_003 NegSem_220306_catch_operation_003.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that error occurs when any from catch is applied to 1D array and index target has wrong type
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If the index redirection is used for single-dimensional port arrays, the type
// of the integer variable shall allow storing the highest index of the respective array.
module NegSem_220306_catch_operation_003 {

	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, 10) };
		}	
	}
	
    testcase TC_NegSem_220306_catch_operation_003() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var float v_index;

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}

		v_ptc.start(f());
		v_ptc.done;

        alt
		{
        	[] any from p.catch(S, integer:?) -> @index value v_index { 
				if(v_index == 1.0){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_NegSem_220306_catch_operation_003(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of port arrays can only be redirected to an integer, an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_004  that any from catch index redirection for multi-D arrays requires arrays of correct size >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_004 NegSem_220306_catch_operation_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch index redirection for multi-D arrays requires arrays of correct size
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220306_catch_operation_004 {

	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall(S:{});
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].raise(S, 10); }
			}
		}
	}
	
	
    testcase TC_NegSem_220306_catch_operation_004() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index[1];

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{}, nowait);
			}
		}

		v_ptc.start(f());
		v_ptc.done;

        alt
		{
        	[] any from p.catch(S, integer:?) -> sender v_src @index value v_index { 
				if(v_index[0] == 1 and v_index[1] == 2){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}    }

    control {
        execute(TC_NegSem_220306_catch_operation_004(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Size of integer array is invalid: the port array has 2 dimensions, but the integer array has 1 element
<END_RESULT>
<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_005 Verify that any from catch index redirection for multi-D arrays requires arrays >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_005 NegSem_220306_catch_operation_005.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch index redirection for multi-D arrays requires arrays
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module NegSem_220306_catch_operation_005 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall(S:{});
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].raise(S, 10); }
			}
		}
	}
	
    testcase TC_NegSem_220306_catch_operation_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index;

		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{}, nowait);
			}
		}

		v_ptc.start(f());
		v_ptc.done;	 

        alt
		{
        	[] any from p.catch(S, integer:?) -> @index value v_index { 
				if(v_index == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_NegSem_220306_catch_operation_005(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Indices of multi-dimensional port arrays can only be redirected to an integer array or a record of integers
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_006 null component in the from clause of the catch operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220306_catch_operation_006 NegSem_220306_catch_operation_006.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, null component in the from clause of the catch operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220306_catch_operation_006 {

	signature S() exception (charstring);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.getcall(S:{});
        p.raise(S, "exc");
	}
	
    testcase TC_NegSem_220306_catch_operation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		connect(self:p, v_compRef:p);
		v_ptc.start(f());
		p.call(S:{}) {
            [] p.catch(S, charstring:?) from v_compRef {} // error expected
            [] p.catch {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220306_catch_operation_006(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_007 null component in the multicast list of the from clause of the catch operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220306_catch_operation_007 NegSem_220306_catch_operation_007.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, null component in the multicast list of the from clause of the catch operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_220306_catch_operation_007 {

	signature S() exception (charstring);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.getcall(S:{});
        p.raise(S, "exc");
	}
	
    testcase TC_NegSem_220306_catch_operation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		connect(self:p, v_compRef:p);
		v_ptc.start(f());
		p.call(S:{}) {
            [] p.catch(S, charstring:?) from (mtc, v_compRef) {} // error expected
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220306_catch_operation_007(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_008 applying @decoded to a forbidden exception field >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_008 NegSem_220306_catch_operation_008.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, applying @decoded to a forbidden exception field
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module NegSem_220306_catch_operation_008 {
    type record R {
        integer id,
        record of integer payload(0..255)
    }    
    
	signature S() exception (R);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var R v_rec := { id := 6, payload := { 0, 0, 0, 0 }}
        p.getcall(S: {});
        p.raise(S, v_rec);
    }
    
    testcase TC_NegSem_220306_catch_operation_008() runs on GeneralComp system GeneralComp {
        var I v_res;      
        var GeneralComp v_ptc := GeneralComp.create("PTC");

        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.catch { setverdict(pass); }
            
        }
    }

    control {
        execute(TC_NegSem_220306_catch_operation_008(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT>
error: The '@decoded' modifier is only available to value redirects of string types.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_009 decoding error in @decoded redirect value assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_220306_catch_operation_009 NegSem_220306_catch_operation_009.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, decoding error in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Failure of this decoding shall cause a test case error. 

module NegSem_220306_catch_operation_009 {
	type record R {
        integer id,
        charstring payload
    }
    
    signature S() exception (R);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 4, payload := oct2char(bit2oct(encvalue(v_src))) & "abcdefgij" };
        p.getcall(S: {});
        p.raise(S, v_rec);
    }
	
    testcase TC_NegSem_220306_catch_operation_009() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := @decoded payload) { 
                setverdict (pass);
            }
            [] p.catch { setverdict(pass); }            
        }
    }

    control {
        execute(TC_NegSem_220306_catch_operation_009(), 5.0);
    }
} with { encode "RAW"}
<END_MODULE>

<RESULT COUNT >
Dynamic test case error: Value redirect #1 failed, because the buffer was not empty after decoding. Remaining octets: 9.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_010 invalid format value in @decoded redirect value assignment >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_010 NegSem_220306_catch_operation_010.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, invalid format value in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220306_catch_operation_010 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() exception (R);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S: {});
        p.raise(S, v_rec); 
    }
	
    testcase TC_NegSem_220306_catch_operation_010() runs on GeneralComp system GeneralComp {
        var I v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := @decoded("proprietary") payload) { 
                setverdict(pass);
            }
            [] p.catch { setverdict(pass); }
        }   
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220306_catch_operation_010(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: 'proprietary' is not a valid encoding format
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_011 value of wrong type in @decoded redirect value assignment >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_011 NegSem_220306_catch_operation_011.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, value of wrong type in @decoded redirect value assignment
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Any other value shall cause an error.

module NegSem_220306_catch_operation_011 {
	type record R {
        integer id,
        universal charstring payload
    } 
    
    signature S() exception (R);

	type integer I with { variant "32 bit"};
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var I v_src := 1953719668;
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S: {});
        p.raise(S, v_rec);
    }
	
    testcase TC_NegSem_220306_catch_operation_011() runs on GeneralComp system GeneralComp {
        var I v_res, v_enc := 32;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := @decoded(v_enc) payload) { 
                setverdict (pass);
            }
            [] p.catch { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220306_catch_operation_011(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: Type mismatch: a value of type `charstring' was expected instead of `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_012 encoding parameter of @decoded redirect value assignment applied to incorrect type >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_012 NegSem_220306_catch_operation_012.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, encoding parameter of @decoded redirect value assignment applied to incorrect type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is not a universal charstring, the optional
// parameter shall not be present.

module NegSem_220306_catch_operation_012 {
	type record R {
        integer id,
        octetstring payload
    }
    
    signature S() exception (R);

	type charstring CS with {variant ""}
    
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var CS v_src := "abc";
        var R v_rec := { id := 3, payload := bit2oct(encvalue(v_src)) };
        p.getcall(S: {});
        p.raise(S, v_rec);
    }
	
    testcase TC_NegSem_220306_catch_operation_012() runs on GeneralComp system GeneralComp {
        var CS v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());

        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := @decoded("UTF-8") payload) { 
                setverdict(pass);
            }
            [] p.catch { setverdict(pass); }
        }        

    }

    control {
        execute(TC_NegSem_220306_catch_operation_012(), 5.0);
    }
} with {encode "RAW"}
<END_MODULE>

<RESULT COUNT >
error: The encoding format parameter for the '@decoded' modifier is only available to value redirects of universal charstrings
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_220306_catch_operation_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_013 incompatible from and sender clause in catch operation >

<COMPILE>

<MODULE TTCN NegSem_220306_catch_operation_013 NegSem_220306_catch_operation_013.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, incompatible from and sender clause in catch operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// If the catch operation contains both from and sender clause, the variable or parameter 
// referenced in the sender clause shall be type compatible with the template in the from 
// clause.

module NegSem_220306_catch_operation_013 {

	signature S() exception (charstring);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp {
        var integer vc_int;
		port P p;
	}
    
    type component AltComp {
		var charstring vc_str;
        port P px;
	}
	
	function f() runs on GeneralComp {
        p.getcall(S:{});
        p.raise(S, "exc");
	}
	
    testcase TC_NegSem_220306_catch_operation_013() runs on GeneralComp system GeneralComp {
        var GeneralComp v_compRef := null;
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);

		p.call(S:{}) {
	        [] p.catch(S, charstring:?) from AltComp:? -> sender v_compRef { } // error expected
            [] p.catch { }
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_220306_catch_operation_013(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: The types in `from' clause and `sender' redirect are not the same: `@NegSem_220306_catch_operation_013.AltComp' was expected instead of `@NegSem_220306_catch_operation_013.GeneralComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_220306_catch_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 220306_001 Verify that error occurs when using index redirection in port.catch operation >

<COMPILE>

<MODULE TTCN NegSyn_220306_catch_operation_001 NegSyn_220306_catch_operation_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that error occurs when using index redirection in port.catch operation
 ** @verdict  pass reject
 *****************************************************************/
// The following requirements are tested:
// Restriction h
// The index redirection shall only be used when the operation is used on an any from 
// port array construct.
module NegSyn_220306_catch_operation_001 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	} with {extension "internal"}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:{});
		p.raise(S, 20);
	}
	
    testcase TC_NegSyn_220306_catch_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
        alt
		{
        	[] p.catch -> @index value v_index { setverdict(pass); }
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason"); } 
		}		
	}

    control {
        execute(TC_NegSyn_220306_catch_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Index redirect cannot be used without the 'any from' clause
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 2204_the_check_operation folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_2204_the_check_operation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2204_001 null component reference in from clause of check operation >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2204_the_check_operation_001 NegSem_2204_the_check_operation_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.4, null component reference in from clause of check operation
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// No AddressRef shall contain the special value null at the time of the operation.

module NegSem_2204_the_check_operation_001 {

	type port P message {
		inout integer;
        //address integer;
	} with {extension "internal"}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_NegSem_2204_the_check_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_comp := null;
        connect(self:p, self:p);
		connect(self:p, v_comp:p);
        p.send(10);
        alt {
            [] p.check (from v_comp) {}
            [] p.check {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_NegSem_2204_the_check_operation_001(), 5.0);
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The second argument of connect operation contains the null component reference.
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.1/174 02-CRL 113 200/5 Uen
:nl.Statement of Compliance for TITAN project
:li D='[2]'.ETSI ES 201 873-1, v4.7.1 Mockup v1 (2015-06):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.
