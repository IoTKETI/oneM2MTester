.******************************************************************************
.* Copyright (C) 2017 ETSI  All Rights Reserved.
.*
.* Contributors:
.*   Adrien Kirjak 
.*
.******************************************************************************/
text.
:lang eng.
.*
:docname.Test Description
:docno.xz/152 91-CRL 113 200 Uen
:rev.PA1
:date.2016-04-04
.*
:prep.ETH/XZ EADRKIR
:subresp.EADRKIR
:appr.ETH/XZ (Elemer Lelik)
:checked.
.*
:title.ETSI TTCN3 Negative Conformance Test
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*	
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains negative tests from ETSI TTCN3 Conformance Test's 23_timer_operations, 24_test_verdict_operations, 26_module_control and B_matching_incoming_values folders. 

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester.pl

:exmp.
:np.

.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2. 23_timer_operations folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_23_toplevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 23_001 Ensure timer operations are not allowed outside of module control, test case, function, altstep >

<COMPILE>

<MODULE TTCN NegSem_23_toplevel_001 NNegSem_23_toplevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer operations are not allowed outside of module control, test case, function, altstep
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Timer read is not allowed in component definitions
module NegSem_23_toplevel_001 
{
    type component TComp
    {
        timer t_timer1 := 1.0;
        timer t_timer2 := t_timer1.read;
    }
    
    testcase TC_NegSem_23_toplevel_001() runs on TComp
    {
        log("Value of t_timer2.read before starting it", t_timer2.read);
    }
    
    control
    {
        execute(TC_NegSem_23_toplevel_001())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A static value was expected instead of operation `timer read'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_23_toplevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 23_002 Ensure timer operations are not allowed outside of module control, test case, function, altstep >

<COMPILE>

<MODULE TTCN NegSem_23_toplevel_002 NegSem_23_toplevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer operations are not allowed outside of module control, test case, function, altstep
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Timer running is not allowed in component definitions
module NegSem_23_toplevel_002 
{
    type component TComp
    {
        timer t_timer1 := 1.0;
        var boolean v_bool := t_timer1.running;
    }
    
    testcase TC_NegSem_23_toplevel_002() runs on TComp
    {
        log("Value of timer.running before starting it", v_bool);
    }
    
    control
    {
        execute(TC_NegSem_23_toplevel_002())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A static value was expected instead of operation `timer running'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_23_toplevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 23_001 Ensure timer operations are not allowed outside of module control, test case, function, altstep >

<COMPILE>

<MODULE TTCN NegSyn_23_toplevel_001 NegSyn_23_toplevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer operations are not allowed outside of module control, test case, function, altstep
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Timer stop is not allowed in module definitions

module NegSyn_23_toplevel_001 
{
    all timer.stop;
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `all': syntax error, unexpected AllKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_23_toplevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 23_002 Ensure timer operations are not allowed outside of module control, test case, function, altstep >

<COMPILE>

<MODULE TTCN NegSyn_23_toplevel_002 NegSyn_23_toplevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer operations are not allowed outside of module control, test case, function, altstep
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Timer timeout operation is not allowed in module definitions

module NegSyn_23_toplevel_002
{
    any timer.timeout;
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `any': syntax error, unexpected AnyKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2302_timer_start_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_001 Ensure infinity is not allowed >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2302_timer_start_001 NegSem_2302_timer_start_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure infinity is not allowed
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Timer value is non-neg float


module NegSem_2302_timer_start_001 {
    type component TComp{
        timer t_timer;
    }

    testcase TC_NegSem_2302_timer_start_001() runs on TComp{
        // Timer value shall be a non-negative numerical float number 
		// (i.e. the value shall be greater or equal 0.0, infinity and not_a_number are disallowed).
        var float duration := infinity;
        t_timer.start(duration);

		setverdict(fail);
    }

    control{
        
        execute(TC_NegSem_2302_timer_start_001())
       
        
    }
}
<END_MODULE>

<RESULT COUNT>
Dynamic test case error: Starting timer t_timer with a non-numeric float value \(inf\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2302_timer_start_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_002 Ensure not_a_number is not allowed >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2302_timer_start_002 NegSem_2302_timer_start_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure not_a_number is not allowed
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Timer value is non-neg float


module NegSem_2302_timer_start_002 {
    type component TComp{
        timer t_timer;
    }

    testcase TC_NegSem_2302_timer_start_002() runs on TComp{
        // Timer value shall be a non-negative numerical float number 
		// (i.e. the value shall be greater or equal 0.0, infinity and not_a_number are disallowed).
        var float duration := not_a_number;
        t_timer.start(duration);

		setverdict(fail);
    }

    control{
        
            execute(TC_NegSem_2302_timer_start_002())
       
        
    }
}
<END_MODULE>

<RESULT COUNT>
Dynamic test case error: Starting timer t_timer with a non-numeric float value \(nan\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2302_timer_start_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_003 Ensure negative value is not allowed >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2302_timer_start_003 NegSem_2302_timer_start_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure negative value is not allowed
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Timer value is non-neg float
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/neg timer value causes error verdict

module NegSem_2302_timer_start_003 {
    type component TComp{
        timer t_timer;
    }

    testcase TC_NegSem_2302_timer_start_003() runs on TComp{
        // Timer value shall be a non-negative numerical float number 
		// (i.e. the value shall be greater or equal 0.0, infinity and not_a_number are disallowed).
        var float duration := -1.0;
        t_timer.start(duration);

		setverdict(fail);
    }

    control{
        
            execute(TC_NegSem_2302_timer_start_003())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Starting timer t_timer with a negative duration \(-1\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2302_timer_start_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_004 Ensure negative infinity is not allowed >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2302_timer_start_004 NegSem_2302_timer_start_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure negative infinity is not allowed
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Timer value is non-neg float


module NegSem_2302_timer_start_004 {
    type component TComp{
        timer t_timer;
    }

    testcase TC_NegSem_2302_timer_start_004() runs on TComp{
        // Timer value shall be a non-negative numerical float number 
		// (i.e. the value shall be greater or equal 0.0, infinity and not_a_number are disallowed).
        var float duration := -infinity;
        t_timer.start(duration);

		setverdict(fail);
    }

    control{
        
            execute(TC_NegSem_2302_timer_start_004())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Starting timer t_timer with a negative duration \(-inf\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_001 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_001 NegSyn_2302_timer_start_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_001 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2302_timer_start_001() runs on TComp{
        t_timer.start();
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_001())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\)': syntax error, unexpected '\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_002 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_002 NegSyn_2302_timer_start_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax  


module NegSyn_2302_timer_start_002 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_002() runs on TComp{
        
        t_timers[].start;
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_002())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_003 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_003 NegSyn_2302_timer_start_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/


module NegSyn_2302_timer_start_003 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_003() runs on TComp{
        
        t_timers[1].start();
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_003())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\)': syntax error, unexpected '\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_004 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_004 NegSyn_2302_timer_start_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_004 {
    type component TComp{
        
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2302_timer_start_004() runs on TComp{
        
        t_timer.start 1.0;
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_004())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `1.0': syntax error, unexpected FloatValue
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_005 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_005 NegSyn_2302_timer_start_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_005 {
    type component TComp{
        
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2302_timer_start_005() runs on TComp{
        
        t_timer start(1.0);
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_005())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected StartKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_006 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_006 NegSyn_2302_timer_start_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_006 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_006() runs on TComp{
        
        t_timers[1].start 1.0;
        
    }

    control{
        
        execute(TC_NegSyn_2302_timer_start_006())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `1.0': syntax error, unexpected FloatValue
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_007 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_007 NegSyn_2302_timer_start_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_007 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_007() runs on TComp{
        
        t_timers[1] start(1.0);
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_007())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected StartKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_009 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_009 NegSyn_2302_timer_start_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax


module NegSyn_2302_timer_start_009 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_009() runs on TComp{
        
        t_timers[1] start;
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_009())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected StartKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_010 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_010 NegSyn_2302_timer_start_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow any timer.start

module NegSyn_2302_timer_start_010 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_010() runs on TComp{
        // This is not allowed by the TTCN3 grammar
        any timer.start;
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_010())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected DotStartKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_011 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_011 NegSyn_2302_timer_start_011.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow any timer.start

module NegSyn_2302_timer_start_011 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_011() runs on TComp{
        // This is not allowed by the TTCN3 grammar
        any timer.start(1.0);
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_011())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected DotStartKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_012 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_012 NegSyn_2302_timer_start_012.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow all timer.start

module NegSyn_2302_timer_start_012 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_012() runs on TComp{
        // This is not allowed by the TTCN3 grammar
        all timer.start;
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_012())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected DotStartKeyword, expecting DotStopKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2302_timer_start_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2302_013 Ensure timer start syntax >

<COMPILE>

<MODULE TTCN NegSyn_2302_timer_start_013 NegSyn_2302_timer_start_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer start syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Start timer syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow all timer.start


module NegSyn_2302_timer_start_013 {
    type component TComp{
        
        timer t_timers[3] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_2302_timer_start_013() runs on TComp{
        // This is not allowed by the TTCN3 grammar
        all timer.start(1.0);
        
    }

    control{
        
            execute(TC_NegSyn_2302_timer_start_013())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `start': syntax error, unexpected DotStartKeyword, expecting DotStopKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2303_001 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_001 NegSyn_2303_timer_stop_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax


module NegSyn_2303_timer_stop_001 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2303_timer_stop_001() runs on TComp{
        t_timer.start;
        t_timer stop;
        
    }

    control{
        
        execute(TC_NegSyn_2303_timer_stop_001())
       
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `stop': syntax error, unexpected StopKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2303_002 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_002 NegSyn_2303_timer_stop_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax


module NegSyn_2303_timer_stop_002 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2303_timer_stop_002() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        t_timer[].stop;
        
    }

    control{
        
       execute(TC_NegSyn_2303_timer_stop_002())
       
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2303_003 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_003 NegSyn_2303_timer_stop_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure all timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax


module NegSyn_2303_timer_stop_003 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2303_timer_stop_003() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        all.stop;
        
    }

    control{
        
        execute(TC_NegSyn_2303_timer_stop_003())

    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `stop': syntax error, unexpected DotStopKeyword, expecting ComponentKeyword or PortKeyword or TimerKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2303_004 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_004 NegSyn_2303_timer_stop_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure all timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax


module NegSyn_2303_timer_stop_004 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2303_timer_stop_004() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        timer.stop;
        
    }

    control{
		execute(TC_NegSyn_2303_timer_stop_004())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `stop': syntax error, unexpected DotStopKeyword, expecting Identifier
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2303_005 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_005 NegSyn_2303_timer_stop_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure all timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax


module NegSyn_2303_timer_stop_005 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2303_timer_stop_005() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        all timer stop;
        
    }

    control{
		execute(TC_NegSyn_2303_timer_stop_005())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `stop': syntax error, unexpected StopKeyword, expecting DotStopKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2303_timer_stop_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -2303_006 Ensure timer stop syntax >

<COMPILE>

<MODULE TTCN NegSyn_2303_timer_stop_006 NegSyn_2303_timer_stop_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure all timer stop syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow any timer.stop

module NegSyn_2303_timer_stop_006 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2303_timer_stop_006() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        any timer.stop;
        
    }

    control{
		execute(TC_NegSyn_2303_timer_stop_006())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `stop': syntax error, unexpected DotStopKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2304_timer_read_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2304_001 Ensure timer read syntax >

<COMPILE>

<MODULE TTCN NegSyn_2304_timer_read_001 NegSyn_2304_timer_read_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Timer Read syntax


module NegSyn_2304_timer_read_001 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2304_timer_read_001() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        t_timer[].read;
        
    }

    control{
		execute(TC_NegSyn_2304_timer_read_001())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2304_timer_read_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2304_002 Ensure timer read syntax >

<COMPILE>

<MODULE TTCN NegSyn_2304_timer_read_002 NegSyn_2304_timer_read_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Timer Read syntax


module NegSyn_2304_timer_read_002 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2304_timer_read_002() runs on TComp{
		var float v_float;
        v_float := t_timer read;
        
    }

    control{
		execute(TC_NegSyn_2304_timer_read_002())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `read': syntax error, unexpected ReadKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2304_timer_read_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2304_003 Ensure timer read syntax >

<COMPILE>

<MODULE TTCN NegSyn_2304_timer_read_003 NegSyn_2304_timer_read_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Timer Read syntax


module NegSyn_2304_timer_read_003 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2304_timer_read_003() runs on TComp{
		var float v_float;
        v_float := read(t_timer);
        
    }

    control{
		execute(TC_NegSyn_2304_timer_read_003())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `read': syntax error, unexpected ReadKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2304_timer_read_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2304_004 Ensure timer read syntax: disallow any timer.read >

<COMPILE>

<MODULE TTCN NegSyn_2304_timer_read_004 NegSyn_2304_timer_read_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read syntax: disallow any timer.read
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Timer Read syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow any timer.read

module NegSyn_2304_timer_read_004 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2304_timer_read_004() runs on TComp{
		var float v_float;
        v_float := any timer.read;
        log ("any timer.read", v_float);
    }

    control{
		execute(TC_NegSyn_2304_timer_read_004())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `read': syntax error, unexpected DotReadKeyword, expecting DotRunningKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2304_timer_read_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2304_005 Ensure timer read syntax >

<COMPILE>

<MODULE TTCN NegSyn_2304_timer_read_005 NegSyn_2304_timer_read_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Timer Read syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow all timer.read

module NegSyn_2305_timer_read_005 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2305_timer_read_005() runs on TComp{
		var float v_float;
        v_float := all timer.read;
    }

    control{
		execute(TC_NegSyn_2305_timer_read_005())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timer': syntax error, unexpected TimerKeyword, expecting ComponentKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_001 Ensure timer running syntax >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_001 NegSyn_2305_timer_running_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax


module NegSyn_2305_timer_running_001 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2305_timer_running_001() runs on TComp{
		var boolean v_bool;
		v_bool := t_timer running;
    }

    control{
		execute(TC_NegSyn_2305_timer_running_001())  
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `running': syntax error, unexpected RunningKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_002 Ensure timer running syntax >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_002 NegSyn_2305_timer_running_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax


module NegSyn_2305_timer_running_002 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2305_timer_running_002() runs on TComp{
        var boolean v_bool;
        v_bool := t_timer[].running;
        
    }

    control{
		execute(TC_NegSyn_2305_timer_running_002())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_003 Ensure timer running syntax >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_003 NegSyn_2305_timer_running_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax


module NegSyn_2305_timer_running_003 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2305_timer_running_003() runs on TComp{
        var boolean v_bool;
        v_bool := any timer running;
        
    }

    control{
		execute(TC_NegSyn_2305_timer_running_003())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `running': syntax error, unexpected RunningKeyword, expecting DotRunningKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_004 Ensure timer running syntax >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_004 NegSyn_2305_timer_running_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax


module NegSyn_2305_timer_running_004 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2305_timer_running_004() runs on TComp{
        var boolean v_bool;
        v_bool := timer.running;
        
    }

    control{
		execute(TC_NegSyn_2305_timer_running_004())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timer': syntax error, unexpected TimerKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_005 Ensure timer running syntax >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_005 NegSyn_2305_timer_running_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax


module NegSyn_2305_timer_running_005 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2305_timer_running_005() runs on TComp{
        var boolean v_bool;
        v_bool := timer any.running;
        
    }

    control{
	 	execute(TC_NegSyn_2305_timer_running_005())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timer': syntax error, unexpected TimerKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2305_timer_running_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2305_006 Ensure timer running syntax: disallow all timer.running >

<COMPILE>

<MODULE TTCN NegSyn_2305_timer_running_006 NegSyn_2305_timer_running_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running syntax: disallow all timer.running
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow all timer.running

module NegSyn_2305_timer_running_006 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2305_timer_running_006() runs on TComp{
        var boolean v_bool;
        v_bool := all timer.running;
        
    }

    control{
		execute(TC_NegSyn_2305_timer_running_006())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timer': syntax error, unexpected TimerKeyword, expecting ComponentKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_001 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_001 NegSyn_2306_timer_timeout_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax


module NegSyn_2306_timer_timeout_001 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }

    testcase TC_NegSyn_2306_timer_timeout_001() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        t_timer[].timeout;
        
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_001())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_002 Ensure timer timeout can`t be used in boolean expressions >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_002 NegSyn_2306_timer_timeout_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout can`t be used in boolean expressions
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The timeout shall not be used in a boolean expression.


module NegSyn_2306_timer_timeout_002 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.1}; 
    }
   
    testcase TC_NegSyn_2306_timer_timeout_002() runs on TComp{
        t_timer[0].start;
        if (t_timer[0].timeout){
            setverdict(fail);
        }
        setverdict(pass);
 
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_002())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timeout': syntax error, unexpected DotTimeoutKeyword, expecting '\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_003 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_003 NegSyn_2306_timer_timeout_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax


module NegSyn_2306_timer_timeout_003 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2306_timer_timeout_003() runs on TComp{
        t_timer.start;
        t_timer.timeout();
        
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_003())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\(': syntax error, unexpected '\('
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_004 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_004 NegSyn_2306_timer_timeout_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax

module NegSyn_2306_timer_timeout_004 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2306_timer_timeout_004() runs on TComp{
        t_timer.start;
        any timer.timeout();
        
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_004()) 
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\(': syntax error, unexpected '\('
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_005 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_005 NegSyn_2306_timer_timeout_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax


module NegSyn_2306_timer_timeout_005 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2306_timer_timeout_005() runs on TComp{
        t_timer.start;
        any timer timeout;

    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_005())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timeout': syntax error, unexpected TimeoutKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_006 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_006 NegSyn_2306_timer_timeout_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax


module NegSyn_2306_timer_timeout_006 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2306_timer_timeout_006() runs on TComp{
        t_timer.start;
        timeout(t_timer);
        
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_006())   
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timeout': syntax error, unexpected TimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_2306_timer_timeout_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2306_007 Ensure timer timeout syntax >

<COMPILE>

<MODULE TTCN NegSyn_2306_timer_timeout_007 NegSyn_2306_timer_timeout_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout syntax
 ** @verdict  pass reject
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timer Timeout syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Disallow all timer.timeout

module NegSyn_2306_timer_timeout_007 {
    type component TComp{
        timer t_timer := 1.0; 
    }

    testcase TC_NegSyn_2306_timer_timeout_007() runs on TComp{
        t_timer.start;
        all timer.timeout;
        
    }

    control{
		execute(TC_NegSyn_2306_timer_timeout_007()) 
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `timeout': syntax error, unexpected DotTimeoutKeyword, expecting DotStopKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 24_test_verdict_operations folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_24_toplevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 24_001 Ensure getverdict is not allowed in constant initialization in control part >

<COMPILE>

<MODULE TTCN NegSem_24_toplevel_001 NegSem_24_toplevel_001.ttcn >
/***************************************************
 ** @version  0.0.2
 ** @purpose  1:24, Ensure getverdict is not allowed in constant initialization in control part
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions.
 **/

module NegSem_24_toplevel_001 {
    // This should be syntactically correct since BNF does not restrict initialization expression 
    const verdicttype c_verdict := getverdict;
	
    type component GeneralComp  {}
	
    testcase TC_NegSem_24_toplevel_001 (verdicttype v_verdict) runs on GeneralComp{
        setverdict(pass)
    }
	
    control {
        execute(TC_NegSem_24_toplevel_001(c_verdict));
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: An evaluable constant value was expected instead of operation `getverdict\(\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_24_toplevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 24_002 Ensure getverdict is not allowed in parameter initialization in control part. >

<COMPILE>

<MODULE TTCN NegSem_24_toplevel_002 NegSem_24_toplevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure getverdict is not allowed in parameter initialization in control part.
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions.
 **/

module NegSem_24_toplevel_002 {
	type component GeneralComp {}
	
	testcase TC_NegSem_24_toplevel_002(verdicttype v_param) runs on GeneralComp {
		setverdict(fail);
	}
	
	control {
		// BNF allows getverdict in expression -- this is a semantic test
		execute(TC_NegSem_24_toplevel_002(getverdict));
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `getverdict\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_24_toplevel_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 24_003 Ensure getverdict is not allowed in variable definition in control part. >

<COMPILE>

<MODULE TTCN NegSem_24_toplevel_003 NegSem_24_toplevel_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure getverdict is not allowed in variable definition in control part.
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions.
 **/

module NegSem_24_toplevel_003 {
	type component GeneralComp {}
	
	testcase TC_NegSem_24_toplevel_003() runs on GeneralComp {
		setverdict(fail);
	}
	
	control {
		var verdicttype v_verdict := getverdict;
		execute(TC_NegSem_24_toplevel_003())
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `getverdict\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_24_toplevel_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 24_004 Ensure setverdict is not allowed in part whithin compound statement. >

<COMPILE>

<MODULE TTCN NegSem_24_toplevel_004 NegSem_24_toplevel_004.ttcn >
/***************************************************
 ** @version  0.0.2
 ** @purpose  1:24, Ensure setverdict is not allowed in part whithin compound statement.
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions.
 **/

module NegSem_24_toplevel_004 {
	type component GeneralComp {}
	
	testcase TC_NegSem_24_toplevel_004() runs on GeneralComp {
		setverdict(fail);
	}
	
	control {
		if (true) {
			// It is allowed by BNF: ControlStatement -> BasicStatements -> ConditionalConstruct -> StatementBlock => SetLocalVerdict  
			setverdict(pass);
		}
		execute(TC_NegSem_24_toplevel_004())
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Setverdict statement is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_24_toplevel_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 24_005 Ensure setverdict is not allowed in control part at the top level. >

<COMPILE>

<MODULE TTCN NegSem_24_toplevel_005 NegSem_24_toplevel_005.ttcn >
/***************************************************
 ** @version  0.0.2
 ** @purpose  1:24, Ensure setverdict is not allowed in control part at the top level.
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions.
 **/

module NegSem_24_toplevel_005 {
	type component GeneralComp {}
	
	testcase TC_NegSem_24_toplevel_005() runs on GeneralComp {
		setverdict(fail);
	}
	
	control {
		// TODO Check with grammar if it is allowed
		// At least grammar allowes it in compound statements
		setverdict(pass);
		execute(TC_NegSem_24_toplevel_005())
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `setverdict': syntax error, unexpected SetVerdictKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2401_SetverdictError_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2401_001 Ensure that setverdict can't set error verdict >

<COMPILE>

<MODULE TTCN NegSem_2401_SetverdictError_001 NegSem_2401_SetverdictError_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24.1, Ensure that setverdict can't set error verdict
 ** @verdict  pass reject, manual:"Ensure only one test case was executed "
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Error verdict shall not be set with setverdict
 **/

module NegSem_2401_SetverdictError_001 {
	type component GeneralComp {};
	
	testcase TC_NegSem_2401_SetverdictError_001_setverdict(out boolean pb_error_occurred) runs on GeneralComp {
		pb_error_occurred := true;
		setverdict(error);
		// Must abort here
		pb_error_occurred := false;
		setverdict(pass)
	}
	
	testcase TC_NegSem_2401_SetverdictError_001_check_error_occured(boolean b_error_occurred) runs on GeneralComp {
		if (b_error_occurred) {
			setverdict(pass);
		} else {
			setverdict(fail)
		}
	}
	
	control {
		var boolean b_error_occurred := true;
		execute(TC_NegSem_2401_SetverdictError_001_setverdict(b_error_occurred));
		execute(TC_NegSem_2401_SetverdictError_001_check_error_occured(b_error_occurred));
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Error verdict cannot be set by the setverdict operation
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2402_setverdict_params_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2402_001 Ensure setverdict accepts parameters of verdicttype only >

<COMPILE>

<MODULE TTCN NegSem_2402_setverdict_params_001 NegSem_2402_setverdict_params_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts parameters of verdicttype only
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Setverdict allowed verdict values
 **/

module NegSem_2402_setverdict_params_001 {
    type component TComp {}
    
    testcase TC_NegSem_2402_setverdict_params_001() runs on TComp {
        var charstring v_pass := "pass";
        setverdict(v_pass);
    }
    
    control {
        execute(TC_NegSem_2402_setverdict_params_001())
    } 
}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type verdict was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2402_setverdict_params_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2402_002 Ensure setverdict accepts parameters of verdicttype only >

<COMPILE>

<MODULE TTCN NegSem_2402_setverdict_params_002 NegSem_2402_setverdict_params_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts parameters of verdicttype only
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Setverdict allowed verdict values
 **/


module NegSem_2402_setverdict_params_002 {
    type component TComp {}
    type record TRec { verdicttype field1 }
    
    testcase TC_NegSem_2402_setverdict_params_002() runs on TComp {
        var TRec v_pass := { field1 := pass };
        setverdict(v_pass);
    }
    
    control {
        execute(TC_NegSem_2402_setverdict_params_002())
    } 
}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type verdict was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2402_setverdict_params_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2402_003 Ensure setverdict accepts parameters of verdicttype only >

<COMPILE>

<MODULE TTCN NegSem_2402_setverdict_params_003 NegSem_2402_setverdict_params_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts values of verdicttype only
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Setverdict allowed verdict values
 **/

module NegSem_2402_setverdict_params_003 {
    type component TComp {}
    
    testcase TC_NegSem_2402_setverdict_params_003() runs on TComp {
        var template verdicttype v_pass := pass;
        setverdict(v_pass);
    }
    
    control {
        execute(TC_NegSem_2402_setverdict_params_003())
    } 
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a value was expected instead of template variable `v_pass'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2402_setverdict_params_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2402_004 Ensure setverdict accepts values only as the parameter >

<COMPILE>

<MODULE TTCN NegSem_2402_setverdict_params_004 NegSem_2402_setverdict_params_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts values only as the parameter
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Setverdict allowed verdict values
 **/

module NegSem_2402_setverdict_params_004 {
    type component TComp {}
    
    testcase TC_NegSem_2402_setverdict_params_004() runs on TComp {
        var template verdicttype v_pass := ?;
        setverdict(v_pass);
    }
    
    control {
        execute(TC_NegSem_2402_setverdict_params_004())
    } 
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a value was expected instead of template variable `v_pass'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2402_setverdict_params_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2402_005 Ensure setverdict accepts values only as the parameter >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_2402_setverdict_params_005 NegSem_2402_setverdict_params_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts values only as the parameter
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Setverdict allowed verdict values
 **/

module NegSem_2402_setverdict_params_005 {
    type component TComp {}
    
    testcase TC_NegSem_2402_setverdict_params_005() runs on TComp {
        var anytype v_var := { integer := 1 };
        setverdict(v_var.verdicttype);
    }
    
    control {
        execute(TC_NegSem_2402_setverdict_params_005())
    } 
}
with {
	extension "anytype integer, verdicttype"
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using non-selected field verdicttype in a value of union type @NegSem_2402_setverdict_params_005.anytype
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 26_module_control folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_2601_ExecuteStatement_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2601_001 Ensure that non-float timeout parameters in the execute statement are rejected (in this case int).>

<COMPILE>

<MODULE TTCN NegSem_2601_ExecuteStatement_001 NegSem_2601_ExecuteStatement_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that non-float timeout parameters in the execute statement are rejected (in this case int).
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2601_ExecuteStatement_001 {

	type component GeneralComp { }

	testcase TC_NegSem_2601_ExecuteStatement_001() runs on GeneralComp {
		setverdict(pass);
	}

	control {
		execute(TC_NegSem_2601_ExecuteStatement_001(), 1); 
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type float was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2601_ExecuteStatement_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2601_002 Ensure that non-float timeout parameters in the execute statement are rejected (in this case charstring).>

<COMPILE>

<MODULE TTCN NegSem_2601_ExecuteStatement_002 NegSem_2601_ExecuteStatement_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that non-float timeout parameters in the execute statement are rejected (in this case charstring).
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2601_ExecuteStatement_002 {

	type component GeneralComp { }

	testcase TC_NegSem_2601_ExecuteStatement_002() runs on GeneralComp {
		setverdict(pass);
	}

	control {
		execute(TC_NegSem_2601_ExecuteStatement_002(), "foobar"); 
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type float was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2601_ExecuteStatement_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2601_004 Ensure that execution rejects test case execution with infinity timer guard >

<COMPILE>

<MODULE TTCN NegSem_2601_ExecuteStatement_004 NegSem_2601_ExecuteStatement_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that execution rejects test case execution with infinity timer guard
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2601_ExecuteStatement_004 {

	type component GeneralComp { }

	testcase TC_NegSem_2601_ExecuteStatement_004(integer p_value, charstring p_string, boolean p_bool) runs on GeneralComp {
			setverdict(pass);
	}

	control {
		var integer v_test := 20;
		execute(TC_NegSem_2601_ExecuteStatement_004(v_test, "hello", true), infinity); //not allowed to explicitly assign infinite timer
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The testcase guard timer duration cannot be INF
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_001 Ensure that setverdict statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_001 NegSem_2602_TheControlPart_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that setverdict statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_001 {

    type component GeneralComp { }

    control {
        setverdict(pass);
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `setverdict': syntax error, unexpected SetVerdictKeyword 
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_002 Ensure that the create component is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_002 NegSem_2602_TheControlPart_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the create component is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_002 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    control {
        var MTCComp v_myComp := MTCComp.create;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `create\(\)' is not allowed in the control part 
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_003 Ensure that the create alive component is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_003 NegSem_2602_TheControlPart_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the create alive component is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_003 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    control {
        var MTCComp v_myComp := MTCComp.create alive;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `create\(\)' is not allowed in the control part 
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_004 Ensure that the start statement is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_004 NegSem_2602_TheControlPart_004.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the start statement is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_004 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        v_myComp.start(f_myBehavior());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Component operation is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_005 Ensure that the stop statement is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_005 NegSem_2602_TheControlPart_005.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the stop statement is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_005 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        v_myComp.start(f_myBehavior());
        v_myComp.stop;
    }

}
<END_MODULE>

<RESULT COUNT 2>
error: Component operation is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_006 Ensure that the kill statement is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_006 NegSem_2602_TheControlPart_006.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the kill statement is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_006 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        v_myComp.start(f_myBehavior());
        v_myComp.kill;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `kill': syntax error, unexpected DotKillKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_007 Ensure that the alive operation is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_007 NegSem_2602_TheControlPart_007.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the alive operation is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_007 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        if (v_myComp.alive) {
        // should be rejected
        }
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `alive' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_008 Ensure that the running operation is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_008 NegSem_2602_TheControlPart_008.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the running operation is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_008 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        if (v_myComp.running) {
        // should be rejected
        }
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `component running' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_009 Ensure that the done operation is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_009 NegSem_2602_TheControlPart_009.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the done operation is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_009 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        v_myComp.start(f_myBehavior());
        v_myComp.done;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `done': syntax error, unexpected DotDoneKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_010 Ensure that the done operation is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_010 NegSem_2602_TheControlPart_010.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the killed operation is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_010 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_myBehavior() runs on MTCComp {
        setverdict(fail);
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        if (v_myComp.killed) {
        // should be rejected
        }
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `killed': syntax error, unexpected DotKilledKeyword, expecting '\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_011 Ensure that the connect statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_011 NegSem_2602_TheControlPart_011.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the connect statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_011 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    type component PTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_firstComp := f_createComp(); // assume create was accepted
        var PTCComp v_secondComp := f_createComp(); // assume create was accepted
	
        connect(v_firstComp:p,v_firstComp:p);
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `connect': syntax error, unexpected ConnectKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_012 Ensure that the disconnect statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_012 NegSem_2602_TheControlPart_012.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the disconnect statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_012 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    type component PTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_firstComp := f_createComp(); // assume create was accepted
        var PTCComp v_secondComp := f_createComp(); // assume create was accepted
	
        disconnect(v_firstComp:p,v_firstComp:p);
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `disconnect': syntax error, unexpected DisconnectKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_013 Ensure that the map statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_013 NegSem_2602_TheControlPart_013.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the map statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_013 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    type component PTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_firstComp := f_createComp(); // assume create was accepted
        var PTCComp v_secondComp := f_createComp(); // assume create was accepted
	
        map(v_firstComp:p,v_firstComp:p);
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `map': syntax error, unexpected MapKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_014 Ensure that the unmap statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_014 NegSem_2602_TheControlPart_014.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the unmap statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_014 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    type component PTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_firstComp := f_createComp(); // assume create was accepted
        var PTCComp v_secondComp := f_createComp(); // assume create was accepted

        unmap(v_firstComp:p,v_firstComp:p);
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `unmap': syntax error, unexpected UnmapKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_015 Ensure that the send statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_015 NegSem_2602_TheControlPart_015.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the send statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_015 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.send(charstring:"foobar");
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `send': syntax error, unexpected DotSendOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_016 Ensure that the receive statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_016 NegSem_2602_TheControlPart_016.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the receive statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_016 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.receive(charstring:"foobar");
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `receive': syntax error, unexpected DotReceiveOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_017 Ensure that the call statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_017 NegSem_2602_TheControlPart_017.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the call statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_017 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    template MyProcedure s_call := { 2, true }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.call(s_call);
	
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `call': syntax error, unexpected DotCallOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_018 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_018 Ensure that the reply statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_018 NegSem_2602_TheControlPart_018.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the reply statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_018 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    template MyProcedure s_call := { 2, true }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.reply(s_call);
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `reply': syntax error, unexpected DotReplyKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_019 Ensure that the raise statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_019 NegSem_2602_TheControlPart_019.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the raise statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_019 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

	type charstring Exception;
	
    signature MyProcedure(integer p_value, boolean p_bool) exception (Exception);
    
    template Exception s_exception := "Thrown exception";

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.raise(MyProcedure, s_exception);
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `raise': syntax error, unexpected DotRaiseKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_020 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_020 Ensure that the trigger statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_020 NegSem_2602_TheControlPart_020.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the trigger statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_020 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        var MyProcedure v_procValue;
        v_myComp.p.trigger(MyProcedure:?) -> value v_procValue;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `trigger': syntax error, unexpected DotTriggerOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_021 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_021 Ensure that the getcall statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_021 NegSem_2602_TheControlPart_021.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the getcall statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_021 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    template MyProcedure s_expected := { 1, ? }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.getcall(s_expected);
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `getcall': syntax error, unexpected DotGetCallOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_022 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_022 Ensure that the getreply statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_022 NegSem_2602_TheControlPart_022.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the getreply statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_022 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.getreply;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `getreply': syntax error, unexpected DotGetReplyOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_023 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_023 Ensure that the catch statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_023 NegSem_2602_TheControlPart_023.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the catch statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_023 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.catch;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `catch': syntax error, unexpected DotCatchOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_024 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_024 Ensure that the check statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_024 NegSem_2602_TheControlPart_024.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the check statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_024 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.check;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `check': syntax error, unexpected DotCheckOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_025 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_025 Ensure that the clear statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_025 NegSem_2602_TheControlPart_025.ttcn >
/*****************************************************************
 ** @version  0.0.2
 ** @purpose  1:26.2, Ensure that the clear statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_025 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.clear;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `clear': syntax error, unexpected DotClearOpKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_026 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_026 Ensure that the start statements on ports are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_026 NegSem_2602_TheControlPart_026.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the start statements on ports are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_026 {

    type port MyPort procedure {
        inout MyProcedure
    }

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.start;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: The argument of start operation is missing, although it cannot be a start timer or start port operation
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_027 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_027 Ensure that the stop statements on ports are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_027 NegSem_2602_TheControlPart_027.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the stop statements on ports are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_027 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.stop;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Component operation is not allowed in the control part
<END_RESULT>
<RESULT COUNT 1>
error: Referencing fields of a component is not allowed
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_028 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_028 Ensure that the halt statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_028 NegSem_2602_TheControlPart_028.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the halt statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_028 {

    type port MyPort procedure {
        inout MyProcedure
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    signature MyProcedure(integer p_value, boolean p_bool);

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
	
        v_myComp.p.halt;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `halt': syntax error, unexpected DotHaltKeyword, expecting DotTimeoutKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_029 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_029 Ensure that alternative behaviours are only used to control timer behavior in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_029 NegSem_2602_TheControlPart_029.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that alternative behaviours are only used to control timer behavior in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_029 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    function f_createComp() return MTCComp {
        return  MTCComp.create;
    }

    control {
        var MTCComp v_myComp := f_createComp(); // assume create was accepted
        alt {
            [] v_myComp.p.receive(charstring:"foobar") {
            }
        }
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Port operation is not allowed in the control part
<END_RESULT>
<RESULT COUNT 1>
error: Reference to a port or port parameter was expected instead of variable `v_myComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_030 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_030 Ensure that getverdict statements are not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_030 NegSem_2602_TheControlPart_030.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that getverdict statements are not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_030 {

    type component GeneralComp { }

    control {
        var verdicttype v_result;
        v_result := getverdict;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `getverdict\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_031 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_031 Ensure that execute statements are not executed from test cases. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_031 NegSem_2602_TheControlPart_031.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that execute statements are not executed from test cases.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_031 {

    type component GeneralComp { }

    testcase TC_NegSem_2602_TheControlPart_031() runs on GeneralComp {
        setverdict(pass);
        execute(TC_NegSem_2602_TheControlPart_031_second()); // shall be rejected
    }

    testcase TC_NegSem_2602_TheControlPart_031_second() runs on GeneralComp {
        setverdict(fail);
    }


    control {
        execute(TC_NegSem_2602_TheControlPart_031());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: A definition that has `runs on' clause cannot execute testcases
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_032 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_032 Ensure that the create alive named component is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_032 NegSem_2602_TheControlPart_032.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the create alive named component is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_032 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    control {
        var MTCComp v_myComp := MTCComp.create("component name") alive;
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `create\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_033 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_033 Ensure that the create named component is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_033 NegSem_2602_TheControlPart_033.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the create named component is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_033 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    control {
        var MTCComp v_myComp := MTCComp.create("component name");
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `create\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_034 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_034 Ensure that the create named component on host is not allowed in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_034 NegSem_2602_TheControlPart_034.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the create named component on host is not allowed in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_034 {

    type port MyPort message {
        inout charstring
    } with {extension "internal"}

    type component MTCComp {
        port MyPort p;
    }

    control {
        var MTCComp v_myComp := MTCComp.create("component name", "localhost");
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Operation `create\(\)' is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_2602_TheControlPart_035 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 2602_035 Ensure that alternative behaviours are only used to control timer behavior in the control part. >

<COMPILE>

<MODULE TTCN NegSem_2602_TheControlPart_035 NegSem_2602_TheControlPart_035.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that alternative behaviours are only used to control timer behavior in the control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_2602_TheControlPart_035 {
    control {
        alt {
            [] any port.receive {
            }
        }
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Port operation is not allowed in the control part
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h2. B_matching_incoming_values folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_B010101_omitting_values_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010101_001 Ensure that the IUT correctly handles template matching of omitted values >

<COMPILE>

<MODULE TTCN NegSem_B010101_omitting_values_001 NegSem_B010101_omitting_values_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.1.1, Ensure that the IUT correctly handles template matching of omitted values 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010101_omitting_values_001 { 

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type set SetType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	RecordType	field1,
  	 	SetType		field2
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010101_omitting_values_001() runs on GeneralComp {

		var MessageType v_testMessage;

	 	template MessageType mw_matchingTemplate:= 
	 	{  
	  		field1 := {a:=1,b:=omit,c:=omit},		//omitting a mandatory field
	  		field2 := {a:=1,b:=omit,c:=omit}
	 	} 

	 	v_testMessage:=  {  
	  		field1 := {a:=1,b:=omit,c:=true}, 
	  		field2 := {a:=1,b:=omit,c:=true}
	 	} 

		connect(self:messagePort, self:messagePort);
	 
	 	messagePort.send(v_testMessage);

	}

	control{
    	execute(TC_NegSem_B010101_omitting_values_001());
	}

}
<END_MODULE>

<RESULT COUNT 2>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010204_any_value_or_none_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010204_001 Ensure that the IUT correctly handles template matching of * values  >

<COMPILE>

<MODULE TTCN NegSem_B010204_any_value_or_none_001 NegSem_B010204_any_value_or_none_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.4, Ensure that the IUT correctly handles template matching of * values 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010204_any_value_or_none_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2, 
  	 	EnumeratedType field3,
  	 	RecordType		field4,
  	 	UnionType		field5,
  	 	RecordType		field6
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010204_any_value_or_none_001() runs on GeneralComp {

    	var MessageType v_testMessage;

		template MessageType mw_matchingTemplate:= 
		{  		
		  	field1 := *,		// * is used on non-optional fields
		  	field2 := *, 
		  	field3 := *,
		  	field4 := *, 
		  	field5 := *,
		  	field6 := {a:=1,b:=*,c:=true}
		} 

		v_testMessage:=  {  
		  	field1 := 2,
		  	field2 := "test string", 
		  	field3 := e_black,
		  	field4 := {a:=1,b:=omit,c:=true}, 
		  	field5 := {a:=1},
		  	field6 := {a:=1,b:=omit,c:=true} 
		} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

		alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
		}
	}

	control{
    	execute(TC_NegSem_B010204_any_value_or_none_001());
	}

}
 
<END_MODULE>

<RESULT COUNT 5>
error: Using `\*' for mandatory field
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010204_any_value_or_none_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010204_002 Ensure that the IUT correctly handles template matching of * values  >

<COMPILE>

<MODULE TTCN NegSem_B010204_any_value_or_none_002 NegSem_B010204_any_value_or_none_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.4, Ensure that the IUT correctly handles template matching of * values 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010204_any_value_or_none_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1 optional, 
  	 	charstring  	field2 optional, 
  	 	EnumeratedType field3 optional,
  	 	RecordType		field4 optional,
  	 	UnionType		field5 optional,
  	 	RecordType		field6,
  	 	UnionType		field7
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010204_any_value_or_none_002() runs on GeneralComp {

    	var MessageType v_testMessage;

		template MessageType mw_matchingTemplate:= 
		{  			
		  	field1 := *,
		  	field2 := *, 
		  	field3 := *,
		  	field4 := *, 
		  	field5 := *,
		  	field6 := {a:=1,b:=*,c:=true}, 
		  	field7 := {a:=*}	//use of * on a union element
		} 

	 	v_testMessage:=  {  
		  	field1 := 2,
		  	field2 := "test string", 
		  	field3 := e_black,
		  	field4 := {a:=1,b:=omit,c:=true}, 
		  	field5 := {a:=1},
		  	field6 := {a:=1,b:=omit,c:=true}, 
		  	field7 := {a:=1}
	 	} 

		connect(self:messagePort, self:messagePort);
 
 		messagePort.send(v_testMessage);

		alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
		}

	}

	control{
		execute(TC_NegSem_B010204_any_value_or_none_002());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: Using `\*' for mandatory field
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010205_value_range_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010205_001 Ensure that the IUT correctly handles template matching of value range definitions >

<COMPILE>

<MODULE TTCN NegSem_B010205_value_range_001 NegSem_B010205_value_range_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010205_value_range_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  			field1, 
  	 	EnumeratedType  	field2, 
  	 	RecordType			field3,
  	 	UnionType			field4
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010205_value_range_001() runs on GeneralComp {

    	var MessageType v_testMessage;

	 	template MessageType mw_matchingTemplate:= 
	 	{  	
	  		field1 := (0..2),
	  		field2 := (e_black..e_white), 	//attempt to use range on enumerated type
	  		field3 := {a:=1,b:=(0..2),c:=true}, 
	  		field4 := {a:=(0..2)}
	 	} 

	 	v_testMessage:=  {  
	  		field1 := 2,
		  	field2 := e_black, 
		  	field3 := {a:=1,b:=2,c:=true}, 
		  	field4 := {a:=1}
	 	} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

	}

	control{
    	execute(TC_NegSem_B010205_value_range_001());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: value range match cannot be used for enumerated type `@NegSem_B010205_value_range_001.EnumeratedType'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010205_value_range_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010205_002 Ensure that the IUT correctly handles template matching of value range definitions  >

<COMPILE>

<MODULE TTCN NegSem_B010205_value_range_002 NegSem_B010205_value_range_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010205_value_range_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2, 
  	 	RecordType		field3,
  	 	UnionType		field4
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010205_value_range_002() runs on GeneralComp {

    	var MessageType v_testMessage;

	 	template MessageType mw_matchingTemplate:= 
	 	{  	
		  	field1 := (2..0),		//boundaries in wrong order
		  	field2 := ("a".."f"), 	
		  	field3 := {a:=1,b:=(0..2),c:=true}, 
		  	field4 := {a:=(0..2)}
	 	} 

	 	v_testMessage:=  {  
		  	field1 := 2,
		  	field2 := "abc", 
		  	field3 := {a:=1,b:=2,c:=true}, 
		  	field4 := {a:=1}
	 	} 
	 
		connect(self:messagePort, self:messagePort);

	 	messagePort.send(v_testMessage);

	}

	control{
		execute(TC_NegSem_B010205_value_range_002());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: The lower boundary is higher than the upper boundary
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010205_value_range_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010205_003 Ensure that the IUT correctly handles template matching of value range definitions >

<COMPILE>

<MODULE TTCN NegSem_B010205_value_range_003 NegSem_B010205_value_range_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010205_value_range_003 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 	

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2, 
  		RecordType		field3,
  	 	UnionType		field4
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010205_value_range_003() runs on GeneralComp {

    	var MessageType v_testMessage;

		template MessageType mw_matchingTemplate:= 
		{  	
		  	field1 := (0..2),		
		  	field2 := ("f".."a"), 	//boundaries in wrong order	
		  	field3 := {a:=1,b:=(0..2),c:=true}, 
		  	field4 := {a:=(0..2)}
		} 

		v_testMessage:=  {  
		  	field1 := 2,
		  	field2 := "abc", 
		  	field3 := {a:=1,b:=2,c:=true}, 
		  	field4 := {a:=1}
		} 

		connect(self:messagePort, self:messagePort); 
		messagePort.send(v_testMessage);

	}

	control{
		execute(TC_NegSem_B010205_value_range_003());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: The lower boundary has higher character code than the upper boundary
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_001 Ensure that the IUT correctly handles template matching of superset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_001 NegSem_B010206_superset_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010206_superset_001 {
	type record MessageType {
		record of integer field1 // superset definition is only allowed over set of
	}

	type port loopbackPort message {
		inout MessageType;
	} with {extension "internal"}


	type component GeneralComp {
		port loopbackPort messagePort;
	}

	testcase TC_NegSem_B010206_superset_001() runs on GeneralComp {

		var MessageType v_testMessage;

		template MessageType mw_matchingTemplate := {field1 := superset(1, 2)}

		v_testMessage := {field1 := {1, 3, 2}};

		connect(self:messagePort, self:messagePort);
		messagePort.send(v_testMessage);
	 	setverdict(pass);
	}

	control {
		execute(TC_NegSem_B010206_superset_001());
	}
}
 
<END_MODULE>

<RESULT COUNT 1>
error: superset match cannot be used for `record of' type `@NegSem_B010206_superset_001.MessageType.field1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_002 Ensure that the IUT correctly handles template matching of superset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_002 NegSem_B010206_superset_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010206_superset_002 {
	type set SetType {
		integer a optional, integer b optional, integer c optional
	}

	type record MessageType {
		SetType field1 // superset definition is only allowed over set of
	}

	type port loopbackPort message {
		inout MessageType;
	} with {extension "internal"}

	type component GeneralComp {
		port loopbackPort messagePort;
	}

	testcase TC_NegSem_B010206_superset_002() runs on GeneralComp {

		var MessageType v_testMessage;

		template MessageType mw_matchingTemplate := {field1 := superset(1, 2)}

		v_testMessage := {field1 := { a:= 1, b:= 3, c:= 2}};

		connect(self:messagePort, self:messagePort);
		messagePort.send(v_testMessage);
	 	setverdict(pass);
	}

	control {
		execute(TC_NegSem_B010206_superset_002());
	}
}
 
<END_MODULE>

<RESULT COUNT 1>
error: superset match cannot be used for set type `@NegSem_B010206_superset_002.SetType'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_004 Ensure that the IUT correctly handles template matching of superset definition >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_004 NegSem_B010206_superset_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010206_superset_004 { 

  	type set of integer SoI;
    type record of integer RoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010206_superset_004() runs on GeneralComp {

    	var SoI v_testMessage;

 		template RoI Template:= {omit};
		
 		template SoI mw_matchingTemplate:= superset(all from Template);    //error

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010206_superset_004());
	}

}
<END_MODULE>

<RESULT COUNT 2>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_005 Ensure that the IUT correctly handles template matching of subset definition >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_005 NegSem_B010206_superset_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definition
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010206_superset_005 { 

  	type set of integer SoI;
    
    type port loopbackPort message {
	  inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010206_superset_005() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template := superset(1,2);

 		template SoI mw_matchingTemplate:= superset(all from Template);    //error

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010206_superset_005());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: A template of type '@NegSem_B010206_superset_005.SoI' can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_006 Ensure that the IUT correctly handles template matching of superset definition >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_006 NegSem_B010206_superset_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010206_superset_006 { 

  	type set of integer SoI;
    
    type port loopbackPort message {
	  inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010206_superset_006() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template:= subset(1,2);

 		template SoI mw_matchingTemplate:= superset(all from Template);    //error

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010206_superset_006());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: A template of type '@NegSem_B010206_superset_006.SoI' can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_007 Ensure that the IUT correctly handles template matching of superset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_007 NegSem_B010206_superset_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010206_superset_007 { 

  	type set of integer SoI;
    
    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010206_superset_007() runs on GeneralComp {

    	var SoI v_testMessage;

		template SoI Template:= {*};

 		template SoI mw_matchingTemplate:= superset(all from Template);    //error

 		v_testMessage:={2};

		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
    	execute(TC_NegSem_B010206_superset_007());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: 'all from' can not refer to permutation or AnyElementsOrNone
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010206_superset_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010206_008 Ensure that the IUT correctly handles template matching of superset definition >

<COMPILE>

<MODULE TTCN NegSem_B010206_superset_008 NegSem_B010206_superset_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010206_superset_008 { 
    type record of integer RoI;
  	type set of integer SoI;
    
    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010206_superset_008() runs on GeneralComp {

    	var SoI v_testMessage;

 		template RoI Template:= {permutation(1,2,3)};

 		template SoI mw_matchingTemplate:= superset(all from Template);    //error

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010206_superset_008());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: 'all from' can not refer to permutation or AnyElementsOrNone
<END_RESULT>
<RESULT COUNT 1>
error: permutation match cannot be used for type `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_001 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_001 NegSem_B010207_subset_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_B010207_subset_001 {
	type record MessageType {
		record of integer
		field1 //     subset definition is only allowed over set of
	}

	type port loopbackPort message {
		inout MessageType;
	} with {extension "internal"}

	type component GeneralComp {
		port loopbackPort messagePort;
	}

	testcase TC_NegSem_B010207_subset_001() runs on GeneralComp {

		var MessageType v_testMessage;

		template MessageType mw_matchingTemplate := {field1 := subset(1, 2)}

		v_testMessage := {field1 := {1}};

		connect(self:messagePort, self:messagePort);
		messagePort.send(v_testMessage);
	 	setverdict(pass);
	}

	control {
		execute(TC_NegSem_B010207_subset_001());
	}
}
 
<END_MODULE>

<RESULT COUNT 1>
error: subset match cannot be used for `record of' type `@NegSem_B010207_subset_001.MessageType.field1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_002 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_002 NegSem_B010207_subset_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010207_subset_002 { 

	type set SetType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	integer  c optional
	} 

	type record MessageType {
  	 	SetType	field1		//subset definition is only allowed over set of
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010207_subset_002() runs on GeneralComp {

    	var MessageType v_testMessage;

 		template MessageType mw_matchingTemplate:= {  	
  			field1 := subset(1,2)
 		} 

 		v_testMessage:=  {  
  			field1 := {a:= 1}
 		} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

	}

	control{
		execute(TC_NegSem_B010207_subset_002());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: subset match cannot be used for set type `@NegSem_B010207_subset_002.SetType'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_004 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_004 NegSem_B010207_subset_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, individual members shall not resolve to AnyValueOrNone and individual fields of
the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010207_subset_004 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	 

	testcase TC_NegSem_B010207_subset_004() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template:= {omit};

 		template SoI mw_matchingTemplate:= subset(all from Template);    
		//error: Compulsory item cannot be omitted.

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010207_subset_004());
	}

}
 
<END_MODULE>

<RESULT COUNT 2>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_005 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_005 NegSem_B010207_subset_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, individual members shall not resolve to AnyValueOrNone and individual fields of
the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010207_subset_005 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010207_subset_005() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template:= superset(3,4);

 		template SoI mw_matchingTemplate:= subset(all from Template);    
		//error: The "all from" clause contains a matching mechanism.

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010207_subset_005());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: A template of type '@NegSem_B010207_subset_005.SoI' can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_006 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_006 NegSem_B010207_subset_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, individual members shall not resolve to AnyValueOrNone and individual fields of
the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010207_subset_006 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010207_subset_006() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template:= subset(3,4);

 		template SoI mw_matchingTemplate:= subset(all from Template);    
		//error: The "all from" clause contains a matching mechanism.

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010207_subset_006());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: A template of type '@NegSem_B010207_subset_006.SoI' can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_007 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_007 NegSem_B010207_subset_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, individual members shall not resolve to AnyValueOrNone and individual fields of
the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010207_subset_007 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010207_subset_007() runs on GeneralComp {

    	var SoI v_testMessage;

 		template SoI Template:= {*};

 		template SoI mw_matchingTemplate:= subset(all from Template);
		//error: forbidden matching mechanism.

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}		
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010207_subset_007());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: 'all from' can not refer to permutation or AnyElementsOrNone
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010207_subset_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010207_008 Ensure that the IUT correctly handles template matching of subset definitions >

<COMPILE>

<MODULE TTCN NegSem_B010207_subset_008 NegSem_B010207_subset_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of subset definitions 
 ** @verdict  pass reject
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, individual members shall not resolve to AnyValueOrNone and individual fields of
the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module NegSem_B010207_subset_008 { 

  	type set of integer SoI;
    type record of integer RoI;

    type port loopbackPort message {
	  	inout SoI
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010207_subset_008() runs on GeneralComp {

    	var SoI v_testMessage;

 		template RoI Template:= {permutation(1,2,4)};

 		template SoI mw_matchingTemplate:= subset(all from Template);    
		//error: forbidden matching mechanism.

 		v_testMessage:={2};
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010207_subset_008());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: 'all from' can not refer to permutation or AnyElementsOrNone
<END_RESULT>
<RESULT COUNT 1>
error: permutation match cannot be used for type `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010208_omit_value_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010208_001 Ensure that the IUT correctly handles template matching of omit values >

<COMPILE>

<MODULE TTCN NegSem_B010208_omit_value_001 NegSem_B010208_omit_value_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010208_omit_value_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2 optional, 
  	 	EnumeratedType 	field3 optional,
  	 	RecordType		field4 optional,
  	 	UnionType		field5 optional,
  	 	RecordType		field6 optional,
  	 	UnionType		field7 optional
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010208_omit_value_001() runs on GeneralComp {

 		template MessageType mw_matchingTemplate:= 
 		{  	
		  	field1 := omit,// causes an error as field1 is mandatory
		  	field2 := *, 
		  	field3 := *,
		  	field4 := *, 
		  	field5 := *,
		  	field6 := *, 
		  	field7 := *
 		} 

 		var MessageType v_testMessage:=  {
		  	field1 := 2,
		  	field2 := omit, 
		  	field3 := omit,
		  	field4 := omit, 
		  	field5 := omit,
		  	field6 := omit, 
		  	field7 := omit
 		} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010208_omit_value_001());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010208_omit_value_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010208_002 Ensure that the IUT correctly handles template matching of omit values >

<COMPILE>

<MODULE TTCN NegSem_B010208_omit_value_002 NegSem_B010208_omit_value_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010208_omit_value_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1, 
  	 	charstring  	field2 optional, 
  	 	EnumeratedType 	field3 optional,
  	 	RecordType		field4 optional,
  	 	UnionType		field5 optional,
  	 	RecordType		field6 optional,
  	 	UnionType		field7 optional
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010208_omit_value_002() runs on GeneralComp {

		template MessageType mw_matchingTemplate:= 
		{  	
		  	field1 := ?,
		  	field2 := *, 
		  	field3 := *,
		  	field4 := *, 
		  	field5 := *,
		  	field6 := {a:=1,b:=2,c:=omit},// causes an error as c field is mandatory
		  	field7 := *
		} 

 		var MessageType v_testMessage:=  {
		  	field1 := 2,
		  	field2 := "test string", 
		  	field3 := e_black,
		  	field4 := {a:=1,b:=omit,c:=true}, 
		  	field5 := {a:=1},
		  	field6 := {a:=1,b:=2,c:=true}, 
		  	field7 := {a:=1}
 		} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(pass);
     		}
     		[] messagePort.receive {
        		setverdict(fail);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010208_omit_value_002());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010303_permutation_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010303_001 Ensure that the IUT correctly handles template matching of ? symbols in value elements >

<COMPILE>

<MODULE TTCN NegSem_B010303_permutation_001 NegSem_B010303_permutation_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010303_permutation_001 {
	type record MessageType {
		set of integer field1, // permutation can only be applied to a record of type
		set of integer field2,
		set of integer field3,
		set of integer field4
	}

	type port loopbackPort message {
		inout MessageType;
	} with {extension "internal"}

	type component GeneralComp {
		port loopbackPort messagePort;
	}

	testcase TC_NegSem_B010303_permutation_001() runs on GeneralComp {
		timer t := 1.0;
		var MessageType v_testMessage;

		template MessageType mw_matchingTemplate := {
			field1 := {permutation(1, 2, 3), 5},
			field2 := {permutation(1, 2, ?), 5},
			field3 := {permutation(1, 2, 3), *},
			field4 := {permutation((1, 2, 3), 2, 3), 5}
		}

		v_testMessage := {
			field1 := {2, 1, 3, 5},
			field2 := {2, 1, 8, 5},
			field3 := {3, 2, 1, 8, 8},
			field4 := {3, 2, 2, 5}
		};
		
		t.start;

		connect(self:messagePort, self:messagePort);
		messagePort.send(v_testMessage);
		alt {
			[] messagePort.receive(mw_matchingTemplate) {
			  setverdict(pass);
			}
			[] t.timeout {
			  setverdict(fail);
			}
		}
	}
	control {
		execute(TC_NegSem_B010303_permutation_001());
	}
}
 
<END_MODULE>

<RESULT COUNT 1>
error: permutation match cannot be used for `set of' type `@NegSem_B010303_permutation_001.MessageType.field1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010303_permutation_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010303_002 Ensure that all from operand can be a record of or set of only >

<COMPILE>

<MODULE TTCN NegSem_B010303_permutation_002 NegSem_B010303_permutation_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that all from operand can be a record of or set of only
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Besides specifying all individual values, it is possible to add all elements of 
// a record of or set of template into permutations using an all from clause.

module NegSem_B010303_permutation_002 { 

	type record of integer RoI;
	template integer t_source := 2;
	// t_source is not a record of or set of -> an error expected
	template RoI t_perm1 := { permutation ( 5, all from t_source ) }; 

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_B010303_permutation_002() runs on GeneralComp {
		if (match({ 2, 5 }, t_perm1)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_NegSem_B010303_permutation_002());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A template of type 'integer' can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010303_permutation_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010303_003 Ensure that type restriction for permutation elements is applied >

<COMPILE>

<MODULE TTCN NegSem_B010303_permutation_003 NegSem_B010303_permutation_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that type restriction for permutation elements is applied
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Each individual member listed in the permutation shall be of the type replicated 
// by the record of type.

module NegSem_B010303_permutation_003 { 

	type record of integer RoI;
	
	template RoI t_perm1 := { permutation ( 5, 2.0 ) }; // float value is not compatible
	
	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_B010303_permutation_003() runs on GeneralComp {
		if (match({ 2, 5 }, t_perm1)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_NegSem_B010303_permutation_003());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: integer value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010303_permutation_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010303_005 Verify restriction on individual members of all from operand in permutation >

<COMPILE>

<MODULE TTCN NegSem_B010303_permutation_005 NegSem_B010303_permutation_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Verify restriction on individual members of all from operand in permutation
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The template in the all from clause as a whole shall not resolve into a matching 
// mechanism

module NegSem_B010303_permutation_005 { 

	type record of integer RoI;
	
	template RoI t_source := ?;
	// The source template resolves to a matching mechanism. It should cause an error.
	template RoI t_perm1 := { permutation ( all from t_source, 2 ) }; 
	

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_B010303_permutation_005() runs on GeneralComp {
		if (match({ 2, 3 }, t_perm1)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_NegSem_B010303_permutation_005());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Matching mechanism can not be used as target of 'all from'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010303_permutation_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010303_006 Verify restriction on individual members of all from operand in permutation >

<COMPILE>

<MODULE TTCN NegSem_B010303_permutation_006 NegSem_B010303_permutation_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Verify restriction on individual members of all from operand in permutation
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Individual members of a permutation and elements of the template in the all from 
// clause shall only be expressions, templates, and the AnyElement and 
// AnyElementsOrNone matching mechanisms.

module NegSem_B010303_permutation_006 { 

	type record of integer RoI;
	
	template RoI t_source := { 1, permutation(2, 3) }
	// The source template contains a matching mechanism inside value (permutation)
	// that is not mentioned as a valid content of the all from operand in
	// B.1.3.3. restriction c
	template RoI t_perm1 := { permutation ( all from t_source, * ) }; 
	

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_B010303_permutation_006() runs on GeneralComp {
		if (match({ 1, 4, 2, 3 }, t_perm1)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_NegSem_B010303_permutation_006());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 'all from' can not refer to permutation or AnyElementsOrNone
<END_RESULT>
<RESULT COUNT 1>
error: permutation match cannot be used for type `integer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010401_length_restrictions_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010401_002 Ensure that the IUT correctly handles template matching of value length definitions >

<COMPILE>

<MODULE TTCN NegSem_B010401_length_restrictions_002 NegSem_B010401_length_restrictions_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.4.1, Ensure that the IUT correctly handles template matching of value length definitions
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010401_length_restrictions_002 { 


	type record MessageType {
  	 	charstring  	field1, 
  	 	bitstring		field2,
  	 	hexstring		field3,
  	 	charstring  	field4, 
  	 	bitstring		field5,
  	 	hexstring		field6
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010401_length_restrictions_002() runs on GeneralComp {

    	var MessageType v_testMessage;

 		template MessageType mw_matchingTemplate:= {  	
		  	field1 := pattern "test s*g" length (6 .. 15),		
		  	field2 := '10*'B  length (3 .. 5), 
		  	field3 := '89?AB'H  length (6),		//pattern is shorter than length restriction
		  	field4 := pattern "tes?" length (4 .. 13),
		  	field5 := '10?'B  length (3 .. 5), 
		  	field6 := '89?ABC'H  length (6)
 		} 

 		v_testMessage:=  {  
		  	field1 := "test string",
		  	field2 := '10101'B, 
		  	field3 := '89ABC'H,
		  	field4 := "test",
		  	field5 := '101'B, 
		  	field6 := '899ABC'H
 		} 
 
 		connect(self:messagePort, self:messagePort);
		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(fail);
     		}
     		[] messagePort.receive {
        		setverdict(pass);
     		}
    	}
	}
	
	control{
		execute(TC_NegSem_B010401_length_restrictions_002());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: There are fewer \(5\) elements in the string than it is allowed by the length restriction \(6\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010401_length_restrictions_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010401_004 Ensure that the IUT correctly handles template matching of value length definitions >

<COMPILE>

<MODULE TTCN NegSem_B010401_length_restrictions_004 NegSem_B010401_length_restrictions_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.4.1, Ensure that the IUT correctly handles template matching of value length definitions
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010401_length_restrictions_004 { 


	type record MessageType {
  	 	record of integer  	field1, 
  	 	record of integer 		field2,
  	 	record of integer 		field3,
  	 	record of integer   	field4, 
  	 	record of integer 		field5,
  	 	record of integer 		field6
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010401_length_restrictions_004() runs on GeneralComp {

    	var MessageType v_testMessage;

 		template MessageType mw_matchingTemplate:= {  	
		  	field1 := { permutation ( 1, 2, 3 ), * } length (3..4),
		  	field2 := { (1,2),* }  length (2 .. 5), 
		  	field3 := { permutation ( 1, 2, 3 ), ? } length (2..3),	//  message length is too long
		  	field4 := { (1,2),? }  length (2 .. 5)
 		} 

 		v_testMessage:=  {  
		  	field1 := {2,1,3},
		  	field2 := {2,1,3,5}, 
		  	field3 := {2,1,3,5},
		  	field4 := {1,1}
 		} 
 
		connect(self:messagePort, self:messagePort);	
 		messagePort.send(v_testMessage);

    	alt {
     		[] messagePort.receive(mw_matchingTemplate) {
        		setverdict(fail);
     		}
     		[] messagePort.receive {
        		setverdict(pass);
     		}
    	}
	}

	control{
		execute(TC_NegSem_B010401_length_restrictions_004());
	}

}
 
<END_MODULE>

<RESULT COUNT 1>
error: There are more \(4\) elements in the template than it is allowed by the length restriction \(at most 3\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010402_ifPresent_indicator_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010402_001 Ensure that the IUT correctly handles template matching of ifpresent indicators >

<COMPILE>

<MODULE TTCN NegSem_B010402_ifPresent_indicator_001 NegSem_B010402_ifPresent_indicator_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.4.2, Ensure that the IUT correctly handles template matching of ifpresent indicators 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010402_ifPresent_indicator_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 	integer  a optional, 
 	 	integer  b optional, 
 	 	boolean  c 
	} 

	type union UnionType { 
 	 	integer  a, 
 	 	EnumeratedType  b, 
 	 	boolean  c 
	} 

	type record MessageType {
  	 	integer  		field1 optional, 
  	 	charstring  	field2 optional, 
  	 	RecordType		field3,
  	 	UnionType		field4 optional
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	
	type component GeneralComp {	    	    
	  	port loopbackPort messagePort
	}	

	testcase TC_NegSem_B010402_ifPresent_indicator_001() runs on GeneralComp {

    	var MessageType v_testMessage;

 		template MessageType mw_matchingTemplate:= {  	
		  	field1 := (0..2) ifpresent,
		  	field2 := ("a".."f") ifpresent, 
		  	field3 := {a:=1,b:=(0..2) ifpresent,c:=true} ifpresent,	
			//use of ifpresent on non-optional field 
		  	field4 := {a:=(0..2)} ifpresent
 		} 

 		v_testMessage:=  {  
		  	field1 := omit,
		  	field2 := omit, 
		  	field3 := {a:=1,b:=omit,c:=true}, 
		  	field4 := omit
 		} 
 
		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);
	}

	control{
		execute(TC_NegSem_B010402_ifPresent_indicator_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: `ifpresent' is not allowed here
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010501_set_expression_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010501_001 Ensure that the IUT correctly handles template matching of character pattern set expressions >

<COMPILE>

<MODULE TTCN NegSem_B010501_set_expression_001 NegSem_B010501_set_expression_001.ttcn >
/***************************************************
 * @author STF 409
 * @version 0.0.1
 * @purpose 1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 * @verdict pass reject
 ***************************************************/
module NegSem_B010501_set_expression_001 {
	type record MessageType {
		charstring field1
	}

	type port loopbackPort message {
		inout MessageType;
	} with {extension "internal"}

	type component GeneralComp {
		port loopbackPort messagePort;
	}

	testcase TC_NegSem_B010501_set_expression_001() runs on GeneralComp {

		var boolean m_res := match( "test", pattern "te[p[q-t]x]t");   // embedded set is not allowed

		setverdict(fail);
		
	}
	control {
		execute(TC_NegSem_B010501_set_expression_001());
	}
}
 
<END_MODULE>

<RESULT COUNT 1>
error: Unmatched `\]'. Did you mean `\\\]'\?
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_B010504_match_referenced_characters_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010504_001 Ensure that the IUT correctly handles template matching of character pattern reference characters >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_B010504_match_referenced_characters_001 NegSem_B010504_match_referenced_characters_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010504_match_referenced_characters_001 { 

    modulepar {
     	charstring MOD_REF:="ef";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 	charstring  	field1, 
  	 	charstring		field2,
  	 	charstring		field3,
  	 	charstring  	field4, 
  	 	charstring		field5,
  	 	charstring		field6
	}

    type port loopbackPort message {
	  	inout MessageType
	} with {extension "internal"}
	

	type component GeneralComp {	    	    
	  	port loopbackPort messagePort;
      	const charstring c_Ref:="s";
	}	

	testcase TC_NegSem_B010504_match_referenced_characters_001(charstring p_Ref) runs on GeneralComp {

    	var MessageType v_testMessage;
    	var charstring v_Ref:="s";
    	template charstring m_Ref:="s";
 
 		template MessageType mw_matchingTemplate:= {  	
		  	field1 := pattern "te[\N{v_Ref}]t",
		  	field2 := pattern "[\N{c_Ref}et]+", 
		  	field3 := pattern "[\N{MOD_REF}-t]+",		//reference length is more than one character
		  	field4 := pattern "te[\N{p_Ref}]t",
		  	field5 := pattern "te[\N{m_Ref}]t",
		  	field6 := pattern "\N{CharRange}+"
 		}; 

 		v_testMessage:=  {  
		  	field1 := "test",
		  	field2 := "test", 
		  	field3 := "test",
		  	field4 := "test",
		  	field5 := "test",
		  	field6 := "test"
 		}; 
	
 		connect(self:messagePort, self:messagePort);
 		messagePort.send(v_testMessage);

	}

	control{
		execute(TC_NegSem_B010504_match_referenced_characters_001("s"));
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The length of the charstring must be of length one, when it is being referenced in a pattern with \\N\{ref\}
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_B010505_pattern_compatibility_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - B010505_001 Ensure that the IUT correctly handles character pattern metacharacters
 compatibility rules of template matching >

<COMPILE>

<MODULE TTCN NegSyn_B010505_pattern_compatibility_001 NegSyn_B010505_pattern_compatibility_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:B.1.5.0, Ensure that the IUT correctly handles character pattern metacharacters
 compatibility rules of template matching
 ** @verdict  pass reject
 ***************************************************/

module NegSyn_B010505_pattern_compatibility_001 { 	

    type component GeneralComp {}

	testcase TC_NegSyn_B010505_pattern_compatibility_001() runs on GeneralComp {

     	template charstring mw_matchingTemplate:= pattern "??riable reference";
     	var charstring mw_matchingTemplate_2:= pattern mw_matchingTemplate;    
		// error: Cannot assign a template to a non-template variable.
   
	}

	control{
    	execute(TC_NegSyn_B010505_pattern_compatibility_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `pattern': syntax error, unexpected PatternKeyword 
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.1/174 02-CRL 113 200/5 Uen
:nl.Statement of Compliance for TITAN project
:li D='[2]'.ETSI ES 201 873-1, v4.7.1 Mockup v1 (2015-06):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.
