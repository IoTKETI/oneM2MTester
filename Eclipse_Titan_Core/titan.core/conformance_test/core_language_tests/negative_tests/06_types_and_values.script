.******************************************************************************
.* Copyright (C) 2017 ETSI  All Rights Reserved.
.*
.* Contributors:
.*   Adrien Kirjak 
.*
.******************************************************************************/
text.
:lang eng.
.*
:docname.Test Description
:docno.xz/152 91-CRL 113 200 Uen
:rev.PA1
:date.2016-04-04
.*
:prep.ETH/XZ EADRKIR
:subresp.EADRKIR
:appr.ETH/XZ (Elemer Lelik)
:checked.
.*
:title.ETSI TTCN3 Negative Conformance Test
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*	
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains negative tests from ETSI TTCN3 Conformance Test's 06_types_and_values folder. 

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester.pl

:exmp.
:np.

.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2. 0601_basic_types_and_values folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_001 Assign float to integer values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_001 NegSyn_060100_SimpleBasicTypes_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign float to integer values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_001 {
    const integer c_i1 := 0.0; // not an integer value
}
<END_MODULE>

<RESULT COUNT 1>
error: integer value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_002 Assign boolean to integer values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_002 NegSyn_060100_SimpleBasicTypes_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign boolean to integer values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_002 {
    const integer c_i1 := true; // not an integer value
}
<END_MODULE>

<RESULT COUNT 1>
error: integer value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_003 Assign integer to float values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_003 NegSyn_060100_SimpleBasicTypes_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign integer to float values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_003 {
    const float c_f1 := 0; // not a float value
}
<END_MODULE>

<RESULT COUNT 1>
error: float value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_004 Assign boolean to float values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_004 NegSyn_060100_SimpleBasicTypes_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign boolean to float values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_004 {
    const float c_f1 := true; // not a float value
}
<END_MODULE>

<RESULT COUNT 1>
error: float value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_005 Assign verdicttype to float values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_005 NegSyn_060100_SimpleBasicTypes_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign verdicttype to float values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_005 {
    const float c_f1 := pass; // not a float value
}
<END_MODULE>

<RESULT COUNT 1>
error: float value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060100_SimpleBasicTypes_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060100_006 Assign integer to verdicttype values >

<COMPILE>

<MODULE TTCN NegSyn_060100_SimpleBasicTypes_006 NegSyn_060100_SimpleBasicTypes_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign integer to verdicttype values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060100_SimpleBasicTypes_006 {
    const verdicttype c_v1 := 1; // not a verdict
}
<END_MODULE>

<RESULT COUNT 1>
error: verdict value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_001 Assign invalid bitstring value >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_001 NegSyn_060101_TopLevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign invalid bitstring value
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_001 {
    const bitstring c_b1 := '2'B; // not an bitstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: Bitstring value contains invalid character
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_002 Assign string to bitstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_002 NegSyn_060101_TopLevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign string to bitstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_002 {
    const bitstring c_b1 := "1"; // not an bitstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: bitstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_003 Assign octetstring to bitstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_003 NegSyn_060101_TopLevel_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign octetstring to bitstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_003 {
    const bitstring c_b1 := '01'O; // not an bitstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: bitstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_004 Assign invalid hexstring value >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_004 NegSyn_060101_TopLevel_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign invalid hexstring value
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_004 {
    const hexstring c_b1 := '01H'O; // not an hexstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: Invalid character `H' \(0x48\) in binary string
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_005 Assign string to hexstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_005 NegSyn_060101_TopLevel_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign string to hexstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_005 {
    const hexstring c_b1 := "010"; // not an hexstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: hexstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_006 Assign octetstring to hexstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_006 NegSyn_060101_TopLevel_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign octetstring to hexstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_006 {
    const hexstring c_b1 := '01'O; // not an hexstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: hexstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_007 Assign invalid octetstring value >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_007 NegSyn_060101_TopLevel_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign invalid octetstring value
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_007 {
    const octetstring c_b1 := '1FA'O; // not an octetstring value, odd number of nibbles
}
<END_MODULE>

<RESULT COUNT 1>
error: Octetstring value contains odd number of hexadecimal digits
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_008 Assign string to octetstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_008 NegSyn_060101_TopLevel_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign string to octetstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_008 {
    const octetstring c_b1 := "F15A"; // not an octetstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: octetstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_009 Assign hexstring to octetstring values >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_009 NegSyn_060101_TopLevel_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign hexstring to octetstring values
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_009 {
    const octetstring c_b1 := 'FA'H; // not an octetstring value
}
<END_MODULE>

<RESULT COUNT 1>
error: octetstring value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060101_TopLevel_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060101_010 Assign invalid hexstring value >

<COMPILE>

<MODULE TTCN NegSyn_060101_TopLevel_010 NegSyn_060101_TopLevel_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign invalid hexstring value
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060101_TopLevel_010 {
    const octetstring c_b1 := '1FAH'O; // not an octetstring value, H not valid
}
<END_MODULE>

<RESULT COUNT 1>
error: Invalid character `H' \(0x48\) in binary string
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_001 Assign values to restricted bitstring. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_001 NegSem_06010201_ListOfValues_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted bitstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_001 {
    type bitstring MyListOfBitStrings ('01'B, '10'B, '11'B);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_001() runs on GeneralComp {
        var MyListOfBitStrings v_b := '00'B; // value is not defined by the type
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '00'B is not a valid value for type `bitstring' which has subtype length\(2\) except \('00'B\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_002 Assign values to restricted hexstring. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_002 NegSem_06010201_ListOfValues_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted hexstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_002 {
    type hexstring MyListOfHexStrings ('01'H, '10'H);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_002() runs on GeneralComp {
        var MyListOfHexStrings v_h := '00'H; // value is not defined by the type
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '00'H is not a valid value for type `hexstring' which has subtype \('01'H,'10'H\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_003 Assign values to restricted octetstring. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_003 NegSem_06010201_ListOfValues_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted octetstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_003 {
    type octetstring MyListOfOctetStrings ('01'O, '10'O);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_003() runs on GeneralComp {
        var MyListOfOctetStrings v_h := '00'O; // value is not defined by the type
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '00'O is not a valid value for type `octetstring' which has subtype \('01'O,'10'O\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_004 Assign values to restricted charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_004 NegSem_06010201_ListOfValues_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_004 {
    type charstring MyCharstr ("a", "abc");

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_004() runs on GeneralComp {
        var MyCharstr v_b := "d"; // value is not defined by the type
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "d" is not a valid value for type `charstring' which has subtype \("a","abc"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_005 Assign values to restricted integer. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_005 NegSem_06010201_ListOfValues_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted integer.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_005 {
    type integer MyInt (1, 5);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_005() runs on GeneralComp {
        var MyInt v_i := 2; // value is not defined by the type
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 2 is not a valid value for type `integer' which has subtype \(1,5\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010201_ListOfValues_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010201_006 Assign values to restricted float. >

<COMPILE>

<MODULE TTCN NegSem_06010201_ListOfValues_006 NegSem_06010201_ListOfValues_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign values to restricted float.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010201_ListOfValues_006 {
    type float MyFloat (1.0, 5.0);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010201_ListOfValues_006() runs on GeneralComp {
        var MyFloat v_f := 2.0; // value is not defined by the type
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010201_ListOfValues_006());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 2.0e0 is not a valid value for type `float' which has subtype \(1.0e0,5.0e0\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_001 Assign invalid values to list of types restricted bitstring. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_001 NegSem_06010202_ListOfTypes_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted bitstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_001 {
    type bitstring BitStrings1 ('0'B, '1'B );
    type bitstring BitStrings2 ('00'B, '01'B, '10'B, '10'B);
    type bitstring BitStrings_1_2 (BitStrings1, BitStrings2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_001() runs on GeneralComp {
        var BitStrings_1_2 v_b := '11'B; // 11 is not defined by the type
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '11'B is not a valid value for type `bitstring' which has subtype length\(1..2\) except \('11'B\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_002 Assign invalid values to list of types restricted hexstring. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_002 NegSem_06010202_ListOfTypes_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted hexstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_002 {
    type hexstring HexStrings1 ('FE80'H, '01'H );
    type hexstring HexStrings2 ('00'H, '7F'H, 'B8'H, 'A0'H);
    type hexstring HexStrings_1_2 (HexStrings1, HexStrings2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_002() runs on GeneralComp {
        var HexStrings_1_2 v_b;
        v_b := 'FE70'H;	 //FE70 value is not defined by any hexstrings
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'FE70'H is not a valid value for type `hexstring' which has subtype \('00'H,'01'H,'7F'H,'A0'H,'B8'H,'FE80'H\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_003 Assign invalid values to list of types restricted octetstring. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_003 NegSem_06010202_ListOfTypes_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted octetstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_003 {
    type octetstring Firstoctetstrings('0036'O,'0050'O); //30 and 40 in decimal
    type octetstring Secondtoctetstrings ('0074'O,'0120'O); //50 and 60 in decimal
    type octetstring octetStrings_1_2 (Firstoctetstrings, Secondtoctetstrings);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_003() runs on GeneralComp {
        var octetStrings_1_2 v_b;
        v_b := '0014'O;	 // '0014'O value is not defined
    		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '0014'O is not a valid value for type `octetstring' which has subtype \('0036'O,'0050'O,'0074'O,'0120'O\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_004 Assign invalid values to list of types restricted charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_004 NegSem_06010202_ListOfTypes_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_004 {
    type charstring Firstcharstrings("abc", "def"); 
    type charstring Secondcharstrings("ghi", "jkl"); 
    type charstring charStrings_1_2 (Firstcharstrings,Secondcharstrings);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_004() runs on GeneralComp {
        var charStrings_1_2 v_b;
        v_b := "xyz";	// invalid charsting
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "xyz" is not a valid value for type `charstring' which has subtype \("abc","def","ghi","jkl"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_005 Assign invalid values to list of types restricted universal charstrings. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_005 NegSem_06010202_ListOfTypes_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted universal charstrings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_005 {
  type universal charstring unicharString1 ("0" .. "9","A".."Z"); // charstring between "0" and "9" and "A".."Z"
  type universal charstring unicharString2 ("a".."z"); // charstring between "a" to "z" 
  type universal charstring unicharStrings_1_2 (unicharString1, unicharString2);
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_005() runs on GeneralComp {
        var unicharStrings_1_2 v_b;
        v_b:="?"; // invalid
      	setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "\?" is not a valid value for type `universal charstring' which has subtype \(from\("0".."9","A".."Z"\) union from\("a".."z"\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_006 Assign invalid values to list of types restricted integers. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_006 NegSem_06010202_ListOfTypes_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted integers.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_006 {
    type integer Integer1 (0..9 );
    type integer Integer2 (20..30);
    type integer Integer_1_2 (Integer1, Integer2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_006() runs on GeneralComp {
        var Integer_1_2 v_b;
        v_b := 15; //invalid
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_006());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 15 is not a valid value for type `integer' which has subtype \(0..9,20..30\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_007 Assign invalid values to list of types restricted floats. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_007 NegSem_06010202_ListOfTypes_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted floats.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_007 {
    type float Float1 (1.0E0..9E0);	//float values between 1 and 9
    type float Float2 (2.0E1..3.0E1);	//float values between 20 and 30
    type float Float_1_2 (Float1, Float2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_007() runs on GeneralComp {
        var Float_1_2 v_b;
        v_b := 15.5E0;	//invalid
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_007());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 1.55e1 is not a valid value for type `float' which has subtype \(1.0e0..9.0e0,2.0e1..3.0e1\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_008 Assign invalid values to list of types restricted boolean value. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_008 NegSem_06010202_ListOfTypes_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted boolean value.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_008 {
    type boolean MyBoolean1 (false);	//only "false" is accepted
	type boolean MyBoolean2 (false);
	type boolean MyBoolean_1_2 (MyBoolean1, MyBoolean2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_008() runs on GeneralComp {
        var MyBoolean_1_2 v_b;
        v_b := true; // invalid
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010202_ListOfTypes_008());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: true is not a valid value for type `boolean' which has subtype \(false\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010202_ListOfTypes_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010202_009 Assign invalid values to list of types restricted verdicttype. >

<COMPILE>

<MODULE TTCN NegSem_06010202_ListOfTypes_009 NegSem_06010202_ListOfTypes_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign invalid values to list of types restricted verdicttype.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010202_ListOfTypes_009 {
    type verdicttype Myverdict1 (pass, error);	//only "pass" and "error" values are listed
	type verdicttype Myverdict2 (inconc, none);	//only "inconc" and "none" values are listed
    type verdicttype Myverdict_1_2 (Myverdict1, Myverdict2);
    
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010202_ListOfTypes_009() runs on GeneralComp {
        var Myverdict_1_2 v_b;
        v_b := fail; //invalid
		setverdict(pass);
    }
    control{
        execute(TC_NegSem_06010202_ListOfTypes_009());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: fail is not a valid value for type `verdicttype' which has subtype \(none,pass,inconc,error\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_001 Assign invalid values to restricted integer. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_001 NegSem_06010203_Ranges_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to restricted integer.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_001 {
	type integer MyIntegerRange (0 .. 255);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_001() runs on GeneralComp {
        var MyIntegerRange v_i := -1; // -1 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: -1 is not a valid value for type `integer' which has subtype \(0..255\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_002 Assign invalid values to restricted integer. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_002 NegSem_06010203_Ranges_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to restricted integer.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_002 {
	type integer MyIntegerRange (-infinity .. 0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_002() runs on GeneralComp {
        var MyIntegerRange v_i := 1; // 1 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 1 is not a valid value for type `integer' which has subtype \(-infinity..0\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_003 Assure that not_a_number is not allowed in float range subtyping. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_003 NegSem_06010203_Ranges_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assure that not_a_number is not allowed in float range subtyping.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_003 {
    // causes an error as not_a_number is not allowed in range subtyping
    type float MyFloatRange (-infinity .. not_a_number);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_003() runs on GeneralComp {
        var MyFloatRange v_i;
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: upper boundary cannot be not_a_number in float subtype range
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_004 Assign invalid values to restricted integer with exclusive bounds. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_004 NegSem_06010203_Ranges_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to restricted integer with exclusive bounds.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_004 {
	type integer MyIntegerRange (!-3 .. 0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_004() runs on GeneralComp {
        var MyIntegerRange v_i := -3; // -3 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: -3 is not a valid value for type `integer' which has subtype \(-2..0\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_005 Assign invalid values to restricted integer with exclusive bounds. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_005 NegSem_06010203_Ranges_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to restricted integer with exclusive bounds.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_005 {
	type integer MyIntegerRange (-infinity .. !0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_005() runs on GeneralComp {
        var MyIntegerRange v_i := 0; // 0 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 0 is not a valid value for type `integer' which has subtype \(-infinity..-1\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_006 Assign range to boolean not permitted. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_006 NegSem_06010203_Ranges_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign range to boolean not permitted.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_006 {
    // only restrictions for integer, float, charstring and universal charstring are allowed in ranges
    type boolean MyBooleanRange (false .. true); // should be rejected
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_006() runs on GeneralComp {
        var MyBooleanRange v_b1;
        v_b1 := true;
        v_b1 := false;
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_006());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Range subtyping is not allowed for type `boolean'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_007 Assign invalid value to range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_007 NegSem_06010203_Ranges_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_007 {
    type charstring MyCharstringRange (!"a"..!"f");
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_007() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "a";
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_007());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "a" is not a valid value for type `charstring' which has subtype from\("b".."e"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_008 Assign invalid value to range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_008 NegSem_06010203_Ranges_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_008 {
    type charstring MyCharstringRange ("a"..!"f");
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_008() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "f";
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_008());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "f" is not a valid value for type `charstring' which has subtype from\("a".."e"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_009 Assign invalid value to range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_009 NegSem_06010203_Ranges_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_009 {
    type charstring MyCharstringRange ("a".."f");
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_009() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "g";
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_009());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "g" is not a valid value for type `charstring' which has subtype from\("a".."f"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_010 Assign invalid values to restricted float. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_010 NegSem_06010203_Ranges_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to restricted float.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_010 {
	type float MyFloatRange (-infinity .. 0.0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_010() runs on GeneralComp {
        var MyFloatRange v_f := 1.0; // 1.0 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_010());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 1.0e0 is not a valid value for type `float' which has subtype \(-INF..0.0e0\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_011 Assign invalid values to restricted float. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_011 NegSem_06010203_Ranges_011.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to range restricted float.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_011 {
	type float MyFloatRange (-5.0 .. 0.0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_011() runs on GeneralComp {
        var MyFloatRange v_f := 10.0; // 10.0 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_011());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 1.0e1 is not a valid value for type `float' which has subtype \(-5.0e0..0.0e0\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_012 Assign invalid values to range excluded restricted float. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_012 NegSem_06010203_Ranges_012.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid values to range excluded restricted float.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_012 {
	type float MyFloatRange (-1.0 .. !10.0);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_012() runs on GeneralComp {
        var MyFloatRange v_f := 10.0; // 10.0 is outside range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_012());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 1.0e1 is not a valid value for type `float' which has subtype \(-1.0e0..!1.0e1\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_013 Assign invalid value to range constrained universal charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_013 NegSem_06010203_Ranges_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained universal charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_013 {
    type universal charstring MyUCharString (char(0, 0, 1, 111) .. !char(0, 0, 1, 113));
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_013() runs on GeneralComp {
        var MyUCharString v_uc1;
        v_uc1 := char(0, 0, 1, 100); // out of range
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_013());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: char\(0, 0, 1, 100\) is not a valid value for type `universal charstring' which has subtype from\(char\(0, 0, 1, 111\)..char\(0, 0, 1, 112\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_014 Assign invalid value to range constrained universal charstring with mixed bounds. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_014 NegSem_06010203_Ranges_014.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained universal charstring with mixed bounds.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_014 {
    type universal charstring MyUCharString (char(0, 0, 1, 111) .. !char(0, 0, 1, 113));
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_014() runs on GeneralComp {
        var MyUCharString v_uc1;
        v_uc1 := char(0, 0, 1, 113); // 113 is excluded
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_014());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: char\(0, 0, 1, 113\) is not a valid value for type `universal charstring' which has subtype from\(char\(0, 0, 1, 111\)..char\(0, 0, 1, 112\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_015 Assign invalid value to range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_015 NegSem_06010203_Ranges_015.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign invalid value to range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_015 {
    type charstring MyCharstringRange ("a".."f");
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_015() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "abcgef"; // g not allowed
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_015());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abcgef" is not a valid value for type `charstring' which has subtype from\("a".."f"\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_016 Invalid value infinity for range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_016 NegSem_06010203_Ranges_016.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Invalid value infinity for range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_016 {
    type charstring MyCharstringRange ("a"..infinity); // infinity not allowed for charstring
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_016() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "abcgef";
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_016());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: upper boundary of a charstring subtype range cannot be infinity
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010203_Ranges_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010203_017 Invalid value -infinity for range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010203_Ranges_017 NegSem_06010203_Ranges_017.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Invalid value -infinity for range constrained charstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010203_Ranges_017 {
    type charstring MyCharstringRange (-infinity.."d"); // -infinity not allowed for charstring
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010203_Ranges_017() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "abcgef";
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010203_Ranges_017());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: lower boundary of a charstring subtype range cannot be -infinity
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_001 Invalid value -infinity for range constrained charstring. >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_001 NegSem_06010204_StringLengthRestrict_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted bitstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_001 {
    type bitstring BitStrings length(1 .. 2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_001() runs on GeneralComp {
        var BitStrings v_b := '111'B; // value length 3 != type length is 1 or 2
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '111'B is not a valid value for type `bitstring' which has subtype length\(1..2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_002 Assign invalid values to length restricted bitstring. >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_002 NegSem_06010204_StringLengthRestrict_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted bitstring.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_002 {
    type bitstring BitStrings length(2);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_002() runs on GeneralComp {
        var BitStrings v_b := '111'B; // value length 3 != type length is 2
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '111'B is not a valid value for type `bitstring' which has subtype length\(2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_003 Assign invalid values to length restricted hexstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_003 NegSem_06010204_StringLengthRestrict_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted hexstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_003 {
    type hexstring HexStrings1 length(3); //3 hexadecimal digits

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_003() runs on GeneralComp {
        var HexStrings1 v_b1;
        v_b1 := 'FE00'H;	//invalid length 4
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'FE00'H is not a valid value for type `hexstring' which has subtype length\(3\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_004 Assign invalid values to length restricted hexstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_004 NegSem_06010204_StringLengthRestrict_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted hexstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_004 {
    type hexstring HexStrings1 length(2 .. infinity); //hexadecimal digits between 2 and 5

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_004() runs on GeneralComp {
        var HexStrings1 v_b1;
        v_b1 := 'A'H; //invalid length 1 
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'A'H is not a valid value for type `hexstring' which has subtype length\(2..infinity\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_005 Assign invalid values to length restricted octetstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_005 NegSem_06010204_StringLengthRestrict_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted octetstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_005 {
    type octetstring ocStrings1 length(4);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_005() runs on GeneralComp {
        var ocStrings1 v_b1;
        v_b1 := 'FE8001'O;	//3 octets invalid length
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'FE8001'O is not a valid value for type `octetstring' which has subtype length\(4\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_006 Assign invalid values to length restricted octetstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_006 NegSem_06010204_StringLengthRestrict_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted octetstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_006 {
    type octetstring ocStrings1 length(2..infinity);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_006() runs on GeneralComp {
        var ocStrings1 v_b1;
        v_b1 := 'FE'O;	//1 octet invalid length
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_006());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'FE'O is not a valid value for type `octetstring' which has subtype length\(2..infinity\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_007 Assign invalid values to length restricted charstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_007 NegSem_06010204_StringLengthRestrict_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted charstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_007{
    type charstring myStrings1 length(2..infinity);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_007() runs on GeneralComp {
        var myStrings1 v_b1;
        v_b1 := "a";	//1 charc. length
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_007());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "a" is not a valid value for type `charstring' which has subtype length\(2..infinity\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010204_StringLengthRestrict_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_008 Assign invalid values to length restricted charstring >

<COMPILE>

<MODULE TTCN NegSem_06010204_StringLengthRestrict_008 NegSem_06010204_StringLengthRestrict_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign invalid values to length restricted charstring
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010204_StringLengthRestrict_008{
    type charstring myStrings1 length(2);

    type component GeneralComp {}
    
    testcase TC_NegSem_06010204_StringLengthRestrict_008() runs on GeneralComp {
        var myStrings1 v_b1;
        v_b1 := "abc";	//2 characters length req.
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010204_StringLengthRestrict_008());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abc" is not a valid value for type `charstring' which has subtype length\(2\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_06010204_StringLengthRestrict_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_001 upper boundary should be greater than lower boundary in string length restictions >

<COMPILE>

<MODULE TTCN NegSyn_06010204_StringLengthRestrict_001 NegSyn_06010204_StringLengthRestrict_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, upper boundary should be greater than lower boundary in string length restictions
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_06010204_StringLengthRestrict_001 {
    type hexstring HexStrings1 length(3 .. 1); // upper bound is smaller than lower bound 

}
<END_MODULE>

<RESULT COUNT 1>
error: The upper boundary of the length restriction \(1\) cannot be smaller than the lower boundary \(3\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_06010204_StringLengthRestrict_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010204_002 boundary integers should be non negative integers >

<COMPILE>

<MODULE TTCN NegSyn_06010204_StringLengthRestrict_002 NegSyn_06010204_StringLengthRestrict_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, boundary integers should be non negative integers
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_06010204_StringLengthRestrict_002 {
    type hexstring HexStrings1 length(0 .. -5); // negative boundary for length

}
<END_MODULE>

<RESULT COUNT 1>
error: The upper boundary of the length restriction must be a non-negative integer value instead of -5
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06010205_StringPattern_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010205_001 Assign invalid values to pattern restricted character strings. >

<COMPILE>

<MODULE TTCN NegSem_06010205_StringPattern_001 NegSem_06010205_StringPattern_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign invalid values to pattern restricted character strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06010205_StringPattern_001 {
    type charstring MyString (pattern "?bc*xyz");
    
    type component GeneralComp {}
    
    testcase TC_NegSem_06010205_StringPattern_001() runs on GeneralComp {
        var MyString v_c := "abcyz"; // value missing x
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_06010205_StringPattern_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abcyz" is not a valid value for type `charstring' which has subtype pattern \(\?bc\*xyz\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_06010205_StringPattern_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010205_001 Assign values to pattern restricted character strings without @nocase modifier. >

<COMPILE>

<MODULE TTCN NegSyn_06010205_StringPattern_001 NegSyn_06010205_StringPattern_001.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign values to pattern restricted character strings without @nocase modifier.
 ** @verdict  pass reject, noexecution
 ***************************************************/

module NegSyn_06010205_StringPattern_001 {
    type charstring MyString (pattern "abc*xyz"); //without @nocase

    type component GeneralComp {}
    
    testcase TC_NegSyn_06010205_StringPattern_001() runs on GeneralComp {
        var MyString v_c;
        v_c := "ABc1234xYz";    //error value is out of constraint: ABc
    }
    
    control{
        execute(TC_NegSyn_06010205_StringPattern_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "ABc1234xYz" is not a valid value for type `charstring' which has subtype pattern \(abc\*xyz\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_06010205_StringPattern_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06010205_002 Assign quadruple values to pattern restricted character strings. >

<COMPILE>

<MODULE TTCN NegSyn_06010205_StringPattern_002 NegSyn_06010205_StringPattern_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign quadruple values to pattern restricted character strings.
 ** @verdict  pass reject, noexecution
 ***************************************************/

module NegSyn_06010205_StringPattern_002 {
    type charstring MyString (pattern "\q{0,0,1,116}abc"); //error: not a legal character for the TTCN 3 charstring type

    
    type component GeneralComp {}
    
    testcase TC_NegSyn_06010205_StringPattern_002() runs on GeneralComp {
        var MyString v_c := "abc";    //error: not a legal character of the TTCN 3 charstring type
    }
    
    control{
        execute(TC_NegSyn_06010205_StringPattern_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: char\(0, 0, 0, 197\) & char\(0, 0, 0, 180\) \& "abc" is not a valid value for type `charstring' which has subtype pattern \(\\q\{0,0,1,116\}abc\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020601_MixingSubtype_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020601_001 Assign invalid values to mixed restricted floats. >

<COMPILE>

<MODULE TTCN NegSem_0601020601_MixingSubtype_001 NegSem_0601020601_MixingSubtype_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.1, Assign invalid values to mixed restricted floats.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020601_MixingSubtype_001 {
    type float lessThanPiAndNaN (-infinity .. 3142E-3, not_a_number);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020601_MixingSubtype_001() runs on GeneralComp {
        var lessThanPiAndNaN v_f := 4.0; // value out of range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020601_MixingSubtype_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 4.0e0 is not a valid value for type `float' which has subtype \(-INF..3.142e0,NaN\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020601_MixingSubtype_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020601_002 Assign invalid values to mixed restricted integers. >

<COMPILE>

<MODULE TTCN NegSem_0601020601_MixingSubtype_002 NegSem_0601020601_MixingSubtype_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.1, Assign invalid values to mixed restricted integers.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020601_MixingSubtype_002 {
    type integer MyInt (1, 5, 10, 100 .. infinity);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020601_MixingSubtype_002() runs on GeneralComp {
        var MyInt v_i := 6; // value out of range
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020601_MixingSubtype_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 6 is not a valid value for type `integer' which has subtype \(1,5,10,100..infinity\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_001 Assign invalid values to mixed restricted character strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_001 NegSem_0601020602_StringMixing_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted character strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_001 {
    type charstring MyString (pattern "?bc*xyz") length (5 .. 8);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_001() runs on GeneralComp {
        var MyString v_c := "abcyz"; // value missing x
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abcyz" is not a valid value for type `charstring' which has subtype \(pattern \(\?bc\*xyz\) intersection length\(5..8\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_002 Assign invalid values to mixed restricted character strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_002 NegSem_0601020602_StringMixing_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted character strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_002 {
    type charstring MyString (pattern "?bc*xyz") length (5 .. 8);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_002() runs on GeneralComp {
        var MyString v_c := "abc123xyz"; // value length 9 exceeds 8
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abc123xyz" is not a valid value for type `charstring' which has subtype \(pattern \(\?bc\*xyz\) intersection length\(5..8\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_003 Assign invalid values to mixed restricted character strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_003 NegSem_0601020602_StringMixing_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted character strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_003 {
    type charstring MyString ("a".."z") length (3 .. 8);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_003() runs on GeneralComp {
        var MyString v_c := "abc1xyz"; // char 1 not allowed
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: "abc1xyz" is not a valid value for type `charstring' which has subtype \(from\("a".."z"\) intersection length\(3..8\)\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_004 Assign invalid values to mixed restricted bit strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_004 NegSem_0601020602_StringMixing_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted bit strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_004 {
    type bitstring MyString ('111'B, '101010'B, '111111'B) length (4 .. 8);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_004() runs on GeneralComp {
        var MyString v_c := '111'B; // value lenght 3 not allowed
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '111'B is not a valid value for type `bitstring' which has subtype \('101010'B,'111111'B\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_005 Assign invalid values to mixed restricted hex strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_005 NegSem_0601020602_StringMixing_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted hex strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_005 {
    type hexstring MyString ('1F1'H, '103A10'H, '111111'H) length (4 .. 8);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_005() runs on GeneralComp {
        var MyString v_c := '1F1'H; // value length 3 not allowed
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_005());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: '1F1'H is not a valid value for type `hexstring' which has subtype \('103A10'H,'111111'H\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0601020602_StringMixing_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0601020602_006 Assign invalid values to mixed restricted octet strings. >

<COMPILE>

<MODULE TTCN NegSem_0601020602_StringMixing_006 NegSem_0601020602_StringMixing_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign invalid values to mixed restricted octet strings.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0601020602_StringMixing_006 {
    type octetstring MyString ('FF1111'O, '101010A3'O, 'FFFFFFFFFF'O) length (4);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_0601020602_StringMixing_006() runs on GeneralComp {
        var MyString v_c := 'FF1111'O; // value length 3 not allowed
		setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_0601020602_StringMixing_006());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: 'FF1111'O is not a valid value for type `octetstring' which has subtype \('101010A3'O\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 0602_structured_types_and_values folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_0602_TopLevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_001 Ensure that value list notation can not be used for a union type. >

<COMPILE>

<MODULE TTCN NegSem_0602_TopLevel_001 NegSem_0602_TopLevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can not be used for a union type. 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0602_TopLevel_001 {
    
    type component GeneralComp {
    }
    
    type union MyUnion {
        integer field1,
        charstring field2,
        float field3
    }

    testcase TC_NegSem_0602_TopLevel_001() runs on GeneralComp {

        var MyUnion v_myUnion := {5}; //value list notation can not be used for a union type

    }

    control {
        execute(TC_NegSem_0602_TopLevel_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: union value was expected for type `@NegSem_0602_TopLevel_001.MyUnion'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0602_TopLevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_002 Ensure that indexed notation can not be used for a record type. >

<COMPILE>

<MODULE TTCN NegSem_0602_TopLevel_002 NegSem_0602_TopLevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can not be used for a record type. 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0602_TopLevel_002 {
    
    type component GeneralComp {
    }
    
    type record MyRecord {
        integer field1,
        charstring field2,
        float field3
    }

    testcase TC_NegSem_0602_TopLevel_002() runs on GeneralComp {

        var MyRecord v_myRecord := {
            field1 := 5,
            field2 := "hi",
            field3 := 3.14
        };
        
        var integer Integer1 :=3;
        v_myRecord[0] := Integer1;//not possible to use index notation on a record type

    }

    control {
        execute(TC_NegSem_0602_TopLevel_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type `@NegSem_0602_TopLevel_002.MyRecord' cannot be indexed
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0602_TopLevel_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_003 Ensure that indexed notation can not be used for a set type.  >

<COMPILE>

<MODULE TTCN NegSem_0602_TopLevel_003 NegSem_0602_TopLevel_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can not be used for a set type. 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0602_TopLevel_003 {
    
    type component GeneralComp {
    }
    
    type set MySet {
        integer field1,
        charstring field2,
        float field3
    }

    testcase TC_NegSem_0602_TopLevel_003() runs on GeneralComp {

        var MySet v_mySet := {
            field1 := 5,
            field2 := "hi",
            field3 := 3.14
        };
        
        var integer Integer1 :=3;
        v_mySet[0] := Integer1;//not possible to use index notation on a set type

    }

    control {
        execute(TC_NegSem_0602_TopLevel_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type `@NegSem_0602_TopLevel_003.MySet' cannot be indexed
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0602_TopLevel_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_004 Ensure that indexed notation can not be used for a union type. >

<COMPILE>

<MODULE TTCN NegSem_0602_TopLevel_004 NegSem_0602_TopLevel_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can not be used for a union type. 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_0602_TopLevel_004 {
    
    type component GeneralComp {
    }
    
    type union MyUnion {
        integer field1,
        charstring field2,
        float field3
    }

    testcase TC_NegSem_0602_TopLevel_004() runs on GeneralComp {

        var MyUnion v_myUnion := {
            field1 := 5
        };
        
        var integer Integer1 :=3;
        v_myUnion[0] := Integer1;//not possible to use index notation on a union type

    }

    control {
        execute(TC_NegSem_0602_TopLevel_004());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Type `@NegSem_0602_TopLevel_004.MyUnion' cannot be indexed
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_0602_TopLevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_001 Invalid recursive union type definition causing an error >

<COMPILE>

<MODULE TTCN NegSyn_0602_TopLevel_001 NegSyn_0602_TopLevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Invalid recursive union type definition causing an error
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_0602_TopLevel_001 {
    // In case of union types, to avoid infinite recursion, at least one of the alternatives shall not reference its own type.
	type union MyUnion {
		MyUnion choice1,
		MyUnion choice2
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: While checking embedded recursions: Circular reference: `@NegSyn_0602_TopLevel_001.MyUnion' -> `@NegSyn_0602_TopLevel_001.MyUnion.choice1' -> `@NegSyn_0602_TopLevel_001.MyUnion'
<END_RESULT>
<RESULT COUNT 1>
error: While checking embedded recursions: Circular reference: `@NegSyn_0602_TopLevel_001.MyUnion' -> `@NegSyn_0602_TopLevel_001.MyUnion.choice2' -> `@NegSyn_0602_TopLevel_001.MyUnion'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_0602_TopLevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_002 Invalid recursive record type definition causing an error >

<COMPILE>

<MODULE TTCN NegSyn_0602_TopLevel_002 NegSyn_0602_TopLevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Invalid recursive record type definition causing an error
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_0602_TopLevel_002 {
    // In case of record and set types, to avoid infinite recursion, fields referencing to its own type, shall be optional.
	type record MyRecord {
		integer field1,
		MyRecord field2,
		integer field3
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: While checking embedded recursions: Circular reference: `@NegSyn_0602_TopLevel_002.MyRecord' -> `@NegSyn_0602_TopLevel_002.MyRecord.field2' -> `@NegSyn_0602_TopLevel_002.MyRecord'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_0602_TopLevel_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0602_003 Combined value list and assignment notation not allowed in the same (immediate) context. >

<COMPILE>

<MODULE TTCN NegSyn_0602_TopLevel_003 NegSyn_0602_TopLevel_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2, Combined value list and assignment notation not allowed in the same (immediate) context.
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_0602_TopLevel_003 {
    type record MyRecord {
        integer field1,
        charstring field2 optional,
        float field3
    }
    const MyRecord c_rec := {
        field1 := 5,
        "hi", // combined value list and assignment notation not allowed in the same (immediate) context.
        field3 := 3.14
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `"': syntax error, unexpected Cstring
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060201_RecordTypeValues_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060201_001 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSyn_060201_RecordTypeValues_001 NegSyn_060201_RecordTypeValues_001.ttcn >
/***************************************************
 ** @author   STF 409, re-numbering done by STF470
 ** @version  0.0.1
 ** @purpose  1:6.2, The omit keyword shall not be used for mandatory fields.
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060201_RecordTypeValues_001 {
    type record MyRecord {
        integer field1,
        MyRecord field2 optional,
        integer field3
    }
    const MyRecord c_rec := {
        field1 := 5,
        field2 := omit,
        field3 := omit // not optional
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060201_RecordTypeValues_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060201_002 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSyn_060201_RecordTypeValues_002 NegSyn_060201_RecordTypeValues_002.ttcn >
/***************************************************
 ** @author   STF 409, re-numbering done by STF470
 ** @version  0.0.1
 ** @purpose  1:6.2, The omit keyword shall not be used for mandatory fields.
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060201_RecordTypeValues_002 {
	type record MyRecord {
		integer field1,
		MyRecord field2 optional,
		integer field3
	}
    const MyRecord c_rec := {
        field1 := 5,
        field2 := -,
        field3 := omit // not optional
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020101_ReferencingRecordFields_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020101_001 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSem_06020101_ReferencingRecordFields_001 NegSem_06020101_ReferencingRecordFields_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, The dot notation used in record type definitions is correctly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06020101_ReferencingRecordFields_001 {

	type component GeneralComp {	    	    
	}

 	type record R {
  		integer field1 (1 .. 10),
  		charstring field2 optional
 	}  
 
 	type R ConstrainedRecord ({1, omit}, {2, "xyz"}, {3, "zyx"}) ;
 
 	type ConstrainedRecord.field1 MyInteger;
 
	testcase TC_NegSem_06020101_ReferencingRecordFields_001() runs on GeneralComp {

 		var MyInteger v_int := 11;  
		// assignment from outside of the carried over (1 .. 10) range constraint
 
	}

	control {
		execute(TC_NegSem_06020101_ReferencingRecordFields_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 11 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020101_ReferencingRecordFields_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020101_002 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSem_06020101_ReferencingRecordFields_002 NegSem_06020101_ReferencingRecordFields_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that record fields cannot reference themselves
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Fields of record type definitions shall not reference themselves.

module NegSem_06020101_ReferencingRecordFields_002 {

    type component GeneralComp {	    	    
    }
    
    type record R {	
        integer	field1,
        R.field2 field2 optional, // this circular reference is NOT ALLOWED
        boolean	field3
    }  
    
    testcase TC_NegSem_06020101_ReferencingRecordFields_002() runs on GeneralComp {
        var R v_rec := { field1 := 1, field2 := omit, field3 := true };
        if (v_rec.field1 == 1) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    
    control {
        execute(TC_NegSem_06020101_ReferencingRecordFields_002());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: While checking referenced type: Circular reference: `@NegSem_06020101_ReferencingRecordFields_002.R.field2' -> `@NegSem_06020101_ReferencingRecordFields_002.R.field2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020101_ReferencingRecordFields_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020101_003 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_06020101_ReferencingRecordFields_003 NegSem_06020101_ReferencingRecordFields_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that referencing uninitialized record on the right hand of an assignment is not allowed
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Referencing a subfield of an uninitialized or omitted record field or value on the right 
// hand side of an assignment shall cause an error.

module NegSem_06020101_ReferencingRecordFields_003 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer subfield1
        } field1,
        charstring field2 optional
    }  
    
    testcase TC_NegSem_06020101_ReferencingRecordFields_003() runs on GeneralComp {
        var R v_rec;
        v_rec.field2 := "abc";
        if (v_rec.field1.subfield1 == 5) {
	        setverdict(fail);
        } else {
	        setverdict(pass);
        }
    }
    
    control {
        execute(TC_NegSem_06020101_ReferencingRecordFields_003());
    }

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Unbound left operand of integer comparison.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020101_ReferencingRecordFields_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020101_004 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_06020101_ReferencingRecordFields_004 NegSem_06020101_ReferencingRecordFields_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that referencing omitted record on the right hand of an assignment is not allowed
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Referencing a subfield of an uninitialized or omitted record field or value on the right 
// hand side of an assignment shall cause an error.

module NegSem_06020101_ReferencingRecordFields_004 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer subfield1
        } field1 optional,
        charstring field2 optional
    }  
    
    testcase TC_NegSem_06020101_ReferencingRecordFields_004() runs on GeneralComp {
        var R v_rec;
        v_rec.field1 := omit;
        v_rec.field2 := "abc";
        if (v_rec.field1.subfield1 == 5) {
	        setverdict(fail);
        } else {
	        setverdict(pass);
        }
    }
    
    control {
        execute(TC_NegSem_06020101_ReferencingRecordFields_004());
    }

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using the value of an optional field containing omit.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060202_SetTypeValues_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060202_001 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSem_060202_SetTypeValues_001 NegSem_060202_SetTypeValues_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The dot notation used in set type definitions is correctly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060202_SetTypeValues_001 {

	type component GeneralComp {	    	    
	}

 	type set S {
  		integer field1 (1 .. 10),
  		charstring field2 optional
 	}  
 
 	//type S ConstrainedSet ({1, omit}, {2, "xyz"}, {3, "zyx"}) ; // value list doesn't work
 	type S ConstrainedSet ({field1 := 1, field2 := omit}, {field1 := 2, field2 := "xyz"}, {field1 := 3, field2 := "zyx"}) ;
 
 	type ConstrainedSet.field1 MyInteger;
 
	testcase TC_NegSem_060202_SetTypeValues_001() runs on GeneralComp {

 		var MyInteger v_int := 11;  
		// assignment from outside of the carried over (1 .. 10) range constraint
 
	}

	control {
		execute(TC_NegSem_060202_SetTypeValues_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 11 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060202_SetTypeValues_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060202_001 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSyn_060202_SetTypeValues_001 NegSyn_060202_SetTypeValues_001.ttcn >
/***************************************************
 ** @author   STF470
 ** @version  0.0.1
 ** @purpose  1:6.2, The omit keyword shall not be used for mandatory fields.
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060202_SetTypeValues_001 {
    type set MySet {
        integer field1,
        MySet field2 optional,
        integer field3
    }
    const MySet c_set := {
        field1 := 5,
        field2 := omit,
        field3 := omit // not optional
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060202_SetTypeValues_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060202_002 The omit keyword shall not be used for mandatory fields. >

<COMPILE>

<MODULE TTCN NegSyn_060202_SetTypeValues_002 NegSyn_060202_SetTypeValues_002.ttcn >
/***************************************************
 ** @author   STF470
 ** @version  0.0.1
 ** @purpose  1:6.2, The omit keyword shall not be used for mandatory fields.
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060202_SetTypeValues_002 {
	type record MySet {
		integer field1,
		MySet field2 optional,
		integer field3
	}
    const MySet c_set := {
        field1 := 5,
        field2 := -,
        field3 :=omit // not optional
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_001 ensure that the inner type referencing is correctly handled >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_001 NegSem_060203_records_and_sets_of_single_types_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, ensure that the inner type referencing is correctly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060203_records_and_sets_of_single_types_001 {

 	type component GeneralComp {	    	    
 	}

 	type record length (5) of record of integer ConstrainedStructure (1 .. 10);
 	type ConstrainedStructure[-] RecordOfInt;
 
	testcase TC_NegSem_060203_records_and_sets_of_single_types_001() runs on GeneralComp {

 		var RecordOfInt v_rec := { 8, 11, 2, 3, 4, 5, 6, 7 };  // a value is outside the restricted range

	}

	control {
   		execute(TC_NegSem_060203_records_and_sets_of_single_types_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 11 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_002 ensure that the inner type referencing is correctly handled >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_002 NegSem_060203_records_and_sets_of_single_types_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, ensure that the inner type referencing is correctly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060203_records_and_sets_of_single_types_002 {

 	type component GeneralComp {	    	    
 	}

 	type record of record length (5) of integer ConstrainedStructure (1 .. 10);
 	type ConstrainedStructure[-] RecordOfInt;
 
	testcase TC_NegSem_060203_records_and_sets_of_single_types_002() runs on GeneralComp {

 		var RecordOfInt v_rec := { 8, 1, 2, 3, 4, 5, 6, 7 };  
		// a record is longer than the restricted length

	}

	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_002());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: \{ 8, 1, 2, 3, 4, 5, 6, 7 \} is not a valid value for type `@NegSem_060203_records_and_sets_of_single_types_002.ConstrainedStructure.SEQUENCE_OF' which has subtype length\(5\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_003 negative index applied to a record of value on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_003 NegSem_060203_records_and_sets_of_single_types_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, negative index applied to a record of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_003 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_003() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		var integer i := v_rec[-1]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_003());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative integer value was expected for indexing type `@NegSem_060203_records_and_sets_of_single_types_003.RoI' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_004 negative index applied to a set of value on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_004 NegSem_060203_records_and_sets_of_single_types_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, negative index applied to a set of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_004 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_004() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		var integer i := v_set[-1]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_004());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative integer value was expected for indexing type `@NegSem_060203_records_and_sets_of_single_types_004.SoI' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_005 negative index applied to a record of value on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_005 NegSem_060203_records_and_sets_of_single_types_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, negative index applied to a record of value on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_005 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_005() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		v_rec[-1] := 10; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_005());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative integer value was expected for indexing type `@NegSem_060203_records_and_sets_of_single_types_005.RoI' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_006 negative index applied to a set of value on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_006 NegSem_060203_records_and_sets_of_single_types_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, negative index applied to a set of value on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_006 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_006() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		v_set[-1] := 10; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_006());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative integer value was expected for indexing type `@NegSem_060203_records_and_sets_of_single_types_006.SoI' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_007 wrong index type applied to a record of value on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_007 NegSem_060203_records_and_sets_of_single_types_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, wrong index type applied to a record of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_007 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_007() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		var integer i := v_rec["0"]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_007());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_008 wrong index type applied to a set of value on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_008 NegSem_060203_records_and_sets_of_single_types_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, wrong index type applied to a set of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_008 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_008() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		var integer i := v_set["0"]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_008());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_009 wrong index type applied to a record of value on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_009 NegSem_060203_records_and_sets_of_single_types_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, wrong index type applied to a record of value on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_009 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_009() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		v_rec["0"] := 10; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_009());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_010 wrong index type applied to a set of value on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_010 NegSem_060203_records_and_sets_of_single_types_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, wrong index type applied to a set of value on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Implicit rule, formal requirement requested in CR 6646 (resolution expected 
// in TTCN-3:2014)
module NegSem_060203_records_and_sets_of_single_types_010 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_010() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		v_set["0"] := 10; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_010());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_013 wrong index type applied to a record of value on the right hand side of an assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_013 NegSem_060203_records_and_sets_of_single_types_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, wrong index type applied to a record of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// If the value of the element indicated by the index at the right-hand of an 
// assignment is undefined (uninitialized), this shall cause a semantic or 
// run-time error.)
module NegSem_060203_records_and_sets_of_single_types_013 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_013() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		var integer i := v_rec[3]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_013());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER: The index is 3, but the value has only 3 elements.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_014 wrong index type applied to a record of value on the right hand side of an assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_014 NegSem_060203_records_and_sets_of_single_types_014.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, wrong index type applied to a record of value on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// If the value of the element indicated by the index at the right-hand of an 
// assignment is undefined (uninitialized), this shall cause a semantic or 
// run-time error.)
module NegSem_060203_records_and_sets_of_single_types_014 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_014() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		var integer i := v_set[3]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_014());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER: The index is 3, but the value has only 3 elements.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_015 verify than an error is generated when sending a partially initialized record of value >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_015 NegSem_060203_records_and_sets_of_single_types_015.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify than an error is generated when sending a partially initialized record of value
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Undefined elements are permitted only in transient states (while the value 
// remains invisible). Sending a record of value with undefined elements shall
// cause a test case error.

module NegSem_060203_records_and_sets_of_single_types_015 { 

	type record of integer RoI;
	
	type port P message {
		inout RoI
	} with {extension "internal"}

	type component GeneralComp {	    	    
		port P p
	}	

	testcase TC_NegSem_060203_records_and_sets_of_single_types_015() runs on GeneralComp {
		var template RoI mw_sendingTemplate := {0, -, 2};
		connect(self:p,self:p);
		p.send(mw_sendingTemplate); // error expected
        setverdict(pass);
	}

	control{
		execute(TC_NegSem_060203_records_and_sets_of_single_types_015());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Performing a valueof or send operation on a non-specific integer template.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_016 array as a record-of value index on right hand side (less items than record-of dimension) >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_016 NegSem_060203_records_and_sets_of_single_types_016.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_016 {

	type component GeneralComp {	    	    
	}
 
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_016() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var integer v_index[3] := { 1, 0, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_016());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `integer\[3\]' contains too many indexes \(3\) in the short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_017 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_017 array as a record-of value index on left hand side (less items than record-of dimension) >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_017 NegSem_060203_records_and_sets_of_single_types_017.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_017 {

	type component GeneralComp {	    	    
	}
 
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_017() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var integer v_index[3] := { 1, 0, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_017());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `integer\[3\]' contains too many indexes \(3\) in the short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_018 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_018 fixed-size record-of as a record-of value index on right hand side (less items than record-of dimension) >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_018 NegSem_060203_records_and_sets_of_single_types_018.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_018 {

	type component GeneralComp {	    	    
	}
 
    type record length(3) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_018() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_018());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `@NegSem_060203_records_and_sets_of_single_types_018.Indexer' contains too many indexes \(3\) in the short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_019 fixed-size record-of as a record-of value index on left hand side (less items than record-of dimension) >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_019 NegSem_060203_records_and_sets_of_single_types_019.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_019 {

	type component GeneralComp {	    	    
	}
 
    type record length(3) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_019() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_019());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `@NegSem_060203_records_and_sets_of_single_types_019.Indexer' contains too many indexes \(3\) in the short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_020 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_020 fixed-size set-of as a record-of value index on right hand side >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_020 NegSem_060203_records_and_sets_of_single_types_020.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size set-of as a record-of value index on right hand side
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_020 {

	type component GeneralComp {	    	    
	}
 
    type set length(2) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_020() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_020());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>
<RESULT COUNT 1>
error: The operands of operation `==' should be of compatible types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_021 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_021 fixed-size set-of as a record-of value index on left hand side >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_021 NegSem_060203_records_and_sets_of_single_types_021.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size set-of as a record-of value index on left hand side
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_021 {

	type component GeneralComp {	    	    
	}
 
    type set length(2) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_021() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_021());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>
<RESULT COUNT 1>
error: record of value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_022 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_022 variable-size record-of as a record-of value index on right hand side >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_022 NegSem_060203_records_and_sets_of_single_types_022.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, variable-size record-of as a record-of value index on right hand side
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_022 {

	type component GeneralComp {	    	    
	}
 
    type record of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_022() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_022());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `@NegSem_060203_records_and_sets_of_single_types_022.Indexer' must have single size length restriction when used as a short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060203_records_and_sets_of_single_types_023 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_023 variable-size record-of as a record-of value index on left hand side (less items than record-of dimension) >

<COMPILE>

<MODULE TTCN NegSem_060203_records_and_sets_of_single_types_023 NegSem_060203_records_and_sets_of_single_types_023.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3, variable-size record-of as a record-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module NegSem_060203_records_and_sets_of_single_types_023 {

	type component GeneralComp {	    	    
	}
 
    type record of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_NegSem_060203_records_and_sets_of_single_types_023() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_NegSem_060203_records_and_sets_of_single_types_023());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `@NegSem_060203_records_and_sets_of_single_types_023.Indexer' must have single size length restriction when used as a short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060203_records_and_sets_of_single_types_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060203_001 ensure that value list cannot contain an empty assignment >

<COMPILE>

<MODULE TTCN NegSyn_060203_records_and_sets_of_single_types_001 NegSyn_060203_records_and_sets_of_single_types_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, ensure that value list cannot contain an empty assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// No empty assignment is allowed (e.g. two commas, the second immediately 
// following the first or only with white space between them).
module NegSyn_060203_records_and_sets_of_single_types_001 {

	type component GeneralComp {	    	    
	}
	
	type record of integer RoI;
	
	testcase TC_NegSyn_060203_records_and_sets_of_single_types_001() runs on GeneralComp {
	
		var RecordOfInt v_rec := { 0, , 2 };  // syntax error expected
	
	}
	
	control {
		execute(TC_NegSyn_060203_records_and_sets_of_single_types_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `,': syntax error, unexpected ','
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060204_enumerated_type_and_values_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060204_001 not unique identifiers in enumerated type declaration >

<COMPILE>

<MODULE TTCN NegSem_060204_enumerated_type_and_values_001 NegSem_060204_enumerated_type_and_values_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, not unique identifiers in enumerated type declaration
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The identifiers of enumerated values shall be unique within the enumerated type 
// (but do not have to be globally unique) and are consequently visible in the 
// context of the given type only.

module NegSem_060204_enumerated_type_and_values_001 {

    type enumerated MyFirstEnumType {
        Monday, Tuesday, Wednesday, Thursday, Friday, Monday
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: Duplicate enumeration identifier `Monday'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060204_enumerated_type_and_values_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060204_002 two equal user-assigned enumerated values >

<COMPILE>

<MODULE TTCN NegSem_060204_enumerated_type_and_values_002 NegSem_060204_enumerated_type_and_values_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.4, two equal user-assigned enumerated values
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Each user-assigned integer number shall be distinct within a single enumerated 
// type. 

module NegSem_060204_enumerated_type_and_values_002 {

    type enumerated MyFirstEnumType {
        Monday, Tuesday(2), Wednesday(2), Thursday, Friday
    };
}
<END_MODULE>

<RESULT COUNT 1>
error: Duplicate numeric value 2 for enumeration `Wednesday'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060204_enumerated_type_and_values_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060204_003 using enumerated value number directly (left hand side of assignments) >

<COMPILE>

<MODULE TTCN NegSem_060204_enumerated_type_and_values_003 NegSem_060204_enumerated_type_and_values_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.4, using enumerated value number directly (left hand side of assignments)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For each enumerated value without an assigned integer value, the system 
// successively associates an integer number in the textual order of the 
// enumerated values, starting at the left-hand side, beginning with zero, by 
// step 1 and skipping any number occupied by any of the enumerated values with 
// a manually assigned value. These values are only used by the system to allow 
// the use of relational operators. The user shall not directly use associated 
// integer values but can access them and convert integer values into enumerated 
// values by using the predefined functions enum2int and int2enum (see clauses 
// 16.1.2, C.1.29 C.1.30 and C.1.4 C.1.4).

module NegSem_060204_enumerated_type_and_values_003 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    
    testcase TC_NegSem_060204_enumerated_type_and_values_003() runs on GeneralComp {
        var EDays v_day0 := 0; // ordinal value shall not be accepted
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060204_enumerated_type_and_values_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: enumerated value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060204_enumerated_type_and_values_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060204_004 using enumerated value number directly (right hand side of assignments) >

<COMPILE>

<MODULE TTCN NegSem_060204_enumerated_type_and_values_004 NegSem_060204_enumerated_type_and_values_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.4, using enumerated value number directly (right hand side of assignments)
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For each enumerated value without an assigned integer value, the system 
// successively associates an integer number in the textual order of the 
// enumerated values, starting at the left-hand side, beginning with zero, by 
// step 1 and skipping any number occupied by any of the enumerated values with 
// a manually assigned value. These values are only used by the system to allow 
// the use of relational operators. The user shall not directly use associated 
// integer values but can access them and convert integer values into enumerated 
// values by using the predefined functions enum2int and int2enum (see clauses 
// 16.1.2, C.1.29 C.1.30 and C.1.4 C.1.4).

module NegSem_060204_enumerated_type_and_values_004 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    
    testcase TC_NegSem_060204_enumerated_type_and_values_004() runs on GeneralComp {
        var EDays v_day0 := Monday;
		var integer v_int := v_day0;
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060204_enumerated_type_and_values_004());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: a value of type `integer' was expected instead of `@NegSem_060204_enumerated_type_and_values_004.EDays'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060204_enumerated_type_and_values_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060204_005 using enumerated value without implicit or explicit type reference >

<COMPILE>

<MODULE TTCN NegSem_060204_enumerated_type_and_values_005 NegSem_060204_enumerated_type_and_values_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.4, using enumerated value without implicit or explicit type reference
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// For any instantiation or value reference of an enumerated type, the given 
// type shall be implicitly or explicitly referenced.

module NegSem_060204_enumerated_type_and_values_005 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    
    testcase TC_NegSem_060204_enumerated_type_and_values_005() runs on GeneralComp {
        if (Tuesday != Wednesday) { // no implicit or explicit reference to enumeration
		    setverdict(pass);
        } else {
            setverdict(fail);
        }
	}
	
	control {
		execute(TC_NegSem_060204_enumerated_type_and_values_005());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Cannot determine the type of the operands in operation `!='
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060205_top_level_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_001 assignment notation for union values with two items >

<COMPILE>

<MODULE TTCN NegSem_060205_top_level_001 NegSem_060205_top_level_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, assignment notation for union values with two items
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The assignment notation shall be used for union-s, and the notation shall assign
// a value to one field only. This field becomes the chosen field.

module NegSem_060205_top_level_001 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_NegSem_060205_top_level_001() runs on GeneralComp {
		var U v_choice := { option1 := 1, option2 := "abc" };
        if (ischosen(v_choice.option1) or ischosen(v_choice.option2)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_060205_top_level_001());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Only one field was expected in union value instead of 2
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060205_top_level_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_002 assignment notation for union values with unknown alternative >

<COMPILE>

<MODULE TTCN NegSem_060205_top_level_002 NegSem_060205_top_level_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, assignment notation for union values with unknown alternative
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The assignment notation shall be used for union-s, and the notation shall assign
// a value to one field only. This field becomes the chosen field.

module NegSem_060205_top_level_002 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_NegSem_060205_top_level_002() runs on GeneralComp {
		var U v_choice := { option1 := 10 };
        v_choice := { option3 := true };
        if (ischosen(v_choice.option1)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_060205_top_level_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to non-existent field `option3' in union value for type `@NegSem_060205_top_level_002.U'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060205_top_level_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_003 "not used" symbol in union value notations >

<COMPILE>

<MODULE TTCN NegSem_060205_top_level_003 NegSem_060205_top_level_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, "not used" symbol in union value notations
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Neither the not used symbol "-" nor omit is allowed in union value notations.

module NegSem_060205_top_level_003 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_NegSem_060205_top_level_003() runs on GeneralComp {
		var U v_choice := { option1 := - };
        if (ischosen(v_choice.option1)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_060205_top_level_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: integer value was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060205_top_level_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_004 omit symbol in union value notations >

<COMPILE>

<MODULE TTCN NegSem_060205_top_level_004 NegSem_060205_top_level_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, omit symbol in union value notations
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Neither the not used symbol "-" nor omit is allowed in union value notations.

module NegSem_060205_top_level_004 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_NegSem_060205_top_level_004() runs on GeneralComp {
		var U v_choice := { option1 := omit };
        if (ischosen(v_choice.option1) or ischosen(v_choice.option2)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_060205_top_level_004());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: `omit' value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060205_top_level_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_005 value list notation used for union value definition >

<COMPILE>

<MODULE TTCN NegSem_060205_top_level_005 NegSem_060205_top_level_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, value list notation used for union value definition
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The value list notation shall not be used for setting values of union types.

module NegSem_060205_top_level_005 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1
	}
    
    testcase TC_NegSem_060205_top_level_005() runs on GeneralComp {
		var U v_choice := { 1 };
        if (ischosen(v_choice.option1)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_060205_top_level_005());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: union value was expected for type `@NegSem_060205_top_level_005.U'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060205_top_level_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060205_001 union type declaration with two equal identifiers >

<COMPILE>

<MODULE TTCN NegSyn_060205_top_level_001 NegSyn_060205_top_level_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5, union type declaration with two equal identifiers
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// TTCN-3 supports the union type. The union type is a collection of alternatives,
// each one identified by an identifier. Only one of the specified alternatives 
// will ever be present in an actual union value. Union types are useful to model 
// data which can take one of a finite number of known types.

module NegSyn_060205_top_level_001 {   
    type union U {	
		integer option1,
		charstring option2,
        boolean option1 // error expected
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Duplicate union field name `option1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_001 unknown union alternative in value dot notation >

<COMPILE>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_001 NegSem_06020501_referencing_fields_of_union_type_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, unknown union alternative in value dot notation
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Alternatives of a union type shall be referenced by the dot notation 
// TypeIdOrExpression.AlternativeId, where TypeIdOrExpression resolves to the name
// of a union type or an expression of a union type such as variable, formal 
// parameter, module parameter, constant, template, or function invocation. 
// AlternativeId shall resolve to the name of an alternative in the union type.

module NegSem_06020501_referencing_fields_of_union_type_001 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_NegSem_06020501_referencing_fields_of_union_type_001() runs on GeneralComp {
		var U v_union;
        v_union.option3 := 1;
        if (ischosen(v_union.option1) or ischosen(v_union.option2)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_001());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to non-existent field `option3' in type `@NegSem_06020501_referencing_fields_of_union_type_001.U'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_002 unknown union alternative in extended type reference >

<COMPILE>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_002 NegSem_06020501_referencing_fields_of_union_type_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, unknown union alternative in extended type reference
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Alternatives of a union type shall be referenced by the dot notation 
// TypeIdOrExpression.AlternativeId, where TypeIdOrExpression resolves to the name
// of a union type or an expression of a union type such as variable, formal 
// parameter, module parameter, constant, template, or function invocation. 
// AlternativeId shall resolve to the name of an alternative in the union type.

module NegSem_06020501_referencing_fields_of_union_type_002 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    type U.option3 UnionItem;
    
    testcase TC_NegSem_06020501_referencing_fields_of_union_type_002() runs on GeneralComp {
		var UnionItem v_val := 1;
        if (v_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to non-existent field `option3' in type `@NegSem_06020501_referencing_fields_of_union_type_002.U'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_003 union alternative referencing itself >

<COMPILE>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_003 NegSem_06020501_referencing_fields_of_union_type_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, union alternative referencing itself
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Alternatives of union type definitions shall not reference themselves.

module NegSem_06020501_referencing_fields_of_union_type_003 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		U.option2 option2
	}
    
    testcase TC_NegSem_06020501_referencing_fields_of_union_type_003() runs on GeneralComp {
		var U v_union := { option1 := 1 };
        if (v_union == { option1 := 1}) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: While checking referenced type: Circular reference: `@NegSem_06020501_referencing_fields_of_union_type_003.U.option2' -> `@NegSem_06020501_referencing_fields_of_union_type_003.U.option2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_004 union alternative referencing indirectly itself >

<COMPILE>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_004 NegSem_06020501_referencing_fields_of_union_type_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, union alternative referencing indirectly itself
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Alternatives of union type definitions shall not reference themselves.

module NegSem_06020501_referencing_fields_of_union_type_004 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		U.option3 option2,
        U.option2 option3
	}
    
    testcase TC_NegSem_06020501_referencing_fields_of_union_type_004() runs on GeneralComp {
		var U v_union := { option1 := 1 };
        if (v_union == { option1 := 1}) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_004());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: While checking referenced type: Circular reference: `@NegSem_06020501_referencing_fields_of_union_type_004.U.option2' -> `@NegSem_06020501_referencing_fields_of_union_type_004.U.option3' -> `@NegSem_06020501_referencing_fields_of_union_type_004.U.option2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_005 union alternative costraint passed through extended type reference >

<COMPILE>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_005 NegSem_06020501_referencing_fields_of_union_type_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, union alternative costraint passed through extended type reference
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// If an alternative in a union type or a subtype of a union type is referenced by 
// the dot notation, the resulting type is the set of values allowed for that 
// alternative imposed by the constraints of the alternative declaration itself 
// (i.e. any constraints applied to the union type itself are ignored).

module NegSem_06020501_referencing_fields_of_union_type_005 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1 (1..10),
		charstring option2
	}
    
    type U.option1 UnionItem;
    
    testcase TC_NegSem_06020501_referencing_fields_of_union_type_005() runs on GeneralComp {
		var UnionItem v_val := 100;
        if (v_val == 100) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_005());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: 100 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_006 referencing not chosen alternative on right hand side of assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_006 NegSem_06020501_referencing_fields_of_union_type_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing not chosen alternative on right hand side of assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// When an alternative of a union type is referenced on the right hand side of 
// an assignment an error shall occur if the referenced alternative is not the 
// currently chosen alternative or if the referenced union field or value is omitted 
// or uninitialized.

module NegSem_06020501_referencing_fields_of_union_type_006 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}

    testcase TC_NegSem_06020501_referencing_fields_of_union_type_006() runs on GeneralComp {
		var U v_union := { option1 := 1 };        
        if (v_union.option2 !=  "test") { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_006());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using non-selected field option2 in a value of union type @NegSem_06020501_referencing_fields_of_union_type_006.U.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_007 referencing not chosen alternative on right hand side of assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_007 NegSem_06020501_referencing_fields_of_union_type_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing alternative of uninitialized union on right hand side of assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// When an alternative of a union type is referenced on the right hand side of 
// an assignment an error shall occur if the referenced alternative is not the 
// currently chosen alternative or if the referenced union field or value is omitted 
// or uninitialized.

module NegSem_06020501_referencing_fields_of_union_type_007 {  
    type component GeneralComp {
	}
    
    type union U {	
		integer option1,
		charstring option2
	}
    
    type record R {
        integer field1,
        U field2
    }

    testcase TC_NegSem_06020501_referencing_fields_of_union_type_007() runs on GeneralComp {
		var R v_rec;
        v_rec.field1 := 5;
        if (v_rec.field2.option1 !=  100) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_007());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using non-selected field option1 in a value of union type @NegSem_06020501_referencing_fields_of_union_type_007.U.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06020501_referencing_fields_of_union_type_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020501_008 referencing alternative of omitted union on right hand side of assignment >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_06020501_referencing_fields_of_union_type_008 NegSem_06020501_referencing_fields_of_union_type_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing alternative of omitted union on right hand side of assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// When an alternative of a union type is referenced on the right hand side of 
// an assignment an error shall occur if the referenced alternative is not the 
// currently chosen alternative or if the referenced union field or value is omitted 
// or uninitialized.

module NegSem_06020501_referencing_fields_of_union_type_008 {  
    type component GeneralComp {
	}
    
    type union U {	
		integer option1,
		charstring option2
	}
    
    type record R {
        integer field1,
        U field2 optional
    }

    testcase TC_NegSem_06020501_referencing_fields_of_union_type_008() runs on GeneralComp {
		var R v_rec;
        v_rec.field1 := 5;
        v_rec.field2 := omit;
        if (v_rec.field2.option1 !=  100) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_NegSem_06020501_referencing_fields_of_union_type_008());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using the value of an optional field containing omit.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_06020502_option_and_union_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06020502_001 referencing alternative of omitted union on right hand side of assignment >

<COMPILE>

<MODULE TTCN NegSyn_06020502_option_and_union_001 NegSyn_06020502_option_and_union_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.5.2, referencing alternative on left hand side of assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Optional fields are not allowed for the union type, which means that the optional 
// keyword shall not be used with union types.

module NegSyn_06020502_option_and_union_001 {  
    type union U {	
		integer option1,
		charstring option2 optional
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `optional': syntax error, unexpected OptionalKeyword, expecting ',' or '\}'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060206_anytype_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060206_001 ensure that after redeclaration of an anytype value the old type and value are lost >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060206_anytype_001 NegSem_060206_anytype_001.ttcn >
/****************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that after redeclaration of an anytype value the old type and value are lost
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060206_anytype_001 {

 	type component GeneralComp {	    	    
		var anytype Var1, Var2;
	}
 
	testcase TC_NegSem_060206_anytype_001() runs on GeneralComp {

		Var1.integer := 10;
		Var2.float := 3.0E0;

		Var1.float := 5.5E0;
		Var2.charstring := "abc";	// the new type of Var2 is charstring instead of float

      	if ( match(Var1.integer, 10) and match(Var2.float, 3.0E0)) {
	    	setverdict(pass);
      	}
      	else {
	    	setverdict(fail);
	  	}

	}

	control {
		execute(TC_NegSem_060206_anytype_001());
	}

}
with {
	extension "anytype integer, float, charstring"
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using non-selected field integer in a value of union type @NegSem_060206_anytype_001.anytype
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060206_anytype_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060206_002 Ensure that anytype can not be address type if not explicitly declareted in the module >

<COMPILE>

<MODULE TTCN NegSem_060206_anytype_002 NegSem_060206_anytype_002.ttcn >
/****************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, Ensure that anytype can not be address type if not explicitly declareted in the module
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060206_anytype_002 {
	
	type component GeneralComp {	    	    

		var anytype x;
	}

	testcase TC_NegSem_060206_anytype_002() runs on GeneralComp {

		x.address:=10;	// error: address type is not declarated in the module explicitly
		
 
      	if (x.address==10)  {
	    	setverdict(pass);
      	}
      	else {
	    	setverdict(fail);
	  	}

	}

	control {
		execute(TC_NegSem_060206_anytype_002());
	}

}
with {
	extension "anytype address"
}
<END_MODULE>

<RESULT COUNT 1>
error: Type `address' is not defined in this module
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060206_anytype_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060206_002 ensure that anytype cannot be port type >

<COMPILE>

<MODULE TTCN NegSyn_060206_anytype_002 NegSyn_060206_anytype_002.ttcn >
/****************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype cannot be port type
 ** @verdict  pass reject
 ***************************************************/

module NegSyn_060206_anytype_002 {

	type port MyPort message{
		//address integer;
		inout integer;
	} with {extension "internal"}

	type component GeneralComp {
		var anytype x;
		port MyPort PCO1;
	}

	testcase TC_NegSyn_060206_anytype_002() runs on GeneralComp {

		x.MyPort:= PCO1; // port type is not allowed with anytype
	
	}

	control {
    	execute(TC_NegSyn_060206_anytype_002());
	}

}
with {
	extension "anytype MyPort"
}
<END_MODULE>

<RESULT COUNT 1>
error: Port type `@NegSyn_060206_anytype_002.MyPort' cannot be embedded into another type
<END_RESULT>
<RESULT COUNT 1>
error: Reference to a value was expected instead of port `@NegSyn_060206_anytype_002.GeneralComp.PCO1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_001 ensure that the value limitation is correctly handled within array >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_001 NegSem_060207_arrays_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that the value limitation is correctly handled within array
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060207_arrays_001 {

 	type component GeneralComp {
 	}

 	type integer MyArrayType1[5] (1 .. 10);
 
	testcase TC_NegSem_060207_arrays_001() runs on GeneralComp {
    
 		var MyArrayType1 v_array1 := { 8, 11, 2, 3, 4};  
		// syntax error expected, value shall be between 1..10 

	}

	control {
    	execute(TC_NegSem_060207_arrays_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 11 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_002 ensure that the inner type referencing is correctly handled >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_002 NegSem_060207_arrays_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that the inner type referencing is correctly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060207_arrays_002 {

 	type component GeneralComp {	    	    
 	}

 	type integer MyArrayType1[5] (1 .. 10);
 
	testcase TC_NegSem_060207_arrays_002() runs on GeneralComp {

  		var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4, 5, 6};  
		// array is longer than the restricted length 

	}

	control {
		execute(TC_NegSem_060207_arrays_002());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Too many elements in the array value: 5 was expected instead of 7
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_003 negative index applied to an array on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_003 NegSem_060207_arrays_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, negative index applied to an array on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.

module NegSem_060207_arrays_003 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_003() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
		var integer i := v_array1[-1]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_003());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index underflow: the index value must be at least `0' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_004 negative index applied to an array on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_004 NegSem_060207_arrays_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, negative index applied to an array on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/
 
// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.
 
module NegSem_060207_arrays_004 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_004() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
        v_array1[-1] := 10; // error expected
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_004());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index underflow: the index value must be at least `0' instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_005 wrong index type applied to an array on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_005 NegSem_060207_arrays_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, wrong index type applied to an array on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.
// [from 3.1] index notation: notation to access individual elements of record of,
// set of, array and string values or templates, where the element to be accessed 
// is identified explicitly by an index value enclosed in square brackets ("[" and
// "]") which specifies the position of that element within the referenced value 
// or template and the index value is either an integer value, array of integers 
// or record of integers.
 
module NegSem_060207_arrays_005 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_005() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
		var integer i := v_array1["0"]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_005());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_006 wrong index type applied to an array on the left hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_006 NegSem_060207_arrays_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, wrong index type applied to an array on the left hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.
// [from 3.1] index notation: notation to access individual elements of record of,
// set of, array and string values or templates, where the element to be accessed 
// is identified explicitly by an index value enclosed in square brackets ("[" and
// "]") which specifies the position of that element within the referenced value 
// or template and the index value is either an integer value, array of integers 
// or record of integers.

module NegSem_060207_arrays_006 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_006() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
        v_array1["0"] := 10; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_006());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_007 array index greater than the upper bound (left-hand side) >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_007 NegSem_060207_arrays_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, array index greater than the upper bound (left-hand side)
 ** @verdict  pass reject
 ***************************************************/
 
// The following requirement is tested:
// The index shall not exceed the limitations given by either the length or the 
// upper bound of the index.

module NegSem_060207_arrays_007 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_007() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
        v_array1[5] := 3; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_007());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `4' instead of `5'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_008 wrong index type applied to an array on the right hand side of an assignment >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_008 NegSem_060207_arrays_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, wrong index type applied to an array on the right hand side of an assignment
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The index shall not exceed the limitations given by either the length or the 
// upper bound of the index.

module NegSem_060207_arrays_008 {

	type component GeneralComp {	    	    
	}
 
    type integer MyArrayType1[5] (1 .. 10);
	
	testcase TC_NegSem_060207_arrays_008() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 8, 9, 2, 3, 4}; 
		var integer i := v_array1[5]; // error expected
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_008());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `4' instead of `5'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_009 verify than an error is generated when sending a partially initialized array >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060207_arrays_009 NegSem_060207_arrays_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify than an error is generated when sending a partially initialized array
 ** @verdict  pass reject
 ***************************************************/
 
// The following requirement is tested:
// Sending an array value with undefined elements shall cause an error. 

module NegSem_060207_arrays_009 { 

    type integer MyArrayType1[5] (1 .. 10);
	
	type port P message {
		inout MyArrayType1
	} with {extension "internal"}

	type component GeneralComp {
		port P p
	} 

	testcase TC_NegSem_060207_arrays_009() runs on GeneralComp {
        var template MyArrayType1 m_array1 := { 8, 9, -, 3, 4}; 
		p.send(m_array1); // error expected
        setverdict(pass);
	}

	control{
		execute(TC_NegSem_060207_arrays_009());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Performing a valueof or send operation on a non-specific integer template.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_010 ensure that the value limitation is correctly handled within array >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_010 NegSem_060207_arrays_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that the value limitation is correctly handled within array
 ** @verdict  pass reject
 ***************************************************/
 
// The following requirement is tested:
// The values of array elements shall be compatible with the corresponding 
// variable or type declaration.

module NegSem_060207_arrays_010 {

 	type component GeneralComp {
 	}

 	type integer MyArrayType1[5] (1 .. 10);
 
	testcase TC_NegSem_060207_arrays_010() runs on GeneralComp {
    
 		var MyArrayType1 v_array1 := { 
     		[0] := 8,
     		[1] := 0,// error expected, value shall be between 1..10 
     		[2] := 2, 
     		[3] := 3,
     		[4] := 4
     	};  

	}

	control {
		execute(TC_NegSem_060207_arrays_010());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: 0 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_011 runtime resolved constant in array type declaration >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_011 NegSem_060207_arrays_011.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, runtime resolved constant in array type declaration
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_011 {

	type component GeneralComp {
	}

    function f() return integer {
        if (rnd() < 0.5) { return 5; }
        else { return 10; }
    }
  
    const integer c_dimension := f();
    type integer Arr[c_dimension];
	
	testcase TC_NegSem_060207_arrays_011() runs on GeneralComp {        
        var Arr v_arr;
        v_arr[0] := 1;
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_011());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a constant value was expected instead of the return value of function `@NegSem_060207_arrays_011.f'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_012 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_012 runtime resolved constant in array variable declaration >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_012 NegSem_060207_arrays_012.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, runtime resolved constant in array variable declaration 
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_012 {

	type component GeneralComp {
	}

    function f() return integer {
        if (rnd() < 0.5) { return 5; }
        else { return 10; }
    }
    
    const integer c_dimension := f();
	
	testcase TC_NegSem_060207_arrays_012() runs on GeneralComp {        
        var integer v_arr[c_dimension];
        v_arr[0] := 1;
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_012());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a constant value was expected instead of the return value of function `@NegSem_060207_arrays_012.f'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_013 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_013 variable in array variable declaration >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_013 NegSem_060207_arrays_013.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, variable in array variable declaration
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_013 {

	type component GeneralComp {
	}

    function f() return integer {
        if (rnd() < 0.5) { return 5; }
        else { return 10; }
    }
	
	testcase TC_NegSem_060207_arrays_013() runs on GeneralComp {        
        var integer v_dimension := f();
        var integer v_arr[v_dimension];
        v_arr[0] := 1;
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_013());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a constant value was expected instead of variable `v_dimension'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_014 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_014 modulepar in array variable declaration >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_014 NegSem_060207_arrays_014.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, modulepar in array variable declaration
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_014 {

	type component GeneralComp {
	}

    function f() return integer {
        if (rnd() < 0.5) { return 5; }
        else { return 10; }
    }
    
    modulepar integer PX_DIMENSION := 5;
	
	testcase TC_NegSem_060207_arrays_014() runs on GeneralComp {
        var integer v_arr[PX_DIMENSION];
        v_arr[0] := 1;
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_014());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to an \(evaluable\) constant value was expected instead of module parameter `@NegSem_060207_arrays_014.PX_DIMENSION'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_015 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_015 zero dimension array >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_015 NegSem_060207_arrays_015.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, zero dimension array
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_015 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_015() runs on GeneralComp {        
        var integer v_arr[0] := {};
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_015());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A positive integer value was expected as array size instead of `0'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_016 array with negative dimension >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_016 NegSem_060207_arrays_016.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, array with negative dimension
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_016 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_016() runs on GeneralComp {        
        var integer v_arr[3][-1];
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_016());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A positive integer value was expected as array size instead of `-1'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_019 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_019 float instead of integer in array dimension >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_019 NegSem_060207_arrays_019.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, float instead of integer in array dimension
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module NegSem_060207_arrays_019 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_019() runs on GeneralComp {        
        var integer v_arr[2.0];
		setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_019());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_020 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_020 integer array with too many items as multidimensional array index >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_020 NegSem_060207_arrays_020.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, integer array with too many items as multidimensional array index
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// An array or record of integer restricted to a single size can be used in the 
// index notation as a short-hand for the repeated index notation.

module NegSem_060207_arrays_020 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_020() runs on GeneralComp {        
        var integer v_rhindexes[3] := { 0, 1, 0 }, v_lhindexes[3] := { 1, 2, 0 }
        var integer v_arr[2][3] := { { 1, 2, 3 }, { 4, 5, 6 } };
        // testing both RH and LH side:
        v_arr[v_lhindexes] := v_arr[v_rhindexes];        
        if (v_arr == { { 1, 2, 3 }, { 4, 5, 2} }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_NegSem_060207_arrays_020());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `integer\[3\]' contains too many indexes \(3\) in the short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_021 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_021 variable-size record of integer as multidimensional array index >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_021 NegSem_060207_arrays_021.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, variable-size record of integer as multidimensional array index
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// An array or record of integer restricted to a single size can be used in the 
// index notation as a short-hand for the repeated index notation.

module NegSem_060207_arrays_021 {

	type component GeneralComp {
	}
    
    type record length(1..2) of integer RI;
	
	testcase TC_NegSem_060207_arrays_021() runs on GeneralComp {        
        var RI v_rhindexes := { 0, 1 }, v_lhindexes := { 1, 2 }
        var integer v_arr[2][3] := { { 1, 2, 3 }, { 4, 5, 6 } };
        // testing both RH and LH side:
        v_arr[v_lhindexes] := v_arr[v_rhindexes];        
        if (v_arr == { { 1, 2, 3 }, { 4, 5, 2} }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_NegSem_060207_arrays_021());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: The type `@NegSem_060207_arrays_021.RI' must have single size length restriction when used as a short-hand notation for nested indexes.
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_022 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_022 using lower than allowed custom array index on the right hand side of assignments >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_022 NegSem_060207_arrays_022.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using lower than allowed custom array index on the right hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.

module NegSem_060207_arrays_022 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_022() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        var boolean v_bool := v_arr[0] == 0;
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_022());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index underflow: the index value must be at least `2' instead of `0'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_023 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_023 using lower than allowed custom array index on the left hand side of assignments >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_023 NegSem_060207_arrays_023.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using lower than allowed custom array index on the left hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.

module NegSem_060207_arrays_023 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_023() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        v_arr[0] := 0;
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_023());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index underflow: the index value must be at least `2' instead of `0'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_024 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_024 using greater than allowed custom array index on the right hand side of assignments >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_024 NegSem_060207_arrays_024.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using greater than allowed custom array index on the right hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The index shall not exceed the limitations given by either the length or the 
// upper bound of the index.

module NegSem_060207_arrays_024 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_024() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        var boolean v_bool := v_arr[6] == 6;
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_024());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `5' instead of `6'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_025 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_025 using greater than allowed custom array index on the left hand side of assignments >

<COMPILE>

<MODULE TTCN NegSem_060207_arrays_025 NegSem_060207_arrays_025.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using greater than allowed custom array index on the left hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The index shall not exceed the limitations given by either the length or the 
// upper bound of the index.

module NegSem_060207_arrays_025 {

	type component GeneralComp {
	}
	
	testcase TC_NegSem_060207_arrays_025() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        v_arr[6] := 6;
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_025());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Array index overflow: the index value must be at most `5' instead of `6'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_026 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_026 using greater than allowed custom array index on the left hand side of assignments >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060207_arrays_026 NegSem_060207_arrays_026.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, referencing uninitialized array element on the right hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// : If the value of the element indicated by the index at the right hand of 
// an assignment is undefined or if the index notation is applied to an uninitialized
// or omitted array value on the right hand side of an assignment, error shall be 
// caused.

module NegSem_060207_arrays_026 {

	type component GeneralComp {
	}
    
    type record R {
        integer field1[3],
        boolean field2
    }
        
	testcase TC_NegSem_060207_arrays_026() runs on GeneralComp {        
        var integer v_arr[3], v_int;
        v_arr[2] := 1;
        v_int := v_arr[0];
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_026());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Assignment of an unbound integer value.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_027 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_027 using greater than allowed custom array index on the left hand side of assignments >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060207_arrays_027 NegSem_060207_arrays_027.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, referencing element of uninitialized arrays on the right hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// : If the value of the element indicated by the index at the right hand of 
// an assignment is undefined or if the index notation is applied to an uninitialized
// or omitted array value on the right hand side of an assignment, error shall be 
// caused.

module NegSem_060207_arrays_027 {

	type component GeneralComp {
	}
    
    type record R {
        integer field1[3],
        boolean field2
    }
        
	testcase TC_NegSem_060207_arrays_027() runs on GeneralComp {        
        var R v_rec := { -, true }
        var integer v_int := v_rec.field1[0];
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_027());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Copying an unbound integer value.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060207_arrays_028 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_028 using greater than allowed custom array index on the left hand side of assignments >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060207_arrays_028 NegSem_060207_arrays_028.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, referencing element of omitted arrays on the right hand side of assignments
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// : If the value of the element indicated by the index at the right hand of 
// an assignment is undefined or if the index notation is applied to an uninitialized
// or omitted array value on the right hand side of an assignment, error shall be 
// caused.

module NegSem_060207_arrays_028 {

	type component GeneralComp {
	}
    
    type record R {
        integer field1[3] optional,
        boolean field2
    }
        
	testcase TC_NegSem_060207_arrays_028() runs on GeneralComp {        
        var R v_rec := { omit, true }
        var integer v_int := v_rec.field1[0];
        setverdict(pass);
	}
	
	control {
		execute(TC_NegSem_060207_arrays_028());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using the value of an optional field containing omit
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060207_arrays_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_001 ensure that array cannot contain an empty assignment >

<COMPILE>

<MODULE TTCN NegSyn_060207_arrays_001 NegSyn_060207_arrays_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that array cannot contain an empty assignment
 ** @verdict  pass reject
 ***************************************************/

module NegSyn_060207_arrays_001 {

 	type component GeneralComp {
    }

 	type integer MyArrayType1[5] (1 .. 10);

 	testcase TC_NegSyn_060207_arrays_001() runs on GeneralComp {

  		var MyArrayType1 v_array1 := { 8, , 2, 3, 4};  // syntax error expected

 	}

 	control {
  		execute(TC_NegSyn_060207_arrays_001());
 	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `,': syntax error, unexpected ','
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060207_arrays_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_002 ensure that array field cannot contain an empty index >

<COMPILE>

<MODULE TTCN NegSyn_060207_arrays_002 NegSyn_060207_arrays_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that array field cannot contain an empty index
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060207_arrays_002 {

 	type component GeneralComp {
 	}

 
 	type integer MyArrayType1[5] (1 .. 10);
 
 	testcase TC_NegSyn_060207_arrays_002() runs on GeneralComp {

  		var MyArrayType1 v_array1 := { 8, 10, 2, 3, 4};
  		v_array1[] := 10; // error expected - missing index
 	}

 	control {
 		execute(TC_NegSyn_060207_arrays_002());
 	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060207_arrays_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_003 ensure that array field cannot contain an empty index >

<COMPILE>

<MODULE TTCN NegSyn_060207_arrays_003 NegSyn_060207_arrays_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that array field cannot contain an empty index
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_060207_arrays_003 {

 	type component GeneralComp {
    }

 
 	type integer MyArrayType1[5] (1 .. 10);
 
 
 	testcase TC_NegSyn_060207_arrays_003() runs on GeneralComp {

  		var MyArrayType1 v_array1 := { 8, 10, 2, 3, 4};
  		var integer i :=v_array1[];// error expected - missing index
    }

 	control {
  		execute(TC_NegSyn_060207_arrays_003());
 	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\]': syntax error, unexpected '\]'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060207_arrays_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060207_004 infinity in array variable dimension >

<COMPILE>

<MODULE TTCN NegSyn_060207_arrays_004 NegSyn_060207_arrays_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.7, infinity in array variable dimension
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Array dimensions may also be specified using ranges (with inclusive 
// boundaries only). In such cases, the lower and upper values of the range 
// define the lower and upper index values. Such an array is corresponding to 
// a record of with a fixed length restriction computed as the difference 
// between upper and lower index bound plus 1 and indexing starting from the 
// lower bound of the array definition.

module NegSyn_060207_arrays_004 {

    control {
        var integer v_arr[1..infinity];
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type integer was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060209_CommunicationPortTypes_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060209_004 Verify that an error is generated when a message port type definition contains no message typess >

<COMPILE>

<MODULE TTCN NegSem_060209_CommunicationPortTypes_004 NegSem_060209_CommunicationPortTypes_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Verify that an error is generated when a message port type definition contains no message types
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Each port type definition shall have one or more lists indicating the allowed collection of 
// (message) types ... with the allowed communication direction.

module NegSem_060209_CommunicationPortTypes_004 {

	type record MyType1 {
        integer f1,
        charstring f2
    }

	type record MyType2 {
	    integer g1,
	    charstring g2
	}

	type record MyType3 {
	    boolean h1,
        MyType3 h2 optional
	}
	
    type port MyMessagePortTypeOne message {
       // address MyType1;
       // map param (in integer p1, inout MyType2 p2);
       // unmap param (in MyType3 p1, out integer p2);
    } with {extension "internal"}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\}': syntax error, unexpected '\}'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060209_CommunicationPortTypes_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060209_005 Verify that an error is generated when a procedure port type definition contains no signatures >

<COMPILE>

<MODULE TTCN NegSem_060209_CommunicationPortTypes_005 NegSem_060209_CommunicationPortTypes_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Verify that an error is generated when a procedure port type definition contains no signatures
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Each port type definition shall have one or more lists indicating the allowed collection of 
// ... procedure signatures with the allowed communication direction.

module NegSem_060209_CommunicationPortTypes_005 {

	type record MyType1 {
        integer f1,
        charstring f2
    }

	type record MyType2 {
	    integer g1,
	    charstring g2
	}

	type record MyType3 {
	    boolean h1,
        MyType3 h2 optional
	}
	
    type port MyMessagePortTypeOne procedure {
       // address MyType1;
       // map param (in integer p1, inout MyType2 p2);
       // unmap param (in MyType3 p1, out integer p2);
    } with {extension "internal"}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `\}': syntax error, unexpected '\}'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060210_ReuseofComponentTypes_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060210_001 Ensure that cyclic extension is not allowed >

<COMPILE>

<MODULE TTCN NegSyn_060210_ReuseofComponentTypes_001 NegSyn_060210_ReuseofComponentTypes_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that cyclic extension is not allowed
 ** @verdict  pass reject, noexecution
 *****************************************************************/

/* The following requirements are tested:
 * Restriction c.: It is allowed to extend component types that are defined by means of extension, 
 * as long as no cyclic chain of definition is created. 
 */

module NegSyn_060210_ReuseofComponentTypes_001 {
 
    type port loopbackPort message {
        inout integer;
        inout float;
    } with {extension "internal"}
     
 	type component MyCompA extends GeneralComp {
       	port loopbackPort pt_myPortA;
    }
    

 	type component MyCompB extends MyCompA {
      	var integer MyInt;
    }
    

 	type component GeneralComp extends MyCompB { //error: cyclic extension
        port loopbackPort pt_myPortB;
    }
    
    testcase TC_NegSyn_060210_ReuseofComponentTypes_001() runs on GeneralComp {
 
     	pt_myPortB.send(2);
  	}

    control{
        execute(TC_NegSyn_060210_ReuseofComponentTypes_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: While checking component type extensions: Circular reference: `@NegSyn_060210_ReuseofComponentTypes_001.MyCompA' -> `@NegSyn_060210_ReuseofComponentTypes_001.GeneralComp' -> `@NegSyn_060210_ReuseofComponentTypes_001.MyCompB' -> `@NegSyn_060210_ReuseofComponentTypes_001.MyCompA'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060210_ReuseofComponentTypes_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060210_002 Ensure that cyclic extension is not allowed >

<COMPILE>

<MODULE TTCN NegSyn_060210_ReuseofComponentTypes_002 NegSyn_060210_ReuseofComponentTypes_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that extending a component that occurs name clash is not allowed
 ** @verdict  pass reject, noexecution
 *****************************************************************/

/* The following requirements are tested:
 * Restriction b.: When defining component types by extending more than one parent type,
 * there shall be no name clash between the definitions of the different parent types
 */

module NegSyn_060210_ReuseofComponentTypes_002 {
 
    type port loopbackPort message {
        inout integer;
        inout float;
    } with {extension "internal"}
     
 	type component MyCompA {
      	port loopbackPort pt_myPortA;
    }
    

 	type component MyCompB  {
      	var integer MyInt;
    }
    
 	type component GeneralComp extends MyCompA, MyCompB { 
        port loopbackPort pt_myPortB;
        var integer MyInt;    //error: name clash
    }
    
    testcase TC_NegSyn_060210_ReuseofComponentTypes_002() runs on GeneralComp {
      
     	pt_myPortA.send(2);
     	pt_myPortB.send(2.0);
  	} 

    control{
        execute(TC_NegSyn_060210_ReuseofComponentTypes_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Local definition `MyInt' collides with definition inherited from component type `@NegSyn_060210_ReuseofComponentTypes_002.MyCompB
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_060210_ReuseofComponentTypes_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060210_003 Ensure that cyclic extension is not allowed >

<COMPILE>

<MODULE TTCN NegSyn_060210_ReuseofComponentTypes_003 NegSyn_060210_ReuseofComponentTypes_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that extending a component that occurs name clash is not allowed
 ** @verdict  pass reject, noexecution
 *****************************************************************/

/* The following requirements are tested:
 * When defining component types by extension, there shall be 
 * no name clash between the definitions being taken from the parent type
 * and the definitions being added in the extended type
 */

module NegSyn_060210_ReuseofComponentTypes_003 {
 
    type port loopbackPort message {
        inout integer;
        inout float;
    } with {extension "internal"}
  
 	type component MyCompA  {
     	port loopbackPort pt_myPortA;
     	var integer MyInt;
    }
    

 	type component GeneralComp extends MyCompA  { 
        port loopbackPort pt_myPortB;
        var integer MyInt;    //error: name clash from parent type
    }
    
    testcase TC_NegSyn_060210_ReuseofComponentTypes_003() runs on GeneralComp {
      
     	pt_myPortA.send(2);
     	pt_myPortB.send(2.0);
 	}

    control{
        execute(TC_NegSyn_060210_ReuseofComponentTypes_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Local definition `MyInt' collides with definition inherited from component type `@NegSyn_060210_ReuseofComponentTypes_003.MyCompA
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021301_LengthSubtyping_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021301_001 The length subtyping check for 'record of' or 'set of' types >

<COMPILE>

<MODULE TTCN NegSem_06021301_LengthSubtyping_001 NegSem_06021301_LengthSubtyping_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021301_LengthSubtyping_001 {
   type record length(0..10) of integer RecordOfLengthLessThan10;	

   type RecordOfLengthLessThan10 RecordOfLength4To5 length(4..5);	
   type RecordOfLength4To5 RecordOfLength6 length(6);				//length out of parent type range

}
<END_MODULE>

<RESULT COUNT 1>
error: The subtype restriction is not a subset of the restriction on the parent type. Subtype length\(6\) is not subset of subtype length\(4..5\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021301_LengthSubtyping_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021301_002 The length subtyping check for 'record of' or 'set of' types >

<COMPILE>

<MODULE TTCN NegSem_06021301_LengthSubtyping_002 NegSem_06021301_LengthSubtyping_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021301_LengthSubtyping_002 {
   type set length(0..10) of integer SetOfLengthLessThan10;	

   type SetOfLengthLessThan10 SetOfLength4To5 length(4..5);	
   type SetOfLength4To5 SetOfLength6 length(6);				//length out of parent type range

}
<END_MODULE>

<RESULT COUNT 1>
error: The subtype restriction is not a subset of the restriction on the parent type. Subtype length\(6\) is not subset of subtype length\(4..5\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021301_LengthSubtyping_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021301_003 The length subtyping check for 'record of' or 'set of' types >

<COMPILE>

<MODULE TTCN NegSem_06021301_LengthSubtyping_003 NegSem_06021301_LengthSubtyping_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021301_LengthSubtyping_003 {
   type record length(0..!10) of integer RecordOfLengthLessThan10;	//only inclusive boundary is allowed

   type RecordOfLengthLessThan10 RecordOfLength4To5 length(4..5);	

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `!': syntax error, unexpected '!'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021301_LengthSubtyping_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021301_004 The length subtyping check for 'record of' or 'set of' types >

<COMPILE>

<MODULE TTCN NegSem_06021301_LengthSubtyping_004 NegSem_06021301_LengthSubtyping_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021301_LengthSubtyping_004 {
   type set length(0..10) of integer SetOfLengthLessThan10;

   type SetOfLengthLessThan10 SetOfLength5 length(!4..5);	//only inclusive boundary is allowed	

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `!': syntax error, unexpected '!'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021302_ListSubtyping_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021302_001 ensure that list subtyping check for record types is properly handled >

<COMPILE>

<MODULE TTCN NegSem_06021302_ListSubtyping_001 NegSem_06021302_ListSubtyping_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.2, ensure that list subtyping check for record types is properly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021302_ListSubtyping_001 {
 	type record MyRecord {
	  	integer f1 optional,
	  	charstring f2,
	  	charstring f3
 	}
 
 	type MyRecord MyRecordSub1 (
  		{ f1 := omit, f2 := "user", f3 := "password" },
  		{ f1 := 1, f2 := "User", f3 := "Password" }
  	); // a valid subtype of MyRecord containing 2 values
  
 	type MyRecordSub1 MyRecordSub2 (
   		{ f1 := 1, f2 := "user", f3 := "password" }, 
   		{ f1 := 1, f2 := "User", f3 := "Password" }
  	); //invalid subtype, the omitted element cannot be overwritten
  
}
<END_MODULE>

<RESULT COUNT 1>
error: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(\{ f1 := 1, f2 := "user", f3 := "password" \},\{ f1 := 1, f2 := "User", f3 := "Password" \}\) is not subset of subtype \(\{ f1 := omit, f2 := "user", f3 := "password" \},\{ f1 := 1, f2 := "User", f3 := "Password" \}\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_06021302_ListSubtyping_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 06021302_002 ensure that list subtyping check for record types is properly handled >

<COMPILE>

<MODULE TTCN NegSem_06021302_ListSubtyping_002 NegSem_06021302_ListSubtyping_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.2.13.2, ensure that list subtyping check for record types is properly handled
 ** @verdict  pass reject
 ***************************************************/
module NegSem_06021302_ListSubtyping_002 {
 	type record MyRecord {
	  	integer f1 optional,
	  	charstring f2,
	  	charstring f3
 	}
 
 	type MyRecord MyRecordSub1 (
  		{ f1 := -, f2 := "user", f3 := "password" },
  		{ f1 := -, f2 := "User", f3 := "Password" }
  	); // a valid subtype of MyRecord containing 2 values
  
  	type MyRecordSub1 MyRecordSub2 (
   		{ f1 := 1, f2 := "user", f3 := "password" }, 
   		{ f1 := 2, f2 := "user", f3 := "Password" }
  	); //invalid subtype, contains wrong combination of f2 and f3
  
}
<END_MODULE>

<RESULT COUNT 1>
error: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(\{ f1 := 1, f2 := "user", f3 := "password" \},\{ f1 := 2, f2 := "user", f3 := "Password" \}\) is not subset of subtype \(\{ f1 := -, f2 := "user", f3 := "password" \},\{ f1 := -, f2 := "User", f3 := "Password" \}\)
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h2. 0603_type_compatibility folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_060301_non_structured_types_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060301_007 Ensure that the IUT correctly handles assignments from compatible size restrictions  >

<COMPILE>

<MODULE TTCN NegSem_060301_non_structured_types_007 NegSem_060301_non_structured_types_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible size restrictions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060301_non_structured_types_007 { 
    type integer ConstrainedInt[1];

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060301_non_structured_types_007() runs on GeneralComp {

		var integer v_int[2]:={5,4};
		var ConstrainedInt v_constrainedInt;
		
		
		v_constrainedInt:=v_int; // length 2 array assigned to length 1 array type
	}

	control{
		execute(TC_NegSem_060301_non_structured_types_007());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `integer\[1\]' and `integer\[2\]' are not compatible: Array types should have the same dimension
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060301_non_structured_types_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060301_008 Ensure that the IUT correctly handles assignments from compatible size restrictions  >

<COMPILE>

<MODULE TTCN NegSem_060301_non_structured_types_008 NegSem_060301_non_structured_types_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible size restrictions 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060301_non_structured_types_008 { 
    type float ConstrainedFloat[1];

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060301_non_structured_types_008() runs on GeneralComp {

		var float v_float[2]:={5.0,4.0};
		var ConstrainedFloat v_constrainedFloat;
		
		
		v_constrainedFloat:=v_float; // length 2 array assigned to length 1 array type
	}

	control{
		execute(TC_NegSem_060301_non_structured_types_008());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `float\[1\]' and `float\[2\]' are not compatible: Array types should have the same dimension
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_001 Reject assignment of other enumerated types since they are only compatible to synonym types  >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_001 NegSem_060302_structured_types_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2.1, Reject assignment of other enumerated types since they are only compatible to synonym types
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_001 { 

	type enumerated EnumeratedType {e_black, e_white};
	type enumerated EnumeratedRedefinition {e_black, e_white};

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_001() runs on GeneralComp {

		var EnumeratedType v_enum1:=e_black;
		var EnumeratedRedefinition v_enum2;
		
		v_enum2:=v_enum1; // not a synonym type
		setverdict(pass);
	}

	control{
		execute(TC_NegSem_060302_structured_types_001());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: a value of type `@NegSem_060302_structured_types_001.EnumeratedRedefinition' was expected instead of `@NegSem_060302_structured_types_001.EnumeratedType'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_002 Ensure that the IUT rejects assignments from incompatible types or type ranges  >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_002 NegSem_060302_structured_types_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments from incompatible types or type ranges 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_002 { 

	type record RecordType1 { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..5) optional, 
 	 boolean  c 
	} 
	type record RecordType2 { 
 	 integer  e 	   optional, 
 	 integer  f(0..10)  , 
 	 boolean  g 
	} 

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_002() runs on GeneralComp {

		var RecordType1 v_rec1:={a:=4,b:=omit,c:=false};
		var RecordType2 v_rec2;
		
		v_rec2:=v_rec1;		// optionality mismatch (e.g. b is optional where f is mandatory)
		setverdict(pass);
	}

	control{
		execute(TC_NegSem_060302_structured_types_002());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `@NegSem_060302_structured_types_002.RecordType2.f' of type `integer' and `@NegSem_060302_structured_types_002.RecordType1.b' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_004 Ensure that the IUT rejects assignments from incompatible types or type ranges >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_004 NegSem_060302_structured_types_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments from incompatible types or type ranges 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_004 { 

	type set SetType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 
	type set ModifiedSet { 
 	 integer  e 	   optional, 
 	 integer  f(0..5)  , 
 	 boolean  g 
	} 

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_004() runs on GeneralComp {

		var ModifiedSet v_set1:={f:=4,e:=8,g:=false};
		var SetType v_set2;

		v_set2:=v_set1;	//optionality mismatch
		setverdict(pass);

	}

	control{
		execute(TC_NegSem_060302_structured_types_004());
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `@NegSem_060302_structured_types_004.SetType.b' of type `integer' and `@NegSem_060302_structured_types_004.ModifiedSet.f' of type `integer' are not compatible: The optionality of fields in set/SET types must be the same
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_009 Ensure that the IUT rejects assignments from incompatible types or type ranges >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_060302_structured_types_009 NegSem_060302_structured_types_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments from incompatible types or type ranges 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_009 { 

	type enumerated EnumeratedType {e_black, e_white};
	type enumerated EnumeratedRedefinition {e_black, e_white};

	type union UnionType { 
 	 integer  a(0..10), 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 
	type union ModifiedUnion { 
 	 integer  a, 
 	 boolean  c, 
 	 EnumeratedRedefinition  b 
	}

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_009() runs on GeneralComp {

		var ModifiedUnion v_union1:={b:=e_black};
		var UnionType v_union2;
		
		v_union2:=v_union1;	//enumerated type mismatch
		setverdict(pass);
	}

	control{
		execute(TC_NegSem_060302_structured_types_009());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Values or templates of types `@NegSem_060302_structured_types_009.ModifiedUnion' and `@NegSem_060302_structured_types_009.UnionType' are not compatible at run-time
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_010 Ensure that the IUT rejects assignments from incompatible types or type ranges >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_010 NegSem_060302_structured_types_010.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments from incompatible types or type ranges 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_010 { 

	type enumerated EnumeratedType {e_black, e_white};
	type EnumeratedType EnumeratedSynonym;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 
	type union ModifiedUnion { 
 	 integer  aa, 
 	 boolean  cc, 
 	 EnumeratedSynonym  bb 
	}


	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_010() runs on GeneralComp {

		var ModifiedUnion v_union1:={aa:=1};
		var UnionType v_union2;
		
		v_union2:=v_union1;	//element naming  mismatch
		setverdict(pass);

	}

control{
    execute(TC_NegSem_060302_structured_types_010());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `@NegSem_060302_structured_types_010.UnionType' and `@NegSem_060302_structured_types_010.ModifiedUnion' are not compatible: No compatible union/CHOICE/anytype field found
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_011 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_011 Ensure that the IUT rejects assignments from structures having incompatible anytypes >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_011 NegSem_060302_structured_types_011.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments from structures having incompatible anytypes 
 ** @verdict  pass reject
 ***************************************************/
module NegSem_060302_structured_types_011 { 

	import from NegSem_060302_structured_types_011_importA all; 
	import from NegSem_060302_structured_types_011_importB all; 

	type component GeneralComp {	    	    
	}	

	testcase TC_NegSem_060302_structured_types_011() runs on GeneralComp {

	   var NegSem_060302_structured_types_011_importA.Atype v_a; 
	   var NegSem_060302_structured_types_011_importB.Atype v_b := { F := 1 } 
		
	   v_a:=v_b;		//v_a's type does not contain the selected alternative
		
		if ( v_a==1 ) {
		    setverdict(pass);
		}
		else {
		    setverdict(fail);
		}		
	}

	control{
		execute(TC_NegSem_060302_structured_types_011());
	}

}
<END_MODULE>

<MODULE TTCN NegSem_060302_structured_types_011_importA NegSem_060302_structured_types_011_importA.ttcn >
module NegSem_060302_structured_types_011_importA { 
  type integer I (0..2); 
  type anytype Atype;
 } 
<END_MODULE>

<MODULE TTCN NegSem_060302_structured_types_011_importB NegSem_060302_structured_types_011_importB.ttcn >
module NegSem_060302_structured_types_011_importB { 
  type integer I (0..2); 
  type integer F; 
  type anytype Atype;
} 
with {
	extension "anytype F"
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `@NegSem_060302_structured_types_011_importA.anytype' and `@NegSem_060302_structured_types_011_importB.anytype' are not compatible: No compatible union/CHOICE/anytype field found
<END_RESULT>
<RESULT COUNT 1>
error: Type mismatch: `@NegSem_060302_structured_types_011_importA.anytype' and `integer' are not compatible: Type anytype is compatible only with other anytype types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_016 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_016 Ensure that the IUT rejects assignments between incompatible structures >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_016 NegSem_060302_structured_types_016.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments between incompatible structures 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_016 {

    type set SetType {
        integer  a,
        integer  b optional,
        integer  c
    }

    type set of integer IntegerList;


    type component GeneralComp {
    }

    testcase TC_NegSem_060302_structured_types_016() runs on GeneralComp {
        
		var SetType v_set := { a:= 1, b:= omit, c:= 2}; // value list not work with sets
		var IntegerList v_IntList;
		var integer v_array[2];
    
        v_array:=v_set;  //assignment between incompatible types

    }

    control{
        execute(TC_NegSem_060302_structured_types_016());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `integer\[2\]' and `@NegSem_060302_structured_types_016.SetType' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060302_structured_types_018 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060302_018 Ensure that the IUT rejects assignments between incompatible structures >

<COMPILE>

<MODULE TTCN NegSem_060302_structured_types_018 NegSem_060302_structured_types_018.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT rejects assignments between incompatible structures 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060302_structured_types_018 {

    type set SetType {
        integer  a,
        integer  b,
        integer  c
    }

    type component GeneralComp {
    }

    testcase TC_NegSem_060302_structured_types_018() runs on GeneralComp {
        
		var SetType v_set := { a:= 1, b:= 2, c:= 3};
		var integer v_array[3];
    
        v_array:=v_set;  //assignment between incompatible types, see clause G.9 compatibility rules

    }

    control{
        execute(TC_NegSem_060302_structured_types_018());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: `integer\[3\]' and `@NegSem_060302_structured_types_018.SetType' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060303_component_types_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060303_001 Ensure that the IUT correctly handles component incompatibility due to differing list of constant definitions >

<COMPILE>

<MODULE TTCN NegSem_060303_component_types_001 NegSem_060303_component_types_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.3, Ensure that the IUT correctly handles component incompatibility due to differing list of constant definitions
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060303_component_types_001 {

    type integer ConstrainedInteger(0..10);

    type component TestCaseComp {
        const integer c_integer:=2;
    }

    type component FunctionComp {
        const integer c_integer:=2;
        const ConstrainedInteger c_constrained:=2;
    }

    function f_testFunction(integer p_arg) runs on FunctionComp return integer {

        var integer v_result;
        v_result:=p_arg*c_integer;
        return v_result;
    }

    testcase TC_NegSem_060303_component_types_001() runs on TestCaseComp {

        var integer v_int:=1;
        
        v_int := f_testFunction(v_int);
        // runs on mtc with type TestCaseComp
        // f_testFunction needs to run on FunctionComp
        // which has 2 variables not 1 as TestCaseComp
        setverdict (fail, "ERROR expected: function runs on mtc with type TestCaseComp f_testFunction needs to run on FunctionComp which has 2 variables not 1 as TestCaseComp");
    }

    control {
        execute(TC_NegSem_060303_component_types_001());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Runs on clause mismatch: A definition that runs on component type `@NegSem_060303_component_types_001.TestCaseComp' cannot call function `@NegSem_060303_component_types_001.f_testFunction', which runs on `@NegSem_060303_component_types_001.FunctionComp'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_060303_component_types_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 060303_002 Ensure that the IUT correctly handles component incompatibility due to differing list of constant definitions >

<COMPILE>

<MODULE TTCN NegSem_060303_component_types_002 NegSem_060303_component_types_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:6.3.3, Ensure that the IUT correctly handles component incompatibility due to differing constant types having same name
 ** @verdict  pass reject
 ***************************************************/

module NegSem_060303_component_types_002 {

    type integer ConstrainedInteger(0..10);

    type component TestCaseComp {
        const integer c_integer:=2;
        const integer c_constrained:=2;
    }

    type component FunctionComp {
        const integer c_integer:=2;
        const ConstrainedInteger c_constrained:=2;
    }

    function f_testFunction(integer p_arg) runs on FunctionComp return integer {

        var integer v_result;
        v_result:=p_arg*c_integer;
        return v_result;
    }

    testcase TC_NegSem_060303_component_types_002() runs on TestCaseComp {

        var integer v_int:=1;
        
        f_testFunction(v_int);

        setverdict(fail, "Error expected: as component types are not compatible since their definitions are not identical.");
    }

    control {
        execute(TC_NegSem_060303_component_types_002());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Runs on clause mismatch: A definition that runs on component type `@NegSem_060303_component_types_002.TestCaseComp' cannot call function `@NegSem_060303_component_types_002.f_testFunction', which runs on `@NegSem_060303_component_types_002.FunctionComp'
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.1/174 02-CRL 113 200/5 Uen 
:nl.Statement of Compliance for TITAN project
:li D='[2]'.ETSI ES 201 873-1, v4.7.1 Mockup v1 (2015-06):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.
