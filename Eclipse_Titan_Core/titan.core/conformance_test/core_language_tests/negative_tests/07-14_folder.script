.******************************************************************************
.* Copyright (C) 2017 ETSI  All Rights Reserved.
.*
.* Contributors:
.*   Adrien Kirjak 
.*
.******************************************************************************/
text.
:lang eng.
.*
:docname.Test Description
:docno.xz/152 91-CRL 113 200 Uen
:rev.PA1
:date.2016-04-04
.*
:prep.ETH/XZ EADRKIR
:subresp.EADRKIR
:appr.ETH/XZ (Elemer Lelik)
:checked.
.*
:title.ETSI TTCN3 Negative Conformance Test
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*	
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains negative tests from ETSI TTCN3 Conformance Test's 07_expressions, 08_modules, 09_test_configurations, 10_constants, 11_variables, 12_timers and 14_procedure_signatures folders. 

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester.pl

:exmp.
:np.

.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2. 07_expressions folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_07_toplevel_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 07_001 function without return clause in expression  >

<COMPILE>

<MODULE TTCN NegSem_07_toplevel_001 NegSem_07_toplevel_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:7, function without return clause in expression
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// Functions used in expressions shall have a return clause. 

module NegSem_07_toplevel_001
{
    type component GeneralComp {
	}
    
    function f()
    {
        var integer v_num := 1;
    }
    
    testcase TC_NegSem_07_toplevel_001() runs on GeneralComp {        
        var integer v_num := 3 * f();
        setverdict(pass);
	}
	
	control {        
		execute(TC_NegSem_07_toplevel_001());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a value was expected instead of a call of function `@NegSem_07_toplevel_001.f', which does not have return type
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_07_toplevel_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 07_002 template used as expression operand  >

<COMPILE>

<MODULE TTCN NegSem_07_toplevel_002 NegSem_07_toplevel_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:7, template used as expression operand
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// The operands of the operators used in an expression shall be values and their root 
// types shall be the types specified for the appropriate operator in the subsequent 
// clauses.

module NegSem_07_toplevel_002
{
    type component GeneralComp {
	}
    
    function f()
    {
        var integer p_num := 1;
    }
    
    testcase TC_NegSem_07_toplevel_002() runs on GeneralComp {        
        var template(value) integer vm_num := 3;
        var integer p_num := 3 * vm_num;
        setverdict(pass);
	}
	
	control {        
		execute(TC_NegSem_07_toplevel_002());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a value was expected instead of template variable `vm_num'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_07_toplevel_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 07_003 uninitialized value in an expression >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_07_toplevel_003 NegSem_07_toplevel_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:7, uninitialized value in an expression
 ** @verdict  pass reject
 ***************************************************/

// The following requirement is tested:
// At the point, when an expression is evaluated, the evaluated values of the 
// operands used in expressions shall be completely initialized except where 
// explicitly stated otherwise in the specific clause of the operator.

module NegSem_07_toplevel_003
{
    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        integer field2 optional
    }
    
    testcase TC_NegSem_07_toplevel_003() runs on GeneralComp {        
        var R v_rec;
        v_rec.field1 := 1;
        if (10 + v_rec.field2 != -1) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_NegSem_07_toplevel_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Using the value of an optional field containing omit.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_001 Ensure that Arithmetic operators are for integer and float values  >

<COMPILE>

<MODULE TTCN NegSem_070101_ArithmeticOperators_001 NegSem_070101_ArithmeticOperators_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that Arithmetic operators are for integer and float values
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_NegSem_070101_ArithmeticOperators_001() runs on GeneralComp {
	var integer v_i := 20;
	var boolean v_k :=true;
	
	var integer v_result := v_i*v_k;	// not allowed int*boolean
	
	setverdict(pass);

	
}	
control{
    execute(TC_NegSem_070101_ArithmeticOperators_001());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Second operand of operation `\*' should be integer or float value
<END_RESULT>
<RESULT COUNT 1>
error: The operands of operation `\*' should be of same type
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_002 Ensure that arithmetic operators can handle same type of variables  >

<COMPILE>

<MODULE TTCN NegSem_070101_ArithmeticOperators_002 NegSem_070101_ArithmeticOperators_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle same type of variables
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_NegSem_070101_ArithmeticOperators_002() runs on GeneralComp {
	var integer v_i := 20;
	var float v_k :=2.0E0;
	
	var integer v_result := v_i*v_k;	// not allowed int*float
	
	setverdict(pass);

}	
control{
    execute(TC_NegSem_070101_ArithmeticOperators_002());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: The operands of operation `\*' should be of same type
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_003 Ensure that mod arithmetic operator can handle integer variables >

<COMPILE>

<MODULE TTCN NegSem_070101_ArithmeticOperators_003 NegSem_070101_ArithmeticOperators_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that mod arithmetic operator can handle integer variables
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_003 {

type component GeneralComp {	    	    
}

testcase TC_NegSem_070101_ArithmeticOperators_003() runs on GeneralComp {
	var float v_i := 2.0E1;
	var float v_k :=2.0E0;
	
	var integer v_result := v_i mod v_k;	// mod operator is only for integer type
	
	setverdict(pass);
}	
control{
    execute(TC_NegSem_070101_ArithmeticOperators_003());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Left operand of operation `mod' should be integer value
<END_RESULT>
<RESULT COUNT 1>
error: Right operand of operation `mod' should be integer value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_004 Ensure that rem arithmetic operator can handle integer variables >

<COMPILE>

<MODULE TTCN NegSem_070101_ArithmeticOperators_004 NegSem_070101_ArithmeticOperators_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that rem arithmetic operator can handle integer variables
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_004 {

type component GeneralComp {	    	    
}

testcase TC_NegSem_070101_ArithmeticOperators_004() runs on GeneralComp {
	var float v_i := 2.0E1;
	var float v_k :=2.0E0;
	
	var integer v_result := v_i rem v_k;	// rem operator is only for integer type
	
	setverdict(pass);
}	
control{
    execute(TC_NegSem_070101_ArithmeticOperators_004());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Left operand of operation `rem' should be integer value
<END_RESULT>
<RESULT COUNT 1>
error: Right operand of operation `rem' should be integer value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_008 Ensure that in x mod y arithmetic operator y is non-zero positive number >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_070101_ArithmeticOperators_008 NegSem_070101_ArithmeticOperators_008.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that in x mod y arithmetic operator y is non-zero positive number 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_008 {

	type component GeneralComp {	    	    
	}

	testcase TC_NegSem_070101_ArithmeticOperators_008() runs on GeneralComp {
		var integer v_i := 20;
		var integer v_k :=0;
	
		var integer v_result := v_i mod v_k;	// arithmetic operator mod with 0 is not allowed

		setverdict(pass);

	}	
	control{
		execute(TC_NegSem_070101_ArithmeticOperators_008());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: The right operand of mod operator is zero.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_009 Ensure that in x rem y arithmetic operator y is non-zero positive number >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_070101_ArithmeticOperators_009 NegSem_070101_ArithmeticOperators_009.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that in x rem y arithmetic operator y is non-zero positive number 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_009 {

	type component GeneralComp {	    	    
	}

	testcase TC_NegSem_070101_ArithmeticOperators_009() runs on GeneralComp {
		var integer v_i := 20;
		var integer v_k :=0;
	
		var integer v_result := v_i rem v_k;	// arithmetic operator rem with 0 is not allowed

		setverdict(pass);

	}	
	control{
		execute(TC_NegSem_070101_ArithmeticOperators_009());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Integer division by zero.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070101_ArithmeticOperators_010 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070101_010 Ensure that in x rem y arithmetic operator y is non-zero positive number >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_070101_ArithmeticOperators_010 NegSem_070101_ArithmeticOperators_010.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that in x rem y arithmetic operator y is non-zero positive number 
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070101_ArithmeticOperators_010 {

type component GeneralComp {	    	    
}

testcase TC_NegSem_070101_ArithmeticOperators_010() runs on GeneralComp {
	var integer v_i := 20;
	var integer v_k :=4;
	var integer v_l :=2;
	
	var integer v_result := v_i rem (v_k mod v_l);	// arithmetic operator rem with 0 is not allowed

		setverdict(pass);

}	
control{
    execute(TC_NegSem_070101_ArithmeticOperators_010());
}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Integer division by zero.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070103_RelationalOperators_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070103_002 Ensure that the equals operator on records is evaluated correctly. >

<COMPILE>

<MODULE TTCN NegSem_070103_RelationalOperators_002 NegSem_070103_RelationalOperators_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_070103_RelationalOperators_002 {

type component GeneralComp {	    	    
}

 type set IntegerSet1 {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

 type set IntegerSet2 {
  integer a4 optional,
  integer a5 optional,
  integer a6 optional
 };

 type set LargeSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional,
  integer a4 optional,
  integer a5 optional,
  integer a6 optional
 };


testcase TC_NegSem_070103_RelationalOperators_002() runs on GeneralComp {
	const IntegerSet1 c_set1 := {a1:=0,a2:=omit,a3:=2};
	const IntegerSet2 c_set2 := {a4:=3,a5:=5,a6:=omit};
	const LargeSet   c_large := {a1:=0,a2:=omit,a3:=2,a4:=3,a5:=5,a6:=omit};

	if ( c_set1 & c_set2 == c_large ) {  //It is intentionally forbidden to concatenate record and set values
		setverdict(pass);
	}

}

control{
    execute(TC_NegSem_070103_RelationalOperators_002());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Left operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>
<RESULT COUNT 1>
error: Right operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070103_RelationalOperators_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070103_003 Ensure that the equals operator on records is evaluated correctly. >

<COMPILE>

<MODULE TTCN NegSem_070103_RelationalOperators_003 NegSem_070103_RelationalOperators_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass reject
 *****************************************************************/
//on hold till resolution of CR6707

module NegSem_070103_RelationalOperators_003 {

type component GeneralComp {	    	    
}

 type set IntegerSet1 {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

 type set IntegerSet2 {
  integer a4 optional,
  integer a5 optional,
  integer a6 optional
 };

 type set LargeSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional,
  integer a4 optional,
  integer a5 optional,
  integer a6 optional
 };


testcase TC_NegSem_070103_RelationalOperators_003() runs on GeneralComp {
	const IntegerSet1 c_set1 := {a1:=0,a2:=omit,a3:=2};
	const IntegerSet2 c_set2 := {a4:=3,a5:=5,a6:=omit};
	const LargeSet   c_large := {a1:=0,a2:=omit,a3:=2,a4:=3,a5:=5,a6:=6};

	if ( c_set1 & c_set2 != c_large ) {  //It is intentionally forbidden to concatenate record and set values
		setverdict(pass);
	} 
	
}

control{
    execute(TC_NegSem_070103_RelationalOperators_003());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Left operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>
<RESULT COUNT 1>
error: Right operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_070103_RelationalOperators_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 070103_004 Ensure that the equals operator on records is evaluated correctly. >

<COMPILE>

<MODULE TTCN NegSem_070103_RelationalOperators_004 NegSem_070103_RelationalOperators_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass reject
 *****************************************************************/
//on hold till resolution of CR6707

module NegSem_070103_RelationalOperators_004 {

type component GeneralComp {	    	    
}

 type set IntegerSet1 {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

 type set IntegerSet2 {
  integer a4 optional,
  integer a5 optional,
  integer a6 optional
 };

 type set LargeSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional,
  integer a4 optional,
  integer a5 optional
 };


testcase TC_NegSem_070103_RelationalOperators_004() runs on GeneralComp {
	const IntegerSet1 c_set1 := {a1:=0,a2:=omit,a3:=2};
	const IntegerSet2 c_set2 := {a4:=3,a5:=5,a6:=omit};
	const LargeSet   c_large := {a1:=0,a2:=omit,a3:=2,a4:=3,a5:=5};

	if ( c_set1 & c_set2 != c_large ) {  //It is intentionally forbidden to concatenate record and set values
		setverdict(pass);
	} 
	
}

control{
    execute(TC_NegSem_070103_RelationalOperators_004());
}

}
<END_MODULE>

<RESULT COUNT 1>
error: Left operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>
<RESULT COUNT 1>
error: Right operand of operation `&' should be a string, `record of' or `set of' value
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h2. 08_modules folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_002 Ensure that name handling of imported enumerations is properly handled  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_002 NegSem_08020301_GeneralFormatOfImport_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that name handling of imported enumerations is properly handled
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_08020301_GeneralFormatOfImport_002 {
	import from NegSem_08020301_GeneralFormatOfImport_002_import all;

	const EnumType2 c_enum := enumX;		
	
	modulepar EnumType px_ModulePar := NegSem_08020301_GeneralFormatOfImport_002.c_enum; //type mismatch
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_002_import NegSem_08020301_GeneralFormatOfImport_002_import.ttcn >
module NegSem_08020301_GeneralFormatOfImport_002_import {
	type enumerated EnumType {enumX, enumY, enumZ};
	type enumerated EnumType2 {enumX, enumY, enumZ};
	
}
<END_MODULE>

<RESULT COUNT 1>
error: Type mismatch: a value of type `@NegSem_08020301_GeneralFormatOfImport_002_import.EnumType' was expected instead of `@NegSem_08020301_GeneralFormatOfImport_002_import.EnumType2'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_003 Ensure that name handling of imported enumerations is properly handled  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_003 NegSem_08020301_GeneralFormatOfImport_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that transitive import rules are properly handled
 ** @verdict  pass reject
 *****************************************************************/


module NegSem_08020301_GeneralFormatOfImport_003 {

import from NegSem_08020301_GeneralFormatOfImport_003_import {
 const all;
};

type component GeneralComp {}

testcase TC_NegSem_08020301_GeneralFormatOfImport_003() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_NegSem_08020301_GeneralFormatOfImport_003());
}
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_003_import NegSem_08020301_GeneralFormatOfImport_003_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_003_import {
	public import from NegSem_08020301_GeneralFormatOfImport_003_import_2 all;
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_003_import_2 NegSem_08020301_GeneralFormatOfImport_003_import_2.ttcn >

module NegSem_08020301_GeneralFormatOfImport_003_import_2 {
	const integer c_myconst := 43532;
}
<END_MODULE>

<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_004 Ensure that transitive import rules are properly handled  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_004 NegSem_08020301_GeneralFormatOfImport_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that transitive import rules are properly handled
 ** @verdict  pass reject
 *****************************************************************/


module NegSem_08020301_GeneralFormatOfImport_004 {

import from NegSem_08020301_GeneralFormatOfImport_004_import all;

type component GeneralComp {}

testcase TC_NegSem_08020301_GeneralFormatOfImport_004() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_NegSem_08020301_GeneralFormatOfImport_004());
}
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_004_import NegSem_08020301_GeneralFormatOfImport_004_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_004_import {
   import from NegSem_08020301_GeneralFormatOfImport_004_import_2 all;
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_004_import_2 NegSem_08020301_GeneralFormatOfImport_004_import_2.ttcn >

module NegSem_08020301_GeneralFormatOfImport_004_import_2 {
	const integer c_myconst := 43532;
}
<END_MODULE>

<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_005 Make sure that the identifier of the current module cannot be used for prefixing imported entities >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_005 NegSem_08020301_GeneralFormatOfImport_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that the identifier of the current module cannot be used for prefixing imported entities
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Name clashes shall be resolved using qualified name(s) for the imported definition(s), 
// i.e. prefixing the imported definition by the identifier of the module in which it has 
// been defined; the prefix and the identifier shall be separated by a dot (".").
// In cases where there are no ambiguities the prefixing need not (but may) be present 
// when the imported definitions are used.

module NegSem_08020301_GeneralFormatOfImport_005 {

import from NegSem_08020301_GeneralFormatOfImport_005_import all;

type component GeneralComp {}

testcase TC_NegSem_08020301_GeneralFormatOfImport_005() runs on GeneralComp {	
	log(NegSem_08020301_GeneralFormatOfImport_005.c_test);
	setverdict(pass);
}
	
control{
    execute(TC_NegSem_08020301_GeneralFormatOfImport_005());
}
}

<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_005_import NegSem_08020301_GeneralFormatOfImport_005_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_005_import {
	const integer c_test := 5;
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no definition with name `c_test' in module `NegSem_08020301_GeneralFormatOfImport_005'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_006 Ensure that the only top-level visible definitions of a module may be imported.  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_006 NegSem_08020301_GeneralFormatOfImport_006.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that the only top-level visible definitions of a module may be imported.
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Restriction b:
// Only top-level visible definitions of a module may be imported. Definitions which 
// are top-level but invisible to the importing module or which occur at a lower scope 
// (e.g. local constants defined in a function) shall not be imported.

module NegSem_08020301_GeneralFormatOfImport_006 {
import from NegSem_08020301_GeneralFormatOfImport_006_import { const c_test };

type component GeneralComp {}

testcase TC_NegSem_08020301_GeneralFormatOfImport_006() runs on GeneralComp {		
	log(c_test);
	setverdict(pass);
}
	
control{
    execute(TC_NegSem_08020301_GeneralFormatOfImport_006());
}
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_006_import NegSem_08020301_GeneralFormatOfImport_006_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_006_import {
	control {
		const integer c_test := 5;
	}
}

<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_test'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_007 Verify that information about message types is imported together with port type  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_007 NegSem_08020301_GeneralFormatOfImport_007.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that information about message types is imported together with port type
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// User defined type, port type

module NegSem_08020301_GeneralFormatOfImport_007 {
import from NegSem_08020301_GeneralFormatOfImport_007_import { type P };

type component GeneralComp {
	port P p1;
} with {extension "internal"}

testcase TC_NegSem_08020301_GeneralFormatOfImport_007() runs on GeneralComp {		
	// Since the type of the sent message is not compatible with the allowed types of the imported
	// port type, a type compatibility error shall be generated. This proves that the type information
	// has been properly imported.
	p1.send(charstring:"abc");
	setverdict(pass);
}
	
control{
    execute(TC_NegSem_08020301_GeneralFormatOfImport_007());
}
}
<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_007_import NegSem_08020301_GeneralFormatOfImport_007_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_007_import {
	type port P message {
		inout integer;
	}
}

<END_MODULE>


<RESULT COUNT 1>
error: Incompatible explicit type specification: `integer' was expected instead of `charstring'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020301_GeneralFormatOfImport_038 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_038 Verify that definition from inside an imported function cannot be referenced  >

<COMPILE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_038 NegSem_08020301_GeneralFormatOfImport_038.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that definition from inside an imported function cannot be referenced
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Restriction f:
// When importing a function, altstep or test case the corresponding behaviour 
// specifications and all definitions used inside the behaviour specifications 
// remain invisible for the importing module.

module NegSem_08020301_GeneralFormatOfImport_038 {
	import from NegSem_08020301_GeneralFormatOfImport_038_import { function f_test };
	// c_test should be undefined, because it is invisible for the importing module
	const integer c_test2 := c_test;
}

<END_MODULE>

<MODULE TTCN NegSem_08020301_GeneralFormatOfImport_038_import NegSem_08020301_GeneralFormatOfImport_038_import.ttcn >

module NegSem_08020301_GeneralFormatOfImport_038_import {
	function f_test() {
		const integer c_test := 1;
	}
}

<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_test'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_08020301_GeneralFormatOfImport_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_001 Ensure that import statement cannot be used in test case blocks  >

<COMPILE>

<MODULE TTCN NegSyn_08020301_GeneralFormatOfImport_001 NegSyn_08020301_GeneralFormatOfImport_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that import statement cannot be used in test case blocks
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Restriction a:
// An import statement shall only be used in the module definitions part and not be used 
// within a control part, function definition, and alike.

module NegSyn_08020301_GeneralFormatOfImport_001 {

	type component GeneralComp {}

	testcase TC_NegSyn_08020301_GeneralFormatOfImport_001() runs on GeneralComp {	
		import from NegSyn_08020301_GeneralFormatOfImport_001_import all;
		log(c_test);
		setverdict(pass);
	}
	
	control{
		execute(TC_NegSyn_08020301_GeneralFormatOfImport_001());
	}
}

<END_MODULE>

<MODULE TTCN NegSyn_08020301_GeneralFormatOfImport_001_import NegSyn_08020301_GeneralFormatOfImport_001_import.ttcn >

module NegSyn_08020301_GeneralFormatOfImport_001_import {
	const integer c_test := 5;
}
<END_MODULE>


<RESULT COUNT 1>
error: at or before token `import': syntax error, unexpected ImportKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_08020301_GeneralFormatOfImport_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020301_002 Ensure that import statement cannot be used in module control part  >

<COMPILE>

<MODULE TTCN NegSyn_08020301_GeneralFormatOfImport_002 NegSyn_08020301_GeneralFormatOfImport_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that import statement cannot be used in module control part
 ** @verdict  pass reject
 *****************************************************************/

// The following requirements are tested:
// Restriction a:
// An import statement shall only be used in the module definitions part and not be used 
// within a control part, function definition, and alike.

module NegSyn_08020301_GeneralFormatOfImport_002 {

	type component GeneralComp {}

	testcase TC_NegSyn_08020301_GeneralFormatOfImport_002() runs on GeneralComp {			
		setverdict(pass);
	}
	
	control{
		import from NegSyn_08020301_GeneralFormatOfImport_002_import all;
		log(c_test);
		execute(TC_NegSyn_08020301_GeneralFormatOfImport_002());
	}
	
}
<END_MODULE>

<MODULE TTCN NegSyn_08020301_GeneralFormatOfImport_002_import NegSyn_08020301_GeneralFormatOfImport_002_import.ttcn >

module NegSyn_08020301_GeneralFormatOfImport_002_import {
	const integer c_test := 5;
}
<END_MODULE>


<RESULT COUNT 1>
error: at or before token `import': syntax error, unexpected ImportKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020307_001 Ensure that the import of import statements works for import all.  >

<COMPILE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001 NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.7, Ensure that the import of import statements works for import all.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001 {

	import from NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA {
		import all;
	};

	type component GeneralComp {}

	testcase TC_NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001() runs on GeneralComp {
		if (c_myconst == 43532) { // c_myconst shall not be accessible as the import in the importA module is private.
		    setverdict(fail);
		} else {
		    setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA.ttcn >

module NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA {
    private import from NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB all;
}

<END_MODULE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB.ttcn >

module NegSem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB {
    const integer c_myconst := 43532;
}

<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 08020307_002 Ensure that the import of import statements works for import all.  >

<COMPILE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002 NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.3.7, Ensure that the import of import statements works for import all.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002 {

	import from Sem_08020307_ImportingOfImportStatementsFromT3Modules_002_importA {
		import all;
	};

	type component GeneralComp {}

	testcase TC_NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002() runs on GeneralComp {
		if (c_myconst == 43532) { // c_myconst shall not be accessible as the import in the importA module is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002());
	}
}

<END_MODULE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importA NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importA.ttcn >

module Sem_08020307_ImportingOfImportStatementsFromT3Modules_002_importA {
    // imports are private by default
	import from NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importB all;
}

<END_MODULE>

<MODULE TTCN NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importB NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importB.ttcn >

module NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importB {
	const integer c_myconst := 43532;
}

<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080204_DefinitionOfFriendModules_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080204_001 Ensure that the import of import statements works for import all.  >

<COMPILE>

<MODULE TTCN NegSem_080204_DefinitionOfFriendModules_001 NegSem_080204_DefinitionOfFriendModules_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.4, Ensure that friend visibility works for a sample constant.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080204_DefinitionOfFriendModules_001 {

	import from NegSem_080204_DefinitionOfFriendModules_001_import all;

	type component GeneralComp {}

	testcase TC_NegSem_080204_DefinitionOfFriendModules_001() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible. A friend module statement is missing in NegSem_080204_DefinitionOfFriendModules_001_import. 
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080204_DefinitionOfFriendModules_001());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_080204_DefinitionOfFriendModules_001_import NegSem_080204_DefinitionOfFriendModules_001_import.ttcn >

module NegSem_080204_DefinitionOfFriendModules_001_import {
	friend const integer c_myconst := 32532;
}

<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080204_DefinitionOfFriendModules_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080204_002 Ensure that private definitions are not made visible by friend declarations (for a constant sample definition). >

<COMPILE>

<MODULE TTCN NegSem_080204_DefinitionOfFriendModules_002 NegSem_080204_DefinitionOfFriendModules_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.4, Ensure that private definitions are not made visible by friend declarations (for a constant sample definition).
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080204_DefinitionOfFriendModules_002 {

	import from NegSem_080204_DefinitionOfFriendModules_002_import all;

	type component GeneralComp {}

	testcase TC_NegSem_080204_DefinitionOfFriendModules_002() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible. The definition is private even though the module is a friend. 
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080204_DefinitionOfFriendModules_002());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_080204_DefinitionOfFriendModules_002_import NegSem_080204_DefinitionOfFriendModules_002_import.ttcn >

module NegSem_080204_DefinitionOfFriendModules_002_import {
	friend module NegSem_080204_DefinitionOfFriendModules_001;

	private const integer c_myconst := 32532;
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080205_VisibilityOfDefinitions_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080205_001 Ensure that private definition (in this case a sample constant) is not visible using a normal import. >

<COMPILE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_001 NegSem_080205_VisibilityOfDefinitions_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that private definition (in this case a sample constant) is not visible using a normal import.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080205_VisibilityOfDefinitions_001 {

	import from NegSem_080205_VisibilityOfDefinitions_001_import all;

	type component GeneralComp {}

	testcase TC_NegSem_080205_VisibilityOfDefinitions_001() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible on import as the definition is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080205_VisibilityOfDefinitions_001());
	}
}

<END_MODULE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_001_import NegSem_080205_VisibilityOfDefinitions_001_import.ttcn >

module NegSem_080205_VisibilityOfDefinitions_001_import {
	private const integer c_myconst := 32532;
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080205_VisibilityOfDefinitions_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080205_002 Ensure that private definition (in this case a sample constant) is not visible using an import of a friend module. >

<COMPILE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_002 NegSem_080205_VisibilityOfDefinitions_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that private definition (in this case a sample constant) is not visible using an import of a friend module.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080205_VisibilityOfDefinitions_002 {

	import from NegSem_080205_VisibilityOfDefinitions_002_import all;

	type component GeneralComp {}

	testcase TC_NegSem_080205_VisibilityOfDefinitions_002() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible on import as the definition is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080205_VisibilityOfDefinitions_002());
	}
}


<END_MODULE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_002_import NegSem_080205_VisibilityOfDefinitions_002_import.ttcn >

module NegSem_080205_VisibilityOfDefinitions_002_import {
	friend module NegSem_080205_VisibilityOfDefinitions_002;

	private const integer c_myconst := 32532;
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080205_VisibilityOfDefinitions_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080205_003 Ensure that friend definition (in this case a sample constant) is not visible using a group import of a non-friend module. >

<COMPILE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_003 NegSem_080205_VisibilityOfDefinitions_003.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that friend definition (in this case a sample constant) is not visible using a group import of a non-friend module.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080205_VisibilityOfDefinitions_003 {

	import from NegSem_080205_VisibilityOfDefinitions_003_import {
		group CONST_GROUP;
	}

	type component GeneralComp {}

	testcase TC_NegSem_080205_VisibilityOfDefinitions_003() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible on import as the definition is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080205_VisibilityOfDefinitions_003());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_003_import NegSem_080205_VisibilityOfDefinitions_003_import.ttcn >

module NegSem_080205_VisibilityOfDefinitions_003_import {
	group CONST_GROUP {
		friend const integer c_myconst := 32532;
	}
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080205_VisibilityOfDefinitions_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080205_004 Ensure that friend definition (in this case a sample constant) is not visible using a group import of a non-friend module. >

<COMPILE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_004 NegSem_080205_VisibilityOfDefinitions_004.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that private definition (in this case a sample constant) is not visible using a group import of a non-friend module.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080205_VisibilityOfDefinitions_004 {

	import from NegSem_080205_VisibilityOfDefinitions_004_import {
		group CONST_GROUP;
	}

	type component GeneralComp {}

	testcase TC_NegSem_080205_VisibilityOfDefinitions_004() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible on import as the definition is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080205_VisibilityOfDefinitions_004());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_004_import NegSem_080205_VisibilityOfDefinitions_004_import.ttcn >

module NegSem_080205_VisibilityOfDefinitions_004_import {
	group CONST_GROUP {
		private const integer c_myconst := 32532;
	}
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_080205_VisibilityOfDefinitions_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 080205_005 Ensure that private definition (in this case a sample constant) is not visible using a group import of a friend module. >

<COMPILE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_005 NegSem_080205_VisibilityOfDefinitions_005.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that private definition (in this case a sample constant) is not visible using a group import of a friend module.
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_080205_VisibilityOfDefinitions_005 {

	import from NegSem_080205_VisibilityOfDefinitions_005_import {
		group CONST_GROUP;
	}

	type component GeneralComp {}

	testcase TC_NegSem_080205_VisibilityOfDefinitions_005() runs on GeneralComp {
		if (c_myconst == 32532) { // c_myconst shall not be visible on import as the definition is private.
			setverdict(fail);
		} else {
			setverdict(pass);
		}
	}

	control{
		execute(TC_NegSem_080205_VisibilityOfDefinitions_005());
	}
}
<END_MODULE>

<MODULE TTCN NegSem_080205_VisibilityOfDefinitions_005_import NegSem_080205_VisibilityOfDefinitions_005_import.ttcn >

module NegSem_080205_VisibilityOfDefinitions_005_import {
	friend module NegSem_080205_VisibilityOfDefinitions_005;

	group CONST_GROUP {
		private const integer c_myconst := 32532;
	}
}
<END_MODULE>


<RESULT COUNT 1>
error: There is no local or imported definition with name `c_myconst'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_0803_ModuleControlPart_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0803_001 Ensure that there is not more than one control part. >

<COMPILE>

<MODULE TTCN NegSyn_0803_ModuleControlPart_001 NegSyn_0803_ModuleControlPart_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:8.3, Ensure that there is not more than one control part.
 ** @verdict  pass reject
 *****************************************************************/

module NegSyn_0803_ModuleControlPart_001 {

	control {
		var integer count := 0;	
	}

	control {
		var integer count := 0;	
	}

}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `control': syntax error, unexpected ControlKeyword, expecting '\{' or '\}'
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h2. 09_test_configurations folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_0901_Communication_ports_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_002 Ensure that it is not possible to connect a mapped port  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_0901_Communication_ports_002 NegSem_0901_Communication_ports_002.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that it is not possible to connect a mapped port
 ** @verdict  pass reject
 ***************************************************/

/*NOTE: see Figure 7(f): connection of two TSI ports is not allowed
 * */

module NegSem_0901_Communication_ports_002{ 


    type port loopbackPort message { 
	  inout integer
	} with {extension "internal"}

	type component GeneralComp {	    	    
		  port loopbackPort p1;
		 
	}	

	type component System {	    	    
		  port loopbackPort p1;
		 
	}	

	testcase TC_NegSem_0901_Communication_ports_002() runs on GeneralComp system System {
		
		var GeneralComp v_ptc := GeneralComp.create;
		map(self:p1, system:p1);		
		connect(self:p1, v_ptc:p1); // error: mtc.p1 is already mapped to SystemComp.p1
		setverdict(pass);
	 
	}

	control{
		execute(TC_NegSem_0901_Communication_ports_002());
	}

}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Connect operation cannot be performed on a mapped port \(p1\)
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0901_Communication_ports_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_004 Verify that it is not possible to map a connected port  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_0901_Communication_ports_004 NegSem_0901_Communication_ports_004.ttcn >
/******************************************************************************
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that it is not possible to map a connected port
 ** @verdict  pass reject
 ***************************************************/

/*NOTE: see Figure 7(b): GeneralComp port p1 is mapped to a TSI port P1.
 * Therefore mapping GeneralComp port p2 with TSI port P1 gives an error.
 * */



module NegSem_0901_Communication_ports_004 {
  
    type port MyPort message {
        inout integer
    } with {extension "internal"}

    type component GeneralComp
    {
        port MyPort p1;
        port MyPort p2;
    }
    
    type component SystemComp
    {
        port MyPort p1;
    }
	
    testcase TC_NegSem_0901_Communication_ports_004() runs on GeneralComp system SystemComp {
		
	//create a test component        
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		map(self:p1, system:p1); // error: mtc.p1 is already connected to v_ptc.p1
		setverdict(pass);
    }
	
    control{
        execute(TC_NegSem_0901_Communication_ports_004());
    }
}

<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Map operation is not allowed on a connected port \(p1\).
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0901_Communication_ports_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_007 Verify that a two TSI port cannot be connected  >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_0901_Communication_ports_007 NegSem_0901_Communication_ports_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a two TSI port cannot be connected
 ** @verdict  pass reject
 ***************************************************/

/*NOTE: see Figure 7(f): Two TSI port cannot be connected
 * */

module NegSem_0901_Communication_ports_007 {
  
    type port P message {
        inout integer
    } with {extension "internal"}

    type component GeneralComp
    {
        port P p1, p2;
    }
	
    testcase TC_NegSem_0901_Communication_ports_007() runs on GeneralComp system GeneralComp {
		var GeneralComp s := system;
        map(s:p2, system:p1); // error: p1 and p2 cannot be connected
		
        setverdict(pass);
    }
	
    control{
        execute(TC_NegSem_0901_Communication_ports_007());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Both arguments of map operation refer to system ports.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0901_Communication_ports_009 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_009 Verify that connections within the test system interface are not allowed  >

<COMPILE>

<MODULE TTCN NegSem_0901_Communication_ports_009 NegSem_0901_Communication_ports_009.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that connections within the test system interface are not allowed
 ** @verdict  pass reject
 ***************************************************/

// The following requirements are tested:
// Restriction a): Connections within the test system interface are not allowed.

module NegSem_0901_Communication_ports_009 {
  
    type port P message {
        inout integer
    } with {extension "internal"}

    type component GeneralComp
    {
        port P p1, p2;
    }
	
    testcase TC_NegSem_0901_Communication_ports_009() runs on GeneralComp system GeneralComp {
		map(system:p1, system:p1); // mapping system port to itself: error expected
		setverdict(pass);
    }
	
    control{
        execute(TC_NegSem_0901_Communication_ports_009());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Both endpoints of the mapping are system ports
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_0901_Communication_ports_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_001 Verify that a two TSI port cannot be connected  >

<COMPILE>

<MODULE TTCN NegSyn_0901_Communication_ports_001 NegSyn_0901_Communication_ports_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a two TSI port cannot be connected
 ** @verdict  pass reject, noexecution
 ***************************************************/

/*NOTE: see Figure 7(f): Two TSI port cannot be connected
 * */

module NegSyn_0901_Communication_ports_001 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
	
        type component General_System_Comp
    {
        port P p_system_1, p_system_2;
    }
    
    testcase TC_NegSyn_0901_Communication_ports_001() runs on GeneralComp system General_System_Comp {
		
        connect(system:p_system_1, system:p_system_2); // error: p_system_1 and p_system_2 cannot be connected
		
        setverdict(pass);
    }
	
    control{
        execute(TC_NegSyn_0901_Communication_ports_001());
    }
}
<END_MODULE>

<RESULT COUNT 2>
error: The `system' component reference shall not be used in `connect' operation
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_0902_Communication_ports_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 0901_003 Ensure that the two system interf. port cannot connect   >

<COMPILE>

<MODULE TTCN NegSem_0902_Communication_ports_003 NegSem_0902_Communication_ports_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the two system interf. port cannot connect 
 ** @verdict  pass reject
 ***************************************************/

//Two system interface ports are not allowed to connect
module NegSem_0902_Communication_ports_003{ 

    type port loopbackPort message {
	  	inout integer
	} with {extension "internal"}

	type component MyTestSystemInterface
	{
 		port loopbackPort messagePortA,messagePortB
	}
	// MyTestSystemInterface is the test system interface
	
	testcase TC_NegSem_0902_Communication_ports_003() runs on MyTestSystemInterface {
		// establishing the port connections
		map(system:messagePortA, system:messagePortB);  // not allowed 

		setverdict(fail);

	}
	control{
		execute(TC_NegSem_0902_Communication_ports_003());
	}
}
<END_MODULE>

<RESULT COUNT 1>
error: Both endpoints of the mapping are system ports
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h2. 10_constants folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_10_Constants_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 10_001 Assign rnd to constant used in type, not allowed since constant expressions used in types have to be known at compile-time.  >

<COMPILE>

<MODULE TTCN NegSem_10_Constants_001 NegSem_10_Constants_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:10, Assign rnd to constant used in type, not allowed since constant expressions used in types have to be known at compile-time.
 ** @verdict  pass reject
 ***************************************************/
module NegSem_10_Constants_001 {

    const float c_i := rnd(314E-2); // not allowed by standard
    type float MyFloat (c_i);
    
    type component GeneralComp {}
    
    testcase TC_NegSem_10_Constants_001() runs on GeneralComp {
        var MyFloat v_f := c_i;
        log(v_f);
        setverdict(pass);
    }
    
    control{
        execute(TC_NegSem_10_Constants_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: An evaluable constant value was expected instead of operation `rnd \(seed\)'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_10_Constants_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 10_002 A value is assigned only once to a constant.  >

<COMPILE>

<MODULE TTCN NegSem_10_Constants_002 NegSem_10_Constants_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:10, A value is assigned only once to a constant
 ** @verdict  pass reject
 ***************************************************/
module NegSem_10_Constants_002 {

    const float c_i := 3.14;

    
    type component GeneralComp {}
    
    testcase TC_NegSem_10_Constants_002() runs on GeneralComp {
        c_i := 3.15; //error because value is assigned only once to the constant
    }
    
    control{
        execute(TC_NegSem_10_Constants_002());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Reference to a variable or template variable was expected instead of constant `@NegSem_10_Constants_002.c_i'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_10_Constants_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 10_003 Constant shall not be of port type  >

<COMPILE>

<MODULE TTCN NegSem_10_Constants_003 NegSem_10_Constants_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:10, Constant shall not be of port type
 ** @verdict  pass reject
 ***************************************************/
module NegSem_10_Constants_003 {

    //only for negSyn constant shall not be of port  type
    type port MyMessagePortType message 
	{
		inout 	integer
	} with {extension "internal"}
    
    
    type component GeneralComp {
    }
    
    testcase TC_NegSem_10_Constants_003() runs on GeneralComp {
        const MyMessagePortType c_port:= 5;//error -  constant shall not be of port type
    }//end testcase
    
    control{
        execute(TC_NegSem_10_Constants_003());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Constant cannot be defined for port type `@NegSem_10_Constants_003.MyMessagePortType'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 11_variables folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_1101_ValueVars_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1101_001 Variables should be assigned only by values  >

<COMPILE>

<MODULE TTCN NegSem_1101_ValueVars_001 NegSem_1101_ValueVars_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:11.1, Variables should be assigned only by values
 ** @verdict  pass reject
 ***************************************************/
module NegSem_1101_ValueVars_001 {
    type component GeneralComp {}
    
	testcase TC_NegSem_1101_ValueVars_001() runs on GeneralComp {
  		var integer v_i := ?; // ? is not a value
        setverdict(pass);
	}
    
    control {
        execute(TC_NegSem_1101_ValueVars_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: any value is not allowed in this context
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_1101_ValueVars_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1101_001 Define variables in module scope >

<COMPILE>

<MODULE TTCN NegSyn_1101_ValueVars_001 NegSyn_1101_ValueVars_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:11.1, Define variables in module scope
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_1101_ValueVars_001 {
    var integer v_i1 := 5;
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `var': syntax error, unexpected VarKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_1102_TemplateVars_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1102_001 Template variables should be assigned with unitialized variables >

<COMPILE>
<EXECUTE_PARALLEL>

<MODULE TTCN NegSem_1102_TemplateVars_001 NegSem_1102_TemplateVars_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:11.2, Template variables should be assigned with unitialized variables
 ** @verdict  pass reject
 ***************************************************/
module NegSem_1102_TemplateVars_001 {
    type component GeneralComp {}
    
	testcase TC_NegSem_1102_TemplateVars_001() runs on GeneralComp {
  		var template integer v_i1;
        var template integer v_i2 := v_i1; // v_i1 is not initialized
  		
        setverdict(pass);
	}
    
    control {
        execute(TC_NegSem_1102_TemplateVars_001());
    }
}
<END_MODULE>

<RESULT COUNT 1>
Dynamic test case error: Copying an uninitialized/unsupported integer template.
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_1102_TemplateVars_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1102_001 Define template variables in module scope >

<COMPILE>

<MODULE TTCN NegSyn_1102_TemplateVars_001 NegSyn_1102_TemplateVars_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:11.2, Define template variables in module scope
 ** @verdict  pass reject
 ***************************************************/
module NegSyn_1102_TemplateVars_001 {
    var template integer v_i1 := 5;
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `var': syntax error, unexpected VarKeyword
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 12_timers folder
.*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_001 Ensure timer can not be initialized with negative duration >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_001 NegSem_12_toplevel_timer_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can not be initialized with negative duration
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer value is non-neg float
 **/


module NegSem_12_toplevel_timer_001 {
    type component TComp{
        timer t_timer := -1.0; // not allowed
    }
    testcase TC_NegSem_12_toplevel_timer_001() runs on TComp{
        t_timer.start;
    }
    control{
        
            execute(TC_NegSem_12_toplevel_timer_001())
       
        
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative float value was expected as timer duration instead of `-1.0e0'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_002 Ensure timer in array can not be initialized with negative duration >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_002 NegSem_12_toplevel_timer_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer in array can not be initialized with negative duration
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer value is non-neg float
 **/


module NegSem_12_toplevel_timer_002 {

    type component TComp{
        timer t_timer[2] := {-1.0, 1.0}; 
    }

    testcase TC_NegSem_12_toplevel_timer_002() runs on TComp{
        t_timer[0].start;
    }

    control{  
        execute(TC_NegSem_12_toplevel_timer_002());  
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A non-negative float value was expected as timer duration instead of `-1.0e0'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_003 Ensure uninitialized timer can't be started >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_003 NegSem_12_toplevel_timer_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure uninitialized timer can't be started
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSem_12_toplevel_timer_003 {

    type component TComp{
        timer t_timer; 
    }

    testcase TC_NegSem_12_toplevel_timer_003() runs on TComp{
        t_timer.start;
    }

    control{
	 	execute(TC_NegSem_12_toplevel_timer_003())  
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Missing duration: timer `@NegSem_12_toplevel_timer_003.TComp.t_timer' does not have default duration
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_004 Ensure uninitialized timer in array can't be started >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_004 NegSem_12_toplevel_timer_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure uninitialized timer in array can't be started
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSem_12_toplevel_timer_004 {
    type component TComp{
        timer t_timer[2] := {-, 1.0}; 
    }

    testcase TC_NegSem_12_toplevel_timer_004() runs on TComp{
        t_timer[0].start;
    }

    control{
        execute(TC_NegSem_12_toplevel_timer_004()); 
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Missing duration: timer `@NegSem_12_toplevel_timer_004.TComp.t_timer' does not have default duration
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_005 Ensure uninitialized timer in array can't be started >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_005 NegSem_12_toplevel_timer_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure uninitialized timer in array can't be started
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSem_12_toplevel_timer_005 {

    type component TComp{
        timer t_timer[2]; 
    }

    testcase TC_NegSem_12_toplevel_timer_005() runs on TComp{
        t_timer[0].start;
    }

    control{
        execute(TC_NegSem_12_toplevel_timer_005())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Missing duration: timer `@NegSem_12_toplevel_timer_005.TComp.t_timer' does not have default duration
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_006 Ensure timer declaration syntax - reject single timer instance initialized with array >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_006 NegSem_12_toplevel_timer_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax - reject single timer instance initialized with array
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSem_12_toplevel_timer_006 {

    type component TComp{
        timer t_timer := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSem_12_toplevel_timer_006() runs on TComp{
        t_timer[0].start;
    }

    control{
        execute(TC_NegSem_12_toplevel_timer_006())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type float was expected
<END_RESULT>
<RESULT COUNT 1>
error: Reference to single timer `@NegSem_12_toplevel_timer_006.TComp.t_timer' cannot have field or array sub-references
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_007 Ensure timer declaration syntax -- reject array initialization with wrong number of initializers >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_007 NegSem_12_toplevel_timer_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax -- reject array initialization with wrong number of initializers
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSem_12_toplevel_timer_007 {
    type component TComp{
        timer t_timer[4] := {1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSem_12_toplevel_timer_007() runs on TComp{
        t_timer[0].start;
    }

    control{
        execute(TC_NegSem_12_toplevel_timer_007())  
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: Too few elements in the default duration of timer array: 4 was expected instead of 3
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_12_toplevel_timer_008 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_008 Ensure timer declaration syntax -- reject array of timers initizlized with a single float value >

<COMPILE>

<MODULE TTCN NegSem_12_toplevel_timer_008 NegSem_12_toplevel_timer_008.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax -- reject array of timers initizlized with a single float value
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_008 {

    type component TComp{
        timer t_timer[4] := 1.0; 
    }

    testcase TC_NegSyn_12_toplevel_timer_008() runs on TComp{
        t_timer[0].start;
    }

    control{  
        execute(TC_NegSyn_12_toplevel_timer_008())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: An array value \(with 4 elements\) was expected as default duration of timer array
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_001 Ensure timer can`t be used in module control parts when declared in components >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_001 NegSyn_12_toplevel_timer_001.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can`t be used in module control parts when declared in components
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timers can be declared in component and used in test cases, functions, altsteps on this component
 **/


module NegSyn_12_toplevel_timer_001 {

    type component TComp{
        timer t_timer:= 1.0; 
    }

    testcase TC_NegSyn_12_toplevel_timer_001(integer f) runs on TComp{
        if (f==0){
        	setverdict(fail);
        }
        else{
            setverdict(pass);
        }
    }

    control{
        
        t_timer.start;
        if (t_timer.running){
            execute(TC_NegSyn_12_toplevel_timer_001(0))
        }
        else{
            execute(TC_NegSyn_12_toplevel_timer_001(1))
        }
        
    }
}
<END_MODULE>

<RESULT COUNT 2>
error: There is no local or imported definition with name `t_timer'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_002 Ensure timer declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_002 NegSyn_12_toplevel_timer_002.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_002 {

    type component TComp{
        timer := 10.0; 
    }

    testcase TC_NegSyn_12_toplevel_timer_002() runs on TComp{
        
    }
    control{
        execute(TC_NegSyn_12_toplevel_timer_002())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `:=': syntax error, unexpected :=, expecting Identifier
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_003 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_003 Ensure timer declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_003 NegSyn_12_toplevel_timer_003.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_003 {

    type component TComp{
        timer t_timer :=; 
    }

    testcase TC_NegSyn_12_toplevel_timer_003() runs on TComp{
        
    }
    control{
    	execute(TC_NegSyn_12_toplevel_timer_003())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `;': syntax error, unexpected ';'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_004 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_004 Ensure timer declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_004 NegSyn_12_toplevel_timer_004.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:04, Ensure timer declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_04_toplevel_timer_004 {

    type component TComp{
        timer t_timer 0.0; 
    }

    testcase TC_NegSyn_04_toplevel_timer_004() runs on TComp{
        
    }

    control{
	 	execute(TC_NegSyn_04_toplevel_timer_004())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `0.0': syntax error, unexpected FloatValue
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_005 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_005 Ensure timer declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_005 NegSyn_12_toplevel_timer_005.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_005 {

    type component TComp{
        timer t_timer := 1; 
    }

    testcase TC_NegSyn_12_toplevel_timer_005() runs on TComp{
        
    }

    control{
		execute(TC_NegSyn_12_toplevel_timer_005()) 
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: A value or expression of type float was expected
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_006 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_006 Ensure timer array declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_006 NegSyn_12_toplevel_timer_006.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer array declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_006 {

    type component TComp{
        timer t_timer[5] := 1.0, 1.0, 1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_12_toplevel_timer_006() runs on TComp{
        
    }

    control{
		execute(TC_NegSyn_12_toplevel_timer_006())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `1.0': syntax error, unexpected FloatValue, expecting Identifier
<END_RESULT>

<END_TC>
:exmp


*---------------------------------------------------------------------*
:h3. NegSyn_12_toplevel_timer_007 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 12_007 Ensure timer array declaration syntax >

<COMPILE>

<MODULE TTCN NegSyn_12_toplevel_timer_007 NegSyn_12_toplevel_timer_007.ttcn >
/***************************************************
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer array declaration syntax
 ** @verdict  pass reject
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module NegSyn_12_toplevel_timer_007 {

    type component TComp{
        timer t_timer[5] := {1.0 1.0, 1.0, 1.0, 1.0}; 
    }

    testcase TC_NegSyn_12_toplevel_timer_007() runs on TComp{
        
    }

    control{
		execute(TC_NegSyn_12_toplevel_timer_007())
    }
}
<END_MODULE>

<RESULT COUNT 1>
error: at or before token `1.0': syntax error, unexpected FloatValue, expecting ',' or '\}'
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h2. 14_procedure_signatures folder
.*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
:h3. NegSem_1400_procedure_signatures_001 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1400_001 Ensure that nonblocking signature contains in parameter >

<COMPILE>

<MODULE TTCN NegSem_1400_procedure_signatures_001 NegSem_1400_procedure_signatures_001.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that nonblocking signature contains in parameter
 ** @verdict  pass reject
 *****************************************************************/

module NegSem_1400_procedure_signatures_001 {

    signature p_procedure_signatures_001(out integer p_par1) noblock; // noblock keyword, shall only have in parameters

    template p_procedure_signatures_001 s_returnTemplate := {
        p_par1 := -  }

    type port remotePort procedure {
        inout p_procedure_signatures_001;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp { }
	
	testcase TC_NegSem_1400_procedure_signatures_001() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
      
		// map the PTCs to the system port
       connect(server:PCO, client:PCO);

 
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO, client:PCO);
   }

    control{
        execute(TC_NegSem_1400_procedure_signatures_001());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: A non-blocking signature cannot have `out' parameter
<END_RESULT>

<END_TC>
:exmp

*---------------------------------------------------------------------*
:h3. NegSem_1400_procedure_signatures_002 negative test
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - 1400_002 Ensure that blocking calls needs response or exception handling >

<COMPILE>

<MODULE TTCN NegSem_1400_procedure_signatures_002 NegSem_1400_procedure_signatures_002.ttcn >
/*****************************************************************
 ** @version  0.0.1
 ** @purpose  1:14, Ensure that blocking calls needs response or exception handling
 ** @verdict  pass reject
 *****************************************************************/
// Multiple calls requires response or exception handling if the signature is blocking

module NegSem_1400_procedure_signatures_002 {

   signature p_Sig1_001( in charstring key );  // noblock needed for multiple calls without response or exections

    type port remotePort procedure {
        inout  p_Sig1_001;
    } with {extension "internal"}

    type component GeneralComp {
        port remotePort PCO;
		var integer MyComp;
    }
	

    function f_Server() runs on GeneralComp {
	timer t_guard;
		
	const charstring key[3] := {"My String1", "hello", "Probe string"};
	
	t_guard.start( 5.0 );
		
	for ( var integer i := 0; i < 3; i := i + 1 ) {
		PCO.call( p_Sig1_001:{key[i]});}
	setverdict(pass);
		
		t_guard.timeout;
		setverdict(fail);
	}  
	
	function f_client() runs on GeneralComp {
	
	}
	
	testcase TC_NegSem_1400_procedure_signatures_002() runs on GeneralComp system GeneralComp {
      
	   	var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
	   	var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       
	
       	connect(server:PCO, client:PCO);

	    server.start(f_Server());
		client.start(f_client());

		alt {
           [] client.done {
               server.stop;
           }
       	}

       	alt {
           [] all component.done {}
       	}

       	disconnect(server:PCO, client:PCO);
   	}

    control{
        execute(TC_NegSem_1400_procedure_signatures_002());
    }

}
<END_MODULE>

<RESULT COUNT 1>
error: Response and exception handling part is missing from blocking call operation
<END_RESULT>

<END_TC>
:exmp

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.1/174 02-CRL 113 200/5 Uen
:nl.Statement of Compliance for TITAN project
:li D='[2]'.ETSI ES 201 873-1, v4.7.1 Mockup v1 (2015-06):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.
