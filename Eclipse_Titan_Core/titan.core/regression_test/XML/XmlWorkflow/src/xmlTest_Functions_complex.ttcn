/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Balasko, Jeno
 *   Delic, Adam
 *   Raduly, Csaba
 *   Szabados, Kristof
 *
 ******************************************************************************/
module xmlTest_Functions_complex
{

import from www_XmlTest_org_complex_simpleContent all;
import from www_XmlTest_org_complex_mixed all;
import from www_XmlTest_org_complex_choice all;
import from www_XmlTest_org_complex_all all;
import from www_XmlTest_org_complex_extension all;
import from www_XmlTest_org_complex_restriction all;
import from www_XmlTest_org_complex_include all;
import from www_XmlTest_org_complex_import all;
import from www_XmlTest_org_complex_any all;
//==============================================================================
//  External functions
//==============================================================================
external function f_enc_ComplexTypeWithSimpleContent1(in ComplexTypeWithSimpleContent1 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_ComplexTypeWithSimpleContent1(in octetstring stream, out ComplexTypeWithSimpleContent1 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_ComplexTypeWithSimpleContent2(in ComplexTypeWithSimpleContent2 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_ComplexTypeWithSimpleContent2(in octetstring stream, out ComplexTypeWithSimpleContent2 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_ComplexTypeWithMixed(in Salutation pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_ComplexTypeWithMixed(in octetstring stream, out Salutation pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//===ComplexTypeWithChoice:===
external function f_enc_Lesson(in Lesson pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_Lesson(in octetstring stream, out Lesson pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_MyLessonElement(in MyLessonElement pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_MyLessonElement(in octetstring stream, out MyLessonElement pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_Lesson2(in Lesson2 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_Lesson2(in octetstring stream, out Lesson2 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_Lesson3(in Lesson3 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_Lesson3(in octetstring stream, out Lesson3 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//===ComplexTypeWithAll:===
external function f_enc_MySubjects1(in MySubjects1 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_MySubjects1(in octetstring stream, out MySubjects1 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_MySubjects2(in MySubjects2 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_MySubjects2(in octetstring stream, out MySubjects2 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//=== complexExtension
external function f_enc_MySubjects3Extension(in MySubjects3Extension pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_MySubjects3Extension(in octetstring stream, out MySubjects3Extension pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//=== complexRestriction
external function f_enc_MySubjects4Restriction(in MySubjects4Restriction pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_MySubjects4Restriction(in octetstring stream, out MySubjects4Restriction pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//=== include, import ===
external function f_enc_PurchaseReportImport(in PurchaseReportImport pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_PurchaseReportImport(in octetstring stream, out PurchaseReportImport pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

//====Any===
external function f_enc_ElementContainingXhtml_1(in ElementContainingXhtml_1 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_ElementContainingXhtml_1(in octetstring stream, out ElementContainingXhtml_1 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_enc_ElementContainingXhtml_2(in ElementContainingXhtml_2 pdu, out octetstring stream)
with { extension "prototype(fast) encode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }

external function f_dec_ElementContainingXhtml_2(in octetstring stream, out ElementContainingXhtml_2 pdu) return integer
with { extension "prototype(backtrack) decode(XER:XER_EXTENDED) errorbehavior(ALL:WARNING)" }
//==============================================================================
//   Encoding decoding test
//==============================================================================

//============================================
//  f_encDecTest_ComplexTypeWithSimpleContent1
//============================================
function f_encDecTest_ComplexTypeWithSimpleContent1() {
  var ComplexTypeWithSimpleContent1 vl_pdu:= {
    idCard:="AU-V-123456",
    passportId:="PN-2009-11-13-HU",
    base:="Kiss Pissta"
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<ComplexTypeWithSimpleContent1 IdCard='AU-V-123456' PassportId='PN-2009-11-13-HU'>Kiss Pissta</ComplexTypeWithSimpleContent1>\n\n")
  ;

  var octetstring vl_stream:=''O;

  f_enc_ComplexTypeWithSimpleContent1(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ComplexTypeWithSimpleContent1(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("The decoded pdu is not the expected one:");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ComplexTypeWithSimpleContent1(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("The decoded pdu is not the expected one:");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }
  
}//f_


//============================================
//  f_encDecTest_ComplexTypeWithSimpleContent2
//============================================
function f_encDecTest_ComplexTypeWithSimpleContent2() {
  var ComplexTypeWithSimpleContent2 vl_pdu:= {
    idCard:="AU-V-123456",
    passportId:="PN-2009-11-13-HU",
    base:="Kiss"
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<ComplexTypeWithSimpleContent2 IdCard='AU-V-123456' PassportId='PN-2009-11-13-HU'>Kiss</ComplexTypeWithSimpleContent2>\n\n")
  ;

  var octetstring vl_stream:=''O;
  f_enc_ComplexTypeWithSimpleContent2(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ComplexTypeWithSimpleContent2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ComplexTypeWithSimpleContent2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs asn1-original value = NOT READY YET===");
  // NOT READY YET -
  // The problem is how to convert "ASN1 with XER instructons" into ttcn

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithSimpleContent2_neg
//============================================
//Wrong length at runtime
function f_encDecTest_ComplexTypeWithSimpleContent2_neg() {
  var ComplexTypeWithSimpleContent2 vl_pdu:= {
    idCard:="AU-V-123456",
    passportId:="PN-2009-11-13-HU",
    base:="Tooo"
  },vl_decodedPdu;

  vl_pdu.base:=vl_pdu.base&" Long";

   var octetstring vl_expectedEncodedPdu:=
    char2oct("<ComplexTypeWithSimpleContent2 IdCard='AU-V-123456' PassportId='PN-2009-11-13-HU'>Tooo Long</ComplexTypeWithSimpleContent2>\n\n")
  ;

  var octetstring vl_stream:=''O;
  f_enc_ComplexTypeWithSimpleContent2(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ComplexTypeWithSimpleContent2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ComplexTypeWithSimpleContent2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
    }
  }

  //log("===Checking value decoded from the expected value vs asn1-original value = NOT READY YET===");
  // NOT READY YET -
  // The problem is how to convert "ASN1 with XER instructons" into ttcn

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithMixed
//============================================
function f_encDecTest_ComplexTypeWithMixed() {
  var  Salutation vl_pdu:= {
    embed_values:={ "Dear Mr. ", "," },
    name:="Jones"
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<ns37:salutation xmlns:ns37='www.XmlTest.org/complex_mixed'>Dear Mr. <name>Jones</name>,</ns37:salutation>\n")

  var octetstring vl_stream:=''O;
  f_enc_ComplexTypeWithMixed(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ComplexTypeWithMixed(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ComplexTypeWithMixed(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithChoice_1
//============================================
function f_encDecTest_ComplexTypeWithChoice_1() {
  var  Lesson vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      english:="Advanced 3"
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson Starts='18:50:21.00'>\n\t<English>Advanced 3</English>\n</Lesson>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithChoice_2
//============================================
function f_encDecTest_ComplexTypeWithChoice_2() {
  var  Lesson vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      nature:={ physics:="Advanced 1" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson Starts='18:50:21.00'>\n\t<Physics>Advanced 1</Physics>\n</Lesson>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_


//============================================
//  f_encDecTest_ComplexTypeWithChoice_3
//============================================
function f_encDecTest_ComplexTypeWithChoice_3() {
  var  Lesson vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      lab:={ measurement:="gravity 2", evaluation:="gravity 2" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson Starts='18:50:21.00'>\n\t<Measurement>gravity 2</Measurement>\n\t<Evaluation>gravity 2</Evaluation>\n</Lesson>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithChoice_4
//============================================
function f_encDecTest_ComplexTypeWithChoice_4() {
  var  MyLessonElement vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      lab:={ measurement:="gravity 2", evaluation:="gravity 2" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<ns40:MyLessonElement xmlns:ns40='www.XmlTest.org/complex_choice' Starts='18:50:21.00'>\n\t<Measurement>gravity 2</Measurement>\n\t<Evaluation>gravity 2</Evaluation>\n</ns40:MyLessonElement>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_MyLessonElement(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_MyLessonElement(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_MyLessonElement(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_


//======


//============================================
//  f_encDecTest_ComplexTypeWithChoice_5
//============================================
function f_encDecTest_ComplexTypeWithChoice_5() {
  var  Lesson2 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      english:="Advanced 3"
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson2 Starts='18:50:21.00'>\n\t<English>Advanced 3</English>\n</Lesson2>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson2(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithChoice_6
//============================================
function f_encDecTest_ComplexTypeWithChoice_6() {
  var  Lesson2 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      choice:={ physics:="Advanced 1" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson2 Starts='18:50:21.00'>\n\t<Physics>Advanced 1</Physics>\n</Lesson2>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson2(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_


//============================================
//  f_encDecTest_ComplexTypeWithChoice_7
//============================================
function f_encDecTest_ComplexTypeWithChoice_7() {
  var  Lesson2 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      sequence:={ measurement:="gravity 2", evaluation:="gravity 2" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson2 Starts='18:50:21.00'>\n\t<Measurement>gravity 2</Measurement>\n\t<Evaluation>gravity 2</Evaluation>\n</Lesson2>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson2(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//==== Lesson 3 ====

//============================================
//  f_encDecTest_ComplexTypeWithChoice_8
//============================================
function f_encDecTest_ComplexTypeWithChoice_8() {
  var  Lesson3 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      english:="Advanced 3"
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson3 Starts='18:50:21.00'>\n\t<English>Advanced 3</English>\n</Lesson3>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson3(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson3(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson3(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithChoice_9
//============================================
function f_encDecTest_ComplexTypeWithChoice_9() {
  var  Lesson3 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={ 
      nature:= {
        choice:={ physics:="Advanced 1" }
      }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson3 Starts='18:50:21.00'>\n\t<Nature>\n\t\t<Physics>Advanced 1</Physics>\n\t</Nature>\n</Lesson3>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson3(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson3(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson3(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_


//============================================
//  f_encDecTest_ComplexTypeWithChoice_10
//============================================
function f_encDecTest_ComplexTypeWithChoice_10() {
  var  Lesson3 vl_pdu:= {
    starts:="18:50:21.00",
    choice:={
      lab:= { measurement:="gravity 2", evaluation:="gravity 2" }
    }
  },vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:=
    char2oct("<Lesson3 Starts='18:50:21.00'>\n\t<Lab>\n\t\t<Measurement>gravity 2</Measurement>\n\t\t<Evaluation>gravity 2</Evaluation>\n\t</Lab>\n</Lesson3>\n\n")

  var octetstring vl_stream:=''O;
  f_enc_Lesson3(vl_pdu,vl_stream);

  if( not match(vl_stream,vl_expectedEncodedPdu)) {
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_Lesson3(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_Lesson3(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(match(vl_pdu,vl_decodedPdu)) {
      setverdict(pass);
    } else {
      log("Pdu could not decoded from the expected value");
      log(match(vl_pdu,vl_decodedPdu));
      setverdict(fail);
    }
  }

}//f_
//============================================
//  f_encDecTest_ComplexTypeWithAll_MySubject1
//  Each "subject" is optional
//============================================
function f_encDecTest_ComplexTypeWithAll_MySubject1(
  in MySubjects1 pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in MySubjects1 pl_expectedPdu)
{
  var  MySubjects1 vl_decodedPdu;

  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;
  f_enc_MySubjects1(pl_pdu,vl_stream);
  
  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_MySubjects1(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_MySubjects1(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_
//============================================
//  f_encDecTest_ComplexTypeWithAll_MySubject2
//  Ther is no  optional "subject"
//============================================
function f_encDecTest_ComplexTypeWithAll_MySubject2(
  in MySubjects2 pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in MySubjects2 pl_expectedPdu,
  in integer pl_expectedRetValAtDecoding)
{
  var  MySubjects2 vl_decodedPdu;

  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;
  f_enc_MySubjects2(pl_pdu,vl_stream);

  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs expected value===");
  var integer vl_retval:= f_dec_MySubjects2(vl_stream, vl_decodedPdu);
  //log("The decoded pdu: ", vl_decodedPdu);
  //log("The decoder returned with ", vl_retval);
  if(pl_expectedRetValAtDecoding==0) {
    if( vl_retval==0) {
      if(isvalue(pl_expectedPdu)){
        if(isvalue(vl_decodedPdu)) {
          if(match(pl_expectedPdu,vl_decodedPdu)) {
            setverdict(pass);
          } else {
            log("Pdu is not the expected one:");
            log(match(pl_expectedPdu,vl_decodedPdu));
            setverdict(fail);
          }
        }else {
          log("The decoded value contains unbounded values, but the decoder doesn't complain!");
          setverdict(fail);
        }
      } else { //don't check
        log("The expected pdu contains unbounded values, it cannot be matched: ", pl_expectedPdu);
      }

    }else{
      log("Unsuccessful decoding");
      setverdict(fail);
    }
  } else { //unsuccesful decoding:
    if(pl_expectedRetValAtDecoding==vl_retval) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }
  //===Checking value decoded from the expected value vs expected value==="

  if(pl_expectedEncodedPdu=="") {
    return;
  }

  //log("===Checking value decoded from the expected encoded value vs expected decoded Pdu===");
  vl_retval:=f_dec_MySubjects2(vl_expectedEncodedPdu, vl_decodedPdu);
  //log("The decoded pdu: ", vl_decodedPdu);
  //log("The decoder returned with ", vl_retval);
  if(pl_expectedRetValAtDecoding==0) {
    if( f_dec_MySubjects2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
      if(isvalue(pl_expectedPdu)){
        if(isvalue(vl_decodedPdu)) {
          if(match(pl_expectedPdu,vl_decodedPdu)) {
            setverdict(pass);
          } else {
            log("Pdu is not the expected one:");
            log(match(pl_expectedPdu,vl_decodedPdu));
            setverdict(fail);
          }
        }else {
          log("The decoded value contains unbounded values, but the decoder doesn't complain!");
          setverdict(fail);
        }
      }else { //don't check
        log("The expected pdu contains unbounded values, it cannot be matched: ", pl_expectedPdu);
      }
    }else{
      log("Unsuccessful decoding");
      setverdict(fail);
    }
  } else {
    //unsuccesful decoding:
    if(pl_expectedRetValAtDecoding==vl_retval) {
      setverdict(pass);
    } else {
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithAll_inconsistentSet
//  each field is optional and one is not present
//============================================
function f_encDecTest_ComplexTypeWithAll_inconsistentSet() {
  var  MySubjects1 vl_pdu:= {
    order:={math,english},
    year:="2009",
    english:="Advanced Group 1",
    math:="Beginners 1",
    physics:=omit,
    chemistry:="CH2"
  },
  vl_expectedPdu:={
    order:={math,english},
    year:="2009",
    english:="Advanced Group 1",
    math:="Beginners 1",
    physics:=omit,
    chemistry:=omit
  },
  vl_decodedPdu;

  var octetstring vl_expectedEncodedPdu:=
    char2oct("<MySubjects1 Year='2009'>\n\t<Math>Beginners 1</Math>\n\t<English>Advanced Group 1</English>\n</MySubjects1>\n\n")
  
  var octetstring vl_stream:=''O;
  f_enc_MySubjects1(vl_pdu,vl_stream);

  if(match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
    log("=============> Really????? We should expect Dynamic testcase error!!! Or at least WARNING!!!");
  }else{
    log("The data to be encoded: ", vl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs expected value===");
  if(f_dec_MySubjects1(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(vl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(vl_pdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }

  //log("===Checking value decoded from the expected value vs expected value===");
  if( f_dec_MySubjects1(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(vl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(vl_pdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }

}//f_

//============================================
//  f_encDecTest_ComplexTypeWithExtension_MySubject3
//  Each "subject" is optional
//============================================
function f_encDecTest_ComplexTypeWithExtension_MySubject3(
  in MySubjects3Extension pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in MySubjects3Extension pl_expectedPdu)
{
  var  MySubjects3Extension vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;

  f_enc_MySubjects3Extension(pl_pdu,vl_stream);

  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_MySubjects3Extension(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_MySubjects3Extension(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_


//============================================
//  f_encDecTest_ComplexTypeWithExtension_MySubject3
//  Each "subject" is optional
//============================================
function f_encDecTest_ComplexTypeWithExtension_MySubject4(
  in MySubjects4Restriction pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in MySubjects4Restriction pl_expectedPdu)
{
  var  MySubjects4Restriction vl_decodedPdu;

  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;
  f_enc_MySubjects4Restriction(pl_pdu,vl_stream);
  
  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Expectation: Dynamic testcase error");
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_MySubjects4Restriction(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_MySubjects4Restriction(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_

//============================================
//  f_encDecTest_PurchaseReportImport
//  Each "subject" is optional
//============================================
function f_encDecTest_PurchaseReportImport (
  in PurchaseReportImport pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in PurchaseReportImport pl_expectedPdu)
{
  var  PurchaseReportImport vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;

  f_enc_PurchaseReportImport(pl_pdu,vl_stream);
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
  if( match(vl_stream,vl_expectedEncodedPdu)) {    
    setverdict(pass);
  }else{
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_PurchaseReportImport(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_PurchaseReportImport(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_

//============================================
//  f_encDecTest_ElementContainingXhtml_1
//  Each "subject" is optional
//============================================
function f_encDecTest_ElementContainingXhtml_1 (
  in ElementContainingXhtml_1 pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in ElementContainingXhtml_1 pl_expectedPdu)
{
  var  ElementContainingXhtml_1 vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;
  f_enc_ElementContainingXhtml_1(pl_pdu,vl_stream);

  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ElementContainingXhtml_1(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ElementContainingXhtml_1(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_


//===
//============================================
//  f_encDecTest_ElementContainingXhtml_2
//  Each "subject" is optional
//============================================
function f_encDecTest_ElementContainingXhtml_2 (
  in ElementContainingXhtml_2 pl_pdu, 
  in charstring pl_expectedEncodedPdu,
  in ElementContainingXhtml_2 pl_expectedPdu)
{
  var  ElementContainingXhtml_2 vl_decodedPdu;
  var octetstring vl_expectedEncodedPdu:= char2oct(pl_expectedEncodedPdu);
  var octetstring vl_stream:=''O;
  f_enc_ElementContainingXhtml_2(pl_pdu,vl_stream);

  if( match(vl_stream,vl_expectedEncodedPdu)) {
    setverdict(pass);
  }else{
    log("The data to be encoded: ", pl_pdu);
    log("Expected encoded value: ",vl_expectedEncodedPdu);
    log("Actual encoded value:   ", vl_stream);
    setverdict(fail);
  }

  //log("===Checking value decoded from the encoded value vs original value===");
  if(f_dec_ElementContainingXhtml_2(vl_stream, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

  //log("===Checking value decoded from the expected value vs original value===");
  if( f_dec_ElementContainingXhtml_2(vl_expectedEncodedPdu, vl_decodedPdu)==0) {
    //log("The decoded pdu: ", vl_decodedPdu);
    if(isvalue(vl_decodedPdu)) {
      if(match(pl_expectedPdu,vl_decodedPdu)) {
        setverdict(pass);
      } else {
        log("Pdu is not the expected one:");
        log(match(pl_expectedPdu,vl_decodedPdu));
        setverdict(fail);
      }
    }else {
      log("The decoded value contains unbounded values");
      setverdict(fail);
    }
  }else{
    log("Unsuccessful decoding");
    setverdict(fail);
  }

}//f_
}//module
