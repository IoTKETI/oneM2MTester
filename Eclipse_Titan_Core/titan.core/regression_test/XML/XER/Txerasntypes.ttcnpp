/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Balasko, Jeno
 *   Baranyi, Botond
 *   Raduly, Csaba
 *   Szabados, Kristof
 *
 ******************************************************************************/
module Txerasntypes {

modulepar boolean Txerasntypes_verbose := false;
#define verbose Txerasntypes_verbose

#include "../macros.ttcnin"

import from Asntypes all;
import from AsnValues all;
import from UTF8 all;

type component ASN1 {}

//external function flatten(inout charstring par) ;
external function flatten(inout universal charstring par) ;

/**************************** BIT STRING ****************************/
DECLARE_XER_ENCODERS(Asn_bs,bs)
DECLARE_EXER_ENCODERS(Asn_bs,bs)

const charstring xer_fifteen := "<Asn-bs>00001111</Asn-bs>";
const charstring xer_pi1 := "<Asn-bs>0010010000111111011010101000100010000101101000110000100011010011"&
"0001001100011001100010100010111000000011011100000111001101000100"&
"1010010000001001001110000010001000101001100111110011000111010000"&
"0000100000101110111110101001100011101100010011100110110010001001</Asn-bs>";
const charstring xer_pi2 := "<Asn-bs>010001010010100000100001111001100011100011010000" &
"000100110111011110111110010101000110011011001111001101001110100100001100"&
"011011001100000010101100001010011011011111001001011111000101000011011101"&
"0011111110000100110101011011010110110101010001110000100100010111</Asn-bs>";
const charstring xer_bs_empty := "<Asn-bs/>";

testcase encode_bs() runs on ASN1 // BIT STRING
{
    var Asn_bs bsval := '00001111'B;
    var universal charstring expected := xer_fifteen;

    CHECK_METHOD(cxer_enc_bs, bsval, expected);
    CHECK_METHOD(bxer_enc_bs, bsval, expected & lf);
    CHECK_METHOD(exer_enc_bs, bsval, expected & lf);

    bsval := ''B;
    expected := xer_bs_empty;
    CHECK_METHOD(cxer_enc_bs, bsval, expected);
    CHECK_METHOD(bxer_enc_bs, bsval, expected & lf);
    CHECK_METHOD(exer_enc_bs, bsval, expected & lf);

    expected := xer_bs_empty; // FIXME: Asn-bs ?
    CHECK_METHOD(cxer_enc_bs, AsnValues.bstr0, expected);
    CHECK_METHOD(bxer_enc_bs, AsnValues.bstr0, expected & lf);

    expected := "<Asn-bs>10100100</Asn-bs>";
    CHECK_METHOD(cxer_enc_bs, AsnValues.bstr, expected);
    CHECK_METHOD(bxer_enc_bs, AsnValues.bstr, expected & lf);

    expected := xer_pi2;
    CHECK_METHOD(cxer_enc_bs, AsnValues.binpi2, expected);
    CHECK_METHOD(bxer_enc_bs, AsnValues.binpi2, expected & lf);

    expected := xer_pi1;
    CHECK_METHOD(cxer_enc_bs, AsnValues.binpi, expected);
    CHECK_METHOD(bxer_enc_bs, AsnValues.binpi, expected & lf);
}

testcase decode_bs() runs on ASN1
{
    var Asn_bs expected;

    expected := ''B;
    CHECK_DECODE(cxer_dec_bs, xer_bs_empty, Asn_bs, expected);
    CHECK_DECODE(bxer_dec_bs, xer_bs_empty, Asn_bs, expected);
    CHECK_DECODE(exer_dec_bs, xer_bs_empty, Asn_bs, expected);

    expected := '00001111'B;
    CHECK_DECODE(cxer_dec_bs, xer_fifteen, Asn_bs, expected);
    CHECK_DECODE(bxer_dec_bs, xer_fifteen, Asn_bs, expected);
    CHECK_DECODE(exer_dec_bs, xer_fifteen, Asn_bs, expected);

    expected := '0100010100101000001000011110011000111000110100000001001101110111101111100101010001100110110011110011010011101001000011000110110011000000101011000010100110110111110010010111110001010000110111010011111110000100110101011011010110110101010001110000100100010111'B;
    CHECK_DECODE(cxer_dec_bs, xer_pi2, Asn_bs, expected);
    CHECK_DECODE(bxer_dec_bs, xer_pi2, Asn_bs, expected);
    CHECK_DECODE(exer_dec_bs, xer_pi2, Asn_bs, expected);
    CHECK_DECODE(cxer_dec_bs, xer_pi2, Asn_bs, AsnValues.binpi2);
    CHECK_DECODE(bxer_dec_bs, xer_pi2, Asn_bs, AsnValues.binpi2);
    CHECK_DECODE(exer_dec_bs, xer_pi2, Asn_bs, AsnValues.binpi2);

    expected := '0010010000111111011010101000100010000101101000110000100011010011000100110001100110001010001011100000001101110000011100110100010010100100000010010011100000100010001010011001111100110001110100000000100000101110111110101001100011101100010011100110110010001001'B;
    CHECK_DECODE(cxer_dec_bs, xer_pi1, Asn_bs, AsnValues.binpi);
    CHECK_DECODE(bxer_dec_bs, xer_pi1, Asn_bs, AsnValues.binpi);
    CHECK_DECODE(exer_dec_bs, xer_pi1, Asn_bs, AsnValues.binpi);
}

/**************************** BOOLEAN ****************************/
DECLARE_XER_ENCODERS(Asn_bool, bool);
DECLARE_EXER_ENCODERS(Asn_bool,bool)
DECLARE_XER_ENCODERS(A_rboolean, arbool);
DECLARE_EXER_ENCODERS(A_rboolean,arbool)

testcase encode_abool() runs on ASN1
{
    var Asn_bool boolval := true;
    var universal charstring expected := "<Asn-bool><true/></Asn-bool>";
    CHECK_METHOD(cxer_enc_bool, boolval, expected);
    CHECK_METHOD(bxer_enc_bool, boolval, expected & lf);
    expected :=  "<Asn-bool>true</Asn-bool>"; // EXER uses TextBoolean
    CHECK_METHOD(exer_enc_bool, boolval, expected & lf);

    expected := "<Asn-bool><true/></Asn-bool>";
    CHECK_METHOD(cxer_enc_bool, AsnValues.boo, expected);
    CHECK_METHOD(bxer_enc_bool, AsnValues.boo, expected & lf);

    CHECK_METHOD(cxer_enc_bool, AsnValues.so_true, expected);
    CHECK_METHOD(bxer_enc_bool, AsnValues.so_true, expected & lf);

    expected :=  "<Asn-bool>true</Asn-bool>"; // EXER uses TextBoolean
    CHECK_METHOD(exer_enc_bool, AsnValues.boo, expected & lf);
    CHECK_METHOD(exer_enc_bool, AsnValues.so_true, expected & lf);

    boolval  := false;
    expected := "<Asn-bool><false/></Asn-bool>";
    CHECK_METHOD(cxer_enc_bool, boolval, expected);
    CHECK_METHOD(bxer_enc_bool, boolval, expected & lf);
    expected :=  "<Asn-bool>false</Asn-bool>"; // EXER uses TextBoolean
    CHECK_METHOD(exer_enc_bool, boolval, expected & lf);

    expected := "<Asn-bool><false/></Asn-bool>";
    CHECK_METHOD(cxer_enc_bool, AsnValues.noo, expected);
    CHECK_METHOD(bxer_enc_bool, AsnValues.noo, expected & lf);
    expected :=  "<Asn-bool>false</Asn-bool>"; // EXER uses TextBoolean
    CHECK_METHOD(exer_enc_bool, AsnValues.noo, expected & lf);

    expected := "<A-rboolean/>\n\n";
    CHECK_METHOD(bxer_enc_arbool, AsnValues.arbomit, expected);
    CHECK_METHOD(exer_enc_arbool, AsnValues.arbomit, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_arbool, AsnValues.arbomit, expected & lf);

    expected :=
        "<A-rboolean>\n" &
        "\t<bb><true/></bb>\n" &
        "</A-rboolean>\n\n";
    CHECK_METHOD(bxer_enc_arbool, AsnValues.arbtrue, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_arbool, AsnValues.arbtrue, expected & lf);
    expected :=
        "<A-rboolean>\n" &
        "\t<bb>true</bb>\n" & // EXER uses TextBoolean
        "</A-rboolean>\n\n";
    CHECK_METHOD(exer_enc_arbool, AsnValues.arbtrue, expected);

    expected :=
        "<A-rboolean>\n" &
        "\t<bb><false/></bb>\n" &
        "</A-rboolean>\n\n";
    CHECK_METHOD(bxer_enc_arbool, AsnValues.arbfalse, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_arbool, AsnValues.arbfalse, expected & lf);
    expected :=
        "<A-rboolean>\n" &
        "\t<bb>false</bb>\n" &
        "</A-rboolean>\n\n";
    CHECK_METHOD(exer_enc_arbool, AsnValues.arbfalse, expected);
}

testcase decode_abool() runs on ASN1
{
    {
    var Asn_bool expected;

    const charstring verite := "<Asn-bool><true/></Asn-bool>";
    expected := true;
    CHECK_DECODE2(bool, verite, Asn_bool, expected);

    const charstring faux := "<Asn-bool><false/></Asn-bool>"
    expected := false;
    CHECK_DECODE2(bool, faux, Asn_bool, expected);
    }

    {
    var A_rboolean expected := { omit };
    const charstring omitted := "<A-rboolean/>\n\n";
    CHECK_DECODE2(arbool, omitted, A_rboolean, expected);
    }

    {
    var A_rboolean expected := { true };
    const charstring one_true :=
        "<A-rboolean>\n" &
        "\t<bb><true/></bb>\n" &
        "</A-rboolean>\n\n";
    CHECK_DECODE2(arbool, one_true, A_rboolean, expected);
    }

    {
    var A_rboolean expected := { false };
    const charstring one_true :=
        "<A-rboolean>\n" &
        "\t<bb><false/></bb>\n" &
        "</A-rboolean>\n\n";
    CHECK_DECODE2(arbool, one_true, A_rboolean, expected);
    }
}

/**************************** EMBEDDED PDV ****************************/
DECLARE_XER_ENCODERS(Asn_pdv, pdv);
DECLARE_EXER_ENCODERS(Asn_pdv,pdv)

const charstring pdvstr_syntax :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<syntax>0.4.0.0.1.2</syntax>\n" &
  "\t</identification>\n" &
  "\t<data-value>BABEFACE</data-value>\n" &
  "</Asn-pdv>\n";

const charstring pdvstr_pci := // pci = initials of presentation-context-id
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<presentation-context-id>1</presentation-context-id>\n" &
  "\t</identification>\n" &
  "\t<data-value>BABEFACE</data-value>\n" &
  "</Asn-pdv>\n";

const charstring pdvstr_syntaxes :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<syntaxes>\n" &
  "\t\t\t<abstract>1.0.9.8.7.6.5</abstract>\n" &
  "\t\t\t<transfer>1.0.5.6.7.8.9</transfer>\n" &
  "\t\t</syntaxes>\n" &
  "\t</identification>\n" &
  //"\t<data-value-descriptor>Food given to cattle</data-value-descriptor>\n" &
  "\t<data-value>BEEFFEED</data-value>\n" &
  "</Asn-pdv>\n"

const charstring pdvstr_syntax2 :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<syntax>0.4.0.1.3.5</syntax>\n" &
  "\t</identification>\n" &
  //"\t<data-value-descriptor>We need real coffee</data-value-descriptor>\n" &
  "\t<data-value>DECAFBAD</data-value>\n" &
  "</Asn-pdv>\n"

const charstring pdvstr_context_neg :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<context-negotiation>\n" &
  "\t\t\t<presentation-context-id>69</presentation-context-id>\n" &
  "\t\t\t<transfer-syntax>2.7.18.28.18.28.45.90.45</transfer-syntax>\n" &
  "\t\t</context-negotiation>\n" &
  "\t</identification>\n" &
  "\t<data-value>C1AFB1</data-value>\n" &
  "</Asn-pdv>\n"

const charstring pdvstr_xfer :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<transfer-syntax>0.4.0.0.1.2</transfer-syntax>\n" &
  "\t</identification>\n" &
  "\t<data-value>C0FFEE</data-value>\n" &
  "</Asn-pdv>\n";

const charstring pdvstr_fixed :=
  "<Asn-pdv>\n" &
  "\t<identification>\n" &
  "\t\t<fixed/>\n" &
  "\t</identification>\n" &
  "\t<data-value>F1</data-value>\n" &
  "</Asn-pdv>\n";

const Asn_pdv tpdv := {
    { syntax := objid { etsi 0 1 2 } },
    omit, // data-value-descriptor not allowed for EMBEDDED PDV
    'BABEFACE'O };

testcase encode_pdv() runs on ASN1
{
    var universal charstring expected;

    expected := pdvstr_syntax;
    CHECK_METHOD(bxer_enc_pdv, tpdv, expected);
    CHECK_METHOD(exer_enc_pdv, tpdv, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, tpdv, expected);

    expected := pdvstr_pci;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_pci, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_pci, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_pci, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_pci, expected);

    expected := pdvstr_syntaxes;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_sxs, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_sxs, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_sxs, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_sxs, expected);

    expected := pdvstr_syntax2;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_sx, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_sx, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_sx, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_sx, expected);

    expected := pdvstr_context_neg;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_cneg, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_cneg, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_cneg, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_cneg, expected);

    expected := pdvstr_xfer;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_xsx, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_xsx, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_xsx, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_xsx, expected);

    expected := pdvstr_fixed;
    CHECK_METHOD(bxer_enc_pdv, AsnValues.pdv_fix, expected);
    CHECK_METHOD(bxer_enc_pdv, AsnValues.epdv_fix, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.pdv_fix, expected);
    CHECK_METHOD(cxer_enc_pdv, AsnValues.epdv_fix, expected);
}

testcase decode_pdv() runs on ASN1
{
    var Asn_pdv expected;

    expected := AsnValues.pdv_sxs;
    CHECK_DECODE2(pdv, pdvstr_syntaxes, Asn_pdv, expected);

    expected := AsnValues.pdv_sx;
    CHECK_DECODE2(pdv, pdvstr_syntax2, Asn_pdv, expected);

    expected := AsnValues.pdv_pci;
    CHECK_DECODE2(pdv, pdvstr_pci, Asn_pdv, expected);

    expected := AsnValues.pdv_cneg;
    CHECK_DECODE2(pdv, pdvstr_context_neg, Asn_pdv, expected);

    expected := AsnValues.pdv_xsx;
    CHECK_DECODE2(pdv, pdvstr_xfer, Asn_pdv, expected);

    expected := AsnValues.pdv_fix;
    CHECK_DECODE2(pdv, pdvstr_fixed, Asn_pdv, expected);
}




/**************************** EXTERNAL ****************************/
DECLARE_XER_ENCODERS(Asn_ext, ext);
DECLARE_EXER_ENCODERS(Asn_ext,ext)

type record extwrap {
    Asn_ext SEQUENCE
}

DECLARE_XER_ENCODERS(extwrap, extw);
DECLARE_EXER_ENCODERS(extwrap,extw)

const charstring ext_octet_aligned :=
  "<Asn-ext>\n" &
  "\t<indirect-reference>66</indirect-reference>\n" &
  "\t<encoding>\n" &
  "\t\t<octet-aligned>DECAFBAD</octet-aligned>\n" &
  "\t</encoding>\n" &
  "</Asn-ext>\n";

const charstring ext_octet_aligned2 :=
  "<Asn-ext>\n" &
  "\t<indirect-reference>2</indirect-reference>\n" &
  "\t<encoding>\n" &
  "\t\t<octet-aligned>BABEFACE</octet-aligned>\n" &
  "\t</encoding>\n" &
  "</Asn-ext>\n";

const charstring ext_syntax_direct :=
  "<Asn-ext>\n" &
  "\t<direct-reference>2.7.18.28.18.28.45.90.45</direct-reference>\n" &
  "\t<data-value-descriptor>using syntax, direct only</data-value-descriptor>\n" &
  "\t<encoding>\n" &
  "\t\t<octet-aligned>BAADF00D</octet-aligned>\n" &
  "\t</encoding>\n" &
  "</Asn-ext>\n";

const charstring ext_context_both :=
  "<Asn-ext>\n" &
  "\t<direct-reference>2.1.1</direct-reference>\n" &
  "\t<indirect-reference>111</indirect-reference>\n" &
  "\t<data-value-descriptor>using context negotiation, both</data-value-descriptor>\n" &
  "\t<encoding>\n" &
  "\t\t<octet-aligned>1337D00D</octet-aligned>\n" &
  "\t</encoding>\n" &
  "</Asn-ext>\n";


const charstring ext_octet_aligned_wrap :=
  "<extwrap>\n" &
  "\t<SEQUENCE>\n" &
  "\t\t<indirect-reference>66</indirect-reference>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>DECAFBAD</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</SEQUENCE>\n" &
  "</extwrap>\n\n";

const charstring ext_syntax_direct_wrap :=
  "<extwrap>\n" &
  "\t<SEQUENCE>\n" &
  "\t\t<direct-reference>2.7.18.28.18.28.45.90.45</direct-reference>\n" &
  "\t\t<data-value-descriptor>using syntax, direct only</data-value-descriptor>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>BAADF00D</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</SEQUENCE>\n" &
  "</extwrap>\n\n";

const Asn_ext extval := {
    { presentation_context_id := 66 },
    omit,
    'DECAFBAD'O
};

testcase encode_ext() runs on ASN1
{
    var universal charstring expected := ext_octet_aligned;
    CHECK_METHOD(bxer_enc_ext, extval, expected);
    CHECK_METHOD(exer_enc_ext, extval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_ext, extval, expected);

    expected := ext_octet_aligned2;
    CHECK_METHOD(bxer_enc_ext, AsnValues.ext, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_ext, AsnValues.ext, expected);

    expected := ext_syntax_direct;
    CHECK_METHOD(bxer_enc_ext, AsnValues.ext_sx, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_ext, AsnValues.ext_sx, expected);

    expected := ext_context_both;
    CHECK_METHOD(bxer_enc_ext, AsnValues.ext_cn, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_ext, AsnValues.ext_cn, expected);

    var extwrap xw := { SEQUENCE := extval }
    expected :=    ext_octet_aligned_wrap;

    CHECK_METHOD(bxer_enc_extw, xw, expected);
    CHECK_METHOD(exer_enc_extw, xw, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_extw, xw, expected & lf);
}

testcase decode_ext() runs on ASN1
{
    var Asn_ext expected := extval;

    CHECK_DECODE2(ext, ext_octet_aligned, Asn_ext, expected);

    CHECK_DECODE2(ext, ext_octet_aligned2, Asn_ext, AsnValues.ext);

    CHECK_DECODE2(ext, ext_syntax_direct, Asn_ext, AsnValues.ext_sx);

    CHECK_DECODE2(ext, ext_context_both, Asn_ext, AsnValues.ext_cn);

    var extwrap expectedw := { SEQUENCE := extval };
    var universal charstring xwrap  := ext_octet_aligned_wrap;
    CHECK_DECODE2(extw, xwrap, extwrap, expectedw);

    expectedw := { SEQUENCE := AsnValues.ext_sx };
    xwrap     := ext_syntax_direct_wrap;
    CHECK_DECODE2(extw, xwrap, extwrap, expectedw);
}

/**************************** INTEGER ****************************/
DECLARE_XER_ENCODERS(Asn_int, aint);
DECLARE_EXER_ENCODERS(Asn_int,aint)

testcase encode_aint() runs on ASN1
{
    var Asn_int intval := -137;
    var universal charstring expected := "<Asn-int>-137</Asn-int>";
    // "<Asn-int/>";
    // It can never do that. Unbound should cause an error.
    CHECK_METHOD(cxer_enc_aint, intval, expected);
    CHECK_METHOD(bxer_enc_aint, intval, expected & lf);
    CHECK_METHOD(exer_enc_aint, intval, expected & lf);

    expected := "<Asn-int>42</Asn-int>";
    CHECK_METHOD(cxer_enc_aint, AsnValues.fourty_two, expected);
    CHECK_METHOD(bxer_enc_aint, AsnValues.fourty_two, expected & lf);

    expected := "<Asn-int>0</Asn-int>";
    CHECK_METHOD(cxer_enc_aint, AsnValues.zarro, expected);
    CHECK_METHOD(bxer_enc_aint, AsnValues.zarro, expected & lf);

    intval := 0;
    CHECK_METHOD(cxer_enc_aint, intval, expected);
    CHECK_METHOD(bxer_enc_aint, intval, expected & lf);
    CHECK_METHOD(exer_enc_aint, intval, expected & lf);

    expected := "<Asn-int>602214179000000000000000</Asn-int>";
    CHECK_METHOD(cxer_enc_aint, AsnValues.avogadro, expected);
    CHECK_METHOD(bxer_enc_aint, AsnValues.avogadro, expected & lf);

    // This is somewhat redundant because [bc]xer_enc_int doesn't encode
    // a TTCN3 integer (see Txerint.ttcnpp for that), but an Asn_int.
    intval := 602214179000000000000000;
    CHECK_METHOD(cxer_enc_aint, intval, expected);
    CHECK_METHOD(bxer_enc_aint, intval, expected & lf);
    CHECK_METHOD(exer_enc_aint, intval, expected & lf);
}

testcase decode_aint() runs on ASN1
{
    var integer expected;
    const charstring one_three_seven := "<Asn-int>137</Asn-int>";
    expected := 137;
    CHECK_DECODE2(aint, one_three_seven, integer, expected);

    const charstring   minus_nine := "<Asn-int>-9</Asn-int>";
    expected := -9;
    CHECK_DECODE2(aint, minus_nine, integer, expected);

    const charstring   fourtytwo := "<Asn-int>42</Asn-int>";
    CHECK_DECODE2(aint, fourtytwo, integer, AsnValues.fourty_two);

    const charstring   nix := "<Asn-int>0</Asn-int>";
    CHECK_DECODE2(aint, nix, integer, AsnValues.zarro);
    const charstring   minix := "<Asn-int>-0</Asn-int>";
    CHECK_DECODE2(aint, minix, integer, AsnValues.zarro);

    const charstring avo := "<Asn-int>602214179000000000000000</Asn-int>";
    expected             :=           602214179000000000000000;
    CHECK_DECODE2(aint, avo, Asn_int, expected);

    const charstring empty_int := "<Asn-int/>";
    var octetstring bytes;
    var integer rv := u2o("UTF-8", empty_int, bytes);
    MUST_UNBOUND(bxer_dec_aint(bytes)); // can't check with ==
}

/**************************** NULL ****************************/
DECLARE_XER_ENCODERS(Asn_nul, nul);
DECLARE_EXER_ENCODERS(Asn_nul,nul)

testcase encode_nul() runs on ASN1
{
    var Asn_nul nulval := NULL;
    var universal charstring expected := "<Asn-nul/>";
    CHECK_METHOD(cxer_enc_nul, nulval, expected);
    CHECK_METHOD(bxer_enc_nul, nulval, expected & lf);
    CHECK_METHOD(exer_enc_nul, nulval, expected & lf);
}

testcase decode_nul() runs on ASN1
{
    const charstring nullstr := "<Asn-nul/>";
    var Asn_nul expected := NULL;
    CHECK_DECODE2(nul, nullstr, Asn_nul, expected);
}

/**************************** OBJECT IDENTIFIER ****************************/
DECLARE_XER_ENCODERS(Asn_oid, oid);
DECLARE_EXER_ENCODERS(Asn_oid,oid)

const charstring oidstr_empty := "<Asn-oid/>";
const charstring oidstr_etsiMobNet := "<Asn-oid>0.4.0.0.1</Asn-oid>";
const charstring oidstr_pi := "<Asn-oid>1.3.14.15.9.2.6.5.3.5.8.9.7.9.3.2.3.8.4.6.2.6.4.3.3</Asn-oid>";
const charstring oidstr_e  := "<Asn-oid>2.7.18.28.18.28.45.90.45</Asn-oid>";
const charstring oidstr_ericsson_testing := "<Asn-oid>0.4.0.127.0.5.0</Asn-oid>";
const charstring oidstr_etsi_solo := "<Asn-oid>0.4.0</Asn-oid>";
const charstring oidstr_ber := "<Asn-oid>2.1.1</Asn-oid>";
const charstring oidstr_cer := "<Asn-oid>2.6.6.1.2.4.4</Asn-oid>";

const Asn_oid etsiMobNet := objid{ itu_t identified_organization etsi(0) mobile_domain(0) umts_Network(1) }

testcase encode_oid() runs on ASN1
{
    var Asn_oid noid;
    var universal charstring expected := oidstr_empty;

    // unbound! CHECK_METHOD(cxer_enc_oid, noid, expected);
    // unbound! CHECK_METHOD(bxer_enc_oid, noid, expected & lf);

    expected := oidstr_etsiMobNet;

    expected := oidstr_pi
    CHECK_METHOD(cxer_enc_oid, pi_oid, expected);
    CHECK_METHOD(bxer_enc_oid, pi_oid, expected & lf);
    CHECK_METHOD(exer_enc_oid, pi_oid, expected & lf);

    expected := oidstr_e;
    CHECK_METHOD(cxer_enc_oid, e_oid, expected);
    CHECK_METHOD(bxer_enc_oid, e_oid, expected & lf);
    CHECK_METHOD(exer_enc_oid, e_oid, expected & lf);

    // { itu-t identified-organization etsi(0) reserved(127) etsi-identified-organization(0) ericsson(5) testing(0) }
    expected := oidstr_ericsson_testing;
    CHECK_METHOD(cxer_enc_oid, ericsson_testing, expected);
    CHECK_METHOD(bxer_enc_oid, ericsson_testing, expected & lf);
    CHECK_METHOD(exer_enc_oid, ericsson_testing, expected & lf);

    expected := oidstr_etsi_solo;
    CHECK_METHOD(cxer_enc_oid, etsi_solo, expected);
    CHECK_METHOD(bxer_enc_oid, etsi_solo, expected & lf);
    CHECK_METHOD(exer_enc_oid, etsi_solo, expected & lf);

    expected := oidstr_ber;
    CHECK_METHOD(cxer_enc_oid, ber_oid, expected);
    CHECK_METHOD(bxer_enc_oid, ber_oid, expected & lf);
    CHECK_METHOD(exer_enc_oid, ber_oid, expected & lf);

    expected := oidstr_cer;
    CHECK_METHOD(cxer_enc_oid, cer_oid, expected);
    CHECK_METHOD(bxer_enc_oid, cer_oid, expected & lf);
    CHECK_METHOD(exer_enc_oid, cer_oid, expected & lf);
}

testcase decode_oid() runs on ASN1
{
    var Asn_oid expected;
    //compiler error, must have at least two components := objid { 1 };
    //CHECK_DECODE2(oid, oidstr_empty, Asn_oid, expected);

    expected := etsiMobNet;
    CHECK_DECODE2(oid, oidstr_etsiMobNet, Asn_oid, expected);

    expected := pi_oid;
    CHECK_DECODE2(oid, oidstr_pi, Asn_oid, expected);

    expected := e_oid;
    CHECK_DECODE2(oid, oidstr_e, Asn_oid, expected);

    expected := ericsson_testing;
    CHECK_DECODE2(oid, oidstr_ericsson_testing, Asn_oid, expected);

    expected := etsi_solo;
    CHECK_DECODE2(oid, oidstr_etsi_solo, Asn_oid, expected);

    expected := ber_oid;
    CHECK_DECODE2(oid, oidstr_ber, Asn_oid, expected);

    expected := cer_oid;
    CHECK_DECODE2(oid, oidstr_cer, Asn_oid, expected);
}

/**************************** RELATIVE OBJECT IDENTIFIER ****************************/
DECLARE_XER_ENCODERS(Asn_roid, roid);
DECLARE_EXER_ENCODERS(Asn_roid,roid)

testcase encode_roid() runs on ASN1
{
    var Asn_oid roidval;
    var universal charstring expected := "<Asn-roid/>";
    // unbound! CHECK_METHOD(cxer_enc_roid, roidval, expected);
    // unbound! CHECK_METHOD(bxer_enc_roid, roidval, expected & lf);

    roidval := objid {iso(1) member_body(2) bsi(826) disc(0) ericsson(1249)};
    expected := "<Asn-roid>1.2.826.0.1249</Asn-roid>";
    CHECK_METHOD(cxer_enc_roid, roidval, expected);
    CHECK_METHOD(bxer_enc_roid, roidval, expected & lf);
    CHECK_METHOD(exer_enc_roid, roidval, expected & lf);

    CHECK_METHOD(cxer_enc_roid, AsnValues.zoid, expected);
    CHECK_METHOD(bxer_enc_roid, AsnValues.zoid, expected & lf);
}

testcase decode_roid() runs on ASN1
{
    var Asn_oid expected;
    expected := objid {iso(1) member_body(2) bsi(826) disc(0) ericsson(1249)};
    CHECK_DECODE2(roid, "<Asn-roid>1.2.826.0.1249</Asn-roid>", Asn_oid, expected);
}

/**************************** OCTET STRING ****************************/
DECLARE_XER_ENCODERS(Asn_os,os)
DECLARE_EXER_ENCODERS(Asn_os,os)

const charstring ostr_1111  := "<Asn-os>00001111</Asn-os>";
const charstring ostr_empty := "<Asn-os/>";
const charstring ostr_0123  := "<Asn-os>00112233</Asn-os>";

testcase encode_os() runs on ASN1 // OCTET STRING
{
    var Asn_os osval := '00001111'O;
    var universal charstring expected := ostr_1111;
    //var charstring encoded := bxer_enc_bs(bsval);
    CHECK_METHOD(cxer_enc_os, osval, expected);
    CHECK_METHOD(bxer_enc_os, osval, expected & lf);
    CHECK_METHOD(exer_enc_os, osval, expected & lf);

    osval := ''O;
    expected := ostr_empty;
    CHECK_METHOD(cxer_enc_os, osval, expected);
    CHECK_METHOD(bxer_enc_os, osval, expected & lf);
    CHECK_METHOD(exer_enc_os, osval, expected & lf);
    // still empty expected
    CHECK_METHOD(cxer_enc_os, AsnValues.os0, expected);
    CHECK_METHOD(bxer_enc_os, AsnValues.os0, expected & lf);

    expected := ostr_0123;
    CHECK_METHOD(cxer_enc_os, AsnValues.os, expected);
    CHECK_METHOD(bxer_enc_os, AsnValues.os, expected & lf);
}

testcase decode_os() runs on ASN1 // OCTET STRING
{
    var Asn_os expected;

    expected := '00001111'O;
    CHECK_DECODE2(os, ostr_1111, Asn_os, expected);

    expected := ''O;
    CHECK_DECODE2(os, ostr_empty, Asn_os, expected);

    expected := AsnValues.os
    CHECK_DECODE2(os, ostr_0123, Asn_os, expected);
}

/**************************** REAL ****************************/
DECLARE_XER_ENCODERS(Asn_real, real);
DECLARE_EXER_ENCODERS(Asn_real,real)

const charstring floatstr_pi := "<Asn-real>3.141593</Asn-real>";
const charstring floatstr_longpi := "<Asn-real>3.14159265358979</Asn-real>";

testcase encode_real() runs on ASN1
{
    var Asn_real rval := 3.1415926;
    var universal charstring expected := floatstr_pi;
    // "<Asn-real/>";
    // It can never do that. Unbound should cause an error.
    CHECK_METHOD(cxer_enc_real, rval, expected);
    CHECK_METHOD(bxer_enc_real, rval, expected & lf);
    CHECK_METHOD(exer_enc_real, rval, expected & lf);
    // TODO
    CHECK_METHOD(cxer_enc_real, AsnValues.pi, expected);
    CHECK_METHOD(bxer_enc_real, AsnValues.pi, expected & lf);
}

testcase decode_real() runs on ASN1
{
    var float expected := 3.141593;

    CHECK_DECODE2(real, floatstr_pi, float, expected);

    CHECK_DECODE2(real, floatstr_longpi, float, AsnValues.pi);
}

/**************************** Strings ****************************/
DECLARE_XER_ENCODERS(Asn_ia5, ia5s);
DECLARE_EXER_ENCODERS(Asn_ia5,ia5s)

const charstring ia5_yay := "<Asn-ia5>Yay!</Asn-ia5>\n";
const charstring ia5_cthulhu := "<Asn-ia5>Ia5! Ia5! Cthulhu fhtagn!</Asn-ia5>\n";
const charstring ia5_empty := "<Asn-ia5/>\n";
const charstring ia5_bonafide := "<Asn-ia5>A bona fide IA5String</Asn-ia5>\n";

testcase encode_ia5str() runs on ASN1
{
    var Asn_ia5 rval := "Yay!";
    var universal charstring expected := ia5_yay;
    CHECK_METHOD(cxer_enc_ia5s, rval, expected);
    CHECK_METHOD(bxer_enc_ia5s, rval, expected & lf);
    CHECK_METHOD(exer_enc_ia5s, rval, expected & lf);

    expected := ia5_cthulhu;
    CHECK_METHOD(cxer_enc_ia5s, AsnValues.ia5val, expected);
    CHECK_METHOD(bxer_enc_ia5s, AsnValues.ia5val, expected & lf);

    expected := ia5_empty;
    CHECK_METHOD(cxer_enc_ia5s, AsnValues.ia6val, expected);
    CHECK_METHOD(bxer_enc_ia5s, AsnValues.ia6val, expected & lf);

    expected := ia5_bonafide;
    CHECK_METHOD(cxer_enc_ia5s, AsnValues.ia7val, expected);
    CHECK_METHOD(bxer_enc_ia5s, AsnValues.ia7val, expected & lf);

    expected := ia5_empty;
    CHECK_METHOD(cxer_enc_ia5s, AsnValues.ia8val, expected);
    CHECK_METHOD(bxer_enc_ia5s, AsnValues.ia8val, expected & lf);
}

testcase decode_ia5str() runs on ASN1
{
    var charstring expected;

    expected := "Yay!";
    CHECK_DECODE2(ia5s, ia5_yay, Asn_ia5, expected);

    expected := AsnValues.ia5val;
    CHECK_DECODE2(ia5s, ia5_cthulhu, Asn_ia5, expected);

    expected := AsnValues.ia6val;
    CHECK_DECODE2(ia5s, ia5_empty, Asn_ia5, expected);

    expected := AsnValues.ia7val;
    CHECK_DECODE2(ia5s, ia5_bonafide, Asn_ia5, expected);
}

/**************************** UTF8String ****************************/
DECLARE_XER_ENCODERS(Asn_utf, utf);
DECLARE_EXER_ENCODERS(Asn_utf,utf)

// XER encoding of "UTF8 A'RVI'ZTU"RO"" TU:KO:RFU'RO'GE'P"
const universal charstring utf_arviz_turo :=
"<Asn-utf>UTF8 " & Aacute & "RV" & Iacute & "ZT" & Udouble & "R" & Odouble &
" T" & Uuml & "K" & Ouml & "RF" & Uacute & "R" & Oacute & "G" & Eacute & "P</Asn-utf>\n";

// XER encoding of an empty string
const charstring utf_empty := "<Asn-utf/>\n";

// XER encoding which needs to do a lot of escaping
const universal charstring utf_esc_oss :=
"<Asn-utf>UTF8 escapology\n<soh/><stx/><etx/><eot/><enq/><ack/><bel/><bs/>\t\n<vt/><ff/>\r<so/><si/><dle/><dc1/><dc2/><dc3/><dc4/><nak/><syn/><etb/><can/><em/><sub/><esc/><is4/><is3/><is2/><is1/>" &
//these would be the UTF8 bytes: "\xc2\x84\xC5\x82\xE4\x89\x82\xF0\x94\x89\x82\xF4\x84\x89\x82</Asn-utf>\n";
//but universal charstring uses UCS4
char(0,0,0,132) & char(0,0,1,66) & char(0,0,66,66) & char(0,1,66,66) & char(0,16,66,66) & "</Asn-utf>\n";

// An alternative representation which should decode into the same value
const universal charstring utf_esc_oss_alt :=
"<Asn-utf>UTF8 escapology\n<soh/><stx/><etx/><eot/><enq/><ack/><bel/><bs/>\t\n<vt/><ff/>\r<so/><si/><dle/><dc1/><dc2/><dc3/><dc4/><nak/><syn/><etb/><can/><em/><sub/><esc/><is4/><is3/><is2/><is1/>" &
// libxml2 handles &#n; and &#xn; for us. But it won't accept control characters.
"&#x84;&#x0142;&#x4242;&#x00014242;&#x00104242;" & "</Asn-utf>\n";

const universal charstring utf_bogus :=
"<Asn-utf>UTF8 escapology\n<doh/><stx/><etx/><eot/><enq/><ack/><bel/><bs/>\t\n<vt/><ff/>\r<so/><si/><dle/><dc1/><dc2/><dc3/><dc4/><nak/><syn/><etb/><can/><em/><sub/><esc/><is4/><is3/><is2/><is1/>" &
//--------------------------^^^
char(0,0,0,132) & char(0,0,1,66) & char(0,0,66,66) & char(0,1,66,66) & char(0,16,66,66) & "</Asn-utf>\n";

// XER encoding which needs to do a lot of escaping:
// "UTF8 " followed by "\x01\x02...\x1F" then \x84\x0142\x4242\x00014242\x00104242
//const charstring utf_esc :=
//"<Asn-utf>UTF8\n\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" &
//"\xc2\x84\xC5\x82\xE4\x89\x82\xF0\x94\x89\x82\xF4\x84\x89\x82</Asn-utf>\n";

// XER encoding of an HTML fragment
const charstring utf_html :=
"<Asn-utf>&lt;html&gt;&lt;body onload=&apos;javascript.alert(&quot;UTF8&quot;)&apos;&gt;&amp;nbsp;&lt;/body&gt;&lt;/html&gt;</Asn-utf>\n";

testcase encode_utf() runs on ASN1
{
    // Encode "UTF8 A'RVI'ZTU"RO"" TU:KO:RFU'RO'GE'P"
    var universal charstring expected := utf_arviz_turo;
    CHECK_METHOD(cxer_enc_utf, AsnValues.val_utf, expected);
    CHECK_METHOD(bxer_enc_utf, AsnValues.val_utf, expected & lf);

    // Encode an empty string
    expected := utf_empty;
    CHECK_METHOD(cxer_enc_utf, AsnValues.blank_utf, expected);
    CHECK_METHOD(bxer_enc_utf, AsnValues.blank_utf, expected & lf);

    // Encode a string with lots of characters that need to be escaped:
    expected := utf_esc_oss;
    CHECK_METHOD(cxer_enc_utf, AsnValues.esc_utf, expected);
    CHECK_METHOD(bxer_enc_utf, AsnValues.esc_utf, expected & lf);

    expected := utf_html;
    CHECK_METHOD(cxer_enc_utf, AsnValues.html_utf, expected);
    CHECK_METHOD(bxer_enc_utf, AsnValues.html_utf, expected & lf);
}

testcase decode_utf() runs on ASN1
{
    var Asn_utf expected;

    expected := AsnValues.val_utf;
    CHECK_DECODE2(utf, utf_arviz_turo, Asn_utf, expected);

    expected := AsnValues.blank_utf;
    CHECK_DECODE2(utf, utf_empty, Asn_utf, expected);

    expected := AsnValues.esc_utf_dec;
    CHECK_DECODE2(utf, utf_esc_oss, Asn_utf, expected);
    CHECK_DECODE2(utf, utf_esc_oss_alt, Asn_utf, expected);
    // Dynamic testcase error, as expected:
    //CHECK_DECODE2(utf, utf_bogus, Asn_utf, expected);

    expected := AsnValues.html_utf;
    CHECK_DECODE2(utf, utf_html, Asn_utf, expected);
}


/**************** Other restricted character string types ****************/
DECLARE_XER_ENCODERS(Asn_bmp, bmp);
DECLARE_EXER_ENCODERS(Asn_bmp,bmp)
DECLARE_XER_ENCODERS(Asn_gen, gen);
DECLARE_EXER_ENCODERS(Asn_gen,gen)
DECLARE_XER_ENCODERS(Asn_gra, gra);
DECLARE_EXER_ENCODERS(Asn_gra,gra)
DECLARE_XER_ENCODERS(Asn_num, num);
DECLARE_EXER_ENCODERS(Asn_num,num)
DECLARE_XER_ENCODERS(Asn_prn, prn);
DECLARE_EXER_ENCODERS(Asn_prn,prn)
DECLARE_XER_ENCODERS(Asn_ttx, ttx);
DECLARE_EXER_ENCODERS(Asn_ttx,ttx)
DECLARE_XER_ENCODERS(Asn_uni, uni);
DECLARE_EXER_ENCODERS(Asn_uni,uni)
DECLARE_XER_ENCODERS(Asn_vtx, vtx);
DECLARE_EXER_ENCODERS(Asn_vtx,vtx)
DECLARE_XER_ENCODERS(Asn_vis, vis);
DECLARE_EXER_ENCODERS(Asn_vis,vis)

DECLARE_XER_ENCODERS(universal charstring, ustr);

const charstring str_bmp  := "<Asn-bmp>Ich wei&#xDF; es! Basic Multilingual Plane.</Asn-bmp>\n";
const charstring str_bmp0 := "<Asn-bmp/>\n";
const charstring str_bmp_esc :=
"<Asn-bmp>BMP\n<nul/><soh/><stx/><etx/><eot/><enq/><ack/><bel/><bs/>\t\n<vt/><ff/>\r<so/><si/><dle/><dc1/><dc2/><dc3/><dc4/><nak/><syn/><etb/><can/><em/><sub/><esc/><is4/><is3/><is2/><is1/>&#x84;&#x0142;&#x4242;</Asn-bmp>\n";
const charstring str_bmp_html :=
"<Asn-bmp>&lt;html&gt;&lt;body onload=&apos;javascript.alert(&quot;BMP&quot;)&apos;&gt;&amp;nbsp;&lt;/body&gt;&lt;/html&gt;</Asn-bmp>\n";

const charstring str_gen0 := "<Asn-gen/>\n";
const charstring str_gen  := "<Asn-gen>Who is General Failure and why is he reading my disk ?</Asn-gen>\n";

const charstring str_gra0 := "<Asn-gra/>\n";
const charstring str_gra  := "<Asn-gra>Graphic</Asn-gra>\n";

const charstring str_num0 := "<Asn-num/>\n";
const charstring str_num  := "<Asn-num>150130937545296572356771972164254457814047970568738777235893533016064</Asn-num>\n";

const charstring str_prn0 := "<Asn-prn/>\n";
const charstring str_prn  := "<Asn-prn>Printable</Asn-prn>\n";

const charstring str_ttx0 := "<Asn-ttx/>\n";
const charstring str_ttx  := "<Asn-ttx>Teletex</Asn-ttx>\n";

const charstring str_uni0    := "<Asn-uni/>\n";
const charstring str_uni     := "<Asn-uni>Universal &#x7070;&#x7FBD;&#xE1;rv&#xED;zt&#x0171;r&#x0151; t&#xFC;k&#xF6;rf&#xFA;r&#xF3;g&#xE9;p</Asn-uni>\n";
const charstring str_uni_esc := "<Asn-uni>Universal escapology\n<nul/><soh/><stx/><etx/><eot/><enq/><ack/><bel/><bs/>\t\n<vt/><ff/>\r<so/><si/><dle/><dc1/><dc2/><dc3/><dc4/><nak/><syn/><etb/><can/><em/><sub/><esc/><is4/><is3/><is2/><is1/>&#x84;&#x0142;&#x4242;&#x014242;&#x104242;</Asn-uni>\n";
//&#x00;&#x84;&#x0142;&#x4242;
const charstring str_uni_html:= "<Asn-uni>&lt;html&gt;&lt;body onload=&apos;javascript.alert(&quot;Universal&quot;)&apos;&gt;&amp;nbsp;&lt;/body&gt;&lt;/html&gt;</Asn-uni>\n";

const charstring str_vtx0 := "<Asn-vtx/>\n";
const charstring str_vtx  := "<Asn-vtx>Videotex</Asn-vtx>\n";

const charstring str_vis0 := "<Asn-vis/>\n";
const charstring str_vis  := "<Asn-vis>Visible (ISO646)</Asn-vis>\n";



testcase encode_restricted_strings() runs on ASN1
{
    var universal charstring expected;

    expected := str_bmp;
    CHECK_METHOD(cxer_enc_bmp, AsnValues.b1val, expected);
    CHECK_METHOD(bxer_enc_bmp, AsnValues.b1val, expected & lf);

    expected := str_bmp0;
    CHECK_METHOD(cxer_enc_bmp, AsnValues.b0val, expected);
    CHECK_METHOD(bxer_enc_bmp, AsnValues.b0val, expected & lf);

    expected := str_bmp_esc;
    CHECK_METHOD(cxer_enc_bmp, AsnValues.esc_bmp, expected);
    CHECK_METHOD(bxer_enc_bmp, AsnValues.esc_bmp, expected & lf);

    expected := str_bmp_html;
    CHECK_METHOD(cxer_enc_bmp, AsnValues.html_bmp, expected);
    CHECK_METHOD(bxer_enc_bmp, AsnValues.html_bmp, expected & lf);

    //----------------------------------------------------
    expected := str_gen0;
    CHECK_METHOD(cxer_enc_gen, AsnValues.g0val, expected);
    CHECK_METHOD(bxer_enc_gen, AsnValues.g0val, expected & lf);

    expected := str_gen;
    CHECK_METHOD(cxer_enc_gen, AsnValues.g1val, expected);
    CHECK_METHOD(bxer_enc_gen, AsnValues.g1val, expected & lf);

    //----------------------------------------------------
    expected := str_gra0;
    CHECK_METHOD(cxer_enc_gra, AsnValues.gr0val, expected);
    CHECK_METHOD(bxer_enc_gra, AsnValues.gr0val, expected & lf);

    expected := str_gra;
    CHECK_METHOD(cxer_enc_gra, AsnValues.gr1val, expected);
    CHECK_METHOD(bxer_enc_gra, AsnValues.gr1val, expected & lf);

    //----------------------------------------------------
    expected := str_num0;
    CHECK_METHOD(cxer_enc_num, AsnValues.blank_num, expected);
    CHECK_METHOD(bxer_enc_num, AsnValues.blank_num, expected & lf);

    expected := str_num;
    CHECK_METHOD(cxer_enc_num, AsnValues.val_num, expected);
    CHECK_METHOD(bxer_enc_num, AsnValues.val_num, expected & lf);

    //----------------------------------------------------
    expected := str_prn0;
    CHECK_METHOD(cxer_enc_prn, AsnValues.blank_prn, expected);
    CHECK_METHOD(bxer_enc_prn, AsnValues.blank_prn, expected & lf);

    expected := str_prn;
    CHECK_METHOD(cxer_enc_prn, AsnValues.val_prn, expected);
    CHECK_METHOD(bxer_enc_prn, AsnValues.val_prn, expected & lf);

    //----------------------------------------------------
    expected := str_ttx0;
    CHECK_METHOD(cxer_enc_ttx, AsnValues.blank_ttx, expected);
    CHECK_METHOD(bxer_enc_ttx, AsnValues.blank_ttx, expected & lf);

    expected := str_ttx;
    CHECK_METHOD(cxer_enc_ttx, AsnValues.val_ttx, expected);
    CHECK_METHOD(bxer_enc_ttx, AsnValues.val_ttx, expected & lf);

    //----------------------------------------------------
    expected := str_uni0;
    CHECK_METHOD(cxer_enc_uni, AsnValues.blank_uni, expected);
    CHECK_METHOD(bxer_enc_uni, AsnValues.blank_uni, expected & lf);

    expected := str_uni_esc;
    CHECK_METHOD(cxer_enc_uni, AsnValues.esc_uni, expected);
    CHECK_METHOD(bxer_enc_uni, AsnValues.esc_uni, expected & lf);

    expected := str_uni;
    CHECK_METHOD(cxer_enc_uni, AsnValues.val_uni, expected);
    CHECK_METHOD(bxer_enc_uni, AsnValues.val_uni, expected & lf);

    expected := str_uni_html;
    CHECK_METHOD(cxer_enc_uni, AsnValues.html_uni, expected);
    CHECK_METHOD(bxer_enc_uni, AsnValues.html_uni, expected & lf);

    //----------------------------------------------------
    expected := str_vtx0;
    CHECK_METHOD(cxer_enc_vtx, AsnValues.blank_vtx, expected);
    CHECK_METHOD(bxer_enc_vtx, AsnValues.blank_vtx, expected & lf);

    expected := str_vtx;
    CHECK_METHOD(cxer_enc_vtx, AsnValues.val_vtx, expected);
    CHECK_METHOD(bxer_enc_vtx, AsnValues.val_vtx, expected & lf);

    //----------------------------------------------------
    expected := str_vis0;
    CHECK_METHOD(cxer_enc_vis, AsnValues.blank_vis, expected);
    CHECK_METHOD(bxer_enc_vis, AsnValues.blank_vis, expected & lf);

    expected := str_vis;
    CHECK_METHOD(cxer_enc_vis, AsnValues.val_vis, expected);
    CHECK_METHOD(bxer_enc_vis, AsnValues.val_vis, expected & lf);
}

testcase decode_restricted_strings() runs on ASN1
{
    {
    var Asn_bmp expected;

    expected := AsnValues.b1val;
    CHECK_DECODE(cxer_dec_bmp, str_bmp, universal charstring, expected/*AsnValues.b1val*/);
    CHECK_DECODE(bxer_dec_bmp, str_bmp, universal charstring, expected /*& lf*/);

    expected := AsnValues.b0val;
    CHECK_DECODE(cxer_dec_bmp, str_bmp0, universal charstring, expected);
    CHECK_DECODE(bxer_dec_bmp, str_bmp0, universal charstring, expected /*& lf*/);

    expected := AsnValues.esc_bmp_dec;
    CHECK_DECODE(cxer_dec_bmp, str_bmp_esc, universal charstring, expected);
    CHECK_DECODE(bxer_dec_bmp, str_bmp_esc, universal charstring, expected /*& lf*/);

    expected := AsnValues.html_bmp;
    CHECK_DECODE(cxer_dec_bmp, str_bmp_html, universal charstring, expected);
    CHECK_DECODE(bxer_dec_bmp, str_bmp_html, universal charstring, expected /*& lf*/);
    }
    //----------------------------------------------------
    {
    var Asn_gen expected := AsnValues.g0val;
    CHECK_DECODE(cxer_dec_gen, str_gen0, Asn_gen, expected);
    CHECK_DECODE(bxer_dec_gen, str_gen0, Asn_gen, expected);

    expected := AsnValues.g1val;
    CHECK_DECODE(cxer_dec_gen, str_gen, Asn_gen, expected);
    CHECK_DECODE(bxer_dec_gen, str_gen, Asn_gen, expected);
    }

    //----------------------------------------------------
    {
    var Asn_gra expected := AsnValues.gr0val;
    CHECK_DECODE(cxer_dec_gra, str_gra0, Asn_gra, expected);
    CHECK_DECODE(bxer_dec_gra, str_gra0, Asn_gra, expected);

    expected := AsnValues.gr1val;
    CHECK_DECODE(cxer_dec_gra, str_gra, Asn_gra, expected);
    CHECK_DECODE(bxer_dec_gra, str_gra, Asn_gra, expected);
    }

    //----------------------------------------------------
    {
    var Asn_num expected := AsnValues.blank_num;
    CHECK_DECODE3(num, str_num0, expected); // checks both BXER and CXER

    expected := AsnValues.val_num;
    CHECK_DECODE3(num, str_num, expected);
    }

    //----------------------------------------------------
    {
    var Asn_prn expected := AsnValues.blank_prn;
    CHECK_DECODE3(prn, str_prn0, expected);

    expected := AsnValues.val_prn;
    CHECK_DECODE3(prn, str_prn, expected);
    }

    //----------------------------------------------------
    {
    var Asn_ttx expected := AsnValues.blank_ttx;
    CHECK_DECODE3(ttx, str_ttx0, expected);

    expected := AsnValues.val_ttx;
    CHECK_DECODE3(ttx, str_ttx, expected);
    }

    //----------------------------------------------------
    {
    var Asn_uni expected := AsnValues.blank_uni;
    CHECK_DECODE3(uni, str_uni0, expected);

    expected := AsnValues.esc_uni_dec;
    CHECK_DECODE3(uni, str_uni_esc, expected);

    expected := AsnValues.val_uni;
    CHECK_DECODE3(uni, str_uni, expected);

    expected := AsnValues.html_uni;
    CHECK_DECODE3(uni, str_uni_html, expected);
    }

    //----------------------------------------------------
    {
    var Asn_vtx expected := AsnValues.blank_vtx;
    CHECK_DECODE3(vtx, str_vtx0, expected);

    expected := AsnValues.val_vtx;
    CHECK_DECODE3(vtx, str_vtx, expected);
    }

    //----------------------------------------------------
    {
    var Asn_vis expected := AsnValues.blank_vis;
    CHECK_DECODE3(vis, str_vis0, expected);

    expected := AsnValues.val_vis;
    CHECK_DECODE3(vis, str_vis, expected);
    }
}

/************ The big, scary, unrestricted CHARACTER STRING ************/
DECLARE_XER_ENCODERS(Asn_unr, unr);
DECLARE_EXER_ENCODERS(Asn_unr,unr)

const charstring str_unr_sxs :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<syntaxes>\n" &
"\t\t\t<abstract>1.3.14.15.9.2.6.5.3.5.8.9.7.9.3.2.3.8.4.6.2.6.4.3.3</abstract>\n" &
"\t\t\t<transfer>2.7.18.28.18.28.45.90.45</transfer>\n" &
"\t\t</syntaxes>\n" &
"\t</identification>\n" &
"\t<string-value>C3A17276C3AD7A74C5B172C5912074C3</string-value>\n" &
"</Asn-unr>\n\n";

const charstring str_unr_sx :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<syntax>1.3.14.15.9.2.6.5.3.5.8.9.7.9.3.2.3.8.4.6.2.6.4.3.3</syntax>\n" &
"\t</identification>\n" &
"\t<string-value>BC6BC3B67266C3BA72C3B367C3A970</string-value>\n" &
"</Asn-unr>\n\n";

const charstring str_unr_pci :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<presentation-context-id>42</presentation-context-id>\n" &
"\t</identification>\n" &
"\t<string-value>C3815256C38D5A54C5B052C5902054C3</string-value>\n" &
"</Asn-unr>\n\n";

const charstring str_unr_cneg :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<context-negotiation>\n" &
"\t\t\t<presentation-context-id>17</presentation-context-id>\n" &
"\t\t\t<transfer-syntax>2.1.1</transfer-syntax>\n" &
"\t\t</context-negotiation>\n" &
"\t</identification>\n" &
"\t<string-value>9C4BC3965246C39A52C39347C38950</string-value>\n" &
"</Asn-unr>\n\n";

const charstring str_unr_tsx :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<transfer-syntax>2.1.1</transfer-syntax>\n" &
"\t</identification>\n" &
"\t<string-value>BEEE</string-value>\n" &
"</Asn-unr>\n\n";

const charstring str_unr_fix :=
"<Asn-unr>\n" &
"\t<identification>\n" &
"\t\t<fixed/>\n" &
"\t</identification>\n" &
"\t<string-value>" &
"C3815256C38D5A54C5B052C5902054C39C4BC3965246C39A52C39347C38950" &
"</string-value>\n" &
"</Asn-unr>\n\n" ;

testcase encode_unr() runs on ASN1
{
    var universal charstring expected;

    expected := str_unr_sxs; // syntaxes
    CHECK_METHOD(bxer_enc_unr, val_unr_sxs, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_sxs, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_sxs, expected & lf);

    expected := str_unr_sx; // syntax
    CHECK_METHOD(bxer_enc_unr, val_unr_sx, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_sx, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_sx, expected & lf);

    expected := str_unr_pci; // presentation-context-id
    CHECK_METHOD(bxer_enc_unr, val_unr_pci, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_pci, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_pci, expected & lf);

    expected := str_unr_cneg; // context-negotiation
    CHECK_METHOD(bxer_enc_unr, val_unr_cneg, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_cneg, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_cneg, expected & lf);

    expected := str_unr_tsx; // transfer-syntax
    CHECK_METHOD(bxer_enc_unr, val_unr_tsx, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_tsx, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_tsx, expected & lf);


    expected := str_unr_fix; // fixed
    CHECK_METHOD(bxer_enc_unr, val_unr_fix, expected);
    CHECK_METHOD(exer_enc_unr, val_unr_fix, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_unr, val_unr_fix, expected & lf);
}

testcase decode_unr() runs on ASN1
{
    var Asn_unr expected;

    expected := val_unr_sxs;
    CHECK_DECODE2(unr, str_unr_sxs, Asn_unr, expected);

    expected := val_unr_sx;
    CHECK_DECODE2(unr, str_unr_sx, Asn_unr, expected);

    expected := val_unr_pci;
    CHECK_DECODE2(unr, str_unr_pci, Asn_unr, expected);

    expected := val_unr_cneg;
    CHECK_DECODE2(unr, str_unr_cneg, Asn_unr, expected);

    expected := val_unr_tsx;
    CHECK_DECODE2(unr, str_unr_tsx, Asn_unr, expected);

    expected := val_unr_fix;
    CHECK_DECODE2(unr, str_unr_fix, Asn_unr, expected);
}



/**************************** XXXX ****************************/
DECLARE_XER_ENCODERS(LotsaText, softext);
DECLARE_EXER_ENCODERS(LotsaText,softext)

testcase limerick() runs on ASN1
{
    var LotsaText rval := AsnValues.limerick;
    var universal charstring expected :=
        "<LotsaText>\n" &
        "\t<VisibleString>There was a young fellow named Fisk</VisibleString>\n" &
        "\t<VisibleString>A swordsman, exceedingly brisk</VisibleString>\n" &
        "\t<VisibleString>So fast was his action</VisibleString>\n" &
        "\t<VisibleString>The Lorentz contraction</VisibleString>\n" &
        "\t<VisibleString>Reduced his rapier to a disc</VisibleString>\n" &
        "</LotsaText>\n\n";
    CHECK_METHOD(bxer_enc_softext, rval, expected);
    CHECK_METHOD(exer_enc_softext, rval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_softext, rval, expected & lf);
    // TODO
}




/**************************** XXXX ****************************
DECLARE_XER_ENCODERS(Asn_xxxx, xxxx);
DECLARE_EXER_ENCODERS(Asn_xxxx,xxxx)

testcase xxxx() runs on ASN1
{
    var Asn_xxxx rval := xXxX;
    var yyyy expected := "<XXXX>3.141593</XXXX>";
    CHECK_METHOD(cxer_enc_xxxx, rval, expected);
    CHECK_METHOD(bxer_enc_xxxx, rval, expected & lf);
    CHECK_METHOD(exer_enc_xxxx, rval, expected & lf);
    // TODO
}

--------------- >8 --------------- cut here

*/

// An empty SEQUENCE
DECLARE_XER_ENCODERS(NothingToSeeHere, nix);
DECLARE_EXER_ENCODERS(NothingToSeeHere,nix)

const universal charstring emptyelement := "<NothingToSeeHere/>\n";

testcase encode_emptyrec() runs on ASN1
{

    CHECK_METHOD(cxer_enc_nix, AsnValues.move_along, emptyelement);
    CHECK_METHOD(bxer_enc_nix, AsnValues.move_along, emptyelement & lf);
}

const universal charstring nonempty_element := "<NothingToSeeHere></NothingToSeeHere>\n";
testcase decode_emptyrec() runs on ASN1
{
    CHECK_DECODE2(nix, emptyelement, NothingToSeeHere, AsnValues.move_along);
    // Use of the empty-element form is required for Canonical XER.
    // Basic XER should accept it.
    CHECK_DECODE(bxer_dec_nix, nonempty_element, NothingToSeeHere, AsnValues.move_along);
}

/**************************** choice ****************************/
DECLARE_XER_ENCODERS(Something, smth);
DECLARE_EXER_ENCODERS(Something,smth)

const charstring smth_bitstr :=
  "<Something>\n" &
  "\t<bitstr>01001000100001</bitstr>\n" &
  "</Something>\n\n";

const charstring smth_bool :=
  "<Something>\n" &
  "\t<booool><true/></booool>\n" &
  "</Something>\n\n";

const charstring smth_ebool :=
  "<Something>\n" &
  "\t<booool>true</booool>\n" &
  "</Something>\n\n";

const charstring smth_float :=
  "<Something>\n" &
  "\t<floating>3.141593</floating>\n" &
  "</Something>\n\n";

const charstring smth_barney :=
  "<Something>\n" &
  "\t<cartoon><barney/></cartoon>\n" &
  "</Something>\n\n";

const charstring smth_ebarney :=
  "<Something>\n" &
  "\t<cartoon>barney</cartoon>\n" &
  "</Something>\n\n";

const charstring smth_int :=
  "<Something>\n" &
  "\t<wholenum>42</wholenum>\n" &
  "</Something>\n\n";


testcase encode_something() runs on ASN1
{
    var universal charstring expected;
    {
    var Something eval := { bitstr := '01001000100001'B }
    expected := smth_bitstr;
    CHECK_METHOD(bxer_enc_smth, eval, expected);
    CHECK_METHOD(exer_enc_smth, eval, expected);
    CHECK_METHOD(exer_enc_smth, eval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_smth, eval, expected & lf);
    }

    {
    var Something eval := { booool := true }
    expected := smth_ebool;
    CHECK_METHOD(exer_enc_smth, eval, expected);
    expected := smth_bool;
    CHECK_METHOD(bxer_enc_smth, eval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_smth, eval, expected & lf);
    }

    {
    var Something eval := { floating := 3.141593 };
    expected := smth_float;
    CHECK_METHOD(bxer_enc_smth, eval, expected);
    CHECK_METHOD(exer_enc_smth, eval, expected);
    CHECK_METHOD(exer_enc_smth, eval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_smth, eval, expected & lf);
    }

    {
    var Something neval := { wholenum := 42 };
    expected := smth_int;
    CHECK_METHOD(bxer_enc_smth, neval, expected);
    CHECK_METHOD(exer_enc_smth, neval, expected);
    CHECK_METHOD(exer_enc_smth, neval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_smth, neval, expected & lf);
    }

    {
    var Something feval := { cartoon := barney };
    expected := smth_ebarney;
    CHECK_METHOD(exer_enc_smth, feval, expected);
    expected := smth_barney;
    CHECK_METHOD(bxer_enc_smth, feval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_smth, feval, expected & lf);
    }
}

testcase decode_something() runs on ASN1
{
    var Something expected;

    expected := { bitstr := '01001000100001'B };
    CHECK_DECODE2(smth, smth_bitstr, Something, expected);

    expected := { booool := true };
    CHECK_DECODE2(smth, smth_bool, Something, expected);

    expected := { floating := 3.141593 };
    CHECK_DECODE2(smth, smth_float, Something, expected);

    expected := { wholenum := 42 };
    CHECK_DECODE2(smth, smth_int, Something, expected);

    expected := { cartoon := barney };
    CHECK_DECODE2(smth, smth_barney, Something, expected);
}

/**************************** record ****************************/

DECLARE_XER_ENCODERS(Everything, ev);
DECLARE_EXER_ENCODERS(Everything,ev)
DECLARE_XER_ENCODERS(MaybeEverything, mev);
DECLARE_EXER_ENCODERS(MaybeEverything,mev)

const charstring xer_everything :=
  "<Everything>\n" &
  "\t<bitstr>01011010</bitstr>\n" &
  "\t<booool><true/></booool>\n" &

  "\t<pdv>\n" &
  "\t\t<identification>\n" &
  "\t\t\t<context-negotiation>\n" &
  "\t\t\t\t<presentation-context-id>69</presentation-context-id>\n" &
  "\t\t\t\t<transfer-syntax>2.7.18.28.18.28.45.90.45</transfer-syntax>\n" &
  "\t\t\t</context-negotiation>\n" &
  "\t\t</identification>\n" &
  "\t\t<data-value>C1AFB1</data-value>\n" &
  "\t</pdv>\n" &

  "\t<cartoon><wilma/></cartoon>\n" &

  "\t<outsider>\n" &
  "\t\t<direct-reference>2.1.1</direct-reference>\n" &
  "\t\t<indirect-reference>111</indirect-reference>\n" &
  "\t\t<data-value-descriptor>using context negotiation, both</data-value-descriptor>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>1337D00D</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</outsider>\n" &

  "\t<wholenum>1252</wholenum>\n" &
  "\t<nix/>\n" &
  "\t<emptyrec/>\n" &
  "\t<objection>2.1.1</objection>\n" &
  "\t<octets>BAADF00D</octets>\n" &
  "\t<printer>evth</printer>\n" &
  "\t<floating>3.141593</floating>\n" &
  //"\t<></>\n" &

  "\t<rroid>1.2.826.0.1249</rroid>\n" &

  "</Everything>\n\n";

const charstring exer_everything :=
  "<Everything>\n" &
  "\t<bitstr>01011010</bitstr>\n" &
  "\t<booool>true</booool>\n" & // EXER uses TextBoolean

  "\t<pdv>\n" &
  "\t\t<identification>\n" &
  "\t\t\t<context-negotiation>\n" &
  "\t\t\t\t<presentation-context-id>69</presentation-context-id>\n" &
  "\t\t\t\t<transfer-syntax>2.7.18.28.18.28.45.90.45</transfer-syntax>\n" &
  "\t\t\t</context-negotiation>\n" &
  "\t\t</identification>\n" &
  "\t\t<data-value>C1AFB1</data-value>\n" &
  "\t</pdv>\n" &

  "\t<cartoon>wilma</cartoon>\n" & // EXER

  "\t<outsider>\n" &
  "\t\t<direct-reference>2.1.1</direct-reference>\n" &
  "\t\t<indirect-reference>111</indirect-reference>\n" &
  "\t\t<data-value-descriptor>using context negotiation, both</data-value-descriptor>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>1337D00D</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</outsider>\n" &

  "\t<wholenum>1252</wholenum>\n" &
  "\t<nix/>\n" &
  "\t<emptyrec/>\n" &
  "\t<objection>2.1.1</objection>\n" &
  "\t<octets>BAADF00D</octets>\n" &
  "\t<printer>evth</printer>\n" &
  "\t<floating>3.141593</floating>\n" &
  //"\t<></>\n" &

  "\t<rroid>1.2.826.0.1249</rroid>\n" &

  "</Everything>\n\n";

const Everything evth := {
    bitstr   := '01011010'B,
    booool   := true,
    pdv      := AsnValues.pdv_cneg,
    cartoon  := wilma,
    outsider := AsnValues.ext_cn,
    wholenum := 1252,
    nix      := NULL,
    emptyrec := {},
    objection:= AsnValues.ber_oid,
    octets   := 'BAADF00D'O,
    printer  := "evth",
    floating := 3.141593,
    rroid    := AsnValues.zoid
}


testcase encode_everything() runs on ASN1
{
    var universal charstring expected;
    {
    var Everything eval := evth;
    expected := xer_everything;
    CHECK_METHOD(bxer_enc_ev, eval, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_ev, eval, expected & lf);
    expected := exer_everything;
    CHECK_METHOD(exer_enc_ev, eval, expected);
    }

    {
    var Everything eval := AsnValues.a_evth;
    }

}

testcase decode_everything() runs on ASN1
{
    var Everything expected;
    expected := evth;
    CHECK_DECODE2(ev, xer_everything, Everything, expected);
}

/*********************** record with optional fields ***********************/

const charstring mevstr_all :=
  "<MaybeEverything>\n" &
  "\t<bitstr>01011010</bitstr>\n" &
  "\t<booool><true/></booool>\n" &

  "\t<pdv>\n" &
  "\t\t<identification>\n" &
  "\t\t\t<context-negotiation>\n" &
  "\t\t\t\t<presentation-context-id>69</presentation-context-id>\n" &
  "\t\t\t\t<transfer-syntax>2.7.18.28.18.28.45.90.45</transfer-syntax>\n" &
  "\t\t\t</context-negotiation>\n" &
  "\t\t</identification>\n" &
  "\t\t<data-value>C1AFB1</data-value>\n" &
  "\t</pdv>\n" &

  "\t<cartoon><betty/></cartoon>\n" &

  "\t<outsider>\n" &
  "\t\t<direct-reference>2.1.1</direct-reference>\n" &
  "\t\t<indirect-reference>111</indirect-reference>\n" &
  "\t\t<data-value-descriptor>using context negotiation, both</data-value-descriptor>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>1337D00D</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</outsider>\n" &

  "\t<wholenum>1252</wholenum>\n" &
  "\t<nix/>\n" &
  "\t<anyad>DECAFF</anyad>\n" &
  "\t<emptyrec/>\n" &
  "\t<objection>2.1.1</objection>\n" &
  "\t<octets>BAADF00D</octets>\n" &
  "\t<printer>mev-all</printer>\n" &
  "\t<floating>3.141593</floating>\n" &
  "\t<rroid>1.2.826.0.1249</rroid>\n" &

  "</MaybeEverything>\n\n";

const charstring mevstr_all_exer :=
  "<MaybeEverything>\n" &
  "\t<bitstr>01011010</bitstr>\n" &
  "\t<booool>true</booool>\n" & // EXER uses TextBooleean

  "\t<pdv>\n" &
  "\t\t<identification>\n" &
  "\t\t\t<context-negotiation>\n" &
  "\t\t\t\t<presentation-context-id>69</presentation-context-id>\n" &
  "\t\t\t\t<transfer-syntax>2.7.18.28.18.28.45.90.45</transfer-syntax>\n" &
  "\t\t\t</context-negotiation>\n" &
  "\t\t</identification>\n" &
  "\t\t<data-value>C1AFB1</data-value>\n" &
  "\t</pdv>\n" &

  "\t<cartoon>betty</cartoon>\n" & // EXER uses TextEnumerated

  "\t<outsider>\n" &
  "\t\t<direct-reference>2.1.1</direct-reference>\n" &
  "\t\t<indirect-reference>111</indirect-reference>\n" &
  "\t\t<data-value-descriptor>using context negotiation, both</data-value-descriptor>\n" &
  "\t\t<encoding>\n" &
  "\t\t\t<octet-aligned>1337D00D</octet-aligned>\n" &
  "\t\t</encoding>\n" &
  "\t</outsider>\n" &

  "\t<wholenum>1252</wholenum>\n" &
  "\t<nix/>\n" &
  "\t<anyad>DECAFF</anyad>\n" &
  "\t<emptyrec/>\n" &
  "\t<objection>2.1.1</objection>\n" &
  "\t<octets>BAADF00D</octets>\n" &
  "\t<printer>mev-all</printer>\n" &
  "\t<floating>3.141593</floating>\n" &
  "\t<rroid>1.2.826.0.1249</rroid>\n" &

  "</MaybeEverything>\n\n";

const MaybeEverything mev_all := {
    bitstr   := '01011010'B,
    booool   := true,
    pdv      := AsnValues.pdv_cneg,
    cartoon  := betty,
    outsider := AsnValues.ext_cn,
    wholenum := 1252,
    nix      := NULL,
    anyad    := 'DECAFF'O,
    emptyrec := {},
    objection:= AsnValues.ber_oid,
    octets   := 'BAADF00D'O,
    printer  := "mev-all",
    floating := 3.141593,
    rroid    := AsnValues.zoid
};

const charstring mevstr_none := "<MaybeEverything/>\n\n";
const MaybeEverything mev_none := {
    bitstr   := omit,
    booool   := omit,
    pdv      := omit,
    cartoon  := omit,
    outsider := omit,
    wholenum := omit,
    nix      := omit,
    anyad    := omit,
    emptyrec := omit,
    objection:= omit,
    octets   := omit,
    printer  := omit,
    floating := omit,
    rroid    := omit
};

const charstring mevstr_bits :=
  "<MaybeEverything>\n" &
  "\t<bitstr>1010101001010101</bitstr>\n" &
  "</MaybeEverything>\n\n";

const MaybeEverything mev_bits := {
    bitstr   := '1010101001010101'B,
    booool   := omit,
    pdv      := omit,
    cartoon  := omit,
    outsider := omit,
    wholenum := omit,
    nix      := omit,
    anyad    := omit,
    emptyrec := omit,
    objection:= omit,
    octets   := omit,
    printer  := omit,
    floating := omit,
    rroid    := omit
};

const charstring mevstr_bitsbool :=
  "<MaybeEverything>\n" &
  "\t<bitstr>1010101001010101</bitstr>\n" &
  "\t<booool><false/></booool>\n" &
  "</MaybeEverything>\n\n";

const charstring mevstr_bitsbool_exer :=
  "<MaybeEverything>\n" &
  "\t<bitstr>1010101001010101</bitstr>\n" &
  "\t<booool>false</booool>\n" & // EXER
  "</MaybeEverything>\n\n";

const MaybeEverything mev_bitsbool := {
    bitstr   := '1010101001010101'B,
    booool   := false,
    pdv      := omit,
    cartoon  := omit,
    outsider := omit,
    wholenum := omit,
    nix      := omit,
    anyad    := omit,
    emptyrec := omit,
    objection:= omit,
    octets   := omit,
    printer  := omit,
    floating := omit,
    rroid    := omit
};

const charstring mevstr_3 :=
  "<MaybeEverything>\n" &
  "\t<bitstr>1010101001010101</bitstr>\n" &
  "\t<booool><false/></booool>\n" &
  "\t<cartoon><fred/></cartoon>\n" &
  "</MaybeEverything>\n\n";

const charstring mevstr_3_exer :=
  "<MaybeEverything>\n" &
  "\t<bitstr>1010101001010101</bitstr>\n" &
  "\t<booool>false</booool>\n" &  // EXER
  "\t<cartoon>fred</cartoon>\n" & // EXER
  "</MaybeEverything>\n\n";

const MaybeEverything mev_3 := {
    bitstr   := '1010101001010101'B,
    booool   := false,
    pdv      := omit,
    cartoon  := fred,
    outsider := omit,
    wholenum := omit,
    nix      := omit,
    anyad    := omit,
    emptyrec := omit,
    objection:= omit,
    octets   := omit,
    printer  := omit,
    floating := omit,
    rroid    := omit
};


testcase encode_everything_opt() runs on ASN1
{
    var universal charstring expected;
    expected := mevstr_all;
    CHECK_METHOD(bxer_enc_mev, mev_all, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_mev, mev_all, expected & lf);
    expected := mevstr_all_exer;
    CHECK_METHOD(exer_enc_mev, mev_all, expected);

    expected := mevstr_none;
    CHECK_METHOD(bxer_enc_mev, mev_none, expected);
    CHECK_METHOD(exer_enc_mev, mev_none, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_mev, mev_none, expected & lf);

    expected := mevstr_bits;
    CHECK_METHOD(bxer_enc_mev, mev_bits, expected);
    CHECK_METHOD(exer_enc_mev, mev_bits, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_mev, mev_bits, expected & lf);

    expected := mevstr_bitsbool;
    CHECK_METHOD(bxer_enc_mev, mev_bitsbool, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_mev, mev_bitsbool, expected & lf);
    expected := mevstr_bitsbool_exer;
    CHECK_METHOD(exer_enc_mev, mev_bitsbool, expected);

    expected := mevstr_3;
    CHECK_METHOD(bxer_enc_mev, mev_3, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_mev, mev_3, expected & lf);
    expected := mevstr_3_exer;
    CHECK_METHOD(exer_enc_mev, mev_3, expected);
}

testcase decode_everything_opt() runs on ASN1
{
    CHECK_DECODE2(mev, mevstr_all, MaybeEverything, mev_all);
    CHECK_DECODE2(mev, mevstr_none, MaybeEverything, mev_none);
    CHECK_DECODE2(mev, mevstr_bits, MaybeEverything, mev_bits);
    CHECK_DECODE2(mev, mevstr_bitsbool, MaybeEverything, mev_bitsbool);
    CHECK_DECODE2(mev, mevstr_3, MaybeEverything, mev_3);
}

/**************************** enumerated ****************************/

DECLARE_XER_ENCODERS(Flintstones, flin);
DECLARE_EXER_ENCODERS(Flintstones,flin)

const universal charstring fredstr_exer  := "fred";
const universal charstring barneystr_exer:= "barney";
const universal charstring wilmastr_exer := "wilma";
const universal charstring bettystr_exer := "betty";

const universal charstring fredstr  := "<" & fredstr_exer   & "/>";
const universal charstring barneystr:= "<" & barneystr_exer & "/>";
const universal charstring wilmastr := "<" & wilmastr_exer  & "/>";
const universal charstring bettystr := "<" & bettystr_exer  & "/>";

const universal charstring fred_nested_exer  := "<Flintstones>" & fredstr_exer   & "</Flintstones>\n\n";
const universal charstring barney_nested_exer:= "<Flintstones>" & barneystr_exer & "</Flintstones>\n\n";
const universal charstring wilma_nested_exer := "<Flintstones>" & wilmastr_exer  & "</Flintstones>\n\n";
const universal charstring betty_nested_exer := "<Flintstones>" & bettystr_exer  & "</Flintstones>\n\n";

const universal charstring fred_nested  := "<Flintstones>" & fredstr   & "</Flintstones>\n";
const universal charstring barney_nested:= "<Flintstones>" & barneystr & "</Flintstones>\n";
const universal charstring wilma_nested := "<Flintstones>" & wilmastr  & "</Flintstones>\n";
const universal charstring betty_nested := "<Flintstones>" & bettystr  & "</Flintstones>\n";

testcase encode_flintstones() runs on ASN1
{
    CHECK_METHOD(bxer_enc_flin, fred, fred_nested & lf);
    CHECK_METHOD(exer_enc_flin, fred, fred_nested_exer);
    CHECK_METHOD(cxer_enc_flin, fred, fred_nested);

    CHECK_METHOD(bxer_enc_flin, barney, barney_nested & lf);
    CHECK_METHOD(exer_enc_flin, barney, barney_nested_exer);
    CHECK_METHOD(cxer_enc_flin, barney, barney_nested);

    CHECK_METHOD(bxer_enc_flin, wilma, wilma_nested & lf);
    CHECK_METHOD(exer_enc_flin, wilma, wilma_nested_exer);
    CHECK_METHOD(cxer_enc_flin, wilma, wilma_nested);

    CHECK_METHOD(bxer_enc_flin, betty, betty_nested & lf);
    CHECK_METHOD(exer_enc_flin, betty, betty_nested_exer);
    CHECK_METHOD(cxer_enc_flin, betty, betty_nested);

}

testcase decode_flintstones() runs on ASN1
{
    var Flintstones expected;

    expected := fred;
    CHECK_DECODE2(flin, fred_nested, Flintstones, expected);

    expected := barney;
    CHECK_DECODE2(flin, barney_nested, Flintstones, expected);

    expected := wilma;
    CHECK_DECODE2(flin, wilma_nested, Flintstones, expected);

    expected := betty;
    CHECK_DECODE2(flin, betty_nested, Flintstones, expected);
}

/**************************** set of enumerated ****************************/

DECLARE_XER_ENCODERS(Family, fam);
DECLARE_EXER_ENCODERS(Family,fam)

const universal charstring rubblestr :=
"<Family>\n\t" & barneystr & bettystr & "\n</Family>\n\n";

const universal charstring nobodystr :=
"<Family/>\n\n";

const universal charstring allstr :=
"<Family>\n\t" & fredstr & wilmastr & bettystr & barneystr & "\n</Family>\n\n";

const universal charstring allstr_exer :=
"<Family>\n" &
"\t<Flintstones>" & fredstr_exer   & "</Flintstones>\n" &
"\t<Flintstones>" & wilmastr_exer  & "</Flintstones>\n" &
"\t<Flintstones>" & bettystr_exer  & "</Flintstones>\n" &
"\t<Flintstones>" & barneystr_exer & "</Flintstones>\n" &
"</Family>\n\n";

const Family nobody := {}
const Family alll := { fred, wilma, betty, barney }

testcase encode_family() runs on ASN1
{
    //family rubble := { barney, betty }
    var universal charstring expected;

    expected := rubblestr;
    CHECK_METHOD(bxer_enc_fam, AsnValues.rubble, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_fam, AsnValues.rubble, expected & lf);

    expected := nobodystr;
    CHECK_METHOD(bxer_enc_fam, nobody, expected);
    CHECK_METHOD(exer_enc_fam, nobody, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_fam, nobody, expected & lf);

    expected := allstr;
    CHECK_METHOD(bxer_enc_fam, alll, expected);
    flatten(expected);
    CHECK_METHOD(cxer_enc_fam, alll, expected & lf);
    expected := allstr_exer;
    CHECK_METHOD(exer_enc_fam, alll, expected);
}

testcase decode_family() runs on ASN1
{
    //         suffix, input    , type  , expected
    CHECK_DECODE2(fam, rubblestr, Family, AsnValues.rubble);
    CHECK_DECODE2(fam, nobodystr, Family, nobody);
    CHECK_DECODE2(fam, allstr   , Family, alll);
}

const universal charstring nagy_arvizturo :=
  char(0,0,0,193) & "RV" & char(0,0,0,205) & "ZT" & char(0,0,1,112) & "R" &
  char(0,0,1,80) & " T" & char(0,0,0,220) & "K" & char(0,0,0,214) & "RF" &
  char(0,0,0,218) & "R" & char(0,0,0,211) & "G" & char(0,0,0,201) & "P";
const universal charstring kis_arvizturo :=
  char(0,0,0,225) & "rv" & char(0,0,0,237) & "zt" & char(0,0,1,113) & "r" &
  char(0,0,1,81) & " t" & char(0,0,0,252) & "k" & char(0,0,0,246) & "rf" &
  char(0,0,0,250) & "r" & char(0,0,0,243) & "g" & char(0,0,0,233) & "p";


//////////////////////////////////////////////////////////////////////////
//
// Control part
//
//////////////////////////////////////////////////////////////////////////

control {
    execute(encode_bs());
    execute(encode_abool());
    execute(encode_pdv());
    execute(encode_ext());
    execute(encode_aint());
    execute(encode_nul());
    execute(encode_oid());
    execute(encode_roid());
    execute(encode_os());
    execute(encode_real());

    execute(encode_ia5str());
    execute(encode_utf());
    execute(encode_restricted_strings());

    execute(encode_unr());

    execute(encode_emptyrec());
    execute(encode_something());
    execute(encode_everything());
    execute(encode_everything_opt());

    execute(encode_flintstones());
    execute(encode_family());

    execute(limerick());

    execute(decode_bs());
    execute(decode_abool());
    execute(decode_pdv());
    execute(decode_ext());
    execute(decode_aint());
    execute(decode_nul());
    execute(decode_oid());
    execute(decode_roid());
    execute(decode_os());
    execute(decode_real());

    execute(decode_ia5str());
    execute(decode_utf());
    execute(decode_restricted_strings());

    execute(decode_unr());

    execute(decode_emptyrec());
    execute(decode_something());
    execute(decode_everything());
    execute(decode_everything_opt());

    execute(decode_flintstones());
    execute(decode_family());
}


}
with {
  encode "XML";
  extension "version R8A";
}
