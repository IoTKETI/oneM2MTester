/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Balasko, Jeno
 *   Baranyi, Botond
 *   Bartha, Norbert
 *   Delic, Adam
 *   Dimitrov, Peter
 *   Forstner, Matyas
 *   Koppany, Csaba
 *   Kovacs, Ferenc
 *   Raduly, Csaba
 *   Szabados, Kristof
 *   Szabo, Janos Zoltan â€“ initial implementation
 *
 ******************************************************************************/
module TcommMessage {

import from ImplMsgEncData all;

type enumerated commMessage_tenum {exx1,exx2,exx3};
type record commMessage_trecord {
	integer x1 optional,
	float x2 };
type record of octetstring commMessage_trecof;
type set commMessage_tset {
	integer x1,
	float x2 optional };
type set of charstring commMessage_tsetof;
type union commMessage_tunion {
	integer x1,
	float x2 };
type integer commMessage_tarray[3][2];

template commMessage_trecord commMessage_temp1 :={
 x1:=(2,4,6),
 x2:=(1.2 .. 2.1) };

template commMessage_trecord commMessage_temp2(integer xt) :={
 x1:=xt,
 x2:=(1.2 .. 2.1) };

template commMessage_tarray commMessage_temp3:= {{1,1},{2,2},{3,3}};

type port commMessage_port1 message
{ inout integer } with { extension "internal" };

//port for testing of sending different types
type port commMessage_port2 message
{ inout float, boolean, bitstring, octetstring, charstring, commMessage_tenum, commMessage_trecord,commMessage_trecof, commMessage_tsetof, commMessage_tset, commMessage_tunion, commMessage_tarray
} with { extension "internal" };

type commMessage_port2 commMessage_port2Alias; // testing type alias on components
type component C { } // testing type alias on components
type C C2;

type component commMessage_comp1 {
 port commMessage_port1 Port1;
 var integer xx1;
 };

type component commMessage_comp2 {
 port commMessage_port1 Port2[5];
 var integer xx2;
 };

type component commMessage_comp3 {
 port commMessage_port2 Port3;
 var integer xx3;
 };

type component commMessage_comp4 {
 port commMessage_port2 Port4[5];
 var integer xx4;
 };

type component commInterPTC_comp1 {
  port commMessage_port2 Port1;
  port commMessage_port2 Port2;
 };

type record R { // to check referencing optional component members
  C f optional
}

function checkOptionalComponent(inout R par) {// to check referencing optional component members
  par.f := C.create;
  if (par.f.running or par.f.alive) { }
  par.f.stop;
  par.f.kill;
  par.f.done;
  par.f.killed;
}

function commMessage_behav1(integer xxx) runs on commMessage_comp1 {
				//sends back x+param
while (true) {
  Port1.receive(integer:?) -> value xx1;
  xx1:=xx1+xxx;
  Port1.send(xx1);
}
};

function commMessage_behav2() runs on commMessage_comp3 {
var charstring xchar;			// sends back x
var float xfloat;
var boolean xbool;
var bitstring xbitstr;
var octetstring xoctetstr;
var charstring xcharstr;
var commMessage_tenum xenum;
var commMessage_trecord xrecord;
var commMessage_trecof xrecof;
var commMessage_tset xset;
var commMessage_tsetof xsetof;
var commMessage_tunion xunion;
var commMessage_tarray xarray;
alt {
 [] Port3.receive(charstring:?) -> value xchar {Port3.send(xchar)} ;
 [] Port3.receive(float:?) -> value xfloat {Port3.send(xfloat)} ;
 [] Port3.receive(boolean:?) -> value xbool {Port3.send(xbool)} ;
 [] Port3.receive(bitstring:?) -> value xbitstr {Port3.send(xbitstr)} ;
 [] Port3.receive(octetstring:?) -> value xoctetstr {Port3.send(xoctetstr)} ;
 [] Port3.receive(charstring:?) -> value xcharstr {Port3.send(xcharstr)} ;
 [] Port3.receive(commMessage_tenum:?) -> value xenum {Port3.send(xenum)} ;
 [] Port3.receive(commMessage_trecord:?) -> value xrecord {Port3.send(xrecord); repeat; } ;
 [] Port3.receive(commMessage_trecof:?) -> value xrecof {Port3.send(xrecof)} ;
 [] Port3.receive(commMessage_tset:?) -> value xset {Port3.send(xset)} ;
 [] Port3.receive(commMessage_tsetof:?) -> value xsetof {Port3.send(xsetof)} ;
 [] Port3.receive(commMessage_tunion:?) -> value xunion {Port3.send(xunion)} ;
 [] Port3.receive(commMessage_tarray:?) -> value xarray {Port3.send(xarray)} ;
};
};

testcase commMessageIntegerEncode() runs on commMessage_comp1
{
    const integer values[8] := { 0, 1, -1, 10000, -100000, 2147483647,
	-2147483647, -2147483646 };
    var commMessage_comp1 ptc;
    timer T1 := 1.0;
    for (var integer i := 0; i < 8; i := i + 1) {
	ptc := commMessage_comp1.create;
	connect(self:Port1, ptc:Port1);
	ptc.start(commMessage_behav1(values[i]));
	Port1.send(0);
	T1.start;
	alt {
	[] Port1.receive(values[i]) { T1.stop; setverdict(pass); }
	[] Port1.receive { T1.stop; setverdict(fail); }
	[] T1.timeout { setverdict(fail); }
	}
	disconnect(self:Port1, ptc:Port1);
	ptc.stop;
    }
    ptc := commMessage_comp1.create;
    connect(self:Port1, ptc:Port1);
    ptc.start(commMessage_behav1(0));
    for (var integer i := 0; i < 8; i := i + 1) {
	Port1.send(values[i]);
	T1.start;
	alt {
	[] Port1.receive(values[i]) { T1.stop; setverdict(pass); }
	[] Port1.receive { T1.stop; setverdict(fail); }
	[] T1.timeout { setverdict(fail); }
	}
    }
    disconnect(self:Port1, ptc:Port1);
    ptc.stop;
}

testcase commMessageValue() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // sending and receiving of data, value checked
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[i],comp[i]:Port1);
  xxint:=5;
  Port2[i].send(xxint);
  Port2[i].receive(integer:?) -> value xxint;
  if (xxint==5+i) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageReceiveAny() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // receive any message
var commMessage_comp1 xxadr;
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[i],comp[i]:Port1);
  xxint:=5;
  Port2[i].send(xxint);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
   [] Port2[i].receive -> sender xxadr {setverdict(pass)};
   [] T1.timeout  {setverdict(fail)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageReceiveAnyPort() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // receive message on any port
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[i],comp[i]:Port1);
}
  xxint:=5;
  Port2[2].send(xxint);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
//   [] any port.receive(xxint+2) {setverdict(pass)};
   [] any port.receive {setverdict(pass)};
   [] T1.timeout  {setverdict(fail)};
   }
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTo() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // sending data to a given partner
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
  xxint:=5;
  Port2[0].send(xxint) to comp[3];
  Port2[0].receive(integer:?) -> value xxint;
  if (xxint==5+3) {setverdict(pass)}
    else {setverdict(fail)};
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageSender1() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // storing sender (component type)
var commMessage_comp1 xxcomp;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
for (i:=0; i<5; i:=i+1)
{  xxint:=5;
  Port2[0].send(xxint) to comp[i];
  Port2[0].receive(integer:?) -> value xxint sender xxcomp;
  if (xxcomp==comp[i]) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxint==5+i) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageSender2() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // storing sender
var commMessage_comp1 xxaddr;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
for (i:=0; i<5; i:=i+1)
{ xxint:=5;
  Port2[0].send(xxint) to comp[i];
  Port2[0].receive(integer:?) -> sender xxaddr;
  xxint:=5;
  Port2[0].send(xxint) to xxaddr;
  Port2[0].receive(integer:?) -> value xxint;
  if (xxint==i+5) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageFrom() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // receiving data from a given partner
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
  xxint:=5;
for (i:=0; i<5; i:=i+1) {   Port2[0].send(xxint) to comp[i]; }
if(T1.running) {T1.stop};
T1.start;
alt {
  [] Port2[0].receive(integer:?) from comp[3] -> value xxint {};
  [] Port2[0].receive(integer:?) {repeat};
  [] T1.timeout {setverdict(fail)};
}
if (xxint==5+3) {setverdict(pass)}
   else {setverdict(fail)};
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTemplate1() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // receiving with template
timer T1:=0.5;
var integer temp1,temp2;
temp1:=2;
var commMessage_trecord xxrecord:={x1:=temp1, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);		// matching
  if(T1.running) {T1.stop};
  T1.start;
  alt {
    [] Port4[i].receive(commMessage_temp1) -> value xxrecord {};
    [] T1.timeout {setverdict(fail)};
   }
  temp2:=xxrecord.x1;
  if (temp2==2) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
xxrecord.x2:=3.1;
for (i:=0; i<5; i:=i+1) {    // not matching
  Port4[i].send(xxrecord);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
    [] Port4[i].receive(commMessage_temp1) -> value xxrecord {setverdict(fail)};
    [] T1.timeout {setverdict(pass)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageTemplate2() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // receiving with parametrized template
timer T1:=0.5;
var integer temp1,temp2;
temp1:=2;
var commMessage_trecord xxrecord:={x1:=temp1, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);		// matching
  if(T1.running) {T1.stop};
  T1.start;
  alt {
    [] Port4[i].receive(commMessage_temp2(2)) -> value xxrecord {};
//    [] Port4[i].receive(commMessage_temp1) -> value xxrecord {};
    [] T1.timeout {setverdict(fail)};
   }
  temp2:=xxrecord.x1;
  if (temp2==2) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
xxrecord.x2:=3.1;
for (i:=0; i<5; i:=i+1) {    // not matching
  Port4[i].send(xxrecord);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
//    [] Port4[i].receive(commMessage_temp2(2)) -> value xxrecord {setverdict(fail)};
    [] Port4[i].receive(commMessage_temp1) -> value xxrecord {setverdict(fail)};
    [] T1.timeout {setverdict(pass)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTrigger() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger operation
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connects all ptc-s to one port
};
  xxint:=5;
for (i:=0; i<5; i:=i+1) {
  Port2[0].send(xxint) to comp[i];
};
if(T1.running) {T1.stop};
T1.start;
alt {
  [] Port2[0].trigger(integer:7)  {setverdict(pass)};
  [] T1.timeout {setverdict(fail)};
  }
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerValue() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger operation, values checked
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connects all ptc-s to one port
};
  xxint:=5;
for (i:=0; i<5; i:=i+1) {
  Port2[0].send(xxint) to comp[i];
};
if(T1.running) {T1.stop};
T1.start;
alt {
  [] Port2[0].trigger(integer:7) -> value xxint {setverdict(pass)};
  [] T1.timeout {setverdict(fail)};
  }
if (xxint==7) {setverdict(pass)}
    else {setverdict(fail)};
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerAny() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger any message
var commMessage_comp1 xxadr;
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[i],comp[i]:Port1);
  xxint:=5;
  Port2[i].send(xxint);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
   [] Port2[i].trigger -> sender xxadr {setverdict(pass)};
   [] T1.timeout  {setverdict(fail)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerAnyPort() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger message on any port
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[i],comp[i]:Port1);
}
  xxint:=5;
  Port2[2].send(xxint);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
//   [] any port.trigger(xxint+2) {setverdict(pass)};
   [] any port.trigger {setverdict(pass)};
   [] T1.timeout  {setverdict(fail)};
   }
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerSender1() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger, storing sender (component type)
var commMessage_comp1 xxcomp;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
for (i:=0; i<5; i:=i+1) {
  xxint:=5;
  Port2[0].send(xxint) to comp[i];
  Port2[0].trigger(integer:?) -> value xxint sender xxcomp;
  if (xxcomp==comp[i]) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxint==5+i) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerSender2() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger, storing sender
var commMessage_comp1 xxaddr;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
for (i:=0; i<5; i:=i+1) {
  xxint:=5;
  Port2[0].send(xxint) to comp[i];
  Port2[0].trigger(integer:?) -> sender xxaddr;
  xxint:=5;
  Port2[0].send(xxint) to xxaddr;
  Port2[0].trigger(integer:?) -> value xxint;
  if (xxint==5+i) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageTriggerFrom() runs on commMessage_comp2 {
var commMessage_comp1 comp[5];   // trigger, from a given partner
timer T1:=1.0;
var integer xxint;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp1.create;
  comp[i].start(commMessage_behav1(i));
  connect(self:Port2[0],comp[i]:Port1); // connect all of the ptc-s to the same port
}
  xxint:=5;
for (i:=0; i<5; i:=i+1) {   Port2[0].send(xxint) to comp[i]; }
if(T1.running) {T1.stop};
T1.start;
alt {
  [] Port2[0].trigger(integer:?) from comp[3] -> value xxint {};
//  [] Port2[0].receive(integer:?) {repeat};
  [] T1.timeout {setverdict(fail)};
}
if (xxint==5+3) {setverdict(pass)}
   else {setverdict(fail)};
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageTriggerTemplate1() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // trigger with template
timer T1:=0.5;
var integer temp1,temp2;
temp1:=2;
var commMessage_trecord xxrecord:={x1:=temp1, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);		// matching
  if(T1.running) {T1.stop};
  T1.start;
  alt {
    [] Port4[i].trigger(commMessage_temp1) -> value xxrecord {};
 //   [] Port4[i].receive(commMessage_trecord:?) -> value xxrecord {};
    [] T1.timeout {setverdict(fail)};
   }
  temp2:=xxrecord.x1;
  if (temp2==2) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
xxrecord.x2:=3.1;
for (i:=0; i<5; i:=i+1) {    // not matching
  Port4[i].send(xxrecord);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
    [] Port4[i].trigger(commMessage_temp1) -> value xxrecord {setverdict(fail)};
    [] T1.timeout {setverdict(pass)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageTriggerTemplate2() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // trigger with parametrized template
timer T1:=0.5;
var integer temp1,temp2;
temp1:=2;
var commMessage_trecord xxrecord:={x1:=temp1, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);		// matching
  if(T1.running) {T1.stop};
  T1.start;
  alt {
//    [] Port4[i].trigger(commMessage_temp2(2)) -> value xxrecord {};
    [] Port4[i].trigger(commMessage_temp1) -> value xxrecord {};
    [] T1.timeout {setverdict(fail)};
   }
  temp2:=xxrecord.x1;
  if (temp2==2) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
xxrecord.x2:=3.1;
for (i:=0; i<5; i:=i+1) {    // not matching
  Port4[i].send(xxrecord);
  if(T1.running) {T1.stop};
  T1.start;
  alt {
//    [] Port4[i].trigger(commMessage_temp2(2)) -> value xxrecord {setverdict(fail)};
    [] Port4[i].trigger(commMessage_temp1) -> value xxrecord {setverdict(fail)};
    [] T1.timeout {setverdict(pass)};
   }
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

//*****************************************************************

testcase commMessageChar() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of char type
var charstring xxchar:="a";
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxchar);
  xxchar:="b";
  Port4[i].receive(charstring:?) -> value xxchar;
  if (xxchar=="a") {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageFloat() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of float type
var float xxfloat:=1.23;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxfloat);
  xxfloat:=123.5;
  Port4[i].receive(float:?) -> value xxfloat;
  if (xxfloat==1.23) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageBool() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of boolean type
var boolean xxbool:=true;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxbool);
  xxbool:=false;
  Port4[i].receive(boolean:?) -> value xxbool;
  if (xxbool==true) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageBitstr() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of bitstring type
var bitstring xxbitstr:='0101'B;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxbitstr);
  xxbitstr:='0000'B;
  Port4[i].receive(bitstring:?) -> value xxbitstr;
  if (xxbitstr=='0101'B) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageOctetstr() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of octetstring type
var octetstring xxoctetstr:='01AB'O;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxoctetstr);
  xxoctetstr:='0000'O;
  Port4[i].receive(octetstring:?) -> value xxoctetstr;
  if (xxoctetstr=='01AB'O) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageCharstr() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of charstring type
var charstring xxcharstr:="abcd";
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxcharstr);
  xxcharstr:="aaaa";
  Port4[i].receive(charstring:?) -> value xxcharstr;
  if (xxcharstr=="abcd") {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageEnum() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of enumerated type
var commMessage_tenum xxenum:=exx1;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxenum);
  xxenum:=exx2;
  Port4[i].receive(commMessage_tenum:?) -> value xxenum;
  if (xxenum==exx1) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageRecord() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of record type with opt. field
var integer temp1,temp2;
temp1:=1;
var commMessage_trecord xxrecord:={x1:=temp1, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);
  temp2:=2;
  xxrecord:={x1:=temp2,x2:=1.4};
  Port4[i].receive(commMessage_trecord:?) -> value xxrecord;
  temp2:=xxrecord.x1;
  if (temp2==1) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageRecordOmit() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of record type with omitted field
var integer temp1,temp2;
temp1:=1;
temp2:=2;
var commMessage_trecord xxrecord:={x1:=omit, x2:=1.2} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecord);
  xxrecord:={x1:=temp2,x2:=1.4};
  Port4[i].receive(commMessage_trecord:?) -> value xxrecord;
  if (not(ispresent(xxrecord.x1))) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecord.x2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageRecof() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of record of type
var commMessage_trecof xxrecof:={'00AB'O,'AB00'O};
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxrecof);
  xxrecof:={'00'O};
  Port4[i].receive(commMessage_trecof:?) -> value xxrecof;
  if (xxrecof[0]=='00AB'O) {setverdict(pass)}
    else {setverdict(fail)};
  if (xxrecof[1]=='AB00'O) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageSet() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of set type with opt. field
var float temp1,temp2;
temp1:=1.2;
var commMessage_tset xxset:={x1:=1, x2:=temp1} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxset);
  temp2:=2.4;
  xxset:={x1:=2,x2:=temp2};
  Port4[i].receive(commMessage_tset:?) -> value xxset;
  temp2:=xxset.x2;
  if (xxset.x1==1) {setverdict(pass)}
    else {setverdict(fail)};
  if (temp2==1.2) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageSetOmit() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of set type with omitted field
var float temp1,temp2;
temp1:=1.2;
var commMessage_tset xxset:={x1:=1, x2:=omit} ;
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxset);
  temp2:=2.4;
  xxset:={x1:=2,x2:=temp2};
  Port4[i].receive(commMessage_tset:?) -> value xxset;
  if (xxset.x1==1) {setverdict(pass)}
    else {setverdict(fail)};
  if (not(ispresent(xxset.x2))) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageSetof() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of set of type
var commMessage_tsetof xxsetof:={"a","b"};
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxsetof);
  xxsetof:={"k"};
  Port4[i].receive(commMessage_tsetof:?) -> value xxsetof;
  if (xxsetof[0]=="a") {setverdict(pass)}
    else {setverdict(fail)};
  if (xxsetof[1]=="b") {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};


testcase commMessageUnion() runs on commMessage_comp4 {
var commMessage_comp3 comp[5];   // sending and receiving of union type
var commMessage_tunion xxunion:={x1:=1};
var integer i;
for (i:=0; i<5; i:=i+1)
{ log(i);
  comp[i]:=commMessage_comp3.create;
  comp[i].start(commMessage_behav2());
  connect(self:Port4[i],comp[i]:Port3);
  Port4[i].send(xxunion);
  xxunion:={x2:=1.3};
  Port4[i].receive(commMessage_tunion:?) -> value xxunion;
  if (xxunion.x1==1) {setverdict(pass)}
    else {setverdict(fail)};
  if (ischosen(xxunion.x1)) {setverdict(pass)}
    else {setverdict(fail)};
  if (not(ischosen(xxunion.x2))) {setverdict(pass)}
    else {setverdict(fail)};
}
for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageArray() runs on commMessage_comp4 {
  var commMessage_comp3 comp[5];   // sending and receiving of array type
  var commMessage_tarray xxarray:={{1,1},{2,2},{3,3}};
  var integer i;
  for (i:=0; i<5; i:=i+1)
  { log(i);
    comp[i]:=commMessage_comp3.create;
    comp[i].start(commMessage_behav2());
    connect(self:Port4[i],comp[i]:Port3);
    Port4[i].send(xxarray);
    xxarray[0][1]:=10;
    Port4[i].receive(commMessage_tarray:?) -> value xxarray;
    if(match(xxarray,commMessage_temp3))
    {setverdict(pass)}
    else
    {setverdict(fail)};
  }
  for (i:=0; i<5; i:=i+1) {comp[i].stop};
};

testcase commMessageInterPTCLocalConnection1() runs on commInterPTC_comp1 {
  var charstring vl_char := "a";
  var float vl_float := 1.23;
  var boolean vl_bool := true;
  var bitstring vl_bitstr := '0101'B;
  var octetstring vl_octetstr := '01AB'O;
  var charstring vl_charstr := "abcd";
  var commMessage_tenum vl_enum := exx1;
  var commMessage_trecord vl_record := { x1 := 1, x2 := 1.2 };
  var commMessage_trecof vl_recof := { '00AB'O, 'AB00'O };
  var commMessage_tset vl_set := { x1 := 1, x2 := 1.2 };
  var commMessage_tsetof vl_setof := { "a", "b" };
  var commMessage_tunion vl_union := { x1:=1 };
  var commMessage_tarray vl_array := {{1,1},{2,2},{3,3}};

  var charstring vl_xchar;
  var float vl_xfloat;
  var boolean vl_xbool;
  var bitstring vl_xbitstr;
  var octetstring vl_xoctetstr;
  var charstring vl_xcharstr;
  var commMessage_tenum vl_xenum;
  var commMessage_trecord vl_xrecord;
  var commMessage_trecof vl_xrecof;
  var commMessage_tset vl_xset;
  var commMessage_tsetof vl_xsetof;
  var commMessage_tunion vl_xunion;
  var commMessage_tarray vl_xarray;

  timer Tl_t := 0.5;

  connect(self:Port1,self:Port2);

  Port2.send(vl_char);
  Tl_t.start;
	alt {
	[] Port1.receive(charstring: ?) -> value vl_xchar
    { Tl_t.stop;
      if(vl_xchar == vl_char) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_float);
  Tl_t.start;
	alt {
	[] Port1.receive(float: ?) -> value vl_xfloat
    { Tl_t.stop;
      if(vl_xfloat == vl_float) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_bool);
  Tl_t.start;
	alt {
	[] Port1.receive(boolean: ?) -> value vl_xbool
    { Tl_t.stop;
      if(vl_xbool == vl_bool) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_bitstr);
  Tl_t.start;
	alt {
	[] Port1.receive(bitstring: ?) -> value vl_xbitstr
    { Tl_t.stop;
      if(vl_xbitstr == vl_bitstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_octetstr);
  Tl_t.start;
	alt {
	[] Port1.receive(octetstring: ?) -> value vl_xoctetstr
    { Tl_t.stop;
      if(vl_xoctetstr == vl_octetstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_charstr);
  Tl_t.start;
	alt {
	[] Port1.receive(charstring: ?) -> value vl_xcharstr
    { Tl_t.stop;
      if(vl_xcharstr == vl_charstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_enum);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tenum: ?) -> value vl_xenum
    { Tl_t.stop;
      if(vl_xenum == vl_enum) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_record);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_trecord: ?) -> value vl_xrecord
    { Tl_t.stop;
      if(vl_xrecord == vl_record) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_recof);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_trecof: ?) -> value vl_xrecof
    { Tl_t.stop;
      if(vl_xrecof == vl_recof) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_set);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tset: ?) -> value vl_xset
    { Tl_t.stop;
      if(vl_xset == vl_set) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_setof);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tsetof: ?) -> value vl_xsetof
    { Tl_t.stop;
      if(vl_xsetof == vl_setof) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_union);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tunion: ?) -> value vl_xunion
    { Tl_t.stop;
      if(vl_xunion == vl_union) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port2.send(vl_array);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tarray: ?) -> value vl_xarray
    { Tl_t.stop;
      if(vl_xarray == vl_array) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}
}

testcase commMessageInterPTCLocalConnection2() runs on commInterPTC_comp1 {
  var charstring vl_char := "a";
  var float vl_float := 1.23;
  var boolean vl_bool := true;
  var bitstring vl_bitstr := '0101'B;
  var octetstring vl_octetstr := '01AB'O;
  var charstring vl_charstr := "abcd";
  var commMessage_tenum vl_enum := exx1;
  var commMessage_trecord vl_record := { x1 := 1, x2 := 1.2 };
  var commMessage_trecof vl_recof := { '00AB'O, 'AB00'O };
  var commMessage_tset vl_set := { x1 := 1, x2 := 1.2 };
  var commMessage_tsetof vl_setof := { "a", "b" };
  var commMessage_tunion vl_union := { x1:=1 };
  var commMessage_tarray vl_array := {{1,1},{2,2},{3,3}};

  var charstring vl_xchar;
  var float vl_xfloat;
  var boolean vl_xbool;
  var bitstring vl_xbitstr;
  var octetstring vl_xoctetstr;
  var charstring vl_xcharstr;
  var commMessage_tenum vl_xenum;
  var commMessage_trecord vl_xrecord;
  var commMessage_trecof vl_xrecof;
  var commMessage_tset vl_xset;
  var commMessage_tsetof vl_xsetof;
  var commMessage_tunion vl_xunion;
  var commMessage_tarray vl_xarray;

  timer Tl_t := 0.5;

  connect(self:Port1,self:Port1);

  Port1.send(vl_char);
  Tl_t.start;
	alt {
	[] Port1.receive(charstring: ?) -> value vl_xchar
    { Tl_t.stop;
      if(vl_xchar == vl_char) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_float);
  Tl_t.start;
	alt {
	[] Port1.receive(float: ?) -> value vl_xfloat
    { Tl_t.stop;
      if(vl_xfloat == vl_float) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_bool);
  Tl_t.start;
	alt {
	[] Port1.receive(boolean: ?) -> value vl_xbool
    { Tl_t.stop;
      if(vl_xbool == vl_bool) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_bitstr);
  Tl_t.start;
	alt {
	[] Port1.receive(bitstring: ?) -> value vl_xbitstr
    { Tl_t.stop;
      if(vl_xbitstr == vl_bitstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_octetstr);
  Tl_t.start;
	alt {
	[] Port1.receive(octetstring: ?) -> value vl_xoctetstr
    { Tl_t.stop;
      if(vl_xoctetstr == vl_octetstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_charstr);
  Tl_t.start;
	alt {
	[] Port1.receive(charstring: ?) -> value vl_xcharstr
    { Tl_t.stop;
      if(vl_xcharstr == vl_charstr) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_enum);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tenum: ?) -> value vl_xenum
    { Tl_t.stop;
      if(vl_xenum == vl_enum) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_record);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_trecord: ?) -> value vl_xrecord
    { Tl_t.stop;
      if(vl_xrecord == vl_record) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_recof);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_trecof: ?) -> value vl_xrecof
    { Tl_t.stop;
      if(vl_xrecof == vl_recof) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_set);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tset: ?) -> value vl_xset
    { Tl_t.stop;
      if(vl_xset == vl_set) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_setof);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tsetof: ?) -> value vl_xsetof
    { Tl_t.stop;
      if(vl_xsetof == vl_setof) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_union);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tunion: ?) -> value vl_xunion
    { Tl_t.stop;
      if(vl_xunion == vl_union) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}

  Port1.send(vl_array);
  Tl_t.start;
	alt {
	[] Port1.receive(commMessage_tarray: ?) -> value vl_xarray
    { Tl_t.stop;
      if(vl_xarray == vl_array) { setverdict(pass); }
      else { setverdict(fail); }
    }
	[] Port1.receive { Tl_t.stop; setverdict(fail); }
	[] Tl_t.timeout { setverdict(fail); }
	}
}

////////////////////////////////////////////////////////////////////////////////
// Tests for implicit message encoding: dual faced ports

external function encodePDU1(in PDU1 pdu) return octetstring
  with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function encodePDU2(in PDU2 pdu) return octetstring
  with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }

external function decodePDU1(in octetstring os, out PDU1 pdu) return integer
  with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }
external function decodePDU2(in octetstring os, out PDU2 pdu) return integer
  with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

type port OctStrPort message {
  inout octetstring
} with { extension "internal" }

type port LowLevelPort message {
  inout octetstring
} with { extension "internal provider" }

type port HighLevelPort message {
  inout PDU1;
  inout PDU2;
  out integer;
  out octetstring;
} with { extension "internal user LowLevelPort
  out( PDU1 -> octetstring : function(encodePDU1);
       PDU2 -> octetstring : function(encodePDU2);
       octetstring -> octetstring : simple;
       integer -> - : discard)
  in ( octetstring -> PDU1 : function(decodePDU1),
                      PDU2 : function(decodePDU2),
                      - : discard)"
}

type component ImplicitMessageEncodingComponent {
  port HighLevelPort hl_port;
  port OctStrPort os_port;
}

testcase commMessageDualFacedPorts1() runs on ImplicitMessageEncodingComponent {
  connect(mtc:hl_port,mtc:os_port);
  var PDU2 pdu2 := { 1234, '1234567890ABCDEF'O, true }
  var PDU1 pdu1 := "uu";
  var octetstring enc_pdu1 := encodePDU1(pdu1);
  var octetstring enc_pdu2 := encodePDU2(pdu2);
  var octetstring recv_os;
  timer T;

  hl_port.send(pdu2);
  T.start(1.0);
  alt {
    [] os_port.receive(octetstring:?) -> value recv_os {
      T.stop;
      if (recv_os==enc_pdu2) { setverdict(pass); } else { setverdict(fail); }
    }
    [] T.timeout { setverdict(fail); }
  }

  hl_port.send(pdu1);
  T.start(1.0);
  alt {
    [] os_port.receive(octetstring:?) -> value recv_os {
      T.stop;
      if (recv_os==enc_pdu1) { setverdict(pass); } else { setverdict(fail); }
    }
    [] T.timeout { setverdict(fail); }
  }

  disconnect(mtc:hl_port,mtc:os_port);
}

type component RepeaterComponent {
  port OctStrPort repeater_port;
}

function fn_repeat() runs on RepeaterComponent {
var octetstring sendmeback;
alt {
 [] repeater_port.receive(octetstring:?) -> value sendmeback {
   repeater_port.send(sendmeback);
   repeat;
 }
}
}

testcase commMessageDualFacedPorts2() runs on ImplicitMessageEncodingComponent {
  timer T;
  var RepeaterComponent rc := RepeaterComponent.create;
  rc.start(fn_repeat());
  var PDU2 pdu2 := { 1234, '1234567890ABCDEF'O, true }
  var PDU2 recv_pdu2;
  connect(mtc:hl_port, rc:repeater_port);

  hl_port.send(pdu2);
  T.start(1.0);
  alt {
    [] hl_port.receive(PDU2:?) -> value recv_pdu2 {
      T.stop;
      if (recv_pdu2==pdu2) { setverdict(pass); } else { setverdict(fail); }
    }
    [] T.timeout { setverdict(fail); }
  }

  //discard at receiving (cannot be decoded by decodePDU1 & 2)
  hl_port.send('AA'O);
  T.start(1.0);
  alt {
    [] hl_port.receive {
      T.stop;
      setverdict(fail);
    }
    [] T.timeout { setverdict(pass); }
  }
  //discard at sending (charstring must be discarded)
  hl_port.send(1234);
	  T.start(1.0);
	  alt {
	    [] hl_port.receive {
	      T.stop;
	      setverdict(fail);
	    }
    [] T.timeout { setverdict(pass); }
  }
  disconnect(mtc:hl_port, rc:repeater_port);
  rc.stop;
}

// '*' is not allowed as a matching template in receive operations
testcase commMessageReceiveAnyOrOmit() runs on commMessage_comp1 {
  connect(self:Port1, self:Port1);
  var template integer vt := *;
  
  // receive
  Port1.send(5);
  @try {
    alt {
      [] Port1.receive(vt) { }
    }
    setverdict(fail, "Receive operation succeeded. Expected error.");
  }
  @catch (msg) {
    if (match(msg, pattern "*Receive operation using '\*' as matching template")) {
      setverdict(pass);
    }
    else {
      setverdict(fail, "Incorrect error message received (receive test): ", msg);
    }
  }
  
  // check-receive
  Port1.send(5);
  @try {
    alt {
      [] Port1.check(receive(vt)) { }
    }
    setverdict(fail, "Check-receive operation succeeded. Expected error.");
  }
  @catch (msg) {
    if (match(msg, pattern "*Check-receive operation using '\*' as matching template")) {
      setverdict(pass);
    }
    else {
      setverdict(fail, "Incorrect error message received (check-receive test): ", msg);
    }
  }
}

control {
 execute(commMessageIntegerEncode());
 execute(commMessageValue());
 execute(commMessageReceiveAny());
 execute(commMessageReceiveAnyPort());
 execute(commMessageTo());
 execute(commMessageSender1());
 execute(commMessageSender2());
 execute(commMessageFrom());
 execute(commMessageTemplate1());
 execute(commMessageTemplate2());
 execute(commMessageTrigger());
 execute(commMessageTriggerValue());
 execute(commMessageTriggerAny());
 execute(commMessageTriggerAnyPort());
 execute(commMessageTriggerSender1());
 execute(commMessageTriggerSender2());
 execute(commMessageTriggerFrom());
 execute(commMessageTriggerTemplate1());
 execute(commMessageTriggerTemplate2());
 execute(commMessageChar());
 execute(commMessageFloat());
 execute(commMessageBool());
 execute(commMessageBitstr());
 execute(commMessageOctetstr());
 execute(commMessageCharstr());
 execute(commMessageEnum());
 execute(commMessageRecord());
 execute(commMessageRecordOmit());
 execute(commMessageRecof());
 execute(commMessageSet());
 execute(commMessageSetOmit());
 execute(commMessageSetof());
 execute(commMessageUnion());
 execute(commMessageArray());
 execute(commMessageInterPTCLocalConnection1());
 execute(commMessageInterPTCLocalConnection2());
 execute(commMessageDualFacedPorts1());
 execute(commMessageDualFacedPorts2());
 execute(commMessageReceiveAnyOrOmit());
}
}
