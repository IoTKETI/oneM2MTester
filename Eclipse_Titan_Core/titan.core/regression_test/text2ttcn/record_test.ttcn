/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Balasko, Jeno
 *
 ******************************************************************************/
/*
//AUTHOR: 
//DATE: 
//VERSION: 
*/
module record_test
{

//=========================================================================
// Import Part
//=========================================================================
import from types all;
import from functions all;

//=========================================================================
// Module Parameters
//=========================================================================
modulepar {
  
  //============= Type: REC =========================================
  //
  template REC tspt_rec_mod4empty := {}
  template RREC tspt_rrec_mod4empty := { rec:={} }
  template REC tspt_rec_v := {1,1.0,"ABBA",'0100'B}
  template REC tspt_rec_a := *;
  template REC tspt_rec_q := ?;
  template REC tspt_rec_o := omit;
  template REC tspt_rec_v_omitx4 :=  {omit,omit,omit,omit} ;
  template REC tspt_rec_r := ({1,1.0,"ABBA",'0100'B}, {2,2.0,"baba",'01001'B})
  template REC tspt_rec_vr := {1,1.0,("ABBA","baba"),'0100'B}
  template REC tspt_rec_c := complement( {1,1.0,("ABBA","baba"),'0100'B} )
  
  template REC tspt_rec_mod4v := {-,-,-,omit}
  template REC tspt_rec_mod4a := {-,-,-,omit}
  template REC tspt_rec_mod4q := {-,-,-,omit}
  template REC tspt_rec_mod4o := {-,-,-,omit}
  template REC tspt_rec_mod4vl2x2 := omit
  template REC tspt_rec_mod4omitx4 := *;
  template REC tspt_rec_mod4r := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4vr := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4c := complement( {1,1.0,("ABBA","baba"),'0100'B} )
  
  template REC tspt_rec_mod4vl := {9,1.0,"NABBA",'0100'B}; //overwritten by cfg
  template REC tspt_rec_mod4vq:= { i := ?, f := 1.0, cs:= pattern "abc*xyz", bs:= '01'B } // not overwritten by cfg
  
  template REC tspt_rec_mod4cspattern:= { i := 2, f := 1.0, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  template REC tspt_rec_mod4cspatternbs:= { i := ?, f := 1.0, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  template REC tspt_rec_mod4cspatternbs2:= { i := ?, f := 1.0, cs:= "ABBA",bs:= '01'B} //overwritten by cfg 
  template REC tspt_mod4pattern_mixed_order:= { i := ?, f := 1.0, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  
  //===
  template REC tspt_rec_mod4emptyifp := {} ifpresent
  template RREC tspt_rrec_mod4emptyifp := { rec:= {} ifpresent }
  template REC tspt_rec_mod4vifp := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4aifp := {1,1.0,"ABBA",'0100'B}
  template REC tspt_rec_mod4qifp := {1,1.0,"ABBA",'0100'B}
  template REC tspt_rec_mod4oifp := {1,1.0,"ABBA",'0100'B}
  template REC tspt_rec_mod4vl2x2ifp := omit
  template REC tspt_rec_mod4omitx4ifp := *;
  template REC tspt_rec_mod4rifp := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4vrifp := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4vrifp2 := {omit,omit,omit,omit} ;
  template REC tspt_rec_mod4cifp := complement( {1,1.0,("ABBA","baba"),'0100'B} )
  
  template REC tspt_rec_mod4vlifp := {9,1.0 ifpresent,"NABBA",'0100'B ifpresent}; //overwritten by cfg
  template REC tspt_rec_mod4vqifp := { i := ?, f := 1.0, cs:= pattern "abc*xyz", bs:= '01'B } // not overwritten by cfg
  
  template REC tspt_rec_mod4cspatternifp  := { i := 2, f := 1.0 ifpresent, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  template REC tspt_rec_mod4cspatternbsifp:= { i := ?, f := 1.0 ifpresent, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  template REC tspt_rec_mod4cspatternbs2ifp:= { i := ?, f := 1.0 ifpresent, cs:= "ABBA",bs:= '01'B} //overwritten by cfg 
  template REC tspt_mod4pattern_mixed_orderifp:= { i := ?, f := 1.0 ifpresent, cs:= "ABBA",bs:= '01'B} //overwritten by cfg
  
  template REC tspt_rec_empty := { }
  template REC tspt_rec_emptyifp := { } ifpresent
  //template REC tspt_rec_a := *
  
  template RREC tspt_rrec_empty := { rec := {} }
  template RREC tspt_rrec_emptyifp := { rec:= {} ifpresent }
  template RREC tspt_rrec_a := { rec := * }
  //===
  //not accepted:
  /*     template REC tspt_rec_mod4vq(in template integer pl_i1) := {
  i := pl_i1,
  f := 1.0,
  cs:= pattern "abc*xyz"
  bs:= '01'B
  } // cannot be overwritten by cfg
  */
  //Type:REC2
  template REC2 tspt_REC2_1 := { b  := true ifpresent, cs := omit, i:= omit } //not overwritten by cfg
  template REC2 tspt_REC2_2 := { b  := true ifpresent, cs := omit, i:= 2 ifpresent } //overwritten by cfg, but not really
  template REC2 tspt_REC2_3 := { b  := true ifpresent, cs := omit, i:= omit } //overwritten by cfg, b:= *
  template REC2 tspt_REC2_4 := { b  := true ifpresent, cs := omit, i:= omit } //overwritten by cfg, b:= * 
  template REC2 tspt_REC2_5 := { b  := true ifpresent, cs := omit, i:= omit } //overwritten by cfg,  
}


//=========================================================================
// Templates
//=========================================================================
template REC t_rec_v_par( template integer pl_i1) := {
  i := pl_i1,
  f := 1.0,
  cs:= pattern "abc*xyz",
  bs:= '0100'B
} // not overwritten by cfg

template REC tspt_rec_mod4vq_BUG(template integer pl_i1) := {
  i := pl_i1,
  f := 1.0,
  cs:= pattern "abc*xyz",
  bs:= '01'B
} ; // not overwritten by cfg

//=========================================================================
// Altsteps
//=========================================================================

// Insert altsteps here if applicable!
// You can use the altstep skeleton!

//=========================================================================
// Functions
//=========================================================================

function f_string2ttcn_REC_t(in charstring pl_rec, in template REC pl_expected_result, in boolean pl_ok_expected := true) {
  var template REC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_rec,vl_result);
      setverdict(pass) 
    }
    @catch(err_str) {
      log("string2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    
    log(pl_expected_result);
    log(vl_result);
    if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else 
  {
    @try {
      string2ttcn(pl_rec, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("string2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
    
  }
}

function f_string2ttcn_REC_t_str(in charstring pl_rec, in charstring pl_expected_result) {
  var template REC vl_result;
  @try {
    string2ttcn(pl_rec,vl_result);
    setverdict(pass) 
  }
  @catch(err_str) {
    log("str2ttcn() failed: ",err_str);
    setverdict(fail);
  }
  log("Expected result: ", pl_expected_result);
  log("Result: ", vl_result);
  if( pl_expected_result == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
}

//template string -> variable conversion
//expected result: error
function f_string2ttcn_REC_v(in charstring pl_cs, in template REC pl_expected_result, in boolean pl_ok_expected) {
  var REC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(pass);
    }
    @catch(err_str) {
      log("string2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else 
  {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("string2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
    
  }
  log("Expected result: ",pl_expected_result );
  log("Result: ", vl_result);
}

//this function is the same but uses
function f_string2ttcn_REC_v_str(in charstring pl_cs, charstring pl_expected_result, in boolean pl_ok_expected) {
  var REC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(pass);
    }
    @catch(err_str) {
      log("str2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    if( pl_expected_result == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else 
  {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("str2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
    
  }
  log("Expected result: ", pl_expected_result );
  log("Result: ", vl_result);
}

//rrec

function f_string2ttcn_RREC_t(in charstring pl_rrec, in template RREC pl_expected_result, in boolean pl_ok_expected := true) {
  var template RREC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_rrec,vl_result);
      setverdict(pass) 
    }
    @catch(err_str) {
      log("string2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    
    if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else
  {
    @try {
      string2ttcn(pl_rrec, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("string2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
  }
  log(pl_expected_result);
  log(vl_result); 
}

function f_cs_transparent_in(in charstring pl_rrec) return charstring {
  return pl_rrec;
}

function f_cs_transparent_inout(in charstring pl_rrec) return charstring {
  return pl_rrec;
}

function f_cs_transparent_inout_t(in template charstring pl_rrec) return template charstring {
  return pl_rrec;
}

function f_rrec_transparent_in_t(in template RREC pl_rrec) return template RREC {
  return pl_rrec;
}

function f_rrec_transparent_inout_t(inout template RREC pl_rrec) return template RREC {
  return pl_rrec;
}

//with input argumentum of string2ttcn is a reurn value of a function
function f_string2ttcn_RREC_t_retval_in(in charstring pl_rrec, in template RREC pl_expected_result) {
  var template RREC vl_result;
  @try {
    string2ttcn(f_cs_transparent_in(pl_rrec),vl_result);
    setverdict(pass) 
  }
  @catch(err_str) {
    log("string2ttcn() failed: ",err_str);
    setverdict(fail);
  }
  log(pl_expected_result);
  log(vl_result);
  if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
}

function f_string2ttcn_RREC_t_retval_inout(in charstring pl_rrec, in template RREC pl_expected_result) {
  var template RREC vl_result;
  @try {
    string2ttcn(f_cs_transparent_inout(pl_rrec),vl_result);
    setverdict(pass) 
  }
  @catch(err_str) {
    log("string2ttcn() failed: ",err_str);
    setverdict(fail);
  }
  log(pl_expected_result);
  log(vl_result);
  if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
}

function f_string2ttcn_RREC_t_str(in charstring pl_rec, in charstring pl_expected_result) {
  var template RREC vl_result;
  @try {
    string2ttcn(pl_rec,vl_result);
    setverdict(pass) 
  }
  @catch(err_str) {
    log("str2ttcn() failed: ",err_str);
    setverdict(fail);
  }
  log("Expected result: ", pl_expected_result);
  log("Result: ", vl_result);
  if( pl_expected_result == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
}

//template string -> variable conversion
//expected result: error
function f_string2ttcn_RREC_v(in charstring pl_cs, in template RREC pl_expected_result, in boolean pl_ok_expected) {
  var RREC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(pass);
    }
    @catch(err_str) {
      log("string2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    if( log2str(pl_expected_result) == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else 
  {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("string2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
    
  }
  log("Expected result: ",pl_expected_result );
  log("Result: ", vl_result);
}

//this function is the same but uses
function f_string2ttcn_RREC_v_str(in charstring pl_cs, charstring pl_expected_result, in boolean pl_ok_expected) {
  var RREC vl_result;
  if( pl_ok_expected ) {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(pass);
    }
    @catch(err_str) {
      log("str2ttcn() failed: ",err_str);
      setverdict(fail);
    }
    if( pl_expected_result == log2str(vl_result) ) { setverdict(pass) } else { setverdict(fail) }
  } 
  else 
  {
    @try {
      string2ttcn(pl_cs, vl_result);
      setverdict(fail);
    }
    @catch(err_str) {
      log("str2ttcn() conversion error: ",err_str);
      setverdict(pass,"Expected error, ok");
    }
    
  }
  log("Expected result: ", pl_expected_result );
  log("Result: ", vl_result);
}


//=========================================================================
// Testcases
//=========================================================================

testcase tc_rec_v() runs on MC {
  var RoREC vl_good_values := { {1,1.0,"ABBA",'0100'B} }
  var RoREC vl_wrong_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0101'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingValues_rec(tspt_rec_v, vl_good_values,vl_wrong_values);
}

testcase tc_rec_a() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_a, vl_good_values);
}

testcase tc_rec_q() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_q, vl_good_values);
}

testcase tc_rec_o() runs on MC {
  var RoREC vl_good_values := {};
  var RoREC vl_wrong_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingValues_rec(tspt_rec_o, vl_good_values, vl_wrong_values);
}


testcase tc_rec_v_omitx4() runs on MC {
  var RoREC vl_good_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit} };
  var RoREC vl_wrong_values := {{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingValues_rec(tspt_rec_v_omitx4, vl_good_values, vl_wrong_values);
}

testcase tc_rec_r() runs on MC {
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B}, {2,2.0,"baba",'01001'B}}
  var RoREC vl_wrong_values := {
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {2,2.0,"ABBA",'0100'B},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} 
  }
  f_checkMatchingValues_rec(tspt_rec_r, vl_good_values, vl_wrong_values);
}



testcase tc_rec_vr() runs on MC {
  var RoREC vl_good_values :=  {{1,1.0,"ABBA",'0100'B}, {1,1.0,"baba",'0100'B}}
  var RoREC vl_wrong_values := {
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {2,2.0,"ABBA",'0100'B},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} 
  }
  f_checkMatchingValues_rec(tspt_rec_vr, vl_good_values, vl_wrong_values);
}

testcase tc_rec_v_par() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {1,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {3,1.0,"abcAxyz",'0100'B}, {1,2.0,"abdXxyz",'0100'B}}
  f_checkMatchingValues_rec(t_rec_v_par(1), vl_good_values, vl_wrong_values);
}

testcase tc_rec_c() runs on MC {
  var RoREC vl_good_values :=  {
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  var RoREC vl_wrong_values := {{1,1.0,"ABBA",'0100'B}, {1,1.0,"baba",'0100'B}} 
  f_checkMatchingValues_rec(tspt_rec_c, vl_good_values, vl_wrong_values);
}

//==========================
//=== modified templates ===
//==========================
//==== Goal: to test if record template is modified from cfg file:===
// tc_rec_mod4*

testcase tc_rec_mod4v() runs on MC {
  var RoREC vl_good_values := { {1,1.0,"ABBA",'0100'B} }
  var RoREC vl_wrong_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0101'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4v, vl_good_values,vl_wrong_values);
}

testcase tc_rec_mod4a() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_mod4a, vl_good_values);
}

testcase tc_rec_mod4q() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_mod4q, vl_good_values);
}

testcase tc_rec_mod4o() runs on MC {
  var RoREC vl_good_values := {};
  var RoREC vl_wrong_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4o, vl_good_values, vl_wrong_values);
}

//goal: to test if template modulepar can be a right value + all fields are omit
testcase tc_rec_mod4omitx4() runs on MC {
  var template REC vlt := tspt_rec_mod4omitx4;
  var RoREC vl_good_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}};
  var RoREC vl_wrong_values := {{1,1.0,"ABBA",'0100'B}};
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}
testcase tc_rec_mod4r() runs on MC {
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B}, {2,2.0,"baba",'01001'B}}
  var RoREC vl_wrong_values := {
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {2,2.0,"ABBA",'0100'B},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} 
  }
  f_checkMatchingValues_rec(tspt_rec_mod4r, vl_good_values, vl_wrong_values);
}

testcase tc_rec_mod4vr() runs on MC {
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B}, {1,1.0,"baba",'0100'B}}
  var RoREC vl_wrong_values :={
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {2,2.0,"ABBA",'0100'B},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_mod4vr, vl_good_values);
  
}

testcase tc_rec_mod4c() runs on MC {
  var RoREC vl_good_values :=  {
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  var RoREC vl_wrong_values := {{1,1.0,"ABBA",'0100'B}, {1,1.0,"baba",'0100'B}} 
  f_checkMatchingValues_rec(tspt_rec_mod4c, vl_good_values, vl_wrong_values);
}

testcase tc_rec_mod4vl2x2() runs on MC {
  var RoREC vl_good_values := { {1,1.0,"ABBA",'0100'B}, {1,1.0,"ABBA",'01001'B},{1,1.0,"baba",'0100'B},{1,1.0,"baba",'01001'B} }
  var RoREC vl_wrong_values := {{3,1.0,"ABBA",'0100'B},{1,2.0,"baba",'0100'B}, {1,1.0,"wrong",'0100'B},{1,1.0,"ABBA",'010010'B},{9,9.9,"wrong",'010010'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4vl2x2, vl_good_values, vl_wrong_values);
}

//modified template: {1,1.0,("ABBA","baba"),'0100'B}
testcase tc_rec_mod4vl() runs on MC {
  var template REC vlt := tspt_rec_mod4vl;
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B},{1,1.0,"baba",'0100'B} }
  var RoREC vl_wrong_values := {{2,1.1,"ABBA",'0100'B}, {2,1.0,"ABBA",'01001'B}, {2,1.0,"blabla",'01001'B}}
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}

//modified for { i := ?, f := 1.0, cs:= pattern "abc*xyz", bs:= '0100'B }
testcase tc_rec_mod4vq() runs on MC {
  var template REC vlt := tspt_rec_mod4vq;
  var RoREC vl_good_values := {{1,1.0,"abc xyz",'0100'B},{112345678,1.0,"abcXxyz",'0100'B} }
  var RoREC vl_wrong_values := {{2,1.0,"ABBA",'01'B}, {2,1.0,"ABBA",'0100'B},{3,4.0,"abcxyzz",'011'B}}
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}


//goal: to test modification like this: { ?, -,pattern "abc*xyz", '0100'B}
testcase tc_rec_mod4cspattern() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B}, {omit,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingValues_rec(tspt_rec_mod4cspattern, vl_good_values, vl_wrong_values);
}

//template as argument of altstep

altstep as_rec(template REC pl_rec, in RoREC pl_good_values, in RoREC pl_wrong_values, timer t) {
  
  [] t.timeout {
    f_checkMatchingValues_rec(pl_rec, pl_good_values, pl_wrong_values);      
  }
}

//test if altstep is cooperate with modulepar
testcase tc_rec_mod4cspattern_as() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B}, {omit,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}};
  timer t:=0.1; t.start;
  as_rec(tspt_rec_mod4cspattern, vl_good_values,vl_wrong_values, t);
  if( log2str(tspt_rec_mod4cspattern) != "{ i := *, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(fail) }
}

//modify template field:
testcase tc_rec_mod4cspatternbs() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingValues_rec(tspt_rec_mod4cspatternbs, vl_good_values, vl_wrong_values);   
  if( log2str(tspt_rec_mod4cspatternbs) != "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(fail) }
}

//value list notation test:
//tspt_rec_mod4cspatternbs2: { i := ?, f := 1.0,cs:= "ABBA", bs:= '01'B} -> { i := ?, f := 1.0,cs:= pattern "abc*xyz", bs:= '01'B} 
testcase tc_rec_mod4cspatternbs2() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingValues_rec(tspt_rec_mod4cspatternbs2, vl_good_values,vl_wrong_values );
  if( log2str(tspt_rec_mod4cspatternbs2) != "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(fail) }
}

//mixed fields in cfg file:
testcase tc_mod4pattern_mixed_order() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingGoodValues_rec(tspt_mod4pattern_mixed_order, vl_good_values);
  f_checkMatchingWrongValues_rec(tspt_mod4pattern_mixed_order, vl_wrong_values);
  if( log2str(tspt_mod4pattern_mixed_order) != "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(fail) }
  log(tspt_mod4pattern_mixed_order);
}

//===

testcase tc_rec_mod4vifp() runs on MC {
  var RoREC vl_good_values := { {1,1.0,"ABBA",'0100'B}, {omit,1.0,"ABBA",'0100'B},{omit,omit,omit,omit} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0101'B}, {2,-99.9,"ABBA",'0100'B} }    
  f_checkMatchingValues_rec(tspt_rec_mod4vifp, vl_good_values,vl_wrong_values);
  if(log2str(tspt_rec_mod4vifp)!="{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }") {setverdict(fail);}
}

testcase tc_rec_mod4aifp() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_mod4aifp, vl_good_values);
}

testcase tc_rec_mod4qifp() runs on MC {
  var RoREC vl_good_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}, {1,1.0,"ABBA",'0100'B}, {2,-99.9,"ABBA",'0100'B} }
  f_checkMatchingGoodValues_rec(tspt_rec_mod4qifp, vl_good_values);
}

testcase tc_rec_mod4oifp() runs on MC {
  var RoREC vl_good_values := {};
  var RoREC vl_wrong_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4oifp, vl_good_values, vl_wrong_values);
}

//goal: to test if template modulepar can be a right value + all fields are omit
testcase tc_rec_mod4omitx4ifp() runs on MC {
  var template REC vlt := tspt_rec_mod4omitx4ifp;
  var RoREC vl_good_values := {{omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit}};
  var RoREC vl_wrong_values := {{1,1.0,"ABBA",'0100'B}};
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}
testcase tc_rec_mod4rifp() runs on MC {
  var RoREC vl_good_values := {
    {1,1.0,"ABBA",'0100'B}, {2,2.0,"baba",'01001'B}, {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},{omit,1.0,omit,omit}}
  var RoREC vl_wrong_values := {
    {2,2.0,"ABBA",'0100'B},{3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,omit,"anything",omit},{omit,omit,omit,'01'B} 
  }
  f_checkMatchingValues_rec(tspt_rec_mod4rifp, vl_good_values, vl_wrong_values);
}

testcase tc_rec_mod4vrifp() runs on MC {
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B}, {2,1.0,"ABBA",'0100'B}, {2,-9.0,"ABBA",'0100'B},{2,2.0,"ABBA",'0100'B},
    {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},{omit,1.0,omit,omit},{omit,omit,omit,'0100'B},{omit,omit,"ABBA",'0100'B}
  }
  var RoREC vl_wrong_values :={    
    {3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},
    {omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4vrifp, vl_good_values,vl_wrong_values );
  
}

testcase tc_rec_mod4cifp() runs on MC {
  var RoREC vl_good_values :=  {     
    {3,1.0,"ABBA",'0100'B},{3,omit,omit,omit},{omit,1.1,omit,omit},{omit,omit,"anything",omit},{omit,omit,omit,'01'B} }
  var RoREC vl_wrong_values := { {omit,omit,omit,omit},{i:=omit,f:=omit,cs:=omit, bs:=omit},
    {1,1.0,"ABBA",'0100'B}, {1,1.0,"baba",'0100'B},{1,omit,omit,omit},{omit,1.0,omit,omit},{omit,omit,"ABBA",omit},{omit,omit,"baba",omit},{omit,omit,omit,'0100'B}} 
  f_checkMatchingValues_rec(tspt_rec_mod4cifp, vl_good_values, vl_wrong_values);
}

testcase tc_rec_mod4vl2x2ifp() runs on MC {
  var RoREC vl_good_values := { {1,1.0,"ABBA",'0100'B}, {1,1.0,"ABBA",'01001'B},{1,1.0,"baba",'0100'B},{1,1.0,"baba",'01001'B} }
  var RoREC vl_wrong_values := {{3,1.0,"ABBA",'0100'B},{1,2.0,"baba",'0100'B}, {1,1.0,"wrong",'0100'B},{1,1.0,"ABBA",'010010'B},{9,9.9,"wrong",'010010'B} }
  f_checkMatchingValues_rec(tspt_rec_mod4vl2x2ifp, vl_good_values, vl_wrong_values);
}

//modified template: {1  ifpresent,1.0 ifpresent,("ABBA","baba") ifpresent,'0100'B}
//failed: if cs:=omit, it failes  
testcase tc_rec_mod4vlifp() runs on MC {
  var template REC vlt := tspt_rec_mod4vlifp;
  var RoREC vl_good_values := {{1,1.0,"ABBA",'0100'B},{1,1.0,"baba",'0100'B}, {omit,omit,omit,'0100'B}, {i:=1,f:=1.0,cs:=omit,bs:='0100'B} }
  var RoREC vl_wrong_values := {{2,1.1,"ABBA",'0100'B}, {2,1.0,"ABBA",'01001'B}, {2,1.0,"blabla",'01001'B}}
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}

//modified for { i := ?, f := 1.0, cs:= pattern "abc*xyz", bs:= '0100'B }
testcase tc_rec_mod4vqifp() runs on MC {
  var template REC vlt := tspt_rec_mod4vqifp;
  var RoREC vl_good_values := {{1,1.0,"abc xyz",'0100'B},{112345678,1.0,"abcXxyz",'0100'B} }
  var RoREC vl_wrong_values := {{2,1.0,"ABBA",'01'B}, {2,1.0,"ABBA",'0100'B},{3,4.0,"abcxyzz",'011'B}}
  f_checkMatchingValues_rec(vlt, vl_good_values, vl_wrong_values);
}


//goal: to test modification like this: { ?, -,pattern "abc*xyz", '0100'B}
testcase tc_rec_mod4cspatternifp() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B}, {omit,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingValues_rec(tspt_rec_mod4cspatternifp, vl_good_values, vl_wrong_values);
}

//test if altstep is cooperate with modulepar
testcase tc_rec_mod4cspattern_asifp() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B},      
    {omit,1.0,"abc5xyz",'0100'B},{omit,omit,omit,omit} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}};
  timer t:=0.1; t.start;
  as_rec(tspt_rec_mod4cspatternifp, vl_good_values,vl_wrong_values, t);
  //log(">>>Test1: { i := * ifpresent, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }")
  //log(">>>Test2:", tspt_rec_mod4cspatternifp);
  if( log2str(tspt_rec_mod4cspatternifp) != "{ i := * ifpresent, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }") { setverdict(fail) }
}

//modify template field:
testcase tc_rec_mod4cspatternbsifp() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B}, {13,omit,omit,omit} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}, {omit,omit,omit,omit} }
  f_checkMatchingValues_rec(tspt_rec_mod4cspatternbsifp, vl_good_values, vl_wrong_values);
  //log(">>>Test3: { i := ?, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }");
  //log(">>>Test4: ",tspt_rec_mod4cspatternbsifp);
  if( log2str(tspt_rec_mod4cspatternbsifp) != "{ i := ?, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }") { setverdict(fail) }
}

//value list notation test:
//tspt_rec_mod4cspatternbs2: { i := ?, f := 1.0,cs:= "ABBA", bs:= '01'B} -> { i := ?, f := 1.0,cs:= pattern "abc*xyz", bs:= '01'B} 
testcase tc_rec_mod4cspatternbs2ifp() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B}, {13,omit,omit,omit} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  
  f_checkMatchingValues_rec(tspt_rec_mod4cspatternbs2ifp, vl_good_values,vl_wrong_values );
  //if( log2str(tspt_rec_mod4cspatternbs2ifp) != "{ i := ? ifpresent, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }") { setverdict(fail) }
}

//mixed fields in cfg file:
testcase tc_mod4pattern_mixed_orderifp() runs on MC {
  var RoREC vl_good_values  := { {1,1.0,"abcAxyz",'0100'B}, {9,1.0,"abcxyz",'0100'B},{1,1.0,"abc5xyz",'0100'B} }
  var RoREC vl_wrong_values := { {1,1.0,"ABBA",'0100'B}, {1,2.0,"abdXxyz",'0100'B},{2,3.0,"oh",'00'B}}
  f_checkMatchingGoodValues_rec(tspt_mod4pattern_mixed_order, vl_good_values);
  f_checkMatchingWrongValues_rec(tspt_mod4pattern_mixed_orderifp, vl_wrong_values);
  if( log2str(tspt_mod4pattern_mixed_orderifp) != "{ i := ?, f := 1.000000 ifpresent, cs := pattern \"abc*xyz\" ifpresent, bs := '0100'B ifpresent }") { setverdict(fail) }
  log(tspt_mod4pattern_mixed_orderifp);
}

//==
template REC2 t_REC2_1 := {
  b  := true ifpresent,
  cs := omit,
  i := omit
}

//Goal: to test if a normal template checking is ok for "ifpresent" and "omit"
testcase tc_REC2_0() runs on MC {
  var RoREC2 vl_good_values  := { {omit,omit,omit},{true,omit,omit} }
  var RoREC2 vl_wrong_values := { {false,omit,omit}, {false,"a",1}, { false, "_anything_else*",1}, { true, "_anything_else*",1}, {omit, "b",1} }
  f_checkMatchingGoodValues_rec2( t_REC2_1, vl_good_values );
  f_checkMatchingWrongValues_rec2( t_REC2_1, vl_wrong_values );
  log(t_REC2_1);
  if( log2str(t_REC2_1) != "{ b := true ifpresent, cs := omit, i := omit }" ) { setverdict(fail) }
}

testcase tc_REC2_1() runs on MC {
  var RoREC2 vl_good_values  := { {omit,omit,omit},{true,omit,omit} }
  var RoREC2 vl_wrong_values := { {false,omit,1}, {false,"a",2}, { false, "_anything_else*",2}, { true, "_anything_else*",2}, {omit, "b",omit}  }
  f_checkMatchingGoodValues_rec2( tspt_REC2_1, vl_good_values );
  f_checkMatchingWrongValues_rec2( tspt_REC2_1, vl_wrong_values );
  log(tspt_REC2_1);
  if( log2str(tspt_REC2_1) != "{ b := true ifpresent, cs := omit, i := omit }" ) { setverdict(fail) }
}

testcase tc_REC2_2() runs on MC {
  var RoREC2 vl_good_values  := { {omit,omit,omit},{true,omit,omit},{omit,omit,2},{true,omit,2} }
  var RoREC2 vl_wrong_values := { {false,omit,omit}, {false,"a",1}, { false, "_anything_else*",2}, { true, "_anything_else*", omit}, {omit,"b",1}  }
  f_checkMatchingGoodValues_rec2( tspt_REC2_2, vl_good_values );
  f_checkMatchingWrongValues_rec2( tspt_REC2_2, vl_wrong_values );
  log(tspt_REC2_2);
  if( log2str(tspt_REC2_2) != "{ b := true ifpresent, cs := omit, i := 2 ifpresent }" ) { setverdict(fail) }
}

//template modification check
testcase tc_REC2_3() runs on MC {
  var RoREC2 vl_good_values  := { {omit,omit,omit},{true,omit,omit}, {false,omit,omit},{omit,omit,2},{true,omit,2},{false,omit,2}}
  var RoREC2 vl_wrong_values := { {false,"a",omit}, { false, "_anything_else*",1}, { true, "_anything_else*",2}, {omit, "b",2}   }
  f_checkMatchingGoodValues_rec2( tspt_REC2_3, vl_good_values );
  f_checkMatchingWrongValues_rec2( tspt_REC2_3, vl_wrong_values );
  log("The modified template is: ",tspt_REC2_3);
  if( log2str(tspt_REC2_3) != "{ b := *, cs := omit, i := 2 ifpresent }" ) { setverdict(fail) }
}
//template modification check, explicit name-value notation:
testcase tc_REC2_4() runs on MC {
  var RoREC2 vl_good_values  := { {true,omit,omit},{false,omit,omit} }
  var RoREC2 vl_wrong_values := { {omit,omit,omit},{false,"a",1}, { false, "_anything_else*",2}, { true, "_anything_else*",2}, {omit, "b", 2} }
  f_checkMatchingGoodValues_rec2( tspt_REC2_4, vl_good_values );
  f_checkMatchingWrongValues_rec2( tspt_REC2_4, vl_wrong_values );
  log("The modified template is: ",tspt_REC2_4);
  if( log2str(tspt_REC2_4) != "{ b := ?, cs := omit, i := omit }" ) { setverdict(fail) }
}

//template modification check, explicit name-value notation:
testcase tc_REC2_5() runs on MC {
  var RoREC2 vl_good_values  := { { true,"a", omit },{ false,"b",omit }, { true,"c", 1 }, { false, "b", 2 }}
  var RoREC2 vl_wrong_values := { { omit,omit,omit },{ false,"al",1 }, { false, "_anything_else*", 2 }, { true, "_anything_else*",2 }, { omit,"babe", 1} }
  f_checkMatchingGoodValues_rec2( tspt_REC2_5, vl_good_values );
  f_checkMatchingWrongValues_rec2( tspt_REC2_5, vl_wrong_values );
  log("The modified template is: ",tspt_REC2_5);
  if( log2str(tspt_REC2_5) != "{ b := ?, cs := ? length (1), i := * }" ) { setverdict(fail) }
}

//==== String comparison testcases ===
testcase tc_REC_log2str() runs on MC {
  log(tspt_rec_empty);
  if(log2str(tspt_rec_empty) == "<uninitialized template>") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4v);
  if(log2str(tspt_rec_mod4v) == "{ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4a);
  if(log2str(tspt_rec_mod4a) == "*") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4q);
  if(log2str(tspt_rec_mod4q) == "?") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4o);
  if(log2str(tspt_rec_mod4o) == "omit") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vr);
  if(log2str(tspt_rec_mod4vr) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl2x2);
  if(log2str(tspt_rec_mod4vl2x2) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := ('0100'B, '01001'B) }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4omitx4);
  if(log2str(tspt_rec_mod4omitx4) == "{ i := omit, f := omit, cs := omit, bs := omit }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4r);
  if(log2str(tspt_rec_mod4r) == "({ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vr);
  if(log2str(tspt_rec_mod4vr) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4c);
  if(log2str(tspt_rec_mod4c) == "complement ({ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl);
  if(log2str(tspt_rec_mod4vl) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vq);
  if(log2str(tspt_rec_mod4vq) == "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}         
}

testcase tc_REC_ifp_log2str() runs on MC {
  log(tspt_rec_empty);
  if(log2str(tspt_rec_empty) == "<uninitialized template>") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vifp);
  if(log2str(tspt_rec_mod4vifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4aifp);
  if(log2str(tspt_rec_mod4aifp) == "* ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4qifp);
  if(log2str(tspt_rec_mod4qifp) == "? ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4oifp);
  if(log2str(tspt_rec_mod4oifp) == "omit ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl2x2ifp);
  if(log2str(tspt_rec_mod4vl2x2ifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\" ifpresent, \"baba\" ifpresent), bs := ('0100'B, '01001'B) ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4omitx4ifp);
  if(log2str(tspt_rec_mod4omitx4ifp) == "{ i := omit, f := omit, cs := omit, bs := omit } ifpresent" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4rifp);
  if(log2str(tspt_rec_mod4rifp) == "({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vrifp);
  if(log2str(tspt_rec_mod4vrifp) == "{ i := (1 .. 2) ifpresent, f := ? ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4cifp);
  if(log2str(tspt_rec_mod4cifp) == "complement ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vlifp);
  if(log2str(tspt_rec_mod4vlifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vqifp);
  if(log2str(tspt_rec_mod4vqifp) == "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}         
}


//===

// Embedded templates
testcase tc_REC_log2str_emb() runs on MC {
  log(tspt_rec_empty);
  if(log2str(tspt_rec_empty) == "<uninitialized template>") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4v));
  if(log2str(t_rrec(tspt_rec_mod4v)) == "{ rec := { i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4a));
  if(log2str(t_rrec(tspt_rec_mod4a)) == "{ rec := * }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4q));
  if(log2str(t_rrec(tspt_rec_mod4q)) == "{ rec := ? }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4o));
  if(log2str(t_rrec(tspt_rec_mod4o)) == "{ rec := omit }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vr));
  if(log2str(t_rrec(tspt_rec_mod4vr)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl2x2));
  if(log2str(t_rrec(tspt_rec_mod4vl2x2)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := ('0100'B, '01001'B) } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4omitx4));
  if(log2str(t_rrec(tspt_rec_mod4omitx4)) == "{ rec := { i := omit, f := omit, cs := omit, bs := omit } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4r));
  if(log2str(t_rrec(tspt_rec_mod4r)) == "{ rec := ({ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vr));
  if(log2str(t_rrec(tspt_rec_mod4vr)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4c));
  if(log2str(t_rrec(tspt_rec_mod4c)) == "{ rec := complement ({ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl));
  if(log2str(t_rrec(tspt_rec_mod4vl)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vq));
  if(log2str(t_rrec(tspt_rec_mod4vq)) == "{ rec := { i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}         
}

testcase tc_REC_ifp_log2str_emb() runs on MC {
  log(tspt_rec_empty);
  if(log2str(tspt_rec_empty) == "<uninitialized template>") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vifp));
  if(log2str(t_rrec(tspt_rec_mod4vifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4aifp));
  if(log2str(t_rrec(tspt_rec_mod4aifp)) == "{ rec := * ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4qifp));
  if(log2str(t_rrec(tspt_rec_mod4qifp)) == "{ rec := ? ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4oifp));
  if(log2str(t_rrec(tspt_rec_mod4oifp)) == "{ rec := omit ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl2x2ifp));
  if(log2str(t_rrec(tspt_rec_mod4vl2x2ifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\" ifpresent, \"baba\" ifpresent), bs := ('0100'B, '01001'B) ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4omitx4ifp));
  if(log2str(t_rrec(tspt_rec_mod4omitx4ifp)) == "{ rec := { i := omit, f := omit, cs := omit, bs := omit } ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4rifp));
  if(log2str(t_rrec(tspt_rec_mod4rifp)) == "{ rec := ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vrifp));
  if(log2str(t_rrec(tspt_rec_mod4vrifp)) == "{ rec := { i := (1 .. 2) ifpresent, f := ? ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4cifp));
  if(log2str(t_rrec(tspt_rec_mod4cifp)) == "{ rec := complement ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vlifp));
  if(log2str(t_rrec(tspt_rec_mod4vlifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vqifp));
  if(log2str(t_rrec(tspt_rec_mod4vqifp)) == "{ rec := { i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}         
}

//======================================
//=========== ttcn2str =================
//======================================

//==== String comparison testcases ===
testcase tc_REC_ttcn2string() runs on MC {
  log(ttcn2string(tspt_rec_empty));
  if(ttcn2string(tspt_rec_empty) == "-") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4v);
  if(ttcn2string(tspt_rec_mod4v) == "{ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4a);
  if(ttcn2string(tspt_rec_mod4a) == "*") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4q);
  if(ttcn2string(tspt_rec_mod4q) == "?") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4o);
  if(ttcn2string(tspt_rec_mod4o) == "omit") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vr);
  if(ttcn2string(tspt_rec_mod4vr) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl2x2);
  if(ttcn2string(tspt_rec_mod4vl2x2) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := ('0100'B, '01001'B) }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4omitx4);
  if(ttcn2string(tspt_rec_mod4omitx4) == "{ i := omit, f := omit, cs := omit, bs := omit }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4r);
  if(ttcn2string(tspt_rec_mod4r) == "({ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vr);
  if(ttcn2string(tspt_rec_mod4vr) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4c);
  if(ttcn2string(tspt_rec_mod4c) == "complement ({ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl);
  if(ttcn2string(tspt_rec_mod4vl) == "{ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vq);
  if(ttcn2string(tspt_rec_mod4vq) == "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B }") { setverdict(pass) } else {setverdict(fail)}         
}

testcase tc_REC_ifp_ttcn2string() runs on MC {
  log(ttcn2string(tspt_rec_emptyifp));
  if(ttcn2string(tspt_rec_emptyifp) == "- ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vifp);
  if(ttcn2string(tspt_rec_mod4vifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4aifp);
  if(ttcn2string(tspt_rec_mod4aifp) == "* ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4qifp);
  if(ttcn2string(tspt_rec_mod4qifp) == "? ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4oifp);
  if(ttcn2string(tspt_rec_mod4oifp) == "omit ifpresent") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vl2x2ifp);
  if(ttcn2string(tspt_rec_mod4vl2x2ifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\" ifpresent, \"baba\" ifpresent), bs := ('0100'B, '01001'B) ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4omitx4ifp);
  if(ttcn2string(tspt_rec_mod4omitx4ifp) == "{ i := omit, f := omit, cs := omit, bs := omit } ifpresent" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4rifp);
  if(ttcn2string(tspt_rec_mod4rifp) == "({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vrifp);
  if(ttcn2string(tspt_rec_mod4vrifp) == "{ i := (1 .. 2) ifpresent, f := ? ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4cifp);
  if(ttcn2string(tspt_rec_mod4cifp) == "complement ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent })") { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vlifp);
  if(ttcn2string(tspt_rec_mod4vlifp) == "{ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(tspt_rec_mod4vqifp);
  if(ttcn2string(tspt_rec_mod4vqifp) == "{ i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}         
}

// Embedded templates
testcase tc_REC_ttcn2string_emb() runs on MC {
  log(ttcn2string(tspt_rrec_empty));
  if(ttcn2string(tspt_rrec_empty) == "-") { setverdict(pass) } else {setverdict(fail)}
  log(ttcn2string(tspt_rrec_mod4empty));
  if(ttcn2string(tspt_rrec_mod4empty) == "-") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4v));
  if(ttcn2string(t_rrec(tspt_rec_mod4v)) == "{ rec := { i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4a));
  if(ttcn2string(t_rrec(tspt_rec_mod4a)) == "{ rec := * }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4q));
  if(ttcn2string(t_rrec(tspt_rec_mod4q)) == "{ rec := ? }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4o));
  if(ttcn2string(t_rrec(tspt_rec_mod4o)) == "{ rec := omit }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vr));
  if(ttcn2string(t_rrec(tspt_rec_mod4vr)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl2x2));
  if(ttcn2string(t_rrec(tspt_rec_mod4vl2x2)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := ('0100'B, '01001'B) } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4omitx4));
  if(ttcn2string(t_rrec(tspt_rec_mod4omitx4)) == "{ rec := { i := omit, f := omit, cs := omit, bs := omit } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4r));
  if(ttcn2string(t_rrec(tspt_rec_mod4r)) == "{ rec := ({ i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vr));
  if(ttcn2string(t_rrec(tspt_rec_mod4vr)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4c));
  if(ttcn2string(t_rrec(tspt_rec_mod4c)) == "{ rec := complement ({ i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl));
  if(ttcn2string(t_rrec(tspt_rec_mod4vl)) == "{ rec := { i := 1, f := 1.000000, cs := (\"ABBA\", \"baba\"), bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vq));
  if(ttcn2string(t_rrec(tspt_rec_mod4vq)) == "{ rec := { i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B } }") { setverdict(pass) } else {setverdict(fail)}         
}

testcase tc_REC_ifp_ttcn2string_emb() runs on MC {
  log(ttcn2string(tspt_rrec_emptyifp));
  if(ttcn2string(tspt_rrec_emptyifp) == "{ rec := - ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(ttcn2string(tspt_rrec_mod4emptyifp));
  if(ttcn2string(tspt_rrec_mod4emptyifp) == "{ rec := - ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  
  log(t_rrec(tspt_rec_mod4vifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4vifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  
  log(ttcn2string(f_rrec_transparent_in_t(t_rrec(tspt_rec_mod4vifp))));
  if(ttcn2string(f_rrec_transparent_in_t(t_rrec(tspt_rec_mod4vifp))) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  
  var template RREC vlt_rrec:= t_rrec(tspt_rec_mod4vifp)
  log(ttcn2string(f_rrec_transparent_inout_t(vlt_rrec)));
  if(ttcn2string(f_rrec_transparent_inout_t(vlt_rrec)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  
  log(t_rrec(tspt_rec_mod4aifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4aifp)) == "{ rec := * ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4qifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4qifp)) == "{ rec := ? ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4oifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4oifp)) == "{ rec := omit ifpresent }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vl2x2ifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4vl2x2ifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\" ifpresent, \"baba\" ifpresent), bs := ('0100'B, '01001'B) ifpresent } }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4omitx4ifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4omitx4ifp)) == "{ rec := { i := omit, f := omit, cs := omit, bs := omit } ifpresent }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4rifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4rifp)) == "{ rec := ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent }, { i := 2, f := 2.000000, cs := \"baba\", bs := '01001'B }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vrifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4vrifp)) == "{ rec := { i := (1 .. 2) ifpresent, f := ? ifpresent, cs := \"ABBA\" ifpresent, bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4cifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4cifp)) == "{ rec := complement ({ i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent }) }") { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vlifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4vlifp)) == "{ rec := { i := 1 ifpresent, f := 1.000000 ifpresent, cs := (\"ABBA\", \"baba\") ifpresent, bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}
  log(t_rrec(tspt_rec_mod4vqifp));
  if(ttcn2string(t_rrec(tspt_rec_mod4vqifp)) == "{ rec := { i := ?, f := 1.000000, cs := pattern \"abc*xyz\", bs := '0100'B ifpresent } }" ) { setverdict(pass) } else {setverdict(fail)}         
}

testcase tc_REC_string2ttcn_empty() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_empty),tspt_rec_empty);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_empty),tspt_rec_empty,true);
}

testcase tc_REC_string2ttcn_v() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_v), tspt_rec_v);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_v),tspt_rec_v,true);
  
  var charstring vl_cs := ttcn2string(tspt_rec_v);
  f_string2ttcn_REC_t(vl_cs, tspt_rec_v);
  f_string2ttcn_REC_v(vl_cs, tspt_rec_v,true);    
}

testcase tc_REC_string2ttcn_a() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_a), tspt_rec_a);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_a),tspt_rec_a,false);
}

testcase tc_REC_string2ttcn_q() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_q), tspt_rec_q);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_q),tspt_rec_q,false);
}


testcase tc_REC_string2ttcn_o() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_o), tspt_rec_o);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_o),tspt_rec_o,false);
}

testcase tc_REC_string2ttcn_v_omitx4() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_v_omitx4), tspt_rec_v_omitx4);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_v_omitx4),tspt_rec_v_omitx4,true);
}

testcase tc_REC_string2ttcn_r() runs on MC {
  f_string2ttcn_REC_t(ttcn2string(tspt_rec_r), tspt_rec_r);
  f_string2ttcn_REC_v(ttcn2string(tspt_rec_r),tspt_rec_r,false);
}

//==rrec - the embedded case ===

testcase tc_RREC_string2ttcn_empty() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(tspt_rrec_empty),tspt_rrec_empty);
  f_string2ttcn_RREC_v(ttcn2string(tspt_rrec_empty),tspt_rrec_empty,true);
}

testcase tc_RREC_string2ttcn_v() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4v)), t_rrec(tspt_rec_mod4v));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4v)),t_rrec(tspt_rec_mod4v),true);
  
  f_string2ttcn_RREC_t_retval_in(ttcn2string(t_rrec(tspt_rec_mod4v)), t_rrec(tspt_rec_mod4v));
  f_string2ttcn_RREC_t_retval_inout(ttcn2string(t_rrec(tspt_rec_mod4v)), t_rrec(tspt_rec_mod4v));
}

testcase tc_RREC_string2ttcn_a() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4a)), t_rrec(tspt_rec_mod4a));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4a)),t_rrec(tspt_rec_mod4a),false);
}

testcase tc_RREC_string2ttcn_q() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4q)), t_rrec(tspt_rec_mod4q));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4q)),t_rrec(tspt_rec_mod4q),false);
}


testcase tc_RREC_string2ttcn_o() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4o)), t_rrec(tspt_rec_mod4o));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4o)),t_rrec(tspt_rec_mod4o),true);
}

testcase tc_RREC_string2ttcn_omitx4() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4omitx4)), t_rrec(tspt_rec_mod4omitx4));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4omitx4)), t_rrec(tspt_rec_mod4omitx4),true);
}

testcase tc_RREC_string2ttcn_r() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4r)), t_rrec(tspt_rec_mod4r));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4r)), t_rrec(tspt_rec_mod4r),false);
}

//ifpresent
testcase tc_RREC_string2ttcn_vifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4vifp)), t_rrec(tspt_rec_mod4vifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4vifp)),t_rrec(tspt_rec_mod4vifp),false);
}

testcase tc_RREC_string2ttcn_aifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4aifp)), t_rrec(tspt_rec_mod4aifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4aifp)),t_rrec(tspt_rec_mod4aifp),false);
}

testcase tc_RREC_string2ttcn_qifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4qifp)), t_rrec(tspt_rec_mod4qifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4qifp)),t_rrec(tspt_rec_mod4qifp),false);
}


testcase tc_RREC_string2ttcn_oifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4oifp)), t_rrec(tspt_rec_mod4oifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4oifp)),t_rrec(tspt_rec_mod4oifp),false); //failed !!!
}

testcase tc_RREC_string2ttcn_omitx4ifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4omitx4ifp)), t_rrec(tspt_rec_mod4omitx4ifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4omitx4ifp)), t_rrec(tspt_rec_mod4omitx4ifp),false);
}

testcase tc_RREC_string2ttcn_rifp() runs on MC {
  f_string2ttcn_RREC_t(ttcn2string(t_rrec(tspt_rec_mod4rifp)), t_rrec(tspt_rec_mod4rifp));
  f_string2ttcn_RREC_v(ttcn2string(t_rrec(tspt_rec_mod4rifp)), t_rrec(tspt_rec_mod4rifp),false);
} 

//=== Negative tests ====

testcase tc_RREC_string2ttcn_neg1() runs on MC {
  f_string2ttcn_RREC_t("{ rec := ? ifpresent }", t_rrec(tspt_rec_mod4qifp),true);
  f_string2ttcn_RREC_t("{ recfalse := ? ifpresent }", t_rrec(tspt_rec_mod4qifp),false);
  f_string2ttcn_RREC_t("{ rec :=  ifpresent }", t_rrec(tspt_rec_mod4qifp),false);
  f_string2ttcn_RREC_t("{ rec :=  x ifpresent }", t_rrec(tspt_rec_mod4qifp),false);// TODO: wrong error message
  f_string2ttcn_RREC_t("{ rec :=  {x:=1 ifpresent }}", t_rrec(tspt_rec_mod4qifp),false);
  f_string2ttcn_RREC_t("{ rec :=  {x:=1 ifpresent }", t_rrec(tspt_rec_mod4qifp),false);
  f_string2ttcn_RREC_v("{ recfalse := { i := 1, f := 1.000000, cs := \"ABBA\", bs := '0100'B } }" , t_rrec(tspt_rec_v),false);
} 

//=========================================================================
// Control
//=========================================================================
control {
  log("****record tests****");
  execute(tc_rec_v());
  execute(tc_rec_a());
  execute(tc_rec_q());
  execute(tc_rec_o());
  execute(tc_rec_v_omitx4());
  execute(tc_rec_r());  
  execute(tc_rec_vr());
  execute(tc_rec_v_par());
  execute(tc_rec_c());
  //=== modified templates ===
  execute(tc_rec_mod4v());
  execute(tc_rec_mod4a());
  execute(tc_rec_mod4q());
  execute(tc_rec_mod4o());
  execute(tc_rec_mod4omitx4());
  execute(tc_rec_mod4r());
  execute(tc_rec_mod4vr());
  execute(tc_rec_mod4c());
  execute(tc_rec_mod4vl2x2());  
  execute(tc_rec_mod4vl());
  execute(tc_rec_mod4vq());
  execute(tc_rec_mod4cspattern());
  execute(tc_rec_mod4cspattern_as());
  execute(tc_rec_mod4cspatternbs());
  execute(tc_mod4pattern_mixed_order());
  //==modified ispresent templates ====
  execute(tc_rec_mod4vifp());
  execute(tc_rec_mod4aifp());
  execute(tc_rec_mod4qifp());
  execute(tc_rec_mod4oifp());
  execute(tc_rec_mod4omitx4ifp());
  execute(tc_rec_mod4rifp());
  execute(tc_rec_mod4vrifp());
  execute(tc_rec_mod4cifp());
  execute(tc_rec_mod4vl2x2ifp());  
  execute(tc_rec_mod4vlifp());
  execute(tc_rec_mod4vqifp());
  execute(tc_rec_mod4cspatternifp());
  execute(tc_rec_mod4cspattern_asifp());
  execute(tc_rec_mod4cspatternbsifp());
  execute(tc_rec_mod4cspatternbs2ifp());
  execute(tc_mod4pattern_mixed_orderifp());
  
  execute(tc_REC2_0());
  execute(tc_REC2_1());
  execute(tc_REC2_2());
  execute(tc_REC2_3());
  execute(tc_REC2_4());
  execute(tc_REC2_5());
  
  //==== String comparison testcases ===
  execute(tc_REC_log2str());
  execute(tc_REC_ifp_log2str());
  execute(tc_REC_log2str_emb());
  execute(tc_REC_ifp_log2str_emb());
  
  execute(tc_REC_ttcn2string());
  execute(tc_REC_ifp_ttcn2string());
  execute(tc_REC_ttcn2string_emb());
  execute(tc_REC_ifp_ttcn2string_emb());  
  
  //execute(tc_REC_string2ttcn_empty()); //TODO: Adam, correct the two bugs. --NOT solved, 
  execute(tc_REC_string2ttcn_v());
  execute(tc_REC_string2ttcn_a());
  execute(tc_REC_string2ttcn_q());
  execute(tc_REC_string2ttcn_o());
  execute(tc_REC_string2ttcn_v_omitx4());
  execute(tc_REC_string2ttcn_r()); //TODO: check the error message "Error while setting parameter field '': Type mismatch: ..."
  
  execute(tc_RREC_string2ttcn_v());
  execute(tc_RREC_string2ttcn_a());
  execute(tc_RREC_string2ttcn_q());
  execute(tc_RREC_string2ttcn_o());
  execute(tc_RREC_string2ttcn_omitx4());
  execute(tc_RREC_string2ttcn_r()); //TODO: check the error message ""Error while setting parameter field '.rec': ..."  
  
  execute(tc_RREC_string2ttcn_vifp());
  execute(tc_RREC_string2ttcn_aifp());
  execute(tc_RREC_string2ttcn_qifp());
  execute(tc_RREC_string2ttcn_oifp()); //fixed by Adam: string2ttcn: { rec := omit ifpresent } -> { rec := omit } /value/, it should be reported as an error!!!!
  execute(tc_RREC_string2ttcn_omitx4ifp());
  execute(tc_RREC_string2ttcn_rifp()); //TODO: check the error message ""Error while setting parameter field '.rec': ..."  
  execute(tc_RREC_string2ttcn_neg1()); 
  
}
}  // end of module
