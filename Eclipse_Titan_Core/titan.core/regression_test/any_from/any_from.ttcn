/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Botond, Baranyi â€“ initial implementation
 *
 ******************************************************************************/

// this module contains tests for the 'any from' clause, which is usable on port,
// timer and component arrays, and for index redirects (with the @index modifier),
// which store the array index of the triggering element
module any_from {


///////// Types /////////

type port PT_Msg message {
  inout integer
}
with {
  extension "internal";
}

signature Sig(inout integer x) return integer exception (integer);

type port PT_Proc procedure {
  inout Sig
}
with {
  extension "internal";
}

type component CT {
  port PT_Msg pta_msg[2][3];
  port PT_Proc pta_proc[3];
}

type CT CT_Array[3];

type function F_type(in CT_Array x) return CT_Array;

type record of integer IntList;
type integer IntArray[1..2];

type integer IntDone with { extension "done" };


///////// Helper functions /////////

function f_connect_ports() runs on CT {
  for (var integer i := 0; i < sizeof(pta_msg); i := i + 1) {
    for (var integer j := 0; j < sizeof(pta_msg[i]); j := j + 1) {
      connect(self:pta_msg[i][j], self:pta_msg[i][j]);
    }
  }
  for (var integer k := 0; k < sizeof(pta_proc); k := k + 1) {
    connect(self:pta_proc[k], self:pta_proc[k]);
  }
}

function f_comp_array(in CT_Array x) return CT_Array {
  return x;
}


///////// Testcases and behavior functions /////////

// tests for 'any from <port array>.receive'
testcase tc_port_receive() runs on CT {
  f_connect_ports();
  
  // test #1: with both value redirect and index redirect,
  // the indexes are stored in a record of integer
  var integer msg := 3;
  var IntList idx := { 1, 2 };
  pta_msg[idx[0]][idx[1]].send(msg);
  var integer val_redir;
  var IntList idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_msg.receive(msg) -> value val_redir @index value idx_redir {
      if (val_redir != msg) {
        setverdict(fail, "Value redirect failed. Expected: ", msg, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.receive(integer: ?) -> value val_redir {
      setverdict(fail, "Invalid message received. Expected: ", msg, ", got: ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no value redirect, only index redirect,
  // the indexes are stored in an integer array
  var integer msg2 := 4;
  var IntArray idx2 := { 1, 0 };
  pta_msg[idx2[1]][idx2[2]].send(msg2);
  var integer val_redir2;
  var IntArray idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_msg.receive(msg2) -> @index value idx_redir2 {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.receive(integer: ?) -> value val_redir2 {
      setverdict(fail, "Invalid message received. Expected: ", msg2, ", got: ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer msg3 := 5;
  pta_msg[0][1].send(msg3);
  var integer val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_msg.receive(msg3) {
      setverdict(pass);
    }
    [] any from pta_msg.receive(integer: ?) -> value val_redir3 {
      setverdict(fail, "Invalid message received. Expected: ", msg3, ", got: ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty receive
  pta_msg[1][1].send(0);
  t.start(0.5);
  alt {
    [] any from pta_msg.receive {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.check(receive)'
testcase tc_port_check_receive() runs on CT {
  f_connect_ports();
  
  // test #1: with both value redirect and index redirect,
  // the indexes are stored in a record of integer
  var integer msg := 3;
  var IntList idx := { 1, 2 };
  pta_msg[idx[0]][idx[1]].send(msg);
  var integer val_redir;
  var IntList idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_msg.check(receive(msg) -> value val_redir @index value idx_redir) {
      if (val_redir != msg) {
        setverdict(fail, "Value redirect failed. Expected: ", msg, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.check(receive(integer: ?) -> value val_redir) {
      setverdict(fail, "Invalid message found. Expected: ", msg, ", got: ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no value redirect, only index redirect,
  // the indexes are stored in an integer array
  var integer msg2 := 4;
  var IntArray idx2 := { 1, 0 }; // these have to be less than the indexes in the
  // previous test, otherwise the message from the previous test will be found instead
  pta_msg[idx2[1]][idx2[2]].send(msg2);
  var integer val_redir2;
  var IntArray idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_msg.check(receive(msg2) -> @index value idx_redir2) {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.check(receive(integer: ?) -> value val_redir2) {
      setverdict(fail, "Invalid message found. Expected: ", msg2, ", got: ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer msg3 := 5;
  pta_msg[0][1].send(msg3);
  var integer val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_msg.check(receive(msg3)) {
      setverdict(pass);
    }
    [] any from pta_msg.check(receive(integer: ?) -> value val_redir3) {
      setverdict(fail, "Invalid message found. Expected: ", msg3, ", got: ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty check-receive
  t.start(0.5);
  alt {
    [] any from pta_msg.check(receive) {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.trigger'
testcase tc_port_trigger() runs on CT {
  f_connect_ports();
  
  // test #1: with both value redirect and index redirect,
  // the indexes are stored in a record of integer,
  // only one message is sent
  var integer msg := 3;
  var IntList idx := { 1, 2 };
  pta_msg[idx[0]][idx[1]].send(msg);
  var integer val_redir;
  var IntList idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_msg.trigger(msg) -> value val_redir @index value idx_redir {
      if (val_redir != msg) {
        setverdict(fail, "Value redirect failed. Expected: ", msg, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.trigger(integer: ?) -> value val_redir {
      setverdict(fail, "Invalid message received. Expected: ", msg, ", got: ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no value redirect, only index redirect,
  // the indexes are stored in an integer array,
  // there are two messages before the awaited message on the same port
  var integer msg2 := 4;
  var IntArray idx2 := { 1, 0 };
  pta_msg[idx2[1]][idx2[2]].send(msg2 + 10);
  pta_msg[idx2[1]][idx2[2]].send(msg2 + 100);
  pta_msg[idx2[1]][idx2[2]].send(msg2);
  var integer val_redir2;
  var IntArray idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_msg.trigger(msg2) -> @index value idx_redir2 {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_msg.trigger(integer: ?) -> value val_redir2 {
      setverdict(fail, "Invalid message received. Expected: ", msg2, ", got: ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects,
  // there are two messages on other ports before the awaited message
  var integer msg3 := 5;
  var IntArray idx3 := { 0, 1 };
  pta_msg[0][0].send(msg3 + 10);
  pta_msg[0][1].send(msg3 + 100);
  pta_msg[0][2].send(msg3);
  var integer val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_msg.trigger(msg3) {
      setverdict(pass);
    }
    [] any from pta_msg.trigger(integer: ?) -> value val_redir3 {
      setverdict(fail, "Invalid message received. Expected: ", msg3, ", got: ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty trigger
  pta_msg[1][1].send(0);
  t.start(0.5);
  alt {
    [] any from pta_msg.trigger {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// behavior function for 'getcall' and 'check-getcall' tests
// sends a procedure call on the specified port, doesn't wait for a response
function f_behavior_getcall(in integer p_par, in integer p_idx)
runs on CT {
  pta_proc[p_idx].call(Sig: { p_par }, 0.2) {
    [] pta_proc[p_idx].catch(timeout) {
      // OK
    }
  }
}

// tests for 'any from <port array>.getcall'
testcase tc_port_getcall() runs on CT {  
  // test #1: with both parameter redirect and index redirect,
  // the index is stored in an integer
  var integer par := 6;
  var integer idx := 2;
  var CT ct := CT.create;
  connect(self:pta_proc[idx], ct:pta_proc[idx]);
  ct.start(f_behavior_getcall(par, idx));
  var integer par_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.getcall(Sig: { par }) -> param (par_redir := x) @index value idx_redir {
      if (par != par_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", par, ", got: ", par_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.getcall(Sig: { ? }) -> param (par_redir := x) {
      setverdict(fail, "Invalid call received. Expected: ", par, ", got: ", par_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no parameter redirect, only index redirect
  var integer par2 := 7;
  var integer idx2 := 1;
  var CT ct2 := CT.create;
  connect(self:pta_proc[idx2], ct2:pta_proc[idx2]);
  ct2.start(f_behavior_getcall(par2, idx2));
  var integer par_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.getcall(Sig: { par2 }) -> @index value idx_redir2 {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.getcall(Sig: { ? }) -> param (par_redir2 := x) {
      setverdict(fail, "Invalid call received. Expected: ", par2, ", got: ", par_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer par3 := 8;
  var integer idx3 := 0;
  var CT ct3 := CT.create;
  connect(self:pta_proc[idx3], ct3:pta_proc[idx3]);
  ct3.start(f_behavior_getcall(par3, idx3));
  var integer par_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.getcall(Sig: { par3 }) {
      setverdict(pass);
    }
    [] any from pta_proc.getcall(Sig: { ? }) -> param (par_redir3 := x) {
      setverdict(fail, "Invalid call received. Expected: ", par3, ", got: ", par_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty getcall
  var integer idx4 := 1;
  var CT ct4 := CT.create;
  connect(self:pta_proc[idx4], ct4:pta_proc[idx4]);
  ct4.start(f_behavior_getcall(0, idx4));
  t.start(0.5);
  alt {
    [] any from pta_proc.getcall {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.check(getcall)'
testcase tc_port_check_getcall() runs on CT {  
  // test #1: with both parameter redirect and index redirect,
  // the index is stored in an integer
  var integer par := 6;
  var integer idx := 2;
  var CT ct := CT.create;
  connect(self:pta_proc[idx], ct:pta_proc[idx]);
  ct.start(f_behavior_getcall(par, idx));
  var integer par_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getcall(Sig: { par }) -> param (par_redir := x) @index value idx_redir) {
      if (par != par_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", par, ", got: ", par_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(getcall(Sig: { ? }) -> param (par_redir := x)) {
      setverdict(fail, "Invalid call found. Expected: ", par, ", got: ", par_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no parameter redirect, only index redirect
  var integer par2 := 7;
  var integer idx2 := 1;
  var CT ct2 := CT.create;
  connect(self:pta_proc[idx2], ct2:pta_proc[idx2]);
  ct2.start(f_behavior_getcall(par2, idx2));
  ct2.done; // make sure the call was sent, otherwise the call from the previous test will be found instead
  var integer par_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getcall(Sig: { par2 }) -> @index value idx_redir2) {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(getcall(Sig: { ? }) -> param (par_redir2 := x)) {
      setverdict(fail, "Invalid call found. Expected: ", par2, ", got: ", par_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer par3 := 8;
  var integer idx3 := 0;
  var CT ct3 := CT.create;
  connect(self:pta_proc[idx3], ct3:pta_proc[idx3]);
  ct3.start(f_behavior_getcall(par3, idx3));
  ct3.done;
  var integer par_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getcall(Sig: { par3 })) {
      setverdict(pass);
    }
    [] any from pta_proc.check(getcall(Sig: { ? }) -> param (par_redir3 := x)) {
      setverdict(fail, "Invalid call found. Expected: ", par3, ", got: ", par_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  
  t.stop;
  
  // test #4: empty check-getcall
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getcall) {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.getreply'
testcase tc_port_getreply() runs on CT {
  f_connect_ports();
  
  // test #1: with all 3 redirects: parameter, return value and index,
  // the index is stored in an integer
  var integer par := 10;
  var integer ret_val := -10;
  var integer idx := 2;
  pta_proc[idx].reply(Sig: { par } value ret_val);
  var integer par_redir, val_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.getreply(Sig: { par } value ret_val)
      -> value val_redir param (par_redir := x) @index value idx_redir {
      if (par != par_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", par, ", got: ", par_redir);
      }
      else if (ret_val != val_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", ret_val, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.getreply(Sig: { ? } value integer: ?)
      -> value val_redir param (par_redir := x) {
      setverdict(fail, "Invalid reply received. Expected parameter ", par,
        " and return value ", ret_val, ", got parameter ", par_redir, " and return value ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no parameter and value redirects, only index redirect
  var integer par2 := 11;
  var integer ret_val2 := -11;
  var integer idx2 := 1;
  pta_proc[idx2].reply(Sig: { par2 } value ret_val2);
  var integer par_redir2, val_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.getreply(Sig: { par2 } value ret_val2) -> @index value idx_redir2 {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.getreply(Sig: { ? } value integer: ?)
      -> value val_redir2 param (par_redir2 := x) {
      setverdict(fail, "Invalid reply received. Expected parameter ", par2,
        " and return value ", ret_val2, ", got parameter ", par_redir2, " and return value ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer par3 := 12;
  var integer ret_val3 := -12
  var integer idx3 := 0;
  pta_proc[idx3].reply(Sig: { par3 } value ret_val3);
  var integer par_redir3, val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.getreply(Sig: { par3 } value ret_val3) {
      setverdict(pass);
    }
     [] any from pta_proc.getreply(Sig: { ? } value integer: ?)
      -> value val_redir3 param (par_redir3 := x) {
      setverdict(fail, "Invalid reply received. Expected parameter ", par3,
        " and return value ", ret_val3, ", got parameter ", par_redir3, " and return value ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty getreply
  pta_proc[1].reply(Sig: { 0 } value 0);
  t.start(0.5);
  alt {
    [] any from pta_proc.getreply {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.check(getreply)'
testcase tc_port_check_getreply() runs on CT {
  f_connect_ports();
  
  // test #1: with all 3 redirects: parameter, return value and index,
  // the index is stored in an integer
  var integer par := 10;
  var integer ret_val := -10;
  var integer idx := 2;
  pta_proc[idx].reply(Sig: { par } value ret_val);
  var integer par_redir, val_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getreply(Sig: { par } value ret_val)
      -> value val_redir param (par_redir := x) @index value idx_redir) {
      if (par != par_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", par, ", got: ", par_redir);
      }
      else if (ret_val != val_redir) {
        setverdict(fail, "Parameter redirect failed. Expected: ", ret_val, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(getreply(Sig: { ? } value integer: ?)
      -> value val_redir param (par_redir := x)) {
      setverdict(fail, "Invalid reply found. Expected parameter ", par,
        " and return value ", ret_val, ", got parameter ", par_redir, " and return value ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no parameter and value redirects, only index redirect
  var integer par2 := 11;
  var integer ret_val2 := -11;
  var integer idx2 := 1; // this has to be less than the index in the
  // previous test, otherwise the reply from the previous test will be found instead
  pta_proc[idx2].reply(Sig: { par2 } value ret_val2);
  var integer par_redir2, val_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getreply(Sig: { par2 } value ret_val2) -> @index value idx_redir2) {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(getreply(Sig: { ? } value integer: ?)
      -> value val_redir2 param (par_redir2 := x)) {
      setverdict(fail, "Invalid reply found. Expected parameter ", par2,
        " and return value ", ret_val2, ", got parameter ", par_redir2, " and return value ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer par3 := 12;
  var integer ret_val3 := -12
  var integer idx3 := 0;
  pta_proc[idx3].reply(Sig: { par3 } value ret_val3);
  var integer par_redir3, val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getreply(Sig: { par3 } value ret_val3)) {
      setverdict(pass);
    }
     [] any from pta_proc.check(getreply(Sig: { ? } value integer: ?)
      -> value val_redir3 param (par_redir3 := x)) {
      setverdict(fail, "Invalid reply received. Expected parameter ", par3,
        " and return value ", ret_val3, ", got parameter ", par_redir3, " and return value ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty check-getreply
  t.start(0.5);
  alt {
    [] any from pta_proc.check(getreply) {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.catch'
testcase tc_port_catch() runs on CT {
  f_connect_ports();
 
  // test #1: with both value redirect and index redirect,
  // the index is stored in an integer
  var integer val := 16;
  var integer idx := 2;
  pta_proc[idx].raise(Sig, val);
  var integer val_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.catch(Sig, val) -> value val_redir @index value idx_redir {
      if (val != val_redir) {
        setverdict(fail, "Value redirect failed. Expected: ", val, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.catch(Sig, integer: ?) -> value val_redir {
      setverdict(fail, "Invalid exception caught. Expected: ", val, ", got: ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no value redirect, only index redirect
  var integer val2 := 17;
  var integer idx2 := 1;
  pta_proc[idx2].raise(Sig, val2);
  var integer val_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.catch(Sig, val2) -> @index value idx_redir2 {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.catch(Sig, integer: ?) -> value val_redir2 {
      setverdict(fail, "Invalid exception caught. Expected: ", val2, ", got: ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer val3 := 18;
  var integer idx3 := 0;
  pta_proc[idx3].raise(Sig, val3);
  var integer val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.catch(Sig, val3) {
      setverdict(pass);
    }
    [] any from pta_proc.catch(Sig, integer: ?) -> value val_redir3 {
      setverdict(fail, "Invalid exception caught. Expected: ", val3, ", got: ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty catch
  pta_proc[1].raise(Sig, 0);
  t.start(0.5);
  alt {
    [] any from pta_proc.catch {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.check(catch)'
testcase tc_port_check_catch() runs on CT {
  f_connect_ports();
 
  // test #1: with both value redirect and index redirect,
  // the index is stored in an integer
  var integer val := 16;
  var integer idx := 2;
  pta_proc[idx].raise(Sig, val);
  var integer val_redir, idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(catch(Sig, val) -> value val_redir @index value idx_redir) {
      if (val != val_redir) {
        setverdict(fail, "Value redirect failed. Expected: ", val, ", got: ", val_redir);
      }
      else if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(catch(Sig, integer: ?) -> value val_redir) {
      setverdict(fail, "Invalid exception found. Expected: ", val, ", got: ", val_redir);
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: with no value redirect, only index redirect
  var integer val2 := 17;
  var integer idx2 := 1; // this has to be less than the index in the
  // previous test, otherwise the exception from the previous test will be found instead
  pta_proc[idx2].raise(Sig, val2);
  var integer val_redir2, idx_redir2;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(catch(Sig, val2) -> @index value idx_redir2) {
      if (idx2 != idx_redir2) {
        setverdict(fail, "Index redirect failed. Expected: ", idx2, ", got: ", idx_redir2);
      }
      else {
        setverdict(pass);
      }
    }
    [] any from pta_proc.check(catch(Sig, integer: ?) -> value val_redir2) {
      setverdict(fail, "Invalid exception caught. Expected: ", val2, ", got: ", val_redir2);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with no redirects
  var integer val3 := 18;
  var integer idx3 := 0;
  pta_proc[idx3].raise(Sig, val3);
  var integer val_redir3;
  t.start(0.5);
  alt {
    [] any from pta_proc.check(catch(Sig, val3)) {
      setverdict(pass);
    }
    [] any from pta_proc.check(catch(Sig, integer: ?) -> value val_redir3) {
      setverdict(fail, "Invalid exception caught. Expected: ", val3, ", got: ", val_redir3);
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty check-catch
  t.start(0.5);
  alt {
    [] any from pta_proc.check(catch) {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
}

// tests for 'any from <port array>.check'
testcase tc_port_check() runs on CT {
  f_connect_ports();

  // test #1: with index redirect, checking the message ports
  var IntList idx := { 1, 0 };
  pta_msg[idx[0]][idx[1]].send(19);
  var IntList idx_redir;
  timer t;
  t.start(0.5);
  alt {
    [] any from pta_msg.check(-> @index value idx_redir) {
      if (idx != idx_redir) {
        setverdict(fail, "Index redirect failed. Expected: ", idx, ", got: ", idx_redir);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: empty check (with no index redirect), checking the procedure ports
  pta_proc[2].reply(Sig: { 20 } value 21);
  t.start(0.5);
  alt {
    [] any from pta_proc.check {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
}

// tests for 'any from <timer array>.timeout'
testcase tc_timer_timeout() runs on CT {
  timer master;
  timer t[3];
  var integer idx;
  t[0].start(0.4);
  t[1].start(0.6);
  t[2].start(0.2);
  master.start(1.0); // just for safety
  alt {
    [] any from t.timeout -> @index value idx {
      if (idx != 2) {
        setverdict(fail, "Index redirect failed. Expected: 2, got: ", idx);
      }
      else {
        setverdict(pass);
      }
    }
    [] master.timeout {
      setverdict(fail, "Master timer timed out.");
    }
  }
}

// tests for 'any from <timer array>.running'
testcase tc_timer_running() runs on CT {
  timer t[3];
  var integer idx;
  t[0].start(0.05);
  t[1].start(0.3);
  t[2].start(0.3);
  t[0].timeout;
  if (any from t.running -> @index value idx) {
    if (idx != 1) {
      setverdict(fail, "Index redirect failed. Expected: 1, got: ", idx);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Running operation returned false.");
  }
}

// behavior function for 'done', 'killed', 'running' and 'alive' tests
// for component arrays
// the function waits for a specified amount before ending
function f_behavior_done(in float p) runs on CT return IntDone {
  timer t := p;
  t.start;
  t.timeout;
  return float2int(p * 100.0);
}

// tests for 'any from <component array>.done'
testcase tc_component_done() runs on CT {
  // test #1: with matching template and index redirect,
  // 'any from' + component array
  var CT_Array cta;
  cta[0] := CT.create;
  cta[1] := CT.create;
  cta[2] := CT.create;
  cta[0].start(f_behavior_done(0.4));
  cta[1].start(f_behavior_done(0.4));
  cta[2].start(f_behavior_done(0.2));
  var integer idx;
  timer t;
  t.start(1.0);
  alt {
    [] any from cta.done(IntDone: ?) -> @index value idx {
      if (idx != 2) {
        setverdict(fail, "Index redirect failed. Expected: 2, got: ", idx);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: empty done (without index redirect),
  // 'any from' + component array
  t.start(1.0);
  alt {
    [] any from cta.done {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with matching template and index redirect,
  // 'any from' + function returning a component array
  var integer idx2;
  var CT_Array cta2;
  cta2[0] := CT.create;
  cta2[1] := CT.create;
  cta2[2] := CT.create;
  cta2[0].start(f_behavior_done(0.4));
  cta2[1].start(f_behavior_done(0.2));
  cta2[2].start(f_behavior_done(0.4));
  t.start(1.0);
  alt {
    [] any from f_comp_array(cta2).done(IntDone: ?) -> @index value idx2 {
      if (idx2 != 1) {
        setverdict(fail, "Index redirect failed. Expected: 1, got: ", idx2);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty done (without index redirect),
  // 'any from' + function returning a component array
  t.start(1.0);
  alt {
    [] any from f_comp_array(cta2).done {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
  t.stop;
  
  // test #5: with matching template and index redirect,
  // 'any from' + dereferencing a function returning a component array
  var CT_Array cta3;
  cta3[0] := CT.create;
  cta3[1] := CT.create;
  cta3[2] := CT.create;
  cta3[0].start(f_behavior_done(0.2));
  cta3[1].start(f_behavior_done(0.4));
  cta3[2].start(f_behavior_done(0.4));
  var F_type f_ptr := refers(f_comp_array);
  var integer idx3;
  t.start(1.0);
  alt {
    [] any from f_ptr.apply(cta3).done(IntDone: ?) -> @index value idx3 {
      if (idx3 != 0) {
        setverdict(fail, "Index redirect failed. Expected: 0, got: ", idx3);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #5 timed out.");
    }
  }
  t.stop;
  
  // test #6: empty done (without index redirect),
  // 'any from' + dereferencing a function returning a component array
  t.start(1.0);
  alt {
    [] any from f_ptr.apply(cta3).done {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #6 timed out.");
    }
  }
}

// tests for 'any from <component array>.killed'
testcase tc_component_killed() runs on CT {
  // test #1: with index redirect,
  // 'any from' + component array
  var CT_Array cta;
  cta[0] := CT.create;
  cta[1] := CT.create;
  cta[2] := CT.create;
  cta[0].start(f_behavior_done(0.4));
  cta[1].start(f_behavior_done(0.4));
  cta[2].start(f_behavior_done(0.2));
  var integer idx;
  timer t;
  t.start(1.0);
  alt {
    [] any from cta.killed -> @index value idx {
      if (idx != 2) {
        setverdict(fail, "Index redirect failed. Expected: 2, got: ", idx);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #1 timed out.");
    }
  }
  t.stop;
  
  // test #2: empty killed (without index redirect),
  // 'any from' + component array
  t.start(1.0);
  alt {
    [] any from cta.killed {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #2 timed out.");
    }
  }
  t.stop;
  
  // test #3: with index redirect,
  // 'any from' + function returning a component array
  var integer idx2;
  var CT_Array cta2;
  cta2[0] := CT.create;
  cta2[1] := CT.create;
  cta2[2] := CT.create;
  cta2[0].start(f_behavior_done(0.4));
  cta2[1].start(f_behavior_done(0.2));
  cta2[2].start(f_behavior_done(0.4));
  t.start(1.0);
  alt {
    [] any from f_comp_array(cta2).killed -> @index value idx2 {
      if (idx2 != 1) {
        setverdict(fail, "Index redirect failed. Expected: 1, got: ", idx2);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #3 timed out.");
    }
  }
  t.stop;
  
  // test #4: empty killed (without index redirect),
  // 'any from' + function returning a component array
  t.start(1.0);
  alt {
    [] any from f_comp_array(cta2).killed {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #4 timed out.");
    }
  }
  t.stop;
  
  // test #5: with index redirect,
  // 'any from' + dereferencing a function returning a component array
  var CT_Array cta3;
  cta3[0] := CT.create;
  cta3[1] := CT.create;
  cta3[2] := CT.create;
  cta3[0].start(f_behavior_done(0.2));
  cta3[1].start(f_behavior_done(0.4));
  cta3[2].start(f_behavior_done(0.4));
  var F_type f_ptr := refers(f_comp_array);
  var integer idx3;
  t.start(1.0);
  alt {
    [] any from f_ptr.apply(cta3).killed -> @index value idx3 {
      if (idx3 != 0) {
        setverdict(fail, "Index redirect failed. Expected: 0, got: ", idx3);
      }
      else {
        setverdict(pass);
      }
    }
    [] t.timeout {
      setverdict(fail, "Test #5 timed out.");
    }
  }
  t.stop;
  
  // test #6: empty killed (without index redirect),
  // 'any from' + dereferencing a function returning a component array
  t.start(1.0);
  alt {
    [] any from f_ptr.apply(cta3).killed {
      setverdict(pass);
    }
    [] t.timeout {
      setverdict(fail, "Test #6 timed out.");
    }
  }
}

// tests for 'any from <component array>.running'
testcase tc_component_running() runs on CT {
  // test #1: 'any from' + component array
  var CT_Array cta;
  cta[0] := CT.create;
  cta[1] := CT.create;
  cta[2] := CT.create;
  cta[0].start(f_behavior_done(0.05));
  cta[1].start(f_behavior_done(0.05));
  cta[2].start(f_behavior_done(0.3));
  cta[0].done;
  cta[1].done;
  var integer idx;
  if (any from cta.running -> @index value idx) {
    if (idx != 2) {
      setverdict(fail, "Index redirect failed. Expected: 2, got: ", idx);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Running operation #1 returned false.");
  }
  if (any from cta.running) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Running operation #2 returned false.");
  }
  
  // test #2: 'any from' + function returning a component array
  var CT_Array cta2;
  cta2[0] := CT.create;
  cta2[1] := CT.create;
  cta2[2] := CT.create;
  cta2[0].start(f_behavior_done(0.05));
  cta2[1].start(f_behavior_done(0.3));
  cta2[2].start(f_behavior_done(0.05));
  cta2[0].done;
  cta2[2].done;
  var integer idx2;
  if (any from f_comp_array(cta2).running -> @index value idx2) {
    if (idx2 != 1) {
      setverdict(fail, "Index redirect failed. Expected: 1, got: ", idx2);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Running operation #3 returned false.");
  }
  if (any from f_comp_array(cta2).running) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Running operation #4 returned false.");
  }
  
  // test #3: 'any from' + dereferencing a function returning a component array
  var CT_Array cta3;
  cta3[0] := CT.create;
  cta3[1] := CT.create;
  cta3[2] := CT.create;
  cta3[0].start(f_behavior_done(0.3));
  cta3[1].start(f_behavior_done(0.05));
  cta3[2].start(f_behavior_done(0.05));
  cta3[1].done;
  cta3[2].done;
  var F_type f_ptr := refers(f_comp_array);
  var integer idx3;
  if (any from f_ptr.apply(cta3).running -> @index value idx3) {
    if (idx3 != 0) {
      setverdict(fail, "Index redirect failed. Expected: 0, got: ", idx3);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Running operation #5 returned false.");
  }
  if (any from f_ptr.apply(cta3).running) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Running operation #6 returned false.");
  }
}

// tests for 'any from <component array>.alive'
testcase tc_component_alive() runs on CT {
  // test #1: 'any from' + component array
  var CT_Array cta;
  cta[0] := CT.create;
  cta[1] := CT.create;
  cta[2] := CT.create;
  cta[0].start(f_behavior_done(0.05));
  cta[1].start(f_behavior_done(0.05));
  cta[2].start(f_behavior_done(0.3));
  cta[0].killed;
  cta[1].killed;
  var integer idx;
  if (any from cta.alive -> @index value idx) {
    if (idx != 2) {
      setverdict(fail, "Index redirect failed. Expected: 2, got: ", idx);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Alive operation #1 returned false.");
  }
  if (any from cta.alive) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Alive operation #2 returned false.");
  }
  
  // test #2: 'any from' + function returning a component array
  var CT_Array cta2;
  cta2[0] := CT.create;
  cta2[1] := CT.create;
  cta2[2] := CT.create;
  cta2[0].start(f_behavior_done(0.05));
  cta2[1].start(f_behavior_done(0.3));
  cta2[2].start(f_behavior_done(0.05));
  cta2[0].killed;
  cta2[2].killed;
  var integer idx2;
  if (any from f_comp_array(cta2).alive -> @index value idx2) {
    if (idx2 != 1) {
      setverdict(fail, "Index redirect failed. Expected: 1, got: ", idx2);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Alive operation #3 returned false.");
  }
  if (any from f_comp_array(cta2).alive) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Alive operation #4 returned false.");
  }
  
  // test #3: 'any from' + dereferencing a function returning a component array
  var CT_Array cta3;
  cta3[0] := CT.create;
  cta3[1] := CT.create;
  cta3[2] := CT.create;
  cta3[0].start(f_behavior_done(0.3));
  cta3[1].start(f_behavior_done(0.05));
  cta3[2].start(f_behavior_done(0.05));
  cta3[1].killed;
  cta3[2].killed;
  var F_type f_ptr := refers(f_comp_array);
  var integer idx3;
  if (any from f_ptr.apply(cta3).alive -> @index value idx3) {
    if (idx3 != 0) {
      setverdict(fail, "Index redirect failed. Expected: 0, got: ", idx3);
    }
    else {
      setverdict(pass);
    }
  }
  else {
    setverdict(fail, "Alive operation #5 returned false.");
  }
  if (any from f_ptr.apply(cta3).alive) {
    setverdict(pass);
  }
  else {
    setverdict(fail, "Alive operation #6 returned false.");
  }
}


control {
  execute(tc_port_receive());
  execute(tc_port_check_receive());
  execute(tc_port_trigger());
  execute(tc_port_getcall());
  execute(tc_port_check_getcall());
  execute(tc_port_getreply());
  execute(tc_port_check_getreply());
  execute(tc_port_catch());
  execute(tc_port_check_catch());
  execute(tc_port_check());
  execute(tc_timer_timeout());
  execute(tc_timer_running());
  execute(tc_component_done());
  execute(tc_component_killed());
  execute(tc_component_running());
  execute(tc_component_alive());
}

}
