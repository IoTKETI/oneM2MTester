.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno. 12/15291-CRL200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/RZD Endre Szalai (+36 1 437 7796)
:appr.ETH/RZ (Zsolt Szendrei)
:checked.ETHGRY

:title.Test description of the ASN.1 Semantic Analyzer: Unknown Object
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2005-02-03   ETHESI     New document
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the ASN.1
compiler:
:nl.SA-1/x: Unknown Object.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h2.Test scope
.*---------------------------------------------------------------------*
Ref [1]: SA-1/x: Unknown object
:nl.Explanation: all unknown objects shall be detected by SA.
.*---------------------------------------------------------------------*
:h2.Test strategy
.*---------------------------------------------------------------------*
Test cases are based on ASN.1 BNF according to the followings:
:list.
:li D='1.'.For each 'basic' definition a complete coverage is done (e.g. for
expressions, assignments, etc.). 'Basic' means that the definition is
used in several places.
:li D='2.'.For each definition a complete coverage is done, except for basic
definitions, in which case only 1-2 examples are covered, not the
whole basic definition. This is to avoid testing all possible subcases
for all possible places it may appear.
:nl.NOTE: a complete coverage means that all occurances are tested where
the specific definition may occur. This is however not complete. Only
one occurance is tested for each construct.
:li D='3.'.Test case names are contsructed following the path in the BNF in TTCN-3
and following the possible notations/subtyping in ASN.1.
:elist.
.*---------------------------------------------------------------------*
:h2.Status
.*---------------------------------------------------------------------*
This is not yet an official document.
:nl.The following structures are not covered:
:list.
:li D='-'.ASN.1:: X.681-X.683
:li D='-'.ASN.1:: only type assignments are covered, value assignments are not
:li D='-'.sub-structures that causes parse error due to limited support of that
part of the language (e.g. interleave construct)
:elist.
.*---------------------------------------------------------------------*
:h2.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.ASN1::ModuleIdentifier->DefinitiveIdentifier->NameForm
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::ModuleIdentifier->DefinitiveIdentifier->NameForm>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN ModuleA ModuleA.asn>
Module-A { nonexi } DEFINITIONS ::=
BEGIN
   -- NOTE: nameform checks are not yet implemented
   IMPORTS ;
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::ModuleIdentifier->DefinitiveIdentifier->DefinitiveNameAndNumberForm
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::ModuleIdentifier->DefinitiveIdentifier->DefinitiveNameAndNumberForm>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN ModuleA ModuleA.asn>
Module-A { nonexi(7) } DEFINITIONS ::=
BEGIN
   -- NOTE: nameform checks are not yet implemented
   IMPORTS ;
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Exports
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Exports>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN ModuleA ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   -- TR 1: compiler hangs if an unexpected EXPORT part is detected
   -- IMPORTS ;
   EXPORTS A, Nonexi;
   IMPORTS ;
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->NameAndNumberForm
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->NameAndNumberForm>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS B FROM Module-B {0 Nonexi 0};
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B {0 4 0} DEFINITIONS ::=
BEGIN
   EXPORTS ALL;
   IMPORTS ;
   B ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue->ExternalValueReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue->ExternalValueReference>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   -- Obj id values are ignored
   IMPORTS c-VAL-OBJ-ID FROM Module-C
           B FROM Module-B {0 Module-C.Nonexi 0};
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B {0 4 0} DEFINITIONS ::=
BEGIN
   EXPORTS B;
   IMPORTS ;
   B ::= SEQUENCE { f1 INTEGER }
   vAL-OBJ-ID OBJECT IDENTIFIER ::= {0 4 0}
END
<END_MODULE>
<MODULE ASN Module-C ModuleC.asn>
Module-C DEFINITIONS ::=
BEGIN
   EXPORTS c-VAL-OBJ-ID;
   IMPORTS ;
   c-VAL-OBJ-ID OBJECT IDENTIFIER ::= {0 4 0}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue->ExternalValueReference (circular reference)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue->ExternalValueReference (circular reference)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   -- Obj id values are ignored
   IMPORTS B FROM Module-B {0 Module-B.vAL-OBJ-ID 0};
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B {0 4 0} DEFINITIONS ::=
BEGIN
   EXPORTS B;
   IMPORTS ;
   B ::= SEQUENCE { f1 INTEGER }
   vAL-OBJ-ID OBJECT IDENTIFIER ::= {0 4 0}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Imports->GlobalModuleReference->ObjectIdentifierValue->DefinedValue>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   -- Obj id values are ignored
   -- TR 658: segfault when using definedvalue in global module reference
   IMPORTS B FROM Module-B nonexi;
   A ::= SEQUENCE { f1 INTEGER }
   -- val-OBJ-ID OBJECT IDENTIFIER ::= {0 4 0}
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B {0 4 0} DEFINITIONS ::=
BEGIN
   EXPORTS B;
   IMPORTS ;
   B ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::Imports->Symbol
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::Imports->Symbol>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS B, Nonexi FROM Module-B;
   A ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B DEFINITIONS ::=
BEGIN
   -- TR 659: parse error when using EXPORTS ALL
   EXPORTS ALL;
   IMPORTS ;
   B ::= SEQUENCE { f1 INTEGER }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BOOLEAN->SingleValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BOOLEAN->SingleValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BOOLEAN ( nonexi )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BOOLEAN->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BOOLEAN->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BOOLEAN ( NONEXI )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NULL->SingleValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NULL->SingleValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NULL ( nonexi )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NULL->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NULL->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NULL ( NONEXI )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: INTEGER->Named value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: INTEGER->Named value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER { mchalls(-767), thisistheone(nonexi) }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: INTEGER->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: INTEGER->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: INTEGER->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: INTEGER->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: INTEGER->Value range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: INTEGER->Value range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (666..nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ENUMERATED->Numbering
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ENUMERATED->Numbering>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ENUMERATED { my-hero (0), is-a-great(1), comedy(nonexi) }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ENUMERATED->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ENUMERATED->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ENUMERATED { my-hero (0), is-a-great(1), comedy(9999) }
         (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ENUMERATED->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ENUMERATED->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ENUMERATED { my-hero (0), is-a-great(1), comedy(9999) }
         (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Single value inside
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Single value inside>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- NOTE: constraints are not yet supported
   -- TR 660: single value constraints are not recognized for compound ypes
   -- X ::= REAL ({mantissa 10, base 10, exponent 1})
   X ::= REAL ({mantissa 10, base 10, exponent nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Nonexistent field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Nonexistent field>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- NOTE: constraints are not yet supported
   -- TR 660: single value constraints are not recognized for compound ypes
   X ::= REAL ({mantissa 10, base 10, exponent 1, nonexi 1})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Interval
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Interval>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL ({mantissa 10, base 10, exponent 1}
             ..nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Interval inside
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Interval inside>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- NOTE: constraints are not yet supported
   X ::= REAL ({mantissa 10, base nonexi, exponent 1}
             ..{mantissa 10, base 10, exponent 1})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL
   Y ::= X ((WITH COMPONENT (1000..nonexi)))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Single inner type constraint \(WITH COMPONENT\) cannot be used on type `float'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->Embedded InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->Embedded InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE SIZE (6) OF SEQUENCE SIZE (6) OF REAL
   Y ::= X (WITH COMPONENT (WITH COMPONENT (-100..nonexi)))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints->MultipleTypeConstraints->FullSpecification
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints->MultipleTypeConstraints->FullSpecification>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL
   Y ::= X (WITH COMPONENTS { mantissa (-65535..65536),
                              base (10),
                              exponent (-127..nonexi) })
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints->MultipleTypeConstraints->PartialSpecification
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: REAL->InnerTypeConstraints->MultipleTypeConstraints->PartialSpecification>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= REAL
   Y ::= X (WITH COMPONENTS { ..., exponent (-127..nonexi) })
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Named bit
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Named bit>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING { nullbit(0), non-null-bit(1), it-s-tricky(nonexi) }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
TODO: from here
.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (SIZE(10..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->Size->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (SIZE(1|2|3|10..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->CONTAINING
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->CONTAINING>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   obj-id OBJECT IDENTIFIER ::= {0 4 0}
   X ::= BIT STRING (CONTAINING Nonexi ENCODED BY obj-id)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BIT STRING->ENCODED BY
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BIT STRING->ENCODED BY>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BIT STRING (CONTAINING INTEGER ENCODED BY nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (SIZE(9999..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->Size->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (SIZE(0|100|107|9999..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->CONTAINING
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->CONTAINING>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (CONTAINING NONEXI ENCODED BY {0 4 0})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OCTET STRING->ENCODED BY
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OCTET STRING->ENCODED BY>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OCTET STRING (CONTAINING INTEGER ENCODED BY nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OBJECT IDENTIFIER (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Single value->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Single value->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= OBJECT IDENTIFIER ({0 4 nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: OBJECT IDENTIFIER->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= OBJECT IDENTIFIER (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= RELATIVE-OID -- {0 4 0 } -- (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Single value->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Single value->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= RELATIVE-OID -- {0 4 0 } -- ({0 4 nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: RELATIVE-OID->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= RELATIVE-OID -- {0 4 0 } -- (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: NumericString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: NumericString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= NumericString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: PrintableString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: PrintableString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= PrintableString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VisibleString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VisibleString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VisibleString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ISO646String->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ISO646String->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ISO646String (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: IA5String->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: IA5String->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= IA5String (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `TeletexString'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: TeletexString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: TeletexString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= TeletexString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `TeletexString'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: T61String->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: T61String->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= T61String (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: VideotexString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: VideotexString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= VideotexString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `VideotexString'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.



.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `GraphicString'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GraphicString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GraphicString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GraphicString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `GeneralString'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->Value list>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= UniversalString ({0 0 0 65}|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->Value list->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->Value list->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= UniversalString ({0 0 0 65}|{0 0 0 nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UniversalString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UniversalString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UniversalString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->Value list>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= BMPString ({0 0 0 65}|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->Value list->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->Value list->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TODO
   X ::= BMPString ({0 0 0 65}|{0 0 0 nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: BMPString->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: BMPString->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= BMPString (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTF8String->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTF8String->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTF8String (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `ObjectDescriptor'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ObjectDescriptor->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= ObjectDescriptor (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `GeneralizedTime'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: GeneralizedTime->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: GeneralizedTime->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= GeneralizedTime (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (SIZE(7|13|88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->Value list
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->Value list>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime ("getting"|"more"|"tricky"|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->Alphabet constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->Alphabet constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (FROM ("0".."9"|"*"|"#"|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `UTCTime'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: UTCTime->PATTERN
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: UTCTime->PATTERN>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= UTCTime (PATTERN nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->TypeReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->TypeReference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE { f1 BOOLEAN, f2 NONEXI }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->DEFAULT
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->DEFAULT>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE { f1 BOOLEAN, f2 INTEGER DEFAULT nonexi }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->COMPONENTS OF
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->COMPONENTS OF>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE { COMPONENTS OF NONEXI, f2 X OPTIONAL }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->Single value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 660: single value constraints are not recognized for compound ypes
   X ::= SEQUENCE { f1 X OPTIONAL } ( { f1 { f1 { f1 - } } } )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE { f1 X OPTIONAL } (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= SEQUENCE { f1 BOOLEAN, f2 INTEGER, f3 OCTET STRING }
   X ::= Y (WITH COMPONENTS{ ..., f2 (2|4|5|10), f3 (SIZE(2..nonexi)) })
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->TypeReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->TypeReference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET { f1 BOOLEAN, f2 NONEXI }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->DEFAULT
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->DEFAULT>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET { f1 BOOLEAN, f2 INTEGER DEFAULT nonexi }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->COMPONENTS OF
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->COMPONENTS OF>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET { COMPONENTS OF NONEXI, f2 X OPTIONAL }
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->Single value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 660: single value constraints are not recognized for compound ypes
   X ::= SET { f1 X OPTIONAL } ( { f1 { f1 { f1 - } } } )
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET { f1 X OPTIONAL } (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= SET { f1 BOOLEAN, f2 INTEGER, f3 OCTET STRING }
   X ::= Y (WITH COMPONENTS{ ..., f2 (2|4|5|10), f3 (SIZE(2..nonexi)) })
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Single value->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Single value->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 660: single value constraints are not recognized for compound ypes
   X ::= SEQUENCE OF INTEGER ({0, 0, 17, 18, nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE OF INTEGER (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE OF INTEGER (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE OF INTEGER (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE OF INTEGER (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE OF INTEGER (SIZE(88|17|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SEQUENCE OF->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= SEQUENCE OF INTEGER
   X ::= Y (WITH COMPONENT(-100..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->Single value->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->Single value->Embedded>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 660: single value constraints are not recognized for compound ypes
   X ::= SET OF INTEGER ({0, 0, 17, 18, nonexi})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?tableconstraint
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET OF INTEGER (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET OF INTEGER (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET OF INTEGER (SIZE(nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET OF INTEGER (SIZE(88..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->List
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->SIZE->List>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SET OF INTEGER (SIZE(88|17|nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: SET OF->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: SET OF->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= SET OF INTEGER
   X ::= Y (WITH COMPONENT(-100..nonexi))
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: CHOICE->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: CHOICE->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHOICE { f1 BOOLEAN, f2 INTEGER, f3 X } (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: CHOICE->Single value->Embedded
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: CHOICE->Single value->Embedded>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHOICE { f1 BOOLEAN, f2 INTEGER, f3 X } (f2:nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: CHOICE->Type inclusion
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: CHOICE->Type inclusion>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHOICE { f1 BOOLEAN, f2 INTEGER, f3 X } (NONEXI)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: CHOICE->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: CHOICE->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= CHOICE { f1 BOOLEAN, f2 INTEGER, f3 X }
   X ::= Y (WITH COMPONENTS {..., f2 (100..200), f3 (nonexi)})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: CHOICE->Selecting alternative
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: CHOICE->Selecting alternative>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= CHOICE { f1 BOOLEAN, f2 INTEGER }
   my-value f2 < NONEXI ::= 10
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ANY
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ANY>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   x ANY ::= NONEXI : '0011'H
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)error.+?syntax.+?error.+?unexpected.+?\:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->BuiltinType: ANY->DEFINED BY
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->BuiltinType: ANY->DEFINED BY>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= SEQUENCE {f1 INTEGER,
                   f2 ANY DEFINED BY nonexi}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Exception->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Exception->Type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Dimensions ::= SET { x INTEGER,
                        y BOOLEAN,
                        ... !NONEXI:"dimension error"}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Exception->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Exception->Value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Dimensions ::= SET { x INTEGER,
                        y BOOLEAN,
                        ... !IA5String:nonexi}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint combination: UNION
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint combination: UNION>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (1|2|3|nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint combination: INTERSECTION
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint combination: INTERSECTION>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (0..200 ^ 100..nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint combination: EXCEPT
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint combination: EXCEPT>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (0..200 EXCEPT nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint combination: ALL EXCEPT
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint combination: ALL EXCEPT>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= INTEGER (ALL EXCEPT nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint exception->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint exception->Type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 662: Exception extension with value list subtyping gives parse error
   -- TODO
   X ::= INTEGER (1|2|3,...!NONEXI:"Fatal")
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->Constraint exception->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->Constraint exception->Value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   -- TR 662: Exception extension with value list subtyping gives parse error
   -- TODO
   X ::= INTEGER (1|2|3,...!IA5String:nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->User defined constraint->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->User defined constraint->Type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X{PARAM} ::= BIT STRING
   (CONSTRAINED BY {NONEXI} !Error:securityViolation)
   Error ::= ENUMERATED {securityViolation}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->User defined constraint->Exception->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->User defined constraint->Exception->Type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= BIT STRING (SIZE(2))
   X{PARAM} ::= BIT STRING
   (CONSTRAINED BY {PARAM} !NONEXI:securityViolation)
   Error ::= ENUMERATED {securityViolation}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->User defined constraint->Exception->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->User defined constraint->Exception->Value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= BIT STRING (SIZE(2))
   X{PARAM} ::= BIT STRING
   (CONSTRAINED BY {PARAM} !Error:nonexi)
   Error ::= ENUMERATED {securityViolation}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->EMBEDDED PDV->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->EMBEDDED PDV->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= EMBEDDED PDV
   X ::= Y (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->EMBEDDED PDV->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->EMBEDDED PDV->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   Y ::= EMBEDDED PDV
   X ::= Y (WITH COMPONENTS {..., data-value (nonexi) })
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->CHARACTER STRING->Single value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->CHARACTER STRING->Single value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHARACTER STRING (nonexi)
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->CHARACTER STRING->InnerTypeConstraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->CHARACTER STRING->InnerTypeConstraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHARACTER STRING (WITH COMPONENTS {..., string-value (nonexi)})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::TypeAssignment->CHARACTER STRING
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::TypeAssignment->CHARACTER STRING>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
   IMPORTS ;
   X ::= CHARACTER STRING (WITH COMPONENTS {..., string-value (nonexi)})
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?assignment.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->Enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->Enumerated>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
Months ::= ENUMERATED {
  january,
  february,
  march,
  april,
  may,
  june,
  july,
  august,
  september,
  october,
  november,
  december
}
First-quarter ::= Months ( january | february | march )
Second-quarter ::= Months ( april | may | june )
Third-quarter ::= Months ( july | august | september )
Fourth-quarter ::= Months ( october | november | december )
First-half ::= Months ( First-quarter | Second-quarter )
Second-half ::= Months ( Third-quarter | Fourth-quarter )
m1 First-half ::= december
MyMonths1 ::= Months ( SIZE ( 1..10 ) | january )
MyMonths2 ::= Months ( FROM ( First-quarter ) )
MyMonths3 ::= Months ( ALL EXCEPT First-quarter)
mm3 MyMonths3 ::= january
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: december is not a valid value for type `.+Months' which has subtype \(january,february,march,april,may,june\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Size constraint is not allowed for type `.+Months'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Permitted alphabet constraint is not allowed for type `.+Months'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: january is not a valid value for type `.+Months' which has subtype \(ALL except \(january,february,march\)\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->Integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->Integer>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
MyInt1 ::= INTEGER (1..5)
mi11 MyInt1 ::= 3
mi12 MyInt1 ::= 6
MyInt2 ::= INTEGER ( REAL(1.0..3.0) UNION PrintableString("abc") UNION INTEGER(1..10) )
MyInt3 ::= INTEGER ( SIZE(10) EXCEPT FROM(1..10) )
MyInt4 ::= MyInt2 (MyInt3)
MyInt5 ::= INTEGER ( PATTERN "abc" EXCEPT 5 )
MyInt6 ::= INTEGER ( ALL EXCEPT ((MIN..0) UNION (0..MAX)) )
MyInt7 ::= INTEGER (1..10) (5..15)
MyInt9 ::= INTEGER (5..6 EXCEPT 1..10)
MyInt10::= INTEGER ( MIN..MAX )
MyInt11::= INTEGER ( INTEGER )
MyInt12::= INTEGER ( INTEGER(1 EXCEPT 1) )
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: 6 is not a valid value for type `integer' which has subtype \(1..5\)
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: Contained subtype constraint is invalid, constrained and constraining types have different root type
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Size constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Permitted alphabet constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Pattern constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 3>
(?im)\berror: The subtype is an empty set
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #2 is \(5..15\), this is not a subset of \(1..10\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: The subtype of type `integer' is a full set, it does not constrain the root type.
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Contained subtype constraint is invalid, the constraining type has no subtype constraint
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->String types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->String types>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
MyIntRange ::= INTEGER ( 6..9 )
MyStrRange ::= PrintableString ( SIZE( ((-1 .. 3) EXCEPT -1) UNION MyIntRange ) )
myStrVal MyStrRange ::= "abcd"

VanillaBMPString ::= BMPString (FROM (BMPString(SIZE(1)) EXCEPT (C0 | C1)))
C0 ::= BMPString (FROM ({0,0,0,0} .. {0,0,0,31}))
C1 ::= BMPString (FROM ({0,0,0,128} .. {0,0,0,159}))
strVanilla VanillaBMPString ::= {0,0,0,0}

MyStrRange222 ::= PrintableString ( SIZE((10 .. -10)) )

VS1 ::= VisibleString ( SIZE (1..10) INTERSECTION ( FROM ("A".."Z")  EXCEPT "ABC" ) )
vs1 VS1 ::= "ABC"
VS2 ::= VisibleString ( SIZE (1..10) INTERSECTION FROM("A".."Z") )
vs2 VS2 ::= "ABC"

VSwrng ::= VisibleString (FROM(MIN..MAX))

NS ::= NumericString ( FROM( "12345" EXCEPT  "3".."6") )
ns NS ::= "567"

VSfrom1 ::= VisibleString ( FROM("abc") UNION FROM("f".."r") )
vsf1 VSfrom1 ::= "abcfr"
VSfrom2 ::= VisibleString ( FROM( "abc" UNION ("f".."r") )  )
vsf2a VSfrom2 ::= "abcfr"
vsf2b VSfrom2 ::= "xyz"

TouchToneString ::= IA5String ( FROM("0123456789"|"*"|"#") ) ( SIZE(1..63) )
tts TouchToneString ::= "abc"
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: "abcd" is not a valid value for type `PrintableString' which has subtype \(from\(" ","'".."\)","\+"..":","=","\?","A".."Z","a".."z"\) intersection length\(0..3,6..9\)\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: char\(0, 0, 0, 0\) is not a valid value for type `BMPString' which has subtype from\(" "..char\(0, 0, 0, 127\),char\(0, 0, 0, 160\)..char\(0, 0, 255, 255\)\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: lower boundary is bigger than upper boundary in INTEGER value range constraint
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "ABC" is not a valid value for type `VisibleString' which has subtype \(length\(1..10\) intersection \(from\("A".."Z"\) except \("ABC"\)\)\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: The subtype of type `VisibleString' is a full set, it does not constrain the root type.
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "567" is not a valid value for type `NumericString' which has subtype from\("1".."2"\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "abcfr" is not a valid value for type `VisibleString' which has subtype \(from\("a".."c"\) union from\("f".."r"\)\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "xyz" is not a valid value for type `VisibleString' which has subtype from\("a".."c","f".."r"\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "abc" is not a valid value for type `IA5String' which has subtype \(from\("#","\*","0".."9"\) intersection length\(1..63\)\)
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->Parametrized types: Type and value parameters
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->Parametrized types: Type and value parameters>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
MyInt ::= INTEGER (10..20)
MyPT1{DummyTypeRef} ::= DummyTypeRef
MyPT1instance ::= MyPT1{MyInt}
myPT1inst MyPT1instance ::= 5

MyParamRecOfType{DummyPar1} ::= SEQUENCE OF DummyPar1
myPRof-const MyParamRecOfType{MyInt} ::= { 1,2 }

MyValueParamRecOf{INTEGER:lowerBound,INTEGER:upperBound} ::= SEQUENCE SIZE(lowerBound..upperBound) OF INTEGER
myVPRof-const MyValueParamRecOf{7,9} ::= { 1,2,3 }

MyIntFld  ::= INTEGER (1..5)
MyBoolFld ::= BOOLEAN (FALSE)
MyStrFld  ::= VisibleString (FROM("abc"))
MyRecParamType{DP1,DP2,DP3}
::= SEQUENCE
{
  fld1 DP1,
  fld2 DP2,
  fld3 DP3
}
myRPT MyRecParamType{MyIntFld,MyBoolFld,MyStrFld} ::= { fld1 -33, fld2 TRUE, fld3 "haha" }

MyRecValParamType{INTEGER:lowerBound,INTEGER:upperBound}
::= SEQUENCE
{
  field1 INTEGER (lowerBound..upperBound),
  field2 VisibleString OPTIONAL
}
MyActType ::= MyRecValParamType{111,222}
myConT MyActType ::= { field1 1, field2 "a" }
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: 5 is not a valid value for type `integer' which has subtype \(10..20\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 1 is not a valid value for type `integer' which has subtype \(10..20\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 2 is not a valid value for type `integer' which has subtype \(10..20\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: \{ 1, 2, 3 \} is not a valid value for type `.+' which has subtype length\(7..9\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: -33 is not a valid value for type `integer' which has subtype \(1..5\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: TRUE is not a valid value for type `boolean' which has subtype \(false\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "haha" is not a valid value for type `VisibleString' which has subtype from\("a".."c"\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 1 is not a valid value for type `integer' which has subtype \(111..222\)
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->Range constraint: MIN,MAX values
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->Range constraint: MIN,MAX values>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MyInt1 ::= INTEGER (-10..10)
MyInt2 ::= MyInt1 (1..MAX)
myint-const MyInt2 ::= 22
MyInt3 ::= INTEGER (MIN..MAX) (MIN..MAX) (-100..MAX) (MIN..100) (MIN..MAX EXCEPT (-10..MAX INTERSECTION MIN..10))
myint3 MyInt3 ::= 0
MyInt4 ::= MyInt3 (MIN..MAX)
MyStr1 ::= NumericString (FROM(MIN.."6"))
MyStr2 ::= NumericString (FROM("3"..MAX))
mystr2 MyStr2 ::= "abc"
MyStr3 ::= VisibleString (FROM("abc") UNION FROM("qwe"))
MyStr4 ::= MyStr3 (FROM(MIN..MAX))
mystr4 MyStr4 ::= "123"
MyReal ::= REAL (NOT-A-NUMBER) (MIN..MAX)
MyStr5 ::= VisibleString ("abc"|"def") (SIZE(1..MAX))
MyStr6 ::= VisibleString ("abc"|"def") (SIZE(MIN..10))
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: 22 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 0 is not a valid value for type `integer' which has subtype \(-100..-11,11..100\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #1 is \(-100..100\), this is not a subset of \(-100..-11,11..100\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #1 is from\(" ".."6"\), this is not a subset of from\(" ","0".."9"\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "abc" is not a valid value for type `NumericString' which has subtype from\("3".."9"\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: Cannot determine the value of MIN, using the minimal char value of the type
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: Cannot determine the value of MAX, using the maximal char value of the type
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "123" is not a valid value for type `VisibleString' which has subtype \(from\("a".."c"\) union from\("e","q","w"\)\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Cannot determine the value of MIN: the parent subtype has no range
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Cannot determine the value of MAX: the parent subtype has no range
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #2 is \(-INF..INF\), this is not a subset of \(NaN\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Cannot determine the value of MAX: the parent subtype does not define a maximal size value
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Cannot determine the value of MIN: the parent subtype does not define a minimal size value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 2>
(?is)\bwarning:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->ValueSet assignments
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->ValueSet assignments>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MyInt ::= INTEGER
MyInt1 MyInt ::= {1..20|"haha"}
MyInt2 MyInt ::= {1..20|SIZE(1..22)}
MyInt3 MyInt (1..10) ::= {1..20}

MyInt4 MyInt ::= {1..20}
myInt4 MyInt4 ::= 22

MyInt5 INTEGER ::= {1..10}
myInt5 MyInt5 ::= 11

ParamType{DummyTypeParam} ::= SEQUENCE {
  fld1 DummyTypeParam
}
SomeType ::= ParamType{MyInt5}


InvokeId ::= INTEGER
PresentInvokeId InvokeId ::= {1..20}
Invoke{InvokeId:InvokeIdSet} ::= SEQUENCE {
   invokeId InvokeId (InvokeIdSet)
}
MAP-Invoke ::= Invoke{{PresentInvokeId}}
mi MAP-Invoke ::= { invokeId 222 }
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: INTEGER value was expected
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Size constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #2 is \(1..20\), this is not a subset of \(1..10\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 22 is not a valid value for type `integer' which has subtype \(1..20\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 11 is not a valid value for type `integer' which has subtype \(1..10\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 222 is not a valid value for type `integer' which has subtype \(1..20\)
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::ValueSet and parametrization
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::ValueSet and parametrization>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MyPardType{INTEGER:DummyIntSet, INTEGER:myDummyLower, INTEGER:myDummyUpper, MyDummyType} ::= SEQUENCE {
  fld1 DummyIntSet,
  fld2 INTEGER (DummyIntSet|-10..0),
  fld3 INTEGER (myDummyLower..myDummyUpper),
  fld4 MyDummyType
}
END
<END_MODULE>
<MODULE ASN Module-B ModuleB.asn>
Module-B DEFINITIONS ::=
BEGIN
IMPORTS MyPardType{} FROM Module-A;
MyType ::= MyPardType{{MyIntSet},cMyLower,cMyUpper,MyIntType}
MyIntSet INTEGER ::= { 10..100 }
MyIntType ::= REAL ( 0.0..<MAX|NOT-A-NUMBER )
cMyLower INTEGER ::= 33
cMyUpper INTEGER ::= 44
c-mytype MyType ::= { fld1 3, fld2 6, fld3 9, fld4 PLUS-INFINITY }
END
<END_MODULE>
<MODULE ASN Module-C ModuleC.asn>
Module-C DEFINITIONS ::=
BEGIN
IMPORTS ;
MyInt1 INTEGER ::= { 1..10 }
MyInt2 INTEGER ::= { MyInt1|11..20 }
MyInt4 ::= MyInt1 (MyInt2)
c-myint2 MyInt2 ::= 21
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: 21 is not a valid value for type `integer' which has subtype \(1..20\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: 3 is not a valid value for type `integer' which has subtype \(10..100\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: 6 is not a valid value for type `integer' which has subtype \(-10..0,10..100\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: INF is not a valid value for type `float' which has subtype \(0.0e0..!INF,NaN\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Constraint #1 is \(1..20\), this is not a subset of \(1..10\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: 21 is not a valid value for type `integer' which has subtype \(1..20\)
<END_RESULT>
<RESULT IF_PASS COUNT 6>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->open type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->open type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
OtherType ::= INTEGER
MyType ::= SEQUENCE { fld1 TYPE-IDENTIFIER.&Type(OtherType) }
MyType2 ::= TYPE-IDENTIFIER.&Type(OtherType)
END
<END_MODULE>
<RESULT COUNT 0>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->circular reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->circular reference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
X ::= INTEGER ( X )
A ::= INTEGER ( B )
B ::= INTEGER ( C )
C ::= INTEGER ( A )
END
<END_MODULE>
<RESULT COUNT 2>
(?im)\berror: While checking circular type references in subtype definitions: Circular reference: .+
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->extension additions
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->extension additions>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
A1 ::= INTEGER (1..32,...,33..128)
B1a ::= A1 (1..128)
B1b ::= INTEGER (1..32,...,33..128) (1..128)

A2 ::= INTEGER (1..256, ..., A1) (1..256)
a2 A2 ::= -1

A3 ::= INTEGER (1..111,...,222..333)
A4 ::= A3
a4 A4 ::= -11

A5 ::= INTEGER (MIN..MAX,...,1..10)

Foo ::= INTEGER (1..6, ..., 73..80)
Bar ::= Foo (73)
foo Foo ::= 73
foo2 Foo ::= 99

CU ::= VisibleString ( SIZE(10..30,...,35..45) UNION SIZE(20..40, ..., 45..55) )
cu CU ::= ""

CI ::= VisibleString ( SIZE(10..30,...,35..45) INTERSECTION SIZE(20..40, ..., 45..55) )
ci CI ::= ""

CD ::= VisibleString ( SIZE(10..30,...,35..45), ..., SIZE(20..40, ..., 45..55) )
cd CD ::= ""

CE ::= VisibleString ( SIZE(10..30,...,35..45) EXCEPT SIZE(20..40, ..., 45..55) )
ce CE ::= ""

MyInt1 ::= INTEGER (0..15, ..., 32..63 )
MyInt2 ::= INTEGER (16..31, ...)
MyInt  ::= INTEGER ( MyInt1 | MyInt2 )
myint MyInt ::= 32

B ::= BOOLEAN (FALSE)
B2 ::= BOOLEAN (FALSE,...,TRUE)
B3 ::= B (FALSE,...,TRUE)
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: Constraint #1 is \(1..128\), this is not a subset of \(1..32\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #2 is \(1..128\), this is not a subset of \(1..32\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: -1 is not a valid value for type `integer' which has subtype \(1..256\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: -11 is not a valid value for type `integer' which has subtype \(1..111\), ..., \(222..333\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: The subtype of type `integer' is a full set, it does not constrain the root type.
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Constraint #1 is \(73\), this is not a subset of \(1..6\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 99 is not a valid value for type `integer' which has subtype \(1..6\), ..., \(73..80\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "" is not a valid value for type `VisibleString' which has subtype length\(10..40\), ..., length\(41..55\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "" is not a valid value for type `VisibleString' which has subtype length\(20..30\), ..., length\(35..40,45\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "" is not a valid value for type `VisibleString' which has subtype length\(10..30\), ..., length\(31..55\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: "" is not a valid value for type `VisibleString' which has subtype length\(10..19\), ..., length\(41..44\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: 32 is not a valid value for type `integer' which has subtype \(0..31\)
<END_RESULT>
<RESULT COUNT 1>
(?im)\bwarning: The subtype of type `boolean' is a full set, it does not constrain the root type.
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Extension addition of constraint #1 is \(true\), this is not a subset of \(false\)
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror: 
<END_RESULT>
<RESULT COUNT 2>
(?is)\bwarning: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->multiple inner type constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->multiple inner type constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MYREC ::= SEQUENCE { x INTEGER, y BOOLEAN }
MYREC1 ::= MYREC ( WITH COMPONENTS { x (7..10), y (FALSE) } )
MYREC2 ::= MYREC ( WITH COMPONENTS { y (FALSE), x (7..10) } )
MYREC3 ::= MYREC ( WITH COMPONENTS { y (FALSE), y (FALSE) } )
MYREC4 ::= MYREC ( WITH COMPONENTS { a (FALSE) } )
MYREC5 ::= MYREC ( WITH COMPONENT (1..5) )
MYREC6 ::= MYREC ( WITH COMPONENTS { x (7..10), y (WITH COMPONENTS{x(SIZE(4))}) } )
MYREC7 ::= MYREC ( WITH COMPONENTS { x (FROM(4)), y (SIZE(4)) } )
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: The order of fields must be the same as in the definition of type `@Module-A.MYREC'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Duplicate reference to field `y' of type `@Module-A.MYREC'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Type `@Module-A.MYREC' does not have a field named `a'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Single inner type constraint \(WITH COMPONENT\) cannot be used on type `@Module-A.MYREC'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Multiple inner type constraint \(WITH COMPONENTS\) cannot be used on type `boolean'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Permitted alphabet constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Size constraint is not allowed for type `boolean'
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->single inner type constraint
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->single inner type constraint>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
SI ::= SEQUENCE OF INTEGER
SSI ::= SEQUENCE OF SI
SI1 ::= SI (WITH COMPONENT (1..10))
SI2 ::= SI (WITH COMPONENT (SIZE(4)))
SI3 ::= SI (WITH COMPONENT ((3..10)|(14..MAX)^("a")))
SI4 ::= SSI (
  WITH COMPONENT (
    WITH COMPONENT (1|2)
    UNION
    WITH COMPONENT (2|4)
  )
  INTERSECTION
  WITH COMPONENT (
    WITH COMPONENT (2..7)
    INTERSECTION
    SIZE (33)
  )
)
SI5 ::= SSI (
  WITH COMPONENT (
    WITH COMPONENT (1|"abc")
    UNION
    WITH COMPONENT (2|WITH COMPONENT(1..5))
  )
  INTERSECTION
  WITH COMPONENT (
    SIZE (33) | WITH COMPONENT (2..7)    
  )
)
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: Size constraint is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: INTEGER value was expected
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Single inner type constraint \(WITH COMPONENT\) cannot be used on type `integer'
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->mixed inner type constraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->mixed inner type constraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
SEQ ::= SEQUENCE { x INTEGER, y SS OPTIONAL }
SS ::= SEQUENCE OF SEQ
-- recursive structure: this is probably legal, because the constraint is not on the field but
-- on the SEQ itself,on different levels of recursion the same embedded SS an SEQ field types 
-- can have different constraints
-- some crazy ASN.1 stuff...
SS1 ::= SEQ ( WITH COMPONENTS { x (1..10), y (WITH COMPONENT(WITH COMPONENTS{x(1..111)})) } )
SS2 ::= SEQ ( WITH COMPONENTS { x (1..10), y (WITH COMPONENT(WITH COMPONENTS{x(WITH COMPONENTS{a(2)})})) } )
SS3 ::= SEQ ( WITH COMPONENTS { x (1..10), y (WITH COMPONENT(WITH COMPONENTS{a(1..5)})) } )
SS4 ::= SEQ ( WITH COMPONENTS { x (1..10), y (WITH COMPONENT(WITH COMPONENTS{y(WITH COMPONENT(1..5))})) } )
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: Multiple inner type constraint \(WITH COMPONENTS\) cannot be used on type `integer'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Type `@Module-A.SEQ' does not have a field named `a'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Value range constraint is not allowed for type `@Module-A.SEQ'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->REAL inner type constraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->REAL inner type constraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MyReal1 ::= REAL (WITH COMPONENTS{ mantissa (10..20), base (2), exponent (3..MAX) })
MyReal2 ::= REAL (WITH COMPONENTS{ mantisssa (10..20), base (2), exponent (3..MAX) })
MyReal3 ::= REAL (WITH COMPONENTS{ base (2), mantissa (10..20), exponent (3..MAX) })
MyReal4 ::= REAL (WITH COMPONENTS{ mantissa (10..20), base (2), base (10), exponent (3..MAX) })
END
<END_MODULE>
<RESULT COUNT 1>
(?im)\berror: Type `float' does not have a field named `mantisssa'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: The order of fields must be the same as in the definition of type `float'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: Duplicate reference to field `base' of type `float'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.ASN1::subtypes->inner type constraints->presence constraints
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ASN1::subtypes->inner type constraints->presence constraints>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Module-A ModuleA.asn>
Module-A DEFINITIONS ::=
BEGIN
IMPORTS ;
MySeq ::= SEQUENCE { x INTEGER OPTIONAL, y REAL }
MySet ::= SET { x INTEGER OPTIONAL, y REAL }
MyChoice ::= CHOICE { x INTEGER, y REAL }
MySeq1 ::= MySeq (WITH COMPONENTS{ x ABSENT })
MySeq2 ::= MySeq (WITH COMPONENTS{ y ABSENT })
MySeq3 ::= MySeq (WITH COMPONENTS{ y (WITH COMPONENTS{ mantissa OPTIONAL, base PRESENT, exponent ABSENT }) })
MySet1 ::= MySet (WITH COMPONENTS{ y(0.0..1.0), x ABSENT })
MySet2 ::= MySet (WITH COMPONENTS{ y ABSENT, x ABSENT })
MySet3 ::= MySet (WITH COMPONENTS{ y (WITH COMPONENTS{ mantissa OPTIONAL, base PRESENT, exponent ABSENT }) })
MyChoice1 ::= MyChoice (WITH COMPONENTS{x ABSENT, y PRESENT})
MyChoice2 ::= MyChoice (WITH COMPONENTS{x PRESENT, y PRESENT})
MyChoice3 ::= MyChoice (WITH COMPONENTS{x ABSENT, y ABSENT})
MyChoice4 ::= MyChoice (WITH COMPONENTS{..., y PRESENT})
MyChoice5 ::= MyChoice (WITH COMPONENTS{y PRESENT})
MyChoice6 ::= MyChoice (WITH COMPONENTS{..., y ABSENT})
MyChoice7 ::= MyChoice (WITH COMPONENTS{y ABSENT})
END
<END_MODULE>
<RESULT COUNT 2>
(?im)\berror: Presence constraint `ABSENT' cannot be used on mandatory field `y'
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: Presence constraint `OPTIONAL' cannot be used on mandatory field `mantissa'
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: Presence constraint `PRESENT' cannot be used on mandatory field `base'
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: Presence constraint `ABSENT' cannot be used on mandatory field `exponent'
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror: CHOICE type `@Module-A.MyChoice' cannot have more than one `PRESENT' field
<END_RESULT>
<RESULT COUNT 2>
(?im)\berror: All fields of CHOICE type `@Module-A.MyChoice' are `ABSENT'
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror: 
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.<docnumber of ASN.1 SA RS>
:nl.Requirement Specification for TITAN's ASN.1 Semantic Analyser
:li D='[2]'.ITU-T X.680 (07/2002):
:nl.Abstract Syntax Notation One (ASN.1):
:nl.Specification of basic notation
:li D='[3]'.ITU-T X.681 (12/97):
:nl.Abstract Syntax Notation One (ASN.1):
:nl.Information object specification
:li D='[4]'.ITU-T X.682 (12/97):
:nl.Abstract Syntax Notation One (ASN.1):
:nl.Constraint specification
:li D='[5]'.ITU-T X.683 (12/97):
:nl.Abstract Syntax Notation One (ASN.1):
:nl.Parameterization of ASN.1 specifications
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

