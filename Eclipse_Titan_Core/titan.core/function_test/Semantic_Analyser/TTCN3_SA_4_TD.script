.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Baji, Laszlo
.*   Balasko, Jeno
.*   Delic, Adam
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.15/152 91-CRL 113 200/3 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Parameters
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
________________________________________________________
PA1   2005-02-19   ETIBHRA    New document for TITAN R6
A     2005-03-18   ETIBHRA    Approved after review
B     2006-07-31   EKRISZA    Updates for TITAN R6E
C     2007-03-06   EJNOSZA    Updates for TITAN R7A (expected error messages)
D     2008-10-01   EFERKOV    Large integers
PE1  2010-03-11  EKRISZA     added tests for the fix of TR HL63421
E     2010-07-02   EKRISZA     version correction.
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-1/4: Parameters.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.

:np.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Parameterization is not allowed
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-4/1.
:p. Explanation:
:nl.  Parameterization is not allowed for the following specific language
      elements: const, var, timer, control, group and import.

:p. Test strategy:
:space 1.
:xmp tab=0.
                       Hierarchy of scope units


       Abbreviations:

           MDP: Module Definitons Part
           MCP: Module Control Part
           CT : Component Type
           FUN: Function without runs on-clause
           ALT: Altstep without runs on-clause
           FWR: Function with runs on-clause
           AWR: Altstep with runs on-clause
           TC : Testcase with runs on-clause and optional system-clause
           BS : Block of statements (within a compound statement)
           EBS: Embedded block of statements (within a compound statement)
:exmp.
:space 2.
:xmp tab=0.
                  _____________________________________________
                 |                                             |
  0.        _____|                      MDP                    |_______
           |     |_____________________________________________|       |
         __|__                   __|__                   __|__       __|__
        |     |                 |     |                 |     |     |     |
  1.    | MCP |         ________| CT  |________         | FUN |     | ALT |
        |_____|        |        |_____|        |        |_____|     |_____|
           |         __|__       __|__       __|__         |           |
           |        |     |     |     |     |     |        |           |
  2.       |        | FWR |     | AWR |     | TC  |        |           |
           |        |_____|     |_____|     |_____|        |           |
         __|__       __|__       __|__       __|__       __|__       __|__
        |     |     |     |     |     |     |     |     |     |     |     |
  3.    | BS  |     | BS  |     | BS  |     | BS  |     | BS  |     | BS  |
        |_____|     |_____|     |_____|     |_____|     |_____|     |_____|
         __|__       __|__       __|__       __|__       __|__       __|__
        |     |     |     |     |     |     |     |     |     |     |     |
  4.    | EBS |     | EBS |     | EBS |     | EBS |     | EBS |     | EBS |
        |_____|     |_____|     |_____|     |_____|     |_____|     |_____|
           |           |           |           |           |           |
           |           |           |           |           |           |
:exmp.
:np.
:xmp tab=1.
Test cases are based on TTCN-3 according to the followings:
- We have to check the "const", "var" and "timer" elements.
- We checked this elements where we can use firstly in the scope
  hierarchy and unnecessary to check on the lower levels.

Example:
  The const is checked only in the MDP because another bubbles are
  on the lower levels.

:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Definitions part: const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Definitions part: const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer C := 1;
    const integer CC := C(0);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?C.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Control part: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Control part: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        var integer X := 1;
        var integer XX := X(0);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type: var
.*---------------------------------------------------------------------*
:p. NOTE:
:nl.The implementation does not support the variable initialized with
    another variable in the component type (but it would be possible
    according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ParameterizationNotAllowed->Component type: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {
        var integer X := 1;
        var integer XX := X(0);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?static.+?value.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Function: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Function: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {
        var integer X := 1;
    }
    function MyCompFunc() runs on MyCT {
        var integer XX := X(0);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Altstep: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Altstep: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {
        var integer X := 1;
    }
    altstep MyCompALtstep() runs on MyCT {
        var integer XX := X(0);
	[else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Testcase: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Testcase: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {
        var integer X := 1;
    }
    testcase MyTestcase() runs on MyCT {
        var integer XX := X(0);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Function: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Function: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        var integer X := 1;
        var integer XX := X(0);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Altstep: var
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Altstep: var>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep(timer T) {
        var integer X := 1;
	[X(0)>2] T.timeout {};
	[else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?X.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Control part: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Control part: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer t ) {}
    control {
        timer T := 1.2;
        MyFunc(T(0));
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer t ) {}
    type component MyCT {
        timer T := 1.2;
    }
    function MyCompFunc() runs on MyCT {
        MyFunc(T(0));
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Altstep: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Altstep: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer t ) {}
    type component MyCT {
        timer T := 1.2;
    }
    altstep MyCompAltstep() runs on MyCT {
	[else] { MyFunc(T(0)); };
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Component type--Testcase: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Component type--Testcase: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer t ) {}
    type component MyCT {
        timer T := 1.2;
    }
    testcase MyTestcase() runs on MyCT {
        MyFunc(T(0));
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc_1( timer t ) {}
    function MyFunc_2() {
        timer T := 1.3;
        MyFunc_1(T(0));
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParameterizationNotAllowed->Altstep: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParameterizationNotAllowed->Altstep: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer t ) {}
    altstep MyAltstep(timer T) {
	[else] { MyFunc(T(0)); };
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?referenced.+?T.+?cannot.+?have.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Not allowed type in a formal/actual parameter list
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-4/2.
:p. Explanation:
:nl.  Some specific types are not allowed to be used in the parameter list
      of a language element.
:list.
:li d='modulepar:' template, component type, port type, default and timer
                   are not allowed according to the TTCN-3 specification
:nl.               ( NotAllowedTypeInParameterList->Modulepar )
:nl.               NOTE: the component type and default are supported in the
                   implementation and not allowed the empty parameter list;
:li d='type:'      any type is not currently supported in the implementation
:nl.               ( NotAllowedTypeInParameterList->Type )
:nl.               NOTE: all basic types, all user-defined types and address
                   type are allowed according to the TTCN-3 specification;
:li d='template:'  component type, port type, default and timer are not allowed
:nl.               ( NotAllowedTypeInParameterList->Template )
:nl.               NOTE: the component type and default are supported in the
                   implementation;
:li d='testcase:'  component type, port type, default and timer are not allowed
:nl.               ( NotAllowedTypeInParameterList->Testcase )
:nl.               NOTE: the component type and default are supported in the
                   implementation;
:li d='signature:' template, port type, default and timer are not allowed
:nl.               ( NotAllowedTypeInParameterList->Signature );
:elist
:p. Test strategy:
:nl.  We made a test for each type of values that is allowed to appear in the
      formal/actual parameter lists of all language elements.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Modulepar: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Modulepar: allowed types>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec { charstring field }
    type record address { integer filed }
	//modulepar not allowed types are tested : in TTCN3_SA_ttcn3adhoc.script (modulepar invalid simple type,
	// modulepar invalid compound type, modulepar invalid list, modulepar invalid type: circular type definition)
    modulepar { 
	    boolean MyBool := false;
	    integer MyInt1, MyInt2;
	    MyRec myrec;
	    address MyPC := { 23475 };
	    template integer MyTemp := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Modulepar: empty
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Modulepar: empty>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Modulepar: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Modulepar: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    modulepar {
        MyPort port_1
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?module.+?parameter.+?cannot.+?port
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Modulepar: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Modulepar: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        timer T := 1.2
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Types>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record rtype (integer p) {integer i (p .. p+10)}

    const rtype(0.0) r1 := {i :=1}
    const rtype('0'B) r2 := {i :=1}
    const rtype('0'H) r3 := {i :=1}
    const rtype('00'O) r4 := {i :=1}
    const rtype("0") r5 := {i :=1}

    type set stype (integer p) {integer i (p .. p+10)}

    const stype(0.0) s1 := {i :=1}
    const stype('0'B) s2 := {i :=1}
    const stype('0'H) s3 := {i :=1}
    const stype('00'O) s4 := {i :=1}
    const stype("0") s5 := {i :=1}
}
<END_MODULE>
<RESULT IF_FAIL COUNT POSITIVE>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Template: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Template: allowed types>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	integer field1,
	boolean field2 optional
    }
    type record address { integer filed }
    type record MyRec {
        float      field1 optional,
        charstring field2,
        MySet      field3,
	address    field4,
	MyCT       field5,
	default    field6
    }
    template MyRec MyTempE := {?,?,?,?,?,?}          // empty parameter list
    template MyRec MyTemp (
        charstring     par_1,
	address        par_2,
	MyCT           par_3,
	default        par_4,
	MySet          par_5,
	template float par_6 ) := {
			            field1 := par_6,
			            field2 := par_1,
			            field3 := par_5,
			            field4 := par_2,
			            field5 := par_3,
			            field6 := par_4
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Template: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Template: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type set MySet {
	integer field1,
	boolean field2 optional
    }
    template MySet MyTemp ( MyPort par_1 ) := {
        field1 := ?,
        field2 := ?
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?template.+?cannot.+?have.+?port
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Template: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Template: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
	integer field1,
	boolean field2 optional
    }
    template MySet MyTemp ( timer par_1 ) := {
        field1 := ?,
        field2 := ?
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Function: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Function: allowed types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer filed }
    function MyFuncE() {}          // empty parameter list
    function MyFunc (
                      integer        par_1,
                      MySet          par_2,
                      address        par_3,
                      template MySet par_4,
                      MyCT           par_5,
                      MyPort         par_6,
                      default        par_7,
                      timer          par_8 ) {}
    function MyCompFuncE() {}          // empty parameter list
    function MyCompFunc (
                          integer        par_1,
                          MySet          par_2,
                          address        par_3,
                          template MySet par_4,
                          MyCT           par_5,
                          MyPort         par_6,
                          default        par_7,
                          timer          par_8 ) runs on MyCT {}
    external function MyExtFuncE();          // empty parameter list
    external function MyExtFunc (
                                  integer        par_1,
                                  MySet          par_2,
                                  address        par_3,
                                  template MySet par_4,
                                  MyCT           par_5,
                                  MyPort         par_6,
                                  default        par_7,
                                  timer          par_8 );
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Altstep: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Altstep: allowed types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer filed }
    altstep MyAltstepE() { [else]{} }          // empty parameter list
    altstep MyAltstep (
                        integer        par_1,
                        MySet          par_2,
                        address        par_3,
                        template MySet par_4,
                        MyCT           par_5,
                        MyPort         par_6,
                        default        par_7,
                        timer          par_8 ) {
        [else] {}
    }
    altstep MyCompAltstepE() { [else]{} }          // empty parameter list
    altstep MyCompAltstep (
                            integer        par_1,
                            MySet          par_2,
                            address        par_3,
                            template MySet par_4,
                            MyCT           par_5,
                            MyPort         par_6,
                            default        par_7,
                            timer          par_8 ) runs on MyCT {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Testcase: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Testcase: allowed types>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer filed }
    testcase MyTestcaseE() runs on MyCT {}          // empty parameter list
    testcase MyTestcase (
                          integer        par_1,
                          MySet          par_2,
                          address        par_3,
                          template MySet par_4,
                          MyCT           par_5,
                          default        par_6 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Testcase: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Testcase: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    testcase MyTestcase( MyPort par_1 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?testcase.+?cannot.+?have.+?port
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Testcase: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Testcase: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( timer par_1 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Signature: allowed types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Signature: allowed types>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer filed }
    signature MySigE();          // empty parameter list
    signature MySig (
                          integer        par_1,
                          MySet          par_2,
                          address        par_3,
                          MyCT           par_5
			  );
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Signature: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Signature: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig( template integer par_1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Signature: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Signature: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    signature MySig( MyPort par_1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Port.+?cannot.+?be.+?signature
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Signature: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Signature: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig( default par_1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Default.+?cannot.+?be.+?signature
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::NotAllowedTypeInParameterList->Signature: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::NotAllowedTypeInParameterList->Signature: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig( timer par_1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Mismatch in actual and formal parameter list
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-4/3.
:p. Explanation:
:nl.  SA shall detect if there is a mismatch between the formal and the actual
      parameter list.
:p.   - We can use the formal and the actual parameter list according to
        the TTCN-3 specification on the following language elements:
:nl.	type, template, function, altstep, testcase and signature.
:nl.    NOTE: types are not currently supported in the implementation.
:p.   - In the actual and the corresponding formal parameter list:
:list.
:li d='number:'.  shall be the same as the number of elements;
:li d='order:'.   shall be the same as the order of elements;
:li d='types:'.   shall be compatible with the types of elements.
:elist.
:space 1.
:p. Test strategy:
:list.
:li d='number:'.  we made a test for each language elements;
:li d='order and type compatibility:'.  the type compatibility checking covers
        the order checking, therefore the order checking is not necessary
	(see the type compatibility checking in the requirement SA-5/2);
:elist.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Types: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Types: number>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record rtype (integer p, boolean b) {integer i (p .. p+10), boolean b (b)}

    const rtype() r1 := {1, true}
    const rtype(1) r2 := {1, true}
    const rtype(1, true, 2) r3 := {1, true}

    type set stype (integer p, boolean b) {integer i (p .. p+10), boolean b (b)}

    const stype() s1 := {1, true}
    const stype(1) s2 := {1, true}
    const stype(1, true, 2) s3 := {1, true}

}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Template: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Template: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    template MyRec MyTemp( charstring par_1, boolean par_2, integer par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    template MyRec MyTemp2( charstring par_1 := "r", boolean par_2):=
    {
      field1 := 6,
      field2 := par_1,
      field3 := par_2
    }
    template MyRec MyTemp3(charstring par_1 := "r", boolean par_2:= false, integer par_3:=6):=
    {
      field1 := par_3,
      field2 := par_1,
      field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
        MyFunc(MyTemp("r",true,6));           // good
        MyFunc(MyTemp("r",true));             // too few parameters
        MyFunc(MyTemp("r",true,6,1.3));       // too many parameters
        MyFunc(MyTemp2(true));                // too few parameters
        MyFunc(MyTemp3("r",true,6,1.3));      // too many parameters
        MyFunc(MyTemp3(-,true,6,1.3));        // too many parameters
        MyFunc(MyTemp3("r",true,6,-));        // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Function: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Function: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer par_1, charstring par_2, boolean par_3 ) {}
    function MyFunc2( integer par_1 := 6, charstring par_2){}
    function MyFunc3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false){}
    control {
        MyFunc(6,"r",true);          // good
        MyFunc(6,"r");               // too few parameters
        MyFunc(56,"r",true,1.3);     // too many parameters
        MyFunc2("r");                // too few parameters
        MyFunc3(6,"r",true,1.3);     // too many parameters
        MyFunc3(-,"r",true,1.3);     // too many parameters
        MyFunc3(6,"r",true,-);       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Function_runs_on: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Function_runs_on: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc( integer par_1, charstring par_2, boolean par_3 ) runs on MyCT {}
    function MyFunc2( integer par_1 := 6, charstring par_2) runs on MyCT {}
    function MyFunc3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false) runs on MyCT {}
    testcase MyTemp() runs on MyCT {
        MyFunc(6,"r",true);          // good
        MyFunc(6,"r");               // too few parameters
        MyFunc(56,"r",true,1.3);     // too many parameters
        MyFunc2("r");                // too few parameters
        MyFunc3(6,"r",true,1.3);     // too many parameters
        MyFunc3(-,"r",true,1.3);     // too many parameters
        MyFunc3(6,"r",true,-);       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->External Function: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->External Function: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    external function MyExtFunc( integer par_1, charstring par_2, boolean par_3 );
    external function MyExtFunc2( integer par_1 := 6, charstring par_2);
    external function MyExtFunc3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false);
    control {
        MyExtFunc(6,"r",true);          // good
        MyExtFunc(6,"r");               // too few parameters
        MyExtFunc(56,"r",true,1.3);     // too many parameters
        MyExtFunc2("r");                // too few parameters
        MyExtFunc3(6,"r",true,1.3);     // too many parameters
        MyExtFunc3(-,"r",true,1.3);     // too many parameters
        MyExtFunc3(6,"r",true,-);       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Altstep: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Altstep: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( integer par_1, charstring par_2, boolean par_3 ) {
        [else] {}
    }
    altstep MyAltstep2( integer par_1 := 6, charstring par_2) {
        [else] {}
    }
    altstep MyAltstep3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false) {
        [else] {}
    }
    control {
        MyAltstep(6,"r",true);          // good
        MyAltstep(6,"r");               // too few parameters
        MyAltstep(56,"r",true,1.3);     // too many parameters
        MyAltstep2("r");                // too few parameters
        MyAltstep3(6,"r",true,1.3);     // too many parameters
        MyAltstep3(-,"r",true,1.3);     // too many parameters
        MyAltstep3(6,"r",true,-);       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Altstep_runs_on: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Altstep_runs_on: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAltstep( integer par_1, charstring par_2, boolean par_3 ) runs on MyCT {
        [else] {}
    }
    altstep MyAltstep2( integer par_1 := 6, charstring par_2) runs on MyCT {
        [else] {}
    }
    altstep MyAltstep3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false) runs on MyCT {
        [else] {}
    }
    testcase MyTemp() runs on MyCT {
        MyAltstep(6,"r",true);          // good
        MyAltstep(6,"r");               // too few parameters
        MyAltstep(56,"r",true,1.3);     // too many parameters
        MyAltstep2("r");                // too few parameters
        MyAltstep3(6,"r",true,1.3);     // too many parameters
        MyAltstep3(-,"r",true,1.3);     // too many parameters
        MyAltstep3(6,"r",true,-);       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Testcase: numberr
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Testcase: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( integer par_1, charstring par_2, boolean par_3 ) runs on MyCT {}
    testcase MyTestcase2( integer par_1 := 6, charstring par_2) runs on MyCT {}
    testcase MyTestcase3( integer par_1:=6, charstring par_2:="r", boolean par_3:=false) runs on MyCT {}
    control {
        execute ( MyTestcase(6,"r",true) );          // good
        execute ( MyTestcase(6,"r") );               // too few parameters
        execute ( MyTestcase(56,"r",true,1.3) );     // too many parameters
        execute ( MyTestcase2("r") );                // too few parameters
        execute ( MyTestcase3(6,"r",true,1.3) );     // too many parameters
        execute ( MyTestcase3(-,"r",true,1.3) );     // too many parameters
        execute ( MyTestcase3(6,"r",true,-) );       // too many parameters
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Too.+?few.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Too.+?many.+?parameters
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::MismachActualFormalParameterList->Signature: number
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::MismachActualFormalParameterList->Signature: number>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig( integer par_1, charstring par_2, boolean par_3 );
    type port MyPortType procedure { inout MySig }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        MyPort.call(MySig:{ 6,"r",true }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 6,"r" }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 6,"r",true,6.8 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Too.+?few.+?elements.+?MySig
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Too.+?many.+?elements.+?MySig
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Parameter list of a modified template
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-4/4.
:p. Explanation:
:nl.  The followings apply:
:nl.  - the derived template shall not omit parameters defined at any of the
        modification steps between the base template and the actual modified
        template
:nl.  - a derived template can have additional (appended) parameters if wished
:nl.  - base template fields containing parameterized templates shall not be
        modified or explicitly omitted in a modified template (including inline
        modified templates)
:nl.  - base template field that depends on a parameter shall not be modified
        or explicitly omitted in a modified template (?)

:p. Test strategy:

:p. TODO: <what TCs are missing and why>


:np.

.*---------------------------------------------------------------------*
:h2.Parameter is not allowed to be passed by value/reference
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-4/5.
:p. Explanation:
:nl.  Many language elements allow only parameter passing by value or reference.

:p. General:
:list.
:li d='Basic types, basic string types, user-defined structured types, address type and component type:'.
    By default, all actual parameters of these types are passed by value.
:nl.This may otionally be denoted by the keyword "in".
:nl.To pass parameters of these types by reference the keywords "out" or "inout"
    shall be used.
:nl.NOTE: the behaviour of the "default" type is similar to the listed below
    in the implementation.
:li d='Timers and ports:'. are always passed by reference.
:nl.Timer parameter are identified by the keyword timer.
:nl.Port parameter are identified by their port type.
:nl.The keyword "inout" may optionally be used to denote passing by reference.
:elist.
:p. Parameters passed by reference:
:nl.Passing parameters by reference has the following limitations:
:list.
:li d='a)'. only the formal parameter lists to altsteps, functions, signatures
            and testcases may contain pass-by-reference parameters;
:li d='b)'. the actual parameters shall only be variables, ports or timers.
:elist.
:p. Parameters passed by value:
:nl.Actual parameters that are passed by value may be variables as well as
    constants, templates etc.

:p. NOTEs:
:nl.The "component type" and the "default" are allowed in the modulepar, the
    template and the testcase in the implementation far afield from the TTCN-3
    specification.
:nl.The "out" and the "inout" parameters can be read and set from within e.g.
    the function. The difference is the "out" parameter may be unbound but the
    "inout" parameter must be initialized before called.

:p. Test strategy:
:nl.There are some tests for the template, function, altstep, testcase and
    signature language elements where we can use "in","out" or "inout" parameters.
    First we checked the allowed cases (positive tests). Other tests are for each
    type of values that is allowed to appear in the formal/actual parameter
    lists of all language elements with "defaul in", "in", "out" and "inout"
    parameters.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Template: allowed in
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Template: allowed in>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRecord {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type record MyRec {
                        integer     field11 optional,
                        integer     field12,
                        octetstring   field21,
                        octetstring   field22,
                        MyRecord    field31,
                        MyRecord    field32,
	                address       field41,
	                address       field42,
	                MyCT        field51,
	                MyCT        field52,
	                default       field61,
	                default       field62,
	                float       field71,
	                float       field72
    }
    template MyRec MyTemp (
                      integer           par_11,      // basic type
                      in integer        par_12,
                      octetstring         par_21,    // basic string type
                      in octetstring      par_22,
                      MyRecord          par_31,      // user-defined structured type
                      in MyRecord       par_32,
                      address             par_41,    // address
                      in address          par_42,
                      template float    par_51,      // template
                      in template float par_52,
                      MyCT                par_61,    // component type
                      in MyCT             par_62,
                      default           par_71,      // default
                      in default        par_72 ) := {
                                                      field11 := par_11,
                                                      field12 := par_12,
                                                      field21 := par_21,
                                                      field22 := par_22,
                                                      field31 := par_31,
                                                      field32 := par_32,
                                                      field41 := par_41,
                                                      field42 := par_42,
                                                      field51 := par_61,
                                                      field52 := par_62,
                                                      field61 := par_71,
                                                      field62 := par_72,
                                                      field71 := par_51,
                                                      field72 := par_52
                      }
    function MyFunc( template MyRec mytemp ) {}
    control {
        var integer myint;
	var octetstring myoctet;
	var MyRecord myrecord;
	var address myadd;
	var float mytemp;
	var MyCT myct_1, myct_2;
	var default mydef_1, mydef_2;
        MyFunc(MyTemp( 1,myint, myoctet,'A5'O, myrecord,{6.7,true}, {5},myadd,
	               mytemp,7.8, myct_1,myct_2, mydef_1,mydef_1));
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Template: allowed non-mandatory in
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Template: allowed non-mandatory in>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRecord {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type record MyRec {
        integer     field11 optional,
        integer     field12,
        octetstring   field21,
        octetstring   field22,
        MyRecord    field31,
        MyRecord    field32,
	address       field41,
	address       field42,
	MyCT        field51,
	MyCT        field52,
	default       field61,
	default       field62,
	float       field71,
	float       field72
    }
    template MyRec MyTemp (
        integer           par_11  := 1,         // basic type
        in integer        par_12  := 1,
        octetstring       par_21  := 'A5'O,     // basic string type
        in octetstring    par_22  := 'A5'O,
        MyRecord          par_31  := {6.7,true},// user-defined structured type
        in MyRecord       par_32  := {6.7,true},
        address           par_41  := {5},       // address
        in address        par_42  := {5},
        template float    par_51  := 7.8,       // template
        in template float par_52  := 7.8,
        MyCT              par_61,               // component type
        in MyCT           par_62,
        default           par_71,               // default
        in default        par_72 ) := {
            field11 := par_11,
            field12 := par_12,
            field21 := par_21,
            field22 := par_22,
            field31 := par_31,
            field32 := par_32,
            field41 := par_41,
            field42 := par_42,
            field51 := par_61,
            field52 := par_62,
            field61 := par_71,
            field62 := par_72,
            field71 := par_51,
            field72 := par_52
        }
    function MyFunc( template MyRec mytemp ) {}
    control {
        var integer myint;
	var octetstring myoctet;
	var MyRecord myrecord;
	var address myadd;
	var float mytemp;
	var MyCT myct_1, myct_2;
	var default mydef_1, mydef_2;
        MyFunc(MyTemp( 1,myint, myoctet,'A5'O, myrecord,{6.7,true}, {5},myadd,
	               mytemp,7.8, myct_1,myct_2, mydef_1,mydef_1));
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Template: out, inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Template: out, inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type record MyRec {
        integer     field1 optional,
        octetstring field2,
        MySet       field3,
	address     field4,
	MyCT        field5,
	default     field6,
	float       field7
    }
    template MyRec MyTemp (
                      out integer    par_13_1,        // basic type
                      inout integer  par_14_1,
                      out octetstring    par_13_2,    // basic string type
                      inout octetstring  par_14_2,
                      out MySet      par_23,          // user-defined structured type
                      inout MySet    par_24,
                      out address    par_33,          // address
                      inout address  par_34,
                      out template float   par_43,    // template
                      inout template float par_44,
                      out MyCT       par_53,          // component type
                      inout MyCT     par_54,
                      out default    par_73,          // default
                      inout default  par_74 ) := {
                                    field1 := par_13_1,
                                    field2 := par_14_2,
                                    field3 := par_23,
                                    field4 := par_34,
                                    field5 := par_53,
                                    field6 := par_74,
                                    field7 := par_44
                      }
}
<END_MODULE>
<RESULT IF_PASS COUNT 14>
(?im)\berror\b.+?template.+?cannot.+?have.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?im)\berror\b.+?template.+?cannot.+?have.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Template: non-mandatory out, inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Template: non-mandatory out, inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type record MyRec {
        integer     field1 optional,
        octetstring field2,
        MySet       field3,
	address     field4,
	float       field5
    }
    template MyRec MyTemp (
       out integer           par_13_1 := 5,         // basic type
       inout integer         par_14_1 := 5,
       out octetstring       par_13_2 := 'A5'O,     // basic string type
       inout octetstring     par_14_2 := 'A5'O,
       out MySet             par_23   := {field1:=1.0,field2:=true},          // user-defined structured type
       inout MySet           par_24   := {field1:=1.0,field2:=true},
       out address           par_33   := {5},       // address
       inout address         par_34   := {5},
       out template float    par_43   := 7.8,       // template
       inout template float  par_44   := 7.8) := {
          field1 := par_13_1,
          field2 := par_14_2,
          field3 := par_23,
          field4 := par_34,
          field5 := par_44
       }
}
<END_MODULE>
<RESULT IF_PASS COUNT 10>
(?im)\berror\b.+?template.+?cannot.+?have.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?im)\berror\b.+?template.+?cannot.+?have.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 8>
(?im)\berror\b.+?reference.+?variable.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 20>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: allowed in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    function MyFunc (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      MyPort         par_61,          // port type
                      inout MyPort   par_64,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74,

                      timer          par_81,          // timer
                      inout timer    par_84 ) {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: allowed in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    function MyCompFunc (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      MyPort         par_61,          // port type
                      inout MyPort   par_64,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74,

                      timer          par_81,          // timer
                      inout timer    par_84 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: allowed non-mandatory in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: allowed non-mandatory in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type component MyCT {
      const integer comp_const_i := 0;
      var integer comp_var_i := 0;
      const octetstring comp_const_o := '00'O;
      var octetstring comp_var_o := '00'O;
      const MySet comp_const_set := {field1 := 1.0, field2 := true};
      var MySet comp_var_set := {field1 := 1.0, field2 := true};
      const address comp_const_address := {5};
      var address comp_var_address := {5};
      port MyPort comp_port;
      timer comp_timer := 1.0;
    }
    function MyCompFunc (
       integer        par_11_1 := comp_const_i,         // basic type
       in integer     par_12_1 := comp_const_i,
       out integer    par_13_1 := comp_var_i,
       inout integer  par_14_1 := comp_var_i,

       octetstring        par_11_2 := comp_const_o,     // basic string type
       in octetstring     par_12_2 := comp_const_o,
       out octetstring    par_13_2 := comp_var_o,
       inout octetstring  par_14_2 := comp_var_o,

       MySet          par_21 := comp_const_set,         // user-defined structured type
       in MySet       par_22 := comp_const_set,
       out MySet      par_23 := comp_var_set,
       inout MySet    par_24 := comp_var_set,

       address        par_31 := comp_const_address,     // address
       in address     par_32 := comp_const_address,
       out address    par_33 := comp_var_address,
       inout address  par_34 := comp_var_address,

       MyPort         par_61 := comp_port,              // port type
       inout MyPort   par_64 := comp_port,

       timer          par_81 := comp_timer,             // timer
       inout timer    par_84 := comp_timer ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: allowed in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    external function MyExtFunc (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      MyPort         par_61,          // port type
                      inout MyPort   par_64,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74,

                      timer          par_81,          // timer
                      inout timer    par_84 );
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: port type with in/out
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: port type with in/out>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    function MyFunc ( in MyPort par_1, out MyPort par_2 ) {}
    function MyCompFunc ( in MyPort par_1, out MyPort par_2 ) {}
    external function MyExtFunc ( in MyPort par_1, out MyPort par_2 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 6>
(?im)\berror\b.+?Port.+?cannot.+?used.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?im)\berror\b.+?Port.+?cannot.+?used.+?out.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer with in/out
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer with in/out>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc ( in timer par_1, out timer par_2 ) {}
    function MyCompFunc ( in timer par_1, out timer par_2 ) {}
    external function MyExtFunc ( in timer par_1, out timer par_2 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 6>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 6>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 ) {
        var integer temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        MyFunc( var_1, var_2, var_3, var_4);          // good
        MyFunc( var_11, var_22, var_33, var_44);      // good
        MyFunc( 1, 2, var_3, var_4);                  // good
        MyFunc( 1, 2, 3, 4);                          // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
        integer        par_1 := 1,        // basic type
        in integer     par_2 := 1,
        out integer    par_3 := 1,
        inout integer  par_4 := 1 ) {
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 ) runs on MyCT {
        var integer temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyTempFunc () runs on MyCT {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        MyCompFunc( var_1, var_2, var_3, var_4);          // good
        MyCompFunc( var_11, var_22, var_33, var_44);      // good
        MyCompFunc( 1, 2, var_3, var_4);                  // good
        MyCompFunc( 1, 2, 3, 4);                          // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 );
    control {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        MyExtFunc( var_1, var_2, var_3, var_4);           // good
        MyExtFunc( var_11, var_22, var_33, var_44);       // good
        MyExtFunc( 1, 2, var_3, var_4);                   // good
        MyExtFunc( 1, 2, 3, 4);                           // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc (
       integer        par_1 := 1,        // basic type
       in integer     par_2 := 1,
       out integer    par_3 := 1,
       inout integer  par_4 := 1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 ) {
        var charstring temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        MyFunc( var_1, var_2, var_3, var_4);             // good
        MyFunc( var_11, var_22, var_33, var_44);         // good
        MyFunc( "w", "e", var_3, var_4);                 // good
        MyFunc( "q", "b", "5", "w");                     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 ) runs on MyCT {
        var charstring temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyTempFunc () runs on MyCT {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        MyCompFunc( var_1, var_2, var_3, var_4);            // good
        MyCompFunc( var_11, var_22, var_33, var_44);        // good
        MyCompFunc( "w", "e", var_3, var_4);                // good
        MyCompFunc( "q", "b", "5", "w");                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 );
    control {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        MyExtFunc( var_1, var_2, var_3, var_4);           // good
        MyExtFunc( var_11, var_22, var_33, var_44);       // good
        MyExtFunc( "w", "e", var_3, var_4);               // good
        MyExtFunc( "q", "b", "5", "w");                   // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    function MyFunc (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 ) {
        var MySet temp := { field1:=par_1.field1 }
        par_1.field1 := par_2.field1;
	par_2.field1 := par_3.field1;
	par_3.field1 := par_4.field1;
	par_4.field1 := temp.field1;
    }
    control {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        MyFunc(var_1,var_2,var_3,var_4);                 // good
        MyFunc(var_11,var_22,var_33,var_44);             // good
        MyFunc( {field1:=1.2, field2:=true},             // good
                {field1:=2.5, field2:=true},
                var_3,
                var_4);
        MyFunc( {field1:=1.2, field2:=true},             // error
                {field1:=2.5, field2:=true},
                {field1:=3.6, field2:=true},
                {field1:=4.1, field2:=true});
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    function MyCompFunc (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 ) runs on MyCT {
        var MySet temp := { field1:=par_1.field1 }
        par_1.field1 := par_2.field1;
	par_2.field1 := par_3.field1;
	par_3.field1 := par_4.field1;
	par_4.field1 := temp.field1;
    }
    function MyTempFunc () runs on MyCT {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        MyCompFunc(var_1,var_2,var_3,var_4);           // good
        MyCompFunc(var_11,var_22,var_33,var_44);       // good
        MyCompFunc( {field1:=1.2, field2:=true},       // good
	            {field1:=2.5, field2:=true},
	            var_3,
		    var_4);
        MyCompFunc( {field1:=1.2, field2:=true},       // error
                    {field1:=2.5, field2:=true},
                    {field1:=3.6, field2:=true},
                    {field1:=4.1, field2:=true});
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    external function MyExtFunc (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 );
    control {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        MyExtFunc(var_1,var_2,var_3,var_4);            // good
        MyExtFunc(var_11,var_22,var_33,var_44);        // good
        MyExtFunc( {field1:=1.2, field2:=true},        // good
	           {field1:=2.5, field2:=true},
	           var_3,
		   var_4);
        MyExtFunc( {field1:=1.2, field2:=true},        // error
                   {field1:=2.5, field2:=true},
                   {field1:=3.6, field2:=true},
                   {field1:=4.1, field2:=true});
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { integer field }
    function MyFunc (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 ) {
        var address temp := { field:=par_1.field };
        par_1.field := par_2.field;
	par_2.field := par_3.field;
	par_3.field := par_4.field;
	par_4.field := temp.field;
    }
    control {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        MyFunc( {1}, {2}, var_3, var_4 );              // good
        MyFunc( var_1, var_2, var_3, var_4 );          // good
        MyFunc( var_11, var_22, var_33, var_44 );      // good
        MyFunc( {1}, {2}, {3}, {4} );                  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { integer field }
    function MyCompFunc (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 ) runs on MyCT {
        var address temp := { field:=par_1.field };
        par_1.field := par_2.field;
	par_2.field := par_3.field;
	par_3.field := par_4.field;
	par_4.field := temp.field;
    }
    function MyTempFunc () runs on MyCT {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        MyCompFunc( {1}, {2}, var_3, var_4 );              // good
        MyCompFunc( var_1, var_2, var_3, var_4 );          // good
        MyCompFunc( var_11, var_22, var_33, var_44 );      // good
        MyCompFunc( {1}, {2}, {3}, {4} );                  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { integer field }
    external function MyExtFunc (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 );
    control {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        MyExtFunc( {1}, {2}, var_3, var_4 );               // good
        MyExtFunc( var_1, var_2, var_3, var_4 );           // good
        MyExtFunc( var_11, var_22, var_33, var_44 );       // good
        MyExtFunc( {1}, {2}, {3}, {4} );                   // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 ) {
        var float temp;
	temp := valueof ( par_1 );
	temp := valueof ( par_2 );
	temp := valueof ( par_3 );
	temp := valueof ( par_4 );
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        MyFunc( 1.1, 2.8, var_33, var_44);            // good
        MyFunc( var_11, var_22, var_33, var_44);      // good
        MyFunc( var_1, var_2, var_3, var_4);          // error
        MyFunc( 1.1, 2.8, 3.53, 4.94);                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 ) runs on MyCT {
        var float temp;
	temp := valueof ( par_1 );
	temp := valueof ( par_2 );
	temp := valueof ( par_3 );
	temp := valueof ( par_4 );
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyTempFunc () runs on MyCT {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        MyCompFunc( 1.1, 2.8, var_33, var_44);            // good
        MyCompFunc( var_11, var_22, var_33, var_44);      // good
        MyCompFunc( var_1, var_2, var_3, var_4);          // error
        MyCompFunc( 1.1, 2.8, 3.53, 4.94);                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 );
    control {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        MyExtFunc( 1.1, 2.8, var_33, var_44);            // good
        MyExtFunc( var_11, var_22, var_33, var_44);      // good
        MyExtFunc( var_1, var_2, var_3, var_4);          // error
        MyExtFunc( 1.1, 2.8, 3.53, 4.94);                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 ) {
        var MyCT temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyCompFunc () runs on MyCT {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;
        MyFunc( var_1, var_2, var_3, var_4 );                          // good
        MyFunc( temp, temp, temp, temp);                               // good
        MyFunc( MyCT.create, MyCT.create, temp, temp );                // good
        MyFunc( MyCT.create, MyCT.create, MyCT.create, MyCT.create );  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 ) runs on MyCT {
        var MyCT temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyTempFunc () runs on MyCT {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;
        MyCompFunc( var_1, var_2, var_3, var_4 );                          // good
        MyCompFunc( temp, temp, temp, temp);                               // good
        MyCompFunc( MyCT.create, MyCT.create, temp, temp );                // good
        MyCompFunc( MyCT.create, MyCT.create, MyCT.create, MyCT.create );  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    external function MyExtFunc (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 );
    function MyTempFunc () runs on MyCT {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;
        MyExtFunc( var_1, var_2, var_3, var_4 );                          // good
        MyExtFunc( temp, temp, temp, temp);                               // good
        MyExtFunc( MyCT.create, MyCT.create, temp, temp );                // good
        MyExtFunc( MyCT.create, MyCT.create, MyCT.create, MyCT.create );  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }         // port type
    type component MyCT {
        port MyPort port_1;
        port MyPort port_2;
    }
    function MyFunc ( MyPort par_1, inout MyPort par_2 ) {
        par_1 := par_2;
	par_2 := par_1;
    }
    function MyCompFunc ( MyPort par_1, inout MyPort par_2 ) runs on MyCT {
        port_1 := par_1;
        par_1 := par_2;
	par_2 := port_1;
    }
    external function MyExtFunc ( MyPort par_1, inout MyPort par_2 );
    function MyTempFunc ( MyPort par_1, inout MyPort par_2 ) runs on MyCT {
        MyFunc( port_1, port_2 );
        MyCompFunc( port_1, port_2 );
        MyExtFunc( port_1, port_2 );
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?port_1
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
                      default        par_1,        // default
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 ) {
        var default temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        MyFunc( var_1, var_2, var_3, var_4 );          // good
        MyFunc( temp, temp, temp, temp);               // good
        MyFunc( null, null, temp, temp);               // good
        MyFunc( null, null, null, null);               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc (
                      default        par_1,        // default type
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 ) runs on MyCT {
        var default temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    function MyTempFunc () runs on MyCT {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        MyCompFunc( var_1, var_2, var_3, var_4 );          // good
        MyCompFunc( temp, temp, temp, temp);               // good
        MyCompFunc( null, null, temp, temp);               // good
        MyCompFunc( null, null, null, null);               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc (
                      default        par_1,        // default type
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 );
    control {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        MyExtFunc( var_1, var_2, var_3, var_4 );          // good
        MyExtFunc( temp, temp, temp, temp);               // good
        MyExtFunc( null, null, temp, temp);               // good
        MyExtFunc( null, null, null, null);               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc ( timer par_1, inout timer par_2 ) {
        timer temp := 2.3;
        temp  := par_1;         // error
        par_1 := par_2;         // error
	par_2 := temp;          // error
    }
    control {
        timer T1 := 2.9;
        timer T2 := 5.7;
	timer T3, T4;
        MyFunc( T1, T2 );           // good
        MyFunc( T3, T4 );           // good
        MyFunc( 3.8, 4.5 );         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?temp
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function: timer as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc (
       timer        par_1 := 1.0,        // basic type
       inout timer  par_4 := 1.0 ) {};
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?for.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Function_runs_on: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc ( timer par_1, inout timer par_2 ) runs on MyCT {
        timer temp := 2.3;
        temp  := par_1;         // error
        par_1 := par_2;         // error
        par_2 := temp;          // error
    }
    function MyTempFunc () runs on MyCT {
        timer T1 := 2.9;
        timer T2 := 5.7;
	timer T3, T4;
        MyCompFunc( T1, T2 );           // good
        MyCompFunc( T3, T4 );           // good
        MyCompFunc( 3.8, 4.5 );         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?temp
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->External Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    external function MyExtFunc ( timer par_1, inout timer par_2 );
    control {
        timer T1 := 2.9;
        timer T2 := 5.7;
	timer T3, T4;
        MyExtFunc( T1, T2 );           // good
        MyExtFunc( T3, T4 );           // good
        MyExtFunc( 3.8, 4.5 );         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: allowed in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    altstep MyAltstep (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      MyPort         par_61,          // port type
                      inout MyPort   par_64,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74,

                      timer          par_81,          // timer
                      inout timer    par_84 ) {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: allowed in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    altstep MyCompAltstep (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      MyPort         par_61,          // port type
                      inout MyPort   par_64,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74,

                      timer          par_81,          // timer
                      inout timer    par_84 ) runs on MyCT {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: allowed non-mandatory in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: allowed non-mandatory in/out/inout>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
        type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type component MyCT {
      const integer comp_const_i := 0;
      var integer comp_var_i := 0;
      const octetstring comp_const_o := '00'O;
      var octetstring comp_var_o := '00'O;
      const MySet comp_const_set := {field1 := 1.0, field2 := true};
      var MySet comp_var_set := {field1 := 1.0, field2 := true};
      const address comp_const_address := {5};
      var address comp_var_address := {5};
      port MyPort comp_port;
      timer comp_timer := 1.0;
    }
    altstep MyCompAltstep (
         integer        par_11_1 := comp_const_i,        // basic type
         in integer     par_12_1 := comp_const_i,
         out integer    par_13_1 := comp_var_i,
         inout integer  par_14_1 := comp_var_i,

         octetstring        par_11_2 := comp_const_o,    // basic string type
         in octetstring     par_12_2 := comp_const_o,
         out octetstring    par_13_2 := comp_var_o,
         inout octetstring  par_14_2 := comp_var_o,

         MySet          par_21 := comp_const_set,        // user-defined structured type
         in MySet       par_22 := comp_const_set,
         out MySet      par_23 := comp_var_set,
         inout MySet    par_24 := comp_var_set,

         address        par_31 := comp_const_address,    // address
         in address     par_32 := comp_const_address,
         out address    par_33 := comp_var_address,
         inout address  par_34 := comp_var_address,

         MyPort         par_61 := comp_port,             // port type
         inout MyPort   par_64 := comp_port,

         timer          par_81 := comp_timer,            // timer
         inout timer    par_84 := comp_timer ) runs on MyCT {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: port type with in/out
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: port type with in/out>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type component MyCT {}
    altstep MyFunc ( in MyPort par_1, out MyPort par_2 ) {
        [else] {}
    }
    altstep MyCompFunc ( in MyPort par_1, out MyPort par_2 ) {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Port.+?cannot.+?used.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Port.+?cannot.+?used.+?out.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer with in/out
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer with in/out>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyFunc ( in timer par_1, out timer par_2 ) {
        [else] {}
    }
    altstep MyCompFunc ( in timer par_1, out timer par_2 ) {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 ) {
        var integer temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    control {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        MyAltstep( var_1, var_2, var_3, var_4);          // good
        MyAltstep( var_11, var_22, var_33, var_44);      // good
        MyAltstep( 1, 2, var_3, var_4);                  // good
        MyAltstep( 1, 2, 3, 4);                          // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep (
        integer        par_1 := 1,        // basic type
        in integer     par_2 := 1,
        out integer    par_3 := 1,
        inout integer  par_4 := 1 ) {
      [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 ) runs on MyCT {
        var integer temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    function MyCompFunc () runs on MyCT {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        MyCompAltstep( var_1, var_2, var_3, var_4);          // good
        MyCompAltstep( var_11, var_22, var_33, var_44);      // good
        MyCompAltstep( 1, 2, var_3, var_4);                  // good
        MyCompAltstep( 1, 2, 3, 4);                          // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 ) {
        var charstring temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
     }
    control {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        MyAltstep( var_1, var_2, var_3, var_4);             // good
        MyAltstep( var_11, var_22, var_33, var_44);         // good
        MyAltstep( "w", "e", var_3, var_4);                 // good
        MyAltstep( "q", "b", "5", "w");                     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 ) runs on MyCT {
        var charstring temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    function MyCompFunc () runs on MyCT {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        MyCompAltstep( var_1, var_2, var_3, var_4);            // good
        MyCompAltstep( var_11, var_22, var_33, var_44);        // good
        MyCompAltstep( "w", "e", var_3, var_4);                // good
        MyCompAltstep( "q", "b", "5", "w");                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    altstep MyAltstep (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 ) {
        var MySet temp := { field1:=par_1.field1 }
        [else] {
                 par_1.field1 := par_2.field1;
                 par_2.field1 := par_3.field1;
                 par_3.field1 := par_4.field1;
                 par_4.field1 := temp.field1;
        }
    }
    control {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        MyAltstep(var_1,var_2,var_3,var_4);                 // good
        MyAltstep(var_11,var_22,var_33,var_44);             // good
        MyAltstep( {field1:=1.2, field2:=true},             // good
                {field1:=2.5, field2:=true},
                var_3,
                var_4);
        MyAltstep( {field1:=1.2, field2:=true},             // error
                   {field1:=2.5, field2:=true},
                   {field1:=3.6, field2:=true},
                   {field1:=4.1, field2:=true});
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    altstep MyCompAltstep (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 ) runs on MyCT {
        var MySet temp := { field1:=par_1.field1 }
        [else] {
                 par_1.field1 := par_2.field1;
                 par_2.field1 := par_3.field1;
                 par_3.field1 := par_4.field1;
                 par_4.field1 := temp.field1;
        }
    }
    function MyCompFunc () runs on MyCT {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        MyCompAltstep(var_1,var_2,var_3,var_4);           // good
        MyCompAltstep(var_11,var_22,var_33,var_44);       // good
        MyCompAltstep( {field1:=1.2, field2:=true},       // good
	            {field1:=2.5, field2:=true},
	            var_3,
		    var_4);
        MyCompAltstep( {field1:=1.2, field2:=true},       // error
                    {field1:=2.5, field2:=true},
                    {field1:=3.6, field2:=true},
                    {field1:=4.1, field2:=true});
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { integer field }
    altstep MyAltstep (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 ) {
        var address temp := { field:=par_1.field };
        [else] {
                 par_1.field := par_2.field;
                 par_2.field := par_3.field;
                 par_3.field := par_4.field;
                 par_4.field := temp.field;
        }
    }
    control {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        MyAltstep( {1}, {2}, var_3, var_4 );              // good
        MyAltstep( var_1, var_2, var_3, var_4 );          // good
        MyAltstep( var_11, var_22, var_33, var_44 );      // good
        MyAltstep( {1}, {2}, {3}, {4} );                  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { integer field }
    altstep MyCompAltstep (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 ) runs on MyCT {
        var address temp := { field:=par_1.field };
        [else] {
                 par_1.field := par_2.field;
                 par_2.field := par_3.field;
                 par_3.field := par_4.field;
                 par_4.field := temp.field;
        }
    }
    function MyCompFunc () runs on MyCT {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        MyCompAltstep( {1}, {2}, var_3, var_4 );              // good
        MyCompAltstep( var_1, var_2, var_3, var_4 );          // good
        MyCompAltstep( var_11, var_22, var_33, var_44 );      // good
        MyCompAltstep( {1}, {2}, {3}, {4} );                  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 ) {
        var float temp;
        [else] {
                 temp := valueof ( par_1 );
                 temp := valueof ( par_2 );
                 temp := valueof ( par_3 );
                 temp := valueof ( par_4 );
                 par_1 := par_2;
                 par_2 := par_3;
                 par_3 := par_4;
                 par_4 := temp;
        }
    }
    control {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        MyAltstep( 1.1, 2.8, var_33, var_44);            // good
        MyAltstep( var_11, var_22, var_33, var_44);      // good
        MyAltstep( var_1, var_2, var_3, var_4);          // error
        MyAltstep( 1.1, 2.8, 3.53, 4.94);                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 ) runs on MyCT {
        var float temp;
        [else] {
                 temp := valueof ( par_1 );
                 temp := valueof ( par_2 );
                 temp := valueof ( par_3 );
                 temp := valueof ( par_4 );
                 par_1 := par_2;
                 par_2 := par_3;
                 par_3 := par_4;
                 par_4 := temp;
        }
    }
    function MyCompFunc () runs on MyCT {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        MyCompAltstep( 1.1, 2.8, var_33, var_44);            // good
        MyCompAltstep( var_11, var_22, var_33, var_44);      // good
        MyCompAltstep( var_1, var_2, var_3, var_4);          // error
        MyCompAltstep( 1.1, 2.8, 3.53, 4.94);                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAltstep (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 ) {
        var MyCT temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    function MyCompFunc () runs on MyCT {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;
        MyAltstep( var_1, var_2, var_3, var_4 );                          // good
        MyAltstep( temp, temp, temp, temp);                               // good
        MyAltstep( MyCT.create, MyCT.create, temp, temp );                // good
        MyAltstep( MyCT.create, MyCT.create, MyCT.create, MyCT.create );  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 ) runs on MyCT {
        var MyCT temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    function MyCompFunc () runs on MyCT {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;
        MyCompAltstep( var_1, var_2, var_3, var_4 );                          // good
        MyCompAltstep( temp, temp, temp, temp);                               // good
        MyCompAltstep( MyCT.create, MyCT.create, temp, temp );                // good
        MyCompAltstep( MyCT.create, MyCT.create, MyCT.create, MyCT.create );  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }         // port type
    type component MyCT {
        port MyPort port_1;
        port MyPort port_2;
    }
    altstep MyAltstep ( MyPort par_1, inout MyPort par_2 ) {
        [else] {
                 par_1 := par_2;
                 par_2 := par_1;
        }
    }
    altstep MyCompAltstep ( MyPort par_1, inout MyPort par_2 ) runs on MyCT {
        [else] {
                 port_1 := par_1;
                 par_1 := par_2;
                 par_2 := port_1;
        }
    }
    function MyCompFunc ( MyPort par_1, inout MyPort par_2 ) runs on MyCT {
        MyAltstep( port_1, port_2 );
        MyCompAltstep( port_1, port_2 );
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?port_1
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep (
                      default        par_1,        // default
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 ) {
        var default temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    control {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        MyAltstep( var_1, var_2, var_3, var_4 );          // good
        MyAltstep( temp, temp, temp, temp);               // good
        MyAltstep( null, null, temp, temp);               // good
        MyAltstep( null, null, null, null);               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep (
                      default        par_1,        // default type
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 ) runs on MyCT {
        var default temp := par_1;
	[else] {
                 par_1 := par_2;
	         par_2 := par_3;
	         par_3 := par_4;
	         par_4 := temp;
	}
    }
    function MyCompFunc () runs on MyCT {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        MyCompAltstep( var_1, var_2, var_3, var_4 );          // good
        MyCompAltstep( temp, temp, temp, temp);               // good
        MyCompAltstep( null, null, temp, temp);               // good
        MyCompAltstep( null, null, null, null);               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAltstep ( timer par_1, inout timer par_2 ) {
        timer temp := 2.3;
	[else] {
                 temp  := par_1;         // error
                 par_1 := par_2;         // error
                 par_2 := temp;          // error
        }
    }
    control {
        timer T1 := 2.9;
        timer T2 := 5.7;
	timer T3, T4;
        MyAltstep( T1, T2 );           // good
        MyAltstep( T3, T4 );           // good
        MyAltstep( 3.8, 4.5 );         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?temp
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep: timer as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAltstep ( timer par_1 := 1.0, inout timer par_2 := 1.0) {
	[else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Altstep_runs_on: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep ( timer par_1, inout timer par_2 ) runs on MyCT {
        timer temp := 2.3;
	[else] {
                 temp  := par_1;         // error
                 par_1 := par_2;         // error
                 par_2 := temp;          // error
        }
    }
    function MyCompFunc () runs on MyCT {
        timer T1 := 2.9;
        timer T2 := 5.7;
	timer T3, T4;
        MyCompAltstep( T1, T2 );           // good
        MyCompAltstep( T3, T4 );           // good
        MyCompAltstep( 3.8, 4.5 );         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?temp
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?instead of.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?timer.+?expected.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: allowed in/out/inout>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    testcase MyTestcase (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      template MySet       par_41,    // template
                      in template MySet    par_42,
                      out template MySet   par_43,
                      inout template MySet par_44,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54,

                      default        par_71,          // default
                      in default     par_72,
                      out default    par_73,
                      inout default  par_74 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: allowed non-mandatory in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: allowed non-mandatory in/out/inout>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPort message { inout charstring; }
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    type component MyCT {
      const integer comp_const_i := 0;
      var integer comp_var_i := 0;
      const octetstring comp_const_o := '00'O;
      var octetstring comp_var_o := '00'O;
      const MySet comp_const_set := {field1 := 1.0, field2 := true};
      var MySet comp_var_set := {field1 := 1.0, field2 := true};
      const address comp_const_address := {5};
      var address comp_var_address := {5};
      port MyPort comp_port;
      timer comp_timer := 1.0;
    }
    testcase MyTestcase (
         integer        par_11_1 := comp_const_i,        // basic type
         in integer     par_12_1 := comp_const_i,
         out integer    par_13_1 := comp_var_i,
         inout integer  par_14_1 := comp_var_i,

         octetstring        par_11_2 := comp_const_o,    // basic string type
         in octetstring     par_12_2 := comp_const_o,
         out octetstring    par_13_2 := comp_var_o,
         inout octetstring  par_14_2 := comp_var_o,

         MySet          par_21 := comp_const_set,        // user-defined structured type
         in MySet       par_22 := comp_const_set,
         out MySet      par_23 := comp_var_set,
         inout MySet    par_24 := comp_var_set,

         address        par_31 := comp_const_address,    // address
         in address     par_32 := comp_const_address,
         out address    par_33 := comp_var_address,
         inout address  par_34 := comp_var_address ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 ) runs on MyCT {
        var integer temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;
        execute ( MyTestcase( var_1, var_2, var_3, var_4) );          // good
        execute ( MyTestcase( var_11, var_22, var_33, var_44) );      // good
        execute ( MyTestcase( 1, 2, var_3, var_4) );                  // good
        execute ( MyTestcase( 1, 2, 3, 4) );                          // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: basic string type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 ) runs on MyCT {
        var charstring temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;
        execute ( MyTestcase( var_1, var_2, var_3, var_4) );            // good
        execute ( MyTestcase( var_11, var_22, var_33, var_44) );        // good
        execute ( MyTestcase( "w", "e", var_3, var_4) );                // good
        execute ( MyTestcase( "q", "b", "5", "w") );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    testcase MyTestcase (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 ) runs on MyCT {
        var MySet temp := { field1:=par_1.field1 }
        par_1.field1 := par_2.field1;
	par_2.field1 := par_3.field1;
	par_3.field1 := par_4.field1;
	par_4.field1 := temp.field1;
    }
    control {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;
        execute ( MyTestcase(var_1,var_2,var_3,var_4) );           // good
        execute ( MyTestcase(var_11,var_22,var_33,var_44) );       // good
        execute ( MyTestcase( {field1:=1.2, field2:=true},         // good
	                      {field1:=2.5, field2:=true},
	                      var_3,
		              var_4) );
        execute ( MyTestcase( {field1:=1.2, field2:=true},         // error
                              {field1:=2.5, field2:=true},
                              {field1:=3.6, field2:=true},
                              {field1:=4.1, field2:=true}) );
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { integer field }
    testcase MyTestcase (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 ) runs on MyCT {
        var address temp := { field:=par_1.field };
        par_1.field := par_2.field;
	par_2.field := par_3.field;
	par_3.field := par_4.field;
	par_4.field := temp.field;
    }
    control {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;
        execute ( MyTestcase( {1}, {2}, var_3, var_4 ) );              // good
        execute ( MyTestcase( var_1, var_2, var_3, var_4 ) );          // good
        execute ( MyTestcase( var_11, var_22, var_33, var_44 ) );      // good
        execute ( MyTestcase( {1}, {2}, {3}, {4} ) );                  // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase (
                      template float        par_1,        // template
                      in template float     par_2,
                      out template float    par_3,
                      inout template float  par_4 ) runs on MyCT {
        var float temp;
	temp := valueof ( par_1 );
	temp := valueof ( par_2 );
	temp := valueof ( par_3 );
	temp := valueof ( par_4 );
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
        var float var_1 := 1.3;
	var float var_2 := 2.5;
	var float var_3 := 3.1;
	var float var_4 := 4.9;
        var template float var_11, var_22, var_33, var_44;

        execute ( MyTestcase( 1.1, 2.8, var_33, var_44) );            // good
        execute ( MyTestcase( var_11, var_22, var_33, var_44) );      // good
        execute ( MyTestcase( var_1, var_2, var_3, var_4) );          // error
        execute ( MyTestcase( 1.1, 2.8, 3.53, 4.94) );                // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 ) runs on MyCT {
        var MyCT temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
        execute ( MyTestcase( null, null, null, null) );                               // good
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Testcase: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase (
                      default        par_1,        // default type
                      in default     par_2,
                      out default    par_3,
                      inout default  par_4 ) runs on MyCT {
        var default temp := par_1;
        par_1 := par_2;
	par_2 := par_3;
	par_3 := par_4;
	par_4 := temp;
    }
    control {
	var default var_1, var_2, var_3, var_4;
        var default temp := null;
        execute ( MyTestcase( var_1, var_2, var_3, var_4 ) );          // good
        execute ( MyTestcase( temp, temp, temp, temp) );               // good
        execute ( MyTestcase( null, null, temp, temp) );               // good
        execute ( MyTestcase( null, null, null, null) );               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?Reference.+?expected.+?out.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?expected.+?inout.+?parameter
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature:  allowed in/out/inout
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature:  allowed in/out/inout>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type set MySet {
	float   field1,
	boolean field2 optional
    }
    type record address { integer field }
    signature MySigE();          // empty parameter list
    signature MySig (
                      integer        par_11_1,        // basic type
                      in integer     par_12_1,
                      out integer    par_13_1,
                      inout integer  par_14_1,

                      octetstring        par_11_2,    // basic string type
                      in octetstring     par_12_2,
                      out octetstring    par_13_2,
                      inout octetstring  par_14_2,

                      MySet          par_21,          // user-defined structured type
                      in MySet       par_22,
                      out MySet      par_23,
                      inout MySet    par_24,

                      address        par_31,          // address
                      in address     par_32,
                      out address    par_33,
                      inout address  par_34,

                      MyCT           par_51,          // component type
                      in MyCT        par_52,
                      out MyCT       par_53,
                      inout MyCT     par_54 );
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: basic type>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
	var integer var_1 := 1;
	var integer var_2 := 2;
	var integer var_3 := 3;
	var integer var_4 := 4;
	var integer var_11, var_22, var_33, var_44;

        MyPort.call(MySig:{ var_1, var_2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ var_11, var_22, var_33, var_44 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 1, 2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 1, 2, 3, 4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: basic string type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: basic string type>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig (
                      charstring        par_1,        // basic string type
                      in charstring     par_2,
                      out charstring    par_3,
                      inout charstring  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
	var charstring var_1 := "q";
	var charstring var_2 := "w";
	var charstring var_3 := "e";
	var charstring var_4 := "r";
	var charstring var_11, var_22, var_33, var_44;

        MyPort.call(MySig:{ var_1, var_2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ var_11, var_22, var_33, var_44 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ "s", "z", var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ "p", "n", "c", "a" }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: user-defined type>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
	float   field1,
	boolean field2
    }
    signature MySig (
                      MySet        par_1,        // user-defined type
                      in MySet     par_2,
                      out MySet    par_3,
                      inout MySet  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        var MySet var_1 := { field1:=1.3 };
	var MySet var_2 := { field1:=2.5 };
	var MySet var_3 := { field1:=3.1 };
	var MySet var_4 := { field1:=4.9 };
	var MySet var_11, var_22, var_33, var_44;

        MyPort.call(MySig:{ var_1, var_2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ var_11, var_22, var_33, var_44 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ {field1:=1.2, field2:=true},
		            {field1:=2.5, field2:=true},
			    var_3,
			    var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ {field1:=1.2, field2:=true},
                            {field1:=2.5, field2:=true},
                            {field1:=3.6, field2:=true},
                            {field1:=4.1, field2:=true} }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: address type>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { integer field }
    signature MySig (
                      address        par_1,        // address type
                      in address     par_2,
                      out address    par_3,
                      inout address  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        var address var_1 := { field:=1 };
	var address var_2 := { field:=2 };
	var address var_3 := { field:=3 };
	var address var_4 := { field:=4 };
	var address var_11, var_22, var_33, var_44;

        MyPort.call(MySig:{ var_1, var_2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ var_11, var_22, var_33, var_44 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ {2}, {5}, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ {2}, {5}, {6}, {4} }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: component type>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    signature MySig (
                      MyCT        par_1,        // component type
                      in MyCT     par_2,
                      out MyCT    par_3,
                      inout MyCT  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
	var MyCT temp, var_1, var_2, var_3, var_4;
        temp := MyCT.create;

        MyPort.call(MySig:{ var_1, var_2, var_3, var_4 }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ temp, temp, temp, temp }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ MyCT.create, MyCT.create, temp, temp }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ MyCT.create, MyCT.create, MyCT.create, MyCT.create }, 20E-3 + 20E-3) {
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: special parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ParNotAllowedPassedByValueOrRef->Signature: special parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig (
                      integer        par_1,        // basic type
                      in integer     par_2,
                      out integer    par_3,
                      inout integer  par_4 );
    type port MyPortType procedure { inout MySig } with { extension "internal" }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        MyPort.call(MySig:{ -, 2, 3, 4 }, 20E-3 + 20E-3) {    // good
            [] MyPort.catch {}
        }
        MyPort.call(MySig:{ 1, -, 3, 4 }, 20E-3 + 20E-3) {    // good
            [] MyPort.catch {}
        }
        MyPort.call(MySig:{ 1, 2, -, 4 }, 20E-3 + 20E-3) {    // good
            [] MyPort.catch {}
        }
        MyPort.call(MySig:{ 1, 2, 3, - }, 20E-3 + 20E-3) {    // error
            [] MyPort.catch {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Signature.+?incomplete.+?inout.+?parameter.+?par_4.+?missing
<END_RESULT>
<RESULT IF_PASS COUNT >
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3. group parametrization test 1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group parametrization test 1 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1(1) {
     type integer int1;
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+syntax error
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. group parametrization test 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group parametrization test 2 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group(1) grp1 {
     type integer int1;
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+syntax error
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type function fntype(in integer i);
  control {
    fntype(11);
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of type 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of type 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type function(in integer i) fntype;
  control {
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of variable
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of variable>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type function fntype(in integer i);
  function fn(in integer i) { }
  control {
    var fntype f := refers(fn);
    f(11);
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of derefers
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of derefers>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type function fntype(in integer i);
  function fn(in integer i) { }
  control {
    var fntype f := refers(fn);
    execute(derefers(f));
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of derefers 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of derefers 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  function fn(in integer i) { }
  control {
    execute(derefers(refers(fn)));
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of derefers 3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of derefers 3>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component my_component{};
  function fn(in integer i) { }
  control {
    var my_component comp_var := my_component.create;
    comp_var.start(derefers(refers(fn)));
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of derefers 4
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of derefers 4>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  function fn(in integer i) { }
  control {
    execute(derefers(null));
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference invalid parametrization of derefers 5
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference invalid parametrization of derefers 5>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component my_component{};
  function fn(in integer i) { }
  control {
    var my_component comp_var := my_component.create;
    comp_var.start(derefers(null));
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Big integer parameters
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Big integer parameters>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component my_component { }
  function fn(in integer i, in integer j) runs on my_component { }
  testcase tc(in integer i) runs on my_component { fn(1234567891011121314151617181920, i) }
  control {
    execute(tc(1234567891011121314151617181920))
  }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Parameterised template reference without parameter list1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Parameterised template reference without parameter list1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type record my_type {
    integer field1,
    integer field2
  };
  template my_type t_orig (in integer pl_1 := 0, in integer pl_2 := 0)
  :=
  { field1 := pl_1,
    field2 := pl_2
  }

  function f() {
    var template my_type X1 := t_orig(1,2);
    var template my_type X2 := t_orig();
    var template my_type X3 := t_orig;
  }
}
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Parameterised template reference without parameter list2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Parameterised template reference without parameter list2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type record my_type {
    integer field1,
    integer field2
  };
  template my_type t_orig (in integer pl_1 := 0, in integer pl_2)
  :=
  { field1 := pl_1,
    field2 := pl_2
  }

  function f() {
    var template my_type X1 := t_orig(1,2);
    var template my_type X2 := t_orig();
    var template my_type X3 := t_orig;
  }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Too.+?few.+?parameters.+?2.+?was.+?expected.+?instead.+?of.+?0
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?to.+?parameterized.+?definition.+?without.+?actual.+?parameter.+?list
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 42 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

