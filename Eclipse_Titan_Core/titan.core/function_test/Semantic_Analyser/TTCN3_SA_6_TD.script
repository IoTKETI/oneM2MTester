.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Baranyi, Botond
.*   Bartha, Norbert
.*   Beres, Szabolcs
.*   Delic, Adam
.*   Forstner, Matyas
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Palugyai, Sandor
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.17/152 91-CRL 113 200/3 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.EKRISZA

:title.Test description of the TTCN-3 Semantic Analyzer: Values, Value Lists, Ranges, Length, Dimensions, Durations and Subtyping
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2005-02-17   ESNDPAL    New document for TITAN R6
A     2005-03-18   ESNDPAL    Approved after review
B     2005-12-16   EKRISZA    Updates for TITAN R6D
C     2006-07-31   EDMDELI    Updates for TITAN R6E
D     2007-03-06   EJNOSZA    Updates for TITAN R7A
PE1   2008-01-22   EFERKOV    Changes for TITAN R7C
PE2   2008-01-25   ETHNBA     Updates for TITAN R7C
F     2009-06-11   EKRISZA    Name correction
G     2009-09-10   EKRISZA    New tests for modified templates.
H     2010-01-25   EKRISZA    Refreshed version number
I      2010-07-02   EKRISZA    version update
J      2010-07-02   EKRISZA    version update
K      2010-12-14   EKRISZA    version update
PL1  2011-02-23  ESZABRE    Constant folding for indexes
L      2011-02-23   EKRISZA   removed line ending whitespaces
M      2011-10-10   EKRISZA    version update
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-6/x: Values, Value Lists, Ranges, Length, Dimensions, Durations and Subtyping.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
Ref [1]: SA-6/x: Values, Value Lists, Ranges, Length, Dimensions, Durations and Subtyping
.*---------------------------------------------------------------------*
:h2.Subtyping
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Allowed subtyping
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/1.

Strategy: TTCN-3 Core Language side:26, Table 3.
:nl.All not allowed subtyping shall be tested based in the table.
For all types in the table, there shall be one case when the subtyping is
used directly with the type name and one for a named type that has a root
type of the tested type, for example:
:xmp tab=2.
   type integer i1 length(10);
   type i1 i2 length(10);
:exmp.
Both types are defined in one module.

TODO: port, component and default tests are missing.

NOTE: the address type is a user defined type so we won't test it.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - integer length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed subtyping - integer length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type integer FaultyInt1 length(10);
type integer Int;
type Int FaultyInt2 length(4);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Length.+?subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - float length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - float length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type float FaultyFloat1 length(10);
type float Float;
type Float FaultyFloat2 length(4);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Length.+?subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - boolean range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - boolean range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type boolean FaultyBool1 (false..true);
type boolean Bool;
type Bool FaultyBool2 (false..true);
type boolean FaultyBool3 (true..true);
type boolean FaultyBool4 (true..false);

}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)Range.+?subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - boolean length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - boolean length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type boolean FaultyBool1 length(1);
type boolean Bool;
type Bool FaultyBool2 length(2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Length.+?subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - objid range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - objid range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type objid FaultyObjid1 (objid{0 1 2} .. objid{0 1 4});
type objid Objid;
type Objid FaultyObjid2 (objid{0 1 2} .. objid{0 1 4});
type objid FaultyObjid3 (objid{0 2 4} .. objid{0 1 2});

}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - objid length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - objid length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type objid FaultyObjid1 length(3);
type objid Objid;
type Objid FaultyObjid2 length(4)

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - verdicttype range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - verdicttype range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type verdicttype FaultyVerdict1 (pass..error);
type verdicttype Verdict;
type verdicttype FaultyVerdict2 (pass..fail);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - verdicttype length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - verdicttype length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type verdicttype FaultyVerdict1 length(1);
type verdicttype Verdict;
type Verdict FaultyVerdict2 length(2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - bitstring range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - bitstring range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type bitstring FaultyBS1 ('0000'B .. '0111'B);
type bitstring BS;
type BS FaultyBS2 ('1000'B .. '1111'B);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - hexstring range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - hexstring range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type hexstring FaultyHS1 ('000'H .. 'A53'H);
type hexstring HS;
type HS FaultyHS2 ('100'H .. 'FFF'H);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - octetstring range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - octetstring range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type octetstring FaultyOS1 ('0000'O .. 'AB53'O);
type octetstring OS;
type OS FaultyOS2 ('00'O .. '7F'O);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - record range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - record range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record Record {
    integer intField,
    float floatField
}

const Record c_lower := {0, 0.0};
const Record c_upper := {10, 10.0};

type Record FaultyRecord1 (0 .. 10);
type Record FaultyRecord2 (c_lower .. c_upper);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - record length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - record length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record Record {
    integer intField,
    float floatField
}
type Record FaultyRecord length(12);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - record of range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - record of range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer RecordOfInt;

const RecordOfInt c_lower := {0, 0};
const RecordOfInt c_upper := {10, 10};

type RecordOfInt FaultyRecordOfInt1 (0 .. 10);
type RecordOfInt FaultyRecordOfInt2 (c_lower .. c_upper);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - set range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - set range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set Set {
    integer intField,
    float floatField
}

const Set c_lower := {0, 0.0};
const Set c_upper := {10, 10.0};

type Set FaultySet1 (0 .. 10);
type Set FaultySet2 (c_lower .. c_upper);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Value.+?list.+?notation.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - set length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - set length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set Set {
    integer intField,
    float floatField
}
type Set FaultySet length(12);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - set of range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - set of range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set of integer SetOfInt;

const SetOfInt c_lower := {0, 0};
const SetOfInt c_upper := {10, 10};

type SetOfInt FaultySetOfInt1 (0 .. 10);
type SetOfInt FaultySetOfInt2 (c_lower .. c_upper);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - enumerated range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - enumerated range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated Enum { EnumValue0(0), EnumValue1(1), EnumValue2(2), EnumValue3(3) };
type Enum FaultyEnum1 (0..2);
type Enum FaultyEnum2 (EnumValue0..EnumValue2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - enumerated length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - enumerated length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated Enum { EnumValue0(0), EnumValue1(1), EnumValue2(2), EnumValue3(3) };
type Enum FaultyEnum length(4);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - union range
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - union range>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type union Union {
    integer intField,
    float floatField
}

const Union c_lower := {intField := 0};
const Union c_upper := {intField := 10};

type Union FaultyUnion1 (0 .. 10);
type Union FaultyUnion2 (c_record_lower .. c_record_upper);

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Allowed subtyping - union length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Allowed subtyping - union length>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type union Union {
    integer intField,
    float floatField
}
type Union FaultyUnion length(8);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)subtyping.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. TTCN-3::FunctionReference->Subtyping: length
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference->Subtyping: length>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type function fntype() length(10);
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4. TTCN-3::FunctionReference->Subtyping: range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference->Subtyping: range>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  function fn1() { }
  function fn2() { }
  function fn3() { }
  type function fntype() (fn1..fn3);
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.True subset
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/2.

Strategy: the values in the list shall be a true subset of the values defined by the root type
All occurances shall be tested, where such a notation can be used.

.*---------------------------------------------------------------------*
:h3.Mixing different subset notations
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/3.

Strategy: Mixing different subset notations is not allowed for the specific type
All occurances shall be tested, where such a notation can be used.

.*---------------------------------------------------------------------*
:h3.Invalid subset notation
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/4.

Strategy: the value notation used for subtyping is invalid due to:
:list.
:li D='-'.duplicated element in a list of values
:li D='-'.ranges/lists have intersection (common elements)
:li D='-'.lower boundary is greater than upper boundary
:li D='-'.the boundaries shall evaluate to valid character positions according to the coded character set table(s) of the type (for example the given position shall not be empty)
:elist.
All occurances shall be tested, where such a notation can be used.

.*---------------------------------------------------------------------*
:h2.Value notations
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Mixing value notations
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/5.

Strategy: check that mixing assignment and value notations are detected
for all types that allow the usage of at least one of the notations
(that is value, assignment). All occurances shall be tested, where
such a notation can be used.

Tested: - record and set in function

TODO: only a couple of TCs are written, this shall be implemented ones the SA performs the checking and not the parser.

.*---------------------------------------------------------------------*
:h4.Mixing value notations - assignment notation in value list (record const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Mixing value notations - assignment notation in value list (record const in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F,
    charstring CS
}
function MyFunc() {
    // NOTE: catched by the parser
    // TR 709: Not allowed value notation reporting
    var Record FaultyRecord := { 10, F:= 0.0, "error" };
}

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error.+?unexpected.+?:=
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Mixing value notations - assignment notation in value list (set const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Mixing value notations - assignment notation in value list (set const in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type set setType {
    integer I,
    float F,
    charstring CS
}
function MyFunc() {
    // NOTE: catched by the parser
    // TR 709: Not allowed value notation reporting
    const setType s := { 10, F:= 0.0, "error" };
}

}

<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error.+?unexpected.+?:=
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Allowed value notations
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/6.

Startegy:
All occurances shall be tested, where such a notation can be used:
:list.
:li D='-'.in constants and variables
:li D='-'.in templates (static, modified, dynamic)
:elist.
All elements in the tables below are tested in 2 situations (whenever it is allowed):
in module definition part and within a function.

:xmp tab=0.
:nl.for constants and variables:
:nl.=================================================================================
:nl. type	    	  assignment | value list  |  array   | value assignment notation
:nl.=================================================================================
:nl.basic types          T             T            O                T
:nl.---------------------------------------------------------------------------------
:nl.string types         T             T            -                T
:nl.---------------------------------------------------------------------------------
:nl.record               -             -            O                O
:nl.---------------------------------------------------------------------------------
:nl.set                  -             O            O                O
:nl.---------------------------------------------------------------------------------
:nl.union                -             T            O                O
:nl.---------------------------------------------------------------------------------
:nl.record of            T             -            -                O
:nl.---------------------------------------------------------------------------------
:nl.set of               T             -            -                O
:nl.---------------------------------------------------------------------------------
:nl.enumerated           T             T            O                T
:nl.---------------------------------------------------------------------------------
:nl.
:nl.for templates and dynamic templates:
:nl.=================================================================================
:nl. type	    	  assignment | value list  |  array   | value assignment notation
:nl.=================================================================================
:nl.basic types          T             T            O                T
:nl.---------------------------------------------------------------------------------
:nl.string types         T             T            -                T
:nl.---------------------------------------------------------------------------------
:nl.record               -             -            O                O
:nl.---------------------------------------------------------------------------------
:nl.set                  -             O            O                O
:nl.---------------------------------------------------------------------------------
:nl.union                -             T            O                O
:nl.---------------------------------------------------------------------------------
:nl.record of            T             -            -                O
:nl.---------------------------------------------------------------------------------
:nl.set of               T             -            -                O
:nl.---------------------------------------------------------------------------------
:nl.enumerated           T             T            O                T
:nl.---------------------------------------------------------------------------------
:nl.
:nl.for modified templates:
:nl.=================================================================================
:nl. type	    	  assignment | value list   | value assignment notation
:nl.=================================================================================
:nl.basic types          T             T                   T
:nl.---------------------------------------------------------------------------------
:nl.string types         T             T                   T
:nl.---------------------------------------------------------------------------------
:nl.record               -             -                   O
:nl.---------------------------------------------------------------------------------
:nl.set                  -             O                   O
:nl.---------------------------------------------------------------------------------
:nl.union                -             T                   O
:nl.---------------------------------------------------------------------------------
:nl.record of            T             -                   -
:nl.---------------------------------------------------------------------------------
:nl.set of               T             -                   O
:nl.---------------------------------------------------------------------------------
:nl.enumerated           T             T                   T
:nl.---------------------------------------------------------------------------------
:nl.(array notation is not used for modified templates)
:nl.
:exmp.

basic types: integer, float, boolean, objid, verdicttype, anytype, address, port, component, default
string types: bitstring, hexstring, charstring, octetstring, universal charstring

T: type compatibility error, shall not be tested here
:nl.O: semantic error, shall be tested here
:nl.-: allowed, so cannot be negative-tested

Tested:	The upper tables for:
:list.
:li D='-'.constants in definition part and function
:li D='-'.templates in definition part
:elist.

TODO:	- Dinamic template tests are not ready.

NOTE:
:nl.- type "anytype" haven't implemented yet. Can't use array notation for type "port".
:nl.- the type "address" in the TITAN implementation is a user defined type, so we won't test it.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const integer in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const integer in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const integer r:= 233;

const integer f:= r[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const integer in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const integer r:= 233;
	const integer f:= r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template integer in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template integer in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

	template integer r:= 233;
	template integer f:= r[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const float in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const float in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const float r:= 23.3;

const float f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const float in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const float r:= 23.3;
	const float f:= r[0];
}
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template float in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template float in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template float r:= 23.3;

template float f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const boolean in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const boolean in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const boolean r:= true;

const boolean f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const boolean in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const boolean r:= true;
	const boolean f:= r[0];
}
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template boolean in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template boolean in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template boolean r:= true;

template boolean f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const objid in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const objid in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const objid r:= objid{ 0 4 };

const objid f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const objid in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const objid in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const objid r:= objid{ 0 4 };
	const objid f:= r[0];
}
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template objid in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template objid in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template objid r:= objid{ 0 4 };

template objid f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const verdicttype in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const verdicttype in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const verdicttype r:= pass;

const verdicttype f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const verdicttype in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const verdicttype in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const verdicttype r:= pass;
	const verdicttype f:= r[0];
}
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template verdicttype in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template verdicttype in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template verdicttype r:= pass;

template verdicttype f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const component in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const component in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type component c{ };
const c r:= null;

const c f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const component in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const component in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type component c{ };

function myFunct(){
	const c r:= null;
	const c f:= r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template component in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template component in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type component c{ };
template c r:= null;

template c f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const default in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const default in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

const default r:= null;

const default f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const default in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const default in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

function myFunct(){
	const default r:= null;
	const default f:= r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template default in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template default in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template default r:= null;

template default f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template bitstring in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template bitstring in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template bitstring r:= '01011'B;
template bitstring f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bCode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template hexstring in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template hexstring in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template hexstring r:= 'AB01D'H;
template hexstring f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template octetstring in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template octetstring in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template octetstring r:= '000000'O;
template octetstring f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template charstring in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template charstring in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template charstring r:= "aiyyo";
template charstring f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template universal charstring in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template universal charstring in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

template universal charstring r:= "aiyyo" & char( 0, 0, 1, 113) & "yo";
template universal charstring f:= r[0];

}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const record in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F optional,
    charstring CS
}

const Record r := { 1, 0.0, "error" };
const integer f := r[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const record in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F optional,
    charstring CS
}

function MyFunc() {

	const Record r := { 1, 0.0, "aiyyo" };
	const integer f := r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template record in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
    integer I,
    float F,
    charstring CS
}

template recT r := { I:= 1, F:= 0.0, CS:= "aiyyo" };
template recT f := r[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (const record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (const record in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT f:={
	[1]:= 1,
	[2]:= 0.9,
	[3]:= "aiyyo"
}

}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?is)\berror: Indexed assignment notation cannot be used for record type `@x.recT'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (const record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (const record in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

function MyFunc() {
	const recT f:={
		[1]:= 1,
		[2]:= 0.9,
		[3]:= "pass"
	}
}
}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?is)\berror: Indexed assignment notation cannot be used for record type `@x.recT'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (template record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (template record in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

template recT f:={
	[1]:= 1,
	[2]:= 0.9,
	[3]:= "aiyyo"
}

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?record.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (timer-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (timer-array in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

function MyFunc() {
	timer timerarray[3] := {[0] := 1, [1] := 2, [2] := 3};
}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 3>
(?is)\bA value or expression of type float was expected
<END_RESULT>
<RESULT IF_FAIL COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (port-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (port-array in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type port myport message{inout charstring};

type component self_comp{
  port myport ports[3];
}

function MyFunc() runs on self_comp{
	ports := {[0] := 1.0, [1] := 2.0, [2] := 3.0};
}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?Reference.+?to.+?a.+?variable.+?or.+?template.+?variable.+?was.+?expected
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (modified template record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (modified template record in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

template recT r:={
	f1:= 1,
	f2:= 0.9,
	f3:= "aiyyo"
}

template recT f modifies r:= { [0]:= 1, [2]:= 0.9 };

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?record.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value list notation (modified template record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value list notation (modified template record in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

template recT r:={
	f1:= 1,
	f2:= 0.9,
	f3:= "aiyyo"
}

template recT f modifies r:= ({ f1:= 1, f2:= 0.9 }, { f1 := 1, f2 := 0.9, f3 := "pppp" });

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?field.+?f3.+?is.+?missing.+?from.+?template.+?for.+?record.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - complement value list notation (modified template record in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - complement value list notation (modified template record in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type record recT{
	integer f1,
	float f2,
	charstring f3
}

template recT r:={
	f1:= 1,
	f2:= 0.9,
	f3:= "aiyyo"
}

template recT f modifies r:= complement({ f1:= 1, f2:= 0.9 }, { f1:= 1, f2:= 0.9, f3 := "pppp" });

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?field.+?f3.+?is.+?missing.+?from.+?template.+?for.+?record.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value list (const set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value list (const set in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F,
    charstring CS
}

const Set s := { 3.14, "error", 9 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)value.+?list.+?notation.+?cannot.+?be.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value list (const set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value list (const set in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F,
    charstring CS
}

function MyFunc() {

	const Set s := { 3.14, "error", 9 };
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)value.+?list.+?notation.+?cannot.+?be.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value list (template set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value list (template set in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F,
    charstring CS
}

template Set s := { 3.14, "error", 9 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Value.+?list.+?notation.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value list (modified template set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value list (modified template set in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT {
    integer I,
    float F,
    charstring CS
}

template setT s:= { F:= 3.14, CS:= "aiyyo", I:= 9 };

template setT f modifies s:= { 0, 8.8, "gerappa" };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Value.+?list.+?notation.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const set in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F optional,
    charstring CS
}

const Set cSet := {
	I:= 1,
	F:= 0.0,
	CS:= "error"
};

const integer FaultyField := cSet[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const set in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F optional,
    charstring CS
}

function MyFunc() {

	const Set cSet := {
		I:= 1,
		F:= 0.0,
		CS:= "error"
	};

	const integer FaultyField := cSet[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template set in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F optional,
    charstring CS
}

template Set cSet := {
	I:= 1,
	F:= 0.0,
	CS:= "error"
};

template integer FaultyField := cSet[0];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (const set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (const set in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT f:={
	[1]:= 1,
	[2]:= 0.9,
	[3]:= "pass"
}

}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (template set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (template set in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type set setT{
	integer f1,
	float f2,
	charstring f3
}

template setT f:={
	[1]:= 1,
	[2]:= 0.9,
	[3]:= "pass"
}

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (modified template set in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (modified template set in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type set setT{
	integer f1,
	float f2,
	charstring f3
}

template setT r:={
	f1:= 1,
	f2:= 0.9,
	f3:= "aiyyo"
}

// TR 711: A nonexistent reference is reported only once
template setT f modifies r:= { [0]:= 1, [2]:= 0.9 };

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const union in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const union in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union u {
    integer f_int,
    float f_float
}

const u r := { f_int:=1 };

const u f:= r[0];
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const union in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union u {
    integer f_int,
    float f_float
}

function myFunct(){
	const u r := { f_int:=1 };
	const u f:= r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template union in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template union in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union u {
    integer f_int,
    float f_float
}

template u r := { f_int:=1 };

template u f:= r[0];
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (const union in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (const union in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT f:={
	[1]:= 1
}

}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?is)\berror: union value was expected for type `@x.uniT'
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (const union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (const union in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

function myFunct(){
	const uniT f:={
		[1]:= 1
	}
}
}
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?is)\berror: union value was expected for type `@x.uniT'
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (template union in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (template union in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

// TR 710: Incorrect error message
template uniT f:={
	[1]:= 1
}

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?union.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - value assignment notation (modified template union in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - value assignment notation (modified template union in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type union u {
    integer f_int,
    float f_float
}

template u r := { f_int:=1 };

// TR 710: Incorrect error message
template u f modifies r:= { [0]:= 2 };

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?assignment.+?notation.+?with.+?array.+?indices.+?cannot.+?be.+?used.+?for.+?union.+?type
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const enumerated in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const enumerated in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enum { ONE(1), TWO(2), THREE(3) };

const enum r:= ONE;

const enum f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (const enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (const enumerated in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enum { ONE(1), TWO(2), THREE(3) };

function myFunct(){
	const enum r:= ONE;
	const enum f:= r[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed value notations - array notation (template enumerated in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed value notations - array notation (template enumerated in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enum { ONE(1), TWO(2), THREE(3) };

template enum r:= ONE;

template enum f:= r[0];
}

<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Type.+?cannot.+?be.+?indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (timer-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (timer-array in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x{

function MyFunc() {
	timer timerarray[3] := {[0] := 1.0, [1] := 2.0, [2] := 3.0, [3] := 4.0};
	timer timerarray2[3] := {[0.0] := 1.0, [1] := 2.0, [2] := 3.0};
	timer timerarray3[3] := {[0] := 1.0, [1] := 2.0};
	timer timerarray4[3] := {[-1] := 1.0, [0] := 2.0, [1] := 3.0};
	timer timerarray5[3] := {[0] := 1.0, [0] := 2.0, [1] := 3.0};
}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror: Array index overflow: the index value must be at most `2' instead of `3'
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror: A value or expression of type integer was expected
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror: Array index underflow: the index value must be at least `0' instead of `-1'
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror: Duplicate index value `0' for timer array elements `2' and `1'
<END_RESULT>
<RESULT IF_FAIL COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (index out of bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (index out of bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type integer myIntType[3];

function MyFunc() {
	var myIntType myintarray := {[0] := 0, [1] := 1, [2]:= 2};
	var myIntType myintarray2 := {[0] := 0, [1] := 1};
	var myIntType myintarray3 := {[0] := 0, [1] := 1, [2]:= 2, [2] := 3};
	
	var integer i := 2;
	var myIntType myintarray4 := {[i] := 0, [i] := 1, [i]:= 2};
	
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Duplicate index value `2' for components `4' and `3'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (negative index is used)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (negative index is used)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type integer myIntType[3];

function MyFunc() {
	var myIntType myintarray := {[0] := 0, [-1] := 1, [2]:= 2};
	var myIntType myintarray2 := {[0.0] := 0, [1.0] := 1, [2.3]:= 2};
	
	var integer i := -56;
	var myIntType myintarray3 := {[i] := 0, [i] := 1, [i]:= 2};
	
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Array index underflow: the index value must be at least `0' instead of `-1'
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?im)\berror: A value or expression of type integer was expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (structured types)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (structured types)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type integer myIntType[3];
type record myTestRec
{
  myIntType intlist,
  integer   myint
}

type record of myTestRec myTestRecList;

type record of integer myIntegerList;

type record myTestRec2
{
  myIntegerList myintegerlist,
  integer myint
}


function MyFunc() {
	
	var myTestRecList mytestreclist := {[0] := {intlist := {[0]:=0, [1]:= 1, [2]:=2}, myint:= 1}};
	var myTestRecList mytestreclist2 := {[0] := {intlist := {[0]:=0, [1]:= 1, [-2]:=2}, myint:= 1}};
	var myTestRecList mytestreclist3 := {[0] := {intlist := {[0]:=0, [1]:= 1, [2.0]:=2}, myint:= 1}};
	var myTestRecList mytestreclist4 := {[0] := {intlist := {[0]:=0, [1]:= 1}, myint:= 1}};
	var myTestRecList mytestreclist5 := {[0] := {intlist := {[0]:=0, [1]:= 1, [2]:=2, [3] := 3}, myint:= 1}};
	var myTestRecList mytestreclist6 := {[0] := {intlist := {[0]:=0, [1]:= 1, [1]:=2}, myint:= 1}};
	
	var myTestRec2 mytestrec := {myintegerlist := {[0]:= 0, [1] := 1, [2] := 2}, myint := 1};
	var myTestRec2 mytestrec2 := {myintegerlist := {[0.0]:= 0, [1] := 1, [2] := 2}, myint := 1};
	var myTestRec2 mytestrec3 := {myintegerlist := {[0]:= 0, [-1] := 1, [2] := 2}, myint := 1};
	var myTestRec2 mytestrec4 := {myintegerlist := {[0]:= 0, [1] := 1, [1] := 2}, myint := 1};
	
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Array index underflow: the index value must be at least `0' instead of `-2'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror: A value or expression of type integer was expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Array index overflow: the index value must be at most `2' instead of `3'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror: Duplicate index value `1' for components `3' and `2'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: A non-negative integer value was expected for indexing type `@x.myIntegerList' instead of `-1'
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (modify template)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (modify template)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type record of integer MyIntType;
template MyIntType T1 := {0, 1, 2};
template MyIntType T2 modifies T1:= {[0] := 1, [0]:= 5};
template MyIntType T3 modifies T1:= {[0] := 1, [-5]:= 5};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Duplicate index value `0' for components `2' and `1'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror: A non-negative integer value was expected for indexing type `@x.MyIntType' instead of `-5'
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - value assignment notation (modify template2)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Value notations - value assignment notation (modify template2)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x{

type integer IntType[3];

type record of integer MyIntType;
template MyIntType T1 := {0, 1, 2};
template MyIntType T2 modifies T1:= {[0.1] := 1, [1]:= 5};
template MyIntType T3 modifies T1:= {[0] := 1, [1.0]:= 5};

function MyFunc() {
	
	var IntType myintarray := {['00'O] := 0, [1.5] := 1, [2]:= 2};
}


}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\bA value or expression of type integer was expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. Value notations - Value notations shall assign a value to a specific element only once
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-6/7.

Startegy: In one value notation an element can get value only once.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.record and set constants in definition part and function
:li D='-'.record modified template in definition part
:li D='-'.enumerated type in definition part
:elist.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in record (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in record (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F,
    charstring CS
}

const Record wrongRecord := {
	I:= 1,
	F:= 0.0,
	CS:= "error",
	F:= 2.0
};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Field.+?already.+?given
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in record (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in record (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F,
    charstring CS
}

function MyFunc() {

	const Record wrongRecord := {
		I:= 1,
		F:= 0.0,
		CS:= "error",
		F:= 2.0
	};
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Field.+?already.+?given
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in set (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in set (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F,
    charstring CS
}

const Set s := {
    F:= 0.0,
    I:= 3,
    CS:= "error",
    F:= 9.0
};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Field.+?already.+?given
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in record of (modified template in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in record of (modified template in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

template rofT temp:= { 1, 2, 3, 4, 5};

template rofT modTemp modifies temp:= { [2]:= 7, [3]:= 10, [2]:= 14 };

}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?Duplicate.+?index.+?value
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in set (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in set (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F,
    charstring CS
}

function MyFunc() {

	const Set s := {
	    F:= 0.0,
	    I:= 3,
	    CS:= "error",
	    F:= 9.0
	};
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Field.+?already.+?given
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once - duplicated element assignment in enumerated type (in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once - duplicated element assignment in enumerated type (in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated Enum { ONE(1), TWO(2), THREE(1) };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Duplicate.+?value.+?enumeration
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)already.+?assigned
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Value notations - A value notation shall assign a value to a specific element only once with binary, octetstring, hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - A value notation shall assign a value to a specific element only once with binary, octetstring, hexstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated Enum { ONE(1), TWO('01'B), THREE('01'O), FOUR('01'H) };

}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)Duplicate.+?value.+?enumeration
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?im)already.+?assigned
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Enumeration allowed defining values: number, hexa, octet, binary in compile time
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Enumeration allowed defining values: number, hexa, octet, binary in compile time>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated Enum { ONE(1), TWO('11'B), THREE('AB'O), FOUR('AC'H), FIVE("STR"), SIX(f()), SEVEN(c_int), EIGHT(c_bit) };

const integer c_int := 4;
const bitrstring c_bit := '010110'B;

function f() return integer {
	return 123;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)INTEGER.+?BITSTRING.+?OCTETSTRING.+?HEXSTRING.+?expected.+?FIVE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)compile.+?time.+?was.+?expected.+?SIX
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h2.Allowed values (each evaluated expression shall conform to the context-specific rules)
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Allowed values of an object identifier
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/8.

Startegy: in assignment of an object identifier the first two elements have to be defined.
We can define these elements in three ways:
:list.
:li D='-'.with numbers : { 0 4 ...}
:li D='-'.with identifiers : { itu_t identified_organization ...}
:li D='-'.with both of them : { itu_t(0) identified_organization(4) ...}
:elist.
For more information see the ITU-T X.660.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.wrong first number in definition part and function
:li D='-'.wrong identifier in definition part and function
:elist.
.*---------------------------------------------------------------------*
:h4.Allowed values of an object identifier - wrong first number (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an object identifier - wrong first number (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const objid o:= objid{ 6 1 0 0 };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)value.+?first.+?OBJECT.+?IDENTIFIER.+?must.+?between.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an object identifier - wrong first number (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an object identifier - wrong first number (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function MyFunc() {

	const objid o:= objid{ 6 1 0 0 };
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)value.+?first.+?OBJECT.+?IDENTIFIER.+?must.+?between.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an object identifier - wrong identifier (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an object identifier - wrong identifier (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const objid o:= objid{ ecci identified_organization ehh(0) behh(0) };
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)error.+?no.+?local.+?imported.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an object identifier - wrong identifier (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an object identifier - wrong identifier (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function MyFunc() {

	const objid o:= objid{ ecci identified_organization ehh(0) behh(0) };
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)error.+?no.+?local.+?imported.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Allowed values of an universal charstring
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-6/9.

Strategy: for information see the ISO/IEC 10646.
:nl.  First number: 0-128
:nl.  Second number: 0-255
:nl.	Third number: 0-255
:nl.	Fourth number: 0-255
:nl.	Only numbers are allowed.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.wrong first number in definition part and function
:li D='-'.operator in definition part
:li D='-'.constant in function
:elist.

.*---------------------------------------------------------------------*
:h4.Allowed values of an universal charstring - wrong first number (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an universal charstring - wrong first number (const in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

	const universal charstring f:= "aiyyo" & char( 130, 25, 10, 25) & "gerappa";
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?first.+?number.+?must.+?within.+?range
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an universal charstring - wrong first number (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an universal charstring - wrong first number (const in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

function MyFunc() {

	const universal charstring f:= "aiyyo" & char( 130, 25, 10, 25) & "gerappa";

}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?first.+?number.+?must.+?within.+?range
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an universal charstring - operator (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an universal charstring - operator (const in def. part)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

	const universal charstring f:= "aiyyo" & char( 13, 25+32, 10, 25) & "gerappa";
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error.+?unexpected.+?\+
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an universal charstring - constant (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an universal charstring - constant (const in function)>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= 12;

function MyFunc() {

	const universal charstring f:= "aiyyo" & char( i, 25, 10, 25) & "gerappa";

}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?syntax.+?error.+?unexpected.+?identifier
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Function reference - incompatible types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Function reference - incompatible types>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {
  type function fntype1();
  type function fntype2();
  function MyFunc() {
    var fntype1 f1;
    var fntype2 f2;
    if (f1==f2) { }
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an function reference - 1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an function reference - 1 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {
  type function fntype();
  function fn1(integer i) { }
  function fn2() { }
  function MyFunc() {
    var fntype f1 := refers(fn1);
    var fntype f2 := refers(fn2);
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an function reference - 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an function reference - 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {
  type function fntype();
  function fn1() { }
  function fn2() return charstring { return ""; }
  function MyFunc() {
    var fntype f1:= refers(fn1);
    var fntype f2:= refers(fn2);
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed values of an function reference - 3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Allowed values of an function reference - 3>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
  type function fntype(integer a);
  function fn1(integer b) { }
  function fn2(integer a) { }
  function MyFunc() {
    var fntype f1:= refers(fn1);
    var fntype f2:= refers(fn2);
  }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bwarning\b.+?name.+?of.+?parameter.+?not.+?the.+?same
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Allowed values of an index when accessing a single element of a string value
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/10.

Strategy: indexing of string values has to beginning with 0. So shall not
use negative numbers or higher numbers than size(string)-1.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.higher number in index than the size in definition part and function
:li D='-'.negative index in definition part and function
:elist.

.*---------------------------------------------------------------------*
:h4.String indexing - indexing begin with zero (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - String indexing - indexing begin with zero (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const charstring CS:="WRONG";
	const charstring wrongCS := CS[5];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Index.+?overflow.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.String indexing - indexing begin with zero (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - String indexing - indexing begin with zero (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function MyFunc() {

	const charstring CS:="WRONG";
	const charstring wrongCS := CS[5];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Index.+?overflow.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.String indexing - indexing must be non-negative (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - String indexing - indexing must be non-negative (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const charstring CS:="WRONG";
	const charstring wrongCS := CS[-1];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)non-negative.+?value.+?expected.+?instead of.+?indexing.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.String indexing - indexing must be non-negative (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - String indexing - indexing must be non-negative (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function MyFunc() {

	const charstring CS:="WRONG";
	const charstring wrongCS := CS[-1];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)non-negative.+?value.+?expected.+?instead of.+?indexing.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Omitting mandatory fields
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/11.

Strategy: shall not omitting mandatory fields
All occurances shall be tested, where such a notation can be used.

Tested:	- record and set fields in definition part and function

.*---------------------------------------------------------------------*
:h4.Omitting mandatory fields - wrong optional record field (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Omitting mandatory fields - wrong optional record field (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F optional,
    charstring CS
}

const Record r := { omit, 0.0, "error" };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Omitting mandatory fields - referencing unbound (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Omitting mandatory fields - referencing unbound (const in def. part)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer a,
    integer b
}

const Record c_R := { b := 1 };
const integer c_i := c_R.a 

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Reference.+?unbound.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Omitting mandatory fields - wrong optional record field (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Omitting mandatory fields - wrong optional record field (const in function)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record Record {
    integer I,
    float F optional,
    charstring CS
}

function MyFunc() {

	const Record r := { omit, 0.0, "error" };
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Omitting mandatory fields - wrong optional set field (const in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Omitting mandatory fields - wrong optional set field> (const in def. part)
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F optional,
    charstring CS
}

const Set s := {
    F:= 0.0,
    I:= omit,
    CS:= "error"
};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Omitting mandatory fields - wrong optional set field (const in function)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Omitting mandatory fields - wrong optional set field> (const in function)
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set Set {
    integer I,
    float F optional,
    charstring CS
}

function MyFunc() {

	const Set s := {
	    F:= 0.0,
	    I:= omit,
	    CS:= "error"
	};
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Values are not constants or literals in subtype-specifications
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/12.

Strategy: values in list, range and string length shall be initialized with constants or literal values.
	So it shall not contains functions returned with random values, and hand-made functions neither.
	See the table 3, side 26.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.inner random and hand-made functions in charstring length
:li D='-'.inner random and hand-made functions in bitstring length-range
:li D='-'.both type of functions in bitstring length-range
:li D='-'.inner random and hand-made functions in integer-range
:li D='-'.both type of functions in float-range
:li D='-'.inner random and hand-made functions in integer-list
:li D='-'.both type of functions in float-list
:elist.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - rnd() in length (charstring )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - rnd() in length (charstring )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type charstring myCharType length( float2int(rnd()) );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - hand-made function in length (charstring )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - hand-made function in length (charstring )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return integer{
	return 5;
}

type charstring myCharType length( myFunct() );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - rnd() in length range (bitstring )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - rnd() in length range (bitstring )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type charstring myCharType length( float2int(rnd()) .. 5 );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - hand-made function in length range (bitstring )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - hand-made function in length range (bitstring )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return integer{
	return 5;
}

type charstring myCharType length( 2 .. myFunct());

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - both types of functions in length range (bitstring )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - both types of functions in length range (bitstring )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return integer{
	return 5;
}

type charstring myCharType length( float2int(rnd()) .. myFunct());

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - rnd() in range (integer )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - rnd() in range (integer )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myIntType ( float2int(rnd()) .. 255 );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - hand-made function in range (integer )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - hand-made function in range (integer )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return integer{
	return 5;
}

type integer myIntType ( 255 .. myFunct() );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - both types of functions in range (float )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - both types of functions in range (float )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return float{
	return 5.0;
}

type float myIntType ( rnd() .. myFunct() );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - rnd() in list (integer )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - rnd() in list (integer )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myIntType ( float2int(rnd()), 255 );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - hand-made function in list (integer )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - hand-made function in list (integer )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return integer{
	return 5;
}

type integer myIntType ( 255, myFunct() );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Values are not constants or literals in subtype-specifications - both types of functions in list (float )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Values are not constants or literals in subtype-specifications - both types of functions in list (float )>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return float{
	return 5.0;
}

type float myIntType ( rnd(), 255.0, myFunct() );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?expected.+?instead
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Negative string lengths
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/13.

Strategy: TTCN-3 permits specification of length restrictions on string types. In all cases, the boundaries shall evaluate to non-negative integer or derived integer constant values.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.type and ranged type definition in definition part for charstring
:li D='-'.charstring in definition part
:li D='-'.bitstring in function
:elist.

.*---------------------------------------------------------------------*
:h4.Negative string lengths - type definition (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative string lengths - type definition (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= -6;

type charstring myChars length( i);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?length.+?restriction.+?must.+?non-negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative string lengths - ranged type definition (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative string lengths - ranged type definition (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= -5;

type charstring myChars length( i..3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Lower.+?boundary.+?length.+?restriction.+?must.+?non-negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative string lengths - using (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative string lengths - using (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring myChars:= "aiyyo";
const charstring f:= myChars[-1];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative string lengths - using (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative string lengths - using (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= -9;
const bitstring myBits:= '100001'B;
const bitstring f:= myBits[i];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Dimension in arrays
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/14.

Strategy: Array dimensions shall be specified using constant expressions which shall evaluate to a positive integer value.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.declaration of integer array with references in control part and function
:li D='-'.declaration of timer array with references in control part and function
:li D='-'.declaration of integer ranged array with references in control part and function
:li D='-'.declaration of timer ranged array with references in control part and function
:li D='-'.declaration of integer array with negative numbers in control part and function
:li D='-'.declaration of timer array with negative numbers in control part and function
:li D='-'.declaration of port array with negative numbers in definition part
:li D='-'.declaration of integer ranged array with negative numbers in control part and function
:li D='-'.declaration of timer ranged array with negative numbers in control part and function
:li D='-'.declaration of port ranged array with negative numbers in control part and function
:li D='-'.declaration of integer array with zero number in control part and function
:li D='-'.declaration of timer array with zero numbers in control part and function
:li D='-'.declaration of port array with zero numbers in definition part
:li D='-'.using of integer array with negative numbers in control part and function
:li D='-'.using of timer array with negative numbers in control part and function
:li D='-'.using of port array with negative numbers in function
:li D='-'.using of integer ranged array with negative numbers in control part and function
:li D='-'.using of timer ranged array with negative numbers in control part and function
:li D='-'.using of port ranged array with negative numbers in function
:elist.
NOTE: it works for timer arrays

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with references (integer array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with references (integer array in control part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer i:= 4;

	// TR693
	var integer myArr[2][i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with references (integer array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with references (integer array in function)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var integer i:= 9;

	// TR693
	var integer myArr[i][3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with references (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with references (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer i:= 4;
	timer myTimerArr[2][i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with references (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with references (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var integer i:= 9;

	// TR 693
	timer myTimerArr[i][3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - port declaration with references (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - port declaration with references (in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

//TR 726
type port myport message{inout charstring};
type myport akarmi[5];

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?cannot.+?embedded.+?into.+?array.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with references (integer ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with references (integer ranged-array in control part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer i:= 4;

	// TR 693
	var integer myArr[2..i][3..4];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with references (integer ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with references (integer ranged-array in function)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var integer i:= 4;

	// TR 693
	var integer myArr[2..6][3..i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with references (ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with references (ranged-array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer i:= 4;
	timer myTimerArr[i..6][3..4];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with references (ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with references (ranged-array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var integer i:= 4;
	timer myTimerArr[2..i][3..4];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with negative literal (integer array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with negative literal (integer array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer myArr[2][-3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?value.+?expected.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with negative constants (integer array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with negative constants (integer array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= -5;
	var integer myArr[i][3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?value.+?expected.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with negative literal (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with negative literal (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer myArr[2][-3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with negative constants (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with negative constants (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= -5;
	timer myArr[i][3];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - port declaration with negative constants (in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - port declaration with negative constants (in def. part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

const integer i := -5;

type component myComp{
  port myPort ports[i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with negative literal (integer ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with negative literal (integer ranged-array in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	var integer myArr[2..6][-8..10];
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with negative constants (integer ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with negative constants (integer ranged-array in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= -3;
	var integer myArr[i..6][8..10];
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with negative literal (ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with negative literal (ranged-array in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	timer myArr[2..6][-8..10];
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with negative constants (ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with negative constants (ranged-array in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= -3;
	timer myArr[i..6][8..10];
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - port declaration with negative constants (ranged-array in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - port declaration with negative constants (ranged-array in def. part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

const integer i := -5;

type component myComp{
  port myPort ports[i..10];
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with zero constants (integer array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with zero constants (integer array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	var integer myArr[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?value.+?expected.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - variable declaration with zero literal (integer array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - variable declaration with zero literal (integer array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= 0;
	var integer myArr[i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?value.+?expected.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with zero constants (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with zero constants (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	timer myArr[0];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - port declaration with zero constants (in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - port declaration with zero constants (in def. part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

type component myComp{
  port myPort ports[0];
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - timer declaration with zero literal (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - timer declaration with zero literal (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= 0;
	timer myArr[i];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - port declaration with zero literal (in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - port declaration with zero literal (in def. part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

const integer i := 0;

type component myComp{
  port myPort ports[i];
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?positive.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (timer array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (timer array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	timer myArr[3];

	myArr[-1].start( 2.0);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Array.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (timer array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (timer array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	timer myArr[3];
	const integer i:= -3;

	myArr[i].start( 2.0);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Array.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (port array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (port array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

type component myComp{
  port myPort ports[3];
}

function myFunc() runs on myComp{
  const integer i := -3;
  ports[i].start;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (integer ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (integer ranged-array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	var integer myArr[4..6][8..10];

	const integer i:= -3;

	// TR694
	var integer f:= myArr[i][9];
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (integer ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (integer ranged-array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	const integer i:= 3;
	var integer myArr[i..6][8..10];

	// TR694
	var integer f:= myArr[4][-9];
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (timer ranged-array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (timer ranged-array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{

	timer myArr[3..6][1..10];
	const integer i:= -3;

	// TR695
	myArr[i][2].start(9.0);

}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (timer ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (timer ranged-array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){

	timer myArr[3..6][1..10];
	const integer i:= -3;

	// TR695
	myArr[i][2].start(9.0);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Dimension in arrays - using (port ranged-array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Dimension in arrays - using (port ranged-array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myPort message{inout charstring};

type component myComp{
  port myPort ports[3..5];
}

function myFunc() runs on myComp{
  const integer i := -3;
  ports[i].start;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Upper and lower boundaries
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/15.

Strategy: The lower boundary shall be smaller than the upper boundary in array definitions, string length restrictions and in
definitions using ranges.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.charstring and integer value-ranges in definition part
:li D='-'.mixed integer list and value-ranges in definition part
:li D='-'.charstring and bitstring length restriction in definition part
:li D='-'.integer array declaration in control part
:li D='-'.timer array declaration in definition part
:li D='-'.port array declaration in definition part
:li D='-'.charstring array declaration in function
:elist.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - value-range (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - value-range (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	type charstring f ( "z".."a");
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?boundary.+?bigger.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - value-range (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - value-range (integer in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const integer i:= 500;
	type integer f (i..255);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?boundary.+?bigger.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - mixed value-list and value-range (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - mixed value-list and value-range (integer in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	type integer f ( 1, 2, 300..255, 500);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?boundary.+?bigger.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - length restriction (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - length restriction (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	const integer i:= 5;
	type charstring f length(7..i);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?upper.+?boundary.+?length.+?restriction.+?cannot.+?be.+?smaller.+?than.+?lower
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - length restriction (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - length restriction (bitstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	type bitstring f length(6..3);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?upper.+?boundary.+?length.+?restriction.+?cannot.+?be.+?smaller.+?than.+?lower
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - array definition (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - array definition (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	const integer i:= 7;
	var integer f [1..2][i..4][3..4];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?greater.+?upper.+?bound
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - array definition (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - array definition (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var charstring f [9..2][1..5];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?greater.+?upper.+?bound
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - timer-array definition (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - timer-array definition (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	const integer i:= 7;
	timer f [1..2][i..4][3..4];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?index.+?greater.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - timer-array definition (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - timer-array definition (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	timer f [9..2][1..5];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?index.+?greater.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - port-array definition (in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - port-array definition (in def. part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myport message{
inout charstring
}

type component mycomp{
port myport ports[6..5]
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?index.+?greater.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Upper and lower boundaries - port-array definition (in def. part) 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Upper and lower boundaries - port-array definition (in def. part) 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myport message{
inout charstring
}

const integer i := 6;

type component mycomp{
port myport ports[i..5]
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?lower.+?bound.+?array.+?index.+?greater.+?than.+?upper
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

.*---------------------------------------------------------------------*
:h3.Overindexing
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/16.

Strategy: When referencing an element of an array, the index shall evaluate to a valid position within string and array.
All occurances shall be tested, where such a notation can be used.

Tested:
:nl.Overindexing
:list.
:li D='-'.bitstring in definition part
:li D='-'.charstring in control part
:li D='-'.hexstring in function
:li D='-'.integer array in control part
:li D='-'.timer array in control part and function
:li D='-'.port array in definition part
:li D='-'.charstring array in function
:li D='-'.integer ranged array in control part
:li D='-'.timer ranged array in control part and function
:li D='-'.port ranged array in definition part
:li D='-'.float arnged array in function
:elist.
:nl.Underindexing
:list.
:li D='-'.integer ranged array in control part
:li D='-'.timer array in control part and function
:li D='-'.timer ranged array in control part and function
:li D='-'.port array in definition part
:li D='-'.port ranged array in definition part
:li D='-'.float ranged array in function
:elist.

.*---------------------------------------------------------------------*
:h4.Overindexing - string overindexing (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - string overindexing (bitstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	type bitstring myBits length(3..5);

	const myBits r:= '11111'B;
	const bitstring f:= r[5];
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Index.+?overflow.+?accessing.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - string overindexing (charstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - string overindexing (charstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type charstring myChars length(3..13);

const myChars r:= "Ford Fairlane";

control{
	const charstring f:= r[15];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Index.+?overflow.+?accessing.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - string overindexing (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - string overindexing (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type hexstring myHexes length(1..10);

const myHexes r:= 'AbbaBaba'H;

function myFunct(){
	const hexstring f:= r[9];
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Index.+?overflow.+?accessing.+?string.+?element
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bNotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - array overindexing (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - array overindexing (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= 10;

control{
	var integer myArr[2][4];
	myArr[1]:= { 1, 2, 3, 4 };

	// TR694
	var integer f:= myArr[1][i];
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - array overindexing (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - array overindexing (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var charstring myArr[2][4];
	myArr[1]:= { "EEE", "MUHAHA", "AIYYO", "GERAPPA"};

	// TR694
	myArr[2][6]:= "ERIXON";
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - timer-array overindexing (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - timer-array overindexing (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer myArr[2][4]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 5;

	// TR695
	f.start( myArr[1][i].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - timer-array overindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - timer-array overindexing (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	timer myArr[2][4]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 5;

	// TR695
	f.start( myArr[1][i].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - port-array overindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - port-array overindexing (in function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myport message{
inout charstring
}

type component mycomp{
port myport ports[5]
}

function myFunc() runs on mycomp{
  ports[5].start;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged-array overindexing (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged-array overindexing (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer myArr[2..4][5..8];

	// TR694
	var integer f:= myArr[6][9];
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged-array overindexing (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged-array overindexing (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= 6;
const integer j:= 10;

function myFunct(){
	var float myArr[2..4][5..8];

	// TR694
	myArr[i][j]:= 3.14;
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged timer-array overindexing (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged timer-array overindexing (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer myArr[2..3][4..7]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 9;

	// TR695
	f.start( myArr[2][i].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged timer-array overindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged timer-array overindexing (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	timer myArr[2..3][4..7]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 9;

	// TR695
	f.start( myArr[2][i].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged port-array overindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged port-array overindexing (in function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myport message{
inout charstring
}

type component mycomp{
port myport ports[5..6]
}

function myFunc() runs on mycomp{
  ports[7].start;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged-array underindexing (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged-array underindexing (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var integer myArr[2..4][5..8];

	// TR694
	var integer f:= myArr[1][3];
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged-array underindexing (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged-array underindexing (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[5..6];

function myFunc(){
  var myint f := {1,2};
  f[4] := 1;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h4.Overindexing - ranged-array underindexing (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged-array underindexing (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer i:= 0;
const integer j:= 4;

function myFunct(){
	var float myArr[2..4][5..8];

	// TR694
	myArr[i][j]:= 3.14;
}
}
<END_MODULE>
<RESULT IF_FAIL NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged timer-array underindexing (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged timer-array underindexing (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer myArr[2..3][4..7]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 1;

	// TR695
	f.start( myArr[i][6].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged timer-array underindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged timer-array underindexing (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	timer myArr[2..3][4..7]:= {{ 1.0, 2.0, 3.0, 4.0 }, { 1.0, 2.0, 3.0, 4.0 }};
	timer f;
	const integer i:= 2;

	// TR695
	f.start( myArr[2][i].read);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Overindexing - ranged port-array underindexing (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Overindexing - ranged port-array underindexing (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port myport message{
inout charstring
}

type component mycomp{
port myport ports[5..6]
}

function myFunc() runs on mycomp{
  ports[4].start;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?index.+?underflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Negative timer duration
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/17.

Strategy: A timer declaration may have an optional default duration value assigned to it. The timer shall be started with this
	value if no other value is specified. This value shall be positive, but we can use constants too. Same is true for timer
	arrays and the oprional timer of the execute operation.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.timer default values in control part and function
:li D='-'.timer starting values in control part and function
:li D='-'.timer-array default values in control part and function
:li D='-'.timer-array starting values in control part and function
:li D='-'.execution timer
:elist.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - default (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - default (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer T:= -12.0;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - default (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - default (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float f:= -2.22;

function myFunct(){
	timer T:= f;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - array default (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - array default (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer T[5]:= { 1.0, 8.9, -3.14, 1.1, 1.5 };
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - array default (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - array default (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float f:= -2.22;

function myFunct(){
	timer T[5]:= { 1.0, f, 3.14, -, 1.5 };
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?non-negative.+?float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - starting value (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - starting value (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer T:= 12.0;

	T.start( -5.9 );
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?timer.+?duration.+?negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - starting value (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - starting value (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float f:= -66.3;

function myFunct(){
	timer T:= 1234.56;

	T.start( f );
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?timer.+?duration.+?negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - array starting value (in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - array starting value (in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer T[5]:= { 1.0, 8.9, 3.14, 1.1, 1.5 };

	T[1].start( - 125.0 );
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?timer.+?duration.+?negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - array starting value (in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - array starting value (in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float f:= -18.07;

function myFunct(){
	timer T[5]:= { 3.3, 3.4, 3.14, 4.1, 2.3 };

	T[1].start( f );
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?timer.+?duration.+?negative
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Negative timer duration - execution timer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Negative timer duration - execution timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type component myComponent{
	const integer i:= 1;
}

function myFunct(){

	timer T1:= 20.0;
	T1.start;
}

testcase myTestCase() runs on myComponent{

	myFunct();
}

control{

	execute( myTestCase(), -5.3 );
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?testcase.+?guard.+?timer.+?negative.+?duration
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Default module parameters
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/18.

Strategy: Default values of module parameters shall be constant expression only.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.module parameters with inner function
:li D='-'.module parameters with hand-made function
:elist.

.*---------------------------------------------------------------------*
:h4.Default module parameters - inner function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Default module parameters - inner function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	modulepar { integer i:= float2int( rnd()); charstring ch:= "aiyyo" };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?evaluable.+?constant.+?value.+?expected.+?instead.+?of.+?operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Default module parameters - hand-made function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Default module parameters - hand-made function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct() return charstring{
	return "RETURNED";
}

modulepar { integer i:= 3; charstring ch:= "aiyyo" & myFunct() };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?constant.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Variable references
.*---------------------------------------------------------------------*

Rule: each variable reference shall conform to the context-specific rules

.*---------------------------------------------------------------------*
:h3.No value shall be assigned to constant elements
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/19.

Strategy: can't change the value of constants, external constants and module parameters.
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.constants, external constants and module parameters in control part and function with ":="
:li D='-'.constants, external constants and module parameters in function with "-> value"
:elist.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - const in control part (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - const in control part (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c:= 1;

control{

	c:=2;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - const in function (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - const in function (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c:= 1;

function myFunct(){

	c:=2;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - const in function ( -> value)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - const in function ( -> value)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c:= 2;

type port portT message {
	in integer
} with {extension "internal"}

type component comp {
	port portT myPort;
}

function myFunct() runs on comp {
	myPort.receive( ?) -> value c;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - external const in control part (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - external const in control part (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

external const integer c;

control{

	c:=2;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - external const in function (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - external const in function (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

external const integer c;

function myFunct(){

	c:=2;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - external const in function ( -> value)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - external const in function ( -> value)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

external const integer c;

type port portT message {
	in integer
} with {extension "internal"}

type component comp {
	port portT myPort;
}

function myFunct() runs on comp {
	myPort.receive( ?) -> value c;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - module parameter in control part (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - module parameter in control part (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

modulepar{
	integer c
}

control{
	c:= 3;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - module parameter in function (:=)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - module parameter in function (:=)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

modulepar{
	integer c
}

function myFunct(){
	c:= 3;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?template.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.No value shall be assigned to constant elements - module parameter in function (-> value)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - No value shall be assigned to constant elements - module parameter in function (-> value)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

modulepar{
	integer c
}

type port portT message {
	in integer
} with {extension "internal"}

type component comp {
	port portT myPort;
}

function myFunct() runs on comp {
	myPort.receive( ?) -> value c;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?variable.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Allowed matching mechanisms
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Allowed matching mechanisms
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/20.

Strategy: SA shall detect if a template of a type uses not allowed matching mechanism.(Table 6, side 68)
Either can be used the following operations: create (99), mtc (101),
system (101), self (101), running (102), getverdict (123)

All occurances shall be tested, where such a notation can be used.

Tested: range, superset, subset, length-restriction, ifpresent mechanisms in definition part, control part and function for
templates and range, superset, subset, length-restriction, ifpresent mechanisms in function for inline-templates

	except
	- "inside values" columns are not tested

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (boolean in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (boolean in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template boolean r:= (false .. true);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (boolean in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (boolean in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template boolean r:= (false .. true);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template boolean r:= (false .. true);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (bitstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template bitstring r:= ('000'B .. '111'B);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (bitstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (bitstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template bitstring r:= ('000'B .. '111'B);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template bitstring r:= ('000'B .. '111'B);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (octetstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (octetstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template octetstring r:= ('0011'O .. '1111'O);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (octetstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (octetstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template octetstring r:= ('0011'O .. '1111'O);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template octetstring r:= ('0011'O .. '1111'O);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (hexstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (hexstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template hexstring r:= ('0011'H .. '1111'H);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (hexstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (hexstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template hexstring r:= ('0011'H .. '1111'H);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template hexstring r:= ('0011'H .. '1111'H);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2
}

const recT c1:= { f1:= 1, f2:= 2.0};
const recT c2:= { f1:= 5, f2:= 7.0};

template recT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2
}

const recT c1:= { f1:= 1, f2:= 2.0};
const recT c2:= { f1:= 5, f2:= 7.0};

control{
	var template recT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2
}

const recT c1:= { f1:= 1, f2:= 2.0};
const recT c2:= { f1:= 5, f2:= 7.0};

function myFunct(){
	var template recT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record of in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

template rofT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record of in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

control{
	var template rofT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

function myFunct(){
	var template rofT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2
}

const setT c1:= { f1:= 1, f2:= 2.0};
const setT c2:= { f1:= 5, f2:= 7.0};


template setT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2
}

const setT c1:= { f1:= 1, f2:= 2.0};
const setT c2:= { f1:= 5, f2:= 7.0};


control{
	var template setT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2
}

const setT c1:= { f1:= 1, f2:= 2.0};
const setT c2:= { f1:= 5, f2:= 7.0};


function myFunct(){
	var template setT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set of in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

const sofT c1:= { 1, 2, 3 };
const sofT c2:= { 4, 5, 6 };


template sofT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set of in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

const sofT c1:= { 1, 2, 3 };
const sofT c2:= { 4, 5, 6 };


control{
	var template sofT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (set of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (set of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

const sofT c1:= { 1, 2, 3 };
const sofT c2:= { 4, 5, 6 };


function myFunct(){
	var template sofT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (enumerated in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT{ ONE(1), TWO(2), THREE(3)};

const enumT c1:= ONE;
const enumT c2:= THREE;

template enumT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (enumerated in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (enumerated in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT{ ONE(1), TWO(2), THREE(3)};

const enumT c1:= ONE;
const enumT c2:= THREE;

control{
	var template enumT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT{ ONE(1), TWO(2), THREE(3)};

const enumT c1:= ONE;
const enumT c2:= THREE;

function myFunct(){
	var template enumT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (union in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (union in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f1:= 5 };

template uniT r:= (c1 .. c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (union in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (union in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f1:= 5 };

control{
	var template uniT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f1:= 5 };

function myFunct(){
	var template uniT r:= (c1 .. c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (array in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (array in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

template myint r :=(c1..c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

control{
  template myint r :=(c1..c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template range (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template range (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

function myFunct(){
  template myint r :=(c1..c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (boolean in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (boolean in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

template boolean r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (boolean in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (boolean in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

control{
	var template boolean r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

function myFunct(){
	var template boolean r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (integer in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

template integer r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

control{
	var template integer r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

function myFunct(){
	var template integer r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (float in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (float in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.6;
const float c2:= 2.4;
const float c3:= 3.9;

template float r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (float in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (float in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.1;
const float c2:= 2.3;
const float c3:= 3.1;

control{
	var template float r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.1;
const float c2:= 2.9;
const float c3:= 3.2;

function myFunct(){
	var template float r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (bitstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

template bitstring r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (bitstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (bitstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

control{
	var template bitstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

function myFunct(){
	var template bitstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (octetstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (octetstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

template octetstring r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (octetstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (octetstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

control{
	var template octetstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

function myFunct(){
	var template octetstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (hexstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (hexstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

template hexstring r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (hexstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (hexstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

control{
	var template hexstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

function myFunct(){
	var template hexstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

template charstring r:= superset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (charstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (charstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

control{
	var template charstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

function myFunct(){
	var template charstring r:= superset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

template recT r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

control{
	var template recT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct(){
	var template recT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record of in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

template rofT r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record of in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

control{
	var template rofT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

function myFunct(){
	var template rofT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (set in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (set in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

template setT r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (set in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (set in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

control{
	var template setT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct(){
	var template setT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (enumerated in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

template enumT r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (enumerated in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (enumerated in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

control{
	var template enumT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

function myFunct(){
	var template enumT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (union in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (union in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

template uniT r:= superset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (union in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (union in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

control{
	var template uniT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

function myFunct(){
	var template uniT r:= superset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (array in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (array in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

  template myint r := superset(c1,c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

control{
  template myint r := superset(c1,c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template superset (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template superset (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

function myFunct(){
  template myint r := superset(c1,c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (boolean in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (boolean in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

template boolean r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (boolean in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (boolean in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

control{
	var template boolean r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

function myFunct(){
	var template boolean r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (integer in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

template integer r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

control{
	var template integer r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 2;
const integer c3:= 3;

function myFunct(){
	var template integer r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (float in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (float in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.6;
const float c2:= 2.4;
const float c3:= 3.9;

template float r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (float in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (float in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.1;
const float c2:= 2.3;
const float c3:= 3.1;

control{
	var template float r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.1;
const float c2:= 2.9;
const float c3:= 3.2;

function myFunct(){
	var template float r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (bitstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

template bitstring r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (bitstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (bitstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

control{
	var template bitstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '101'B;
const bitstring c2:= '110'B;
const bitstring c3:= '111'B;

function myFunct(){
	var template bitstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (octetstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (octetstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

template octetstring r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (octetstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (octetstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

control{
	var template octetstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '1011'O;
const octetstring c2:= '1110'O;
const octetstring c3:= '1111'O;

function myFunct(){
	var template octetstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (hexstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (hexstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

template hexstring r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (hexstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (hexstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

control{
	var template hexstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '1011'H;
const hexstring c2:= '1110'H;
const hexstring c3:= '1111'H;

function myFunct(){
	var template hexstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (charstring in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

template charstring r:= subset (c1, c2, c3);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (charstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (charstring in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

control{
	var template charstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "ogin";
const charstring c2:= "dwa";
const charstring c3:= "try";

function myFunct(){
	var template charstring r:= subset (c1, c2, c3);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

template recT r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

control{
	var template recT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct(){
	var template recT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record of in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

template rofT r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record of in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

control{
	var template rofT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

function myFunct(){
	var template rofT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (set in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (set in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

template setT r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (set in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (set in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

control{
	var template setT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct(){
	var template setT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (enumerated in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

template enumT r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (enumerated in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (enumerated in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

control{
	var template enumT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

function myFunct(){
	var template enumT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (union in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (union in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

template uniT r:= subset (c1, c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (union in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (union in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

control{
	var template uniT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f2:= 7.0 };

function myFunct(){
	var template uniT r:= subset (c1, c2);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (array in def. part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (array in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

  template myint r := subset(c1,c2);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

control{
  template myint r := subset(c1,c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template subset (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template subset (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[1];

const myint c1:={1};
const myint c2 :={3};

function myFunct(){
  template myint r := subset(c1,c2);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (boolean in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (boolean in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

template boolean r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (boolean in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (boolean in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template boolean r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template boolean r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (integer in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

template integer r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (integer in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template integer r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template integer r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (float in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (float in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

template float r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (float in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (float in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template float r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template float r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (record in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (record in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

template recT r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (record in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (record in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

control{
	var template recT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

function myFunct(){
	var template recT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (set in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (set in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

template setT r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (set in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (set in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

control{
	var template setT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

function myFunct(){
	var template setT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (enumerated in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

template enumT r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (enumerated in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (enumerated in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

control{
	var template enumT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

function myFunct(){
	var template enumT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (union in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (union in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

template uniT r:= ? length(1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (union in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (union in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

control{
	var template uniT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

function myFunct(){
	var template uniT r:= ? length(1);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (array in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (array in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];
//TR 727
template arrint r:= ? length(10);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?number.+?elements.+?allowed.+?length.+?restriction.+?contradicts.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (array in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

control{
//TR 727
template arrint r:= ? length(10);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?number.+?elements.+?allowed.+?length.+?restriction.+?contradicts.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template length-restriction (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template length-restriction (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

function myFunct(){
//TR 727
template arrint r:= ? length(10);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?number.+?elements.+?allowed.+?length.+?restriction.+?contradicts.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (boolean in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (boolean in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template boolean f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (boolean in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (boolean in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template boolean f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (boolean in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template boolean f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (integer in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (integer in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template integer f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (integer in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (integer in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template integer f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (integer in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template integer f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (float in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (float in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template float f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (float in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (float in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template float f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (float in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template float f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (bitstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (bitstring in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template bitstring f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (bitstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (bitstring in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template bitstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (bitstring in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template bitstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (octetstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (octetstring in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template octetstring f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (octetstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (octetstring in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template octetstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (octetstring in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template octetstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (hexstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (hexstring in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template hexstring f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (hexstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (hexstring in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template hexstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (hexstring in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template hexstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (charstring in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (charstring in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	template charstring f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (charstring in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (charstring in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var template charstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (charstring in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var template charstring f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (record of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (record of in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

	template rofT f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (record of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (record of in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

control{
	var template rofT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (record of in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

function myFunct(){
	var template rofT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (set of in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (set of in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

	template sofT f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (set of in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (set of in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

control{
	var template sofT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (set of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (set of in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

function myFunct(){
	var template sofT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (enumerated in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

	template enumT f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (enumerated in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (enumerated in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

control{
	var template enumT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (enumerated in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

function myFunct(){
	var template enumT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (union in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (union in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

	template uniT f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (union in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (union in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

control{
	var template uniT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (union in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

function myFunct(){
	var template uniT f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (array in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (array in def.part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

template arrint f:= ? ifpresent;

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (array in control part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (array in control part)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

control{
template arrint f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - template ifpresent (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - template ifpresent (array in function)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

function myFunct(){
template arrint f:= ? ifpresent;
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in boolean
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	const boolean c1:= false;
	const boolean c2:= true;

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in bitstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	const bitstring c1:= '000'B;
	const bitstring c2:= '111'B;

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in octetstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	const octetstring c1:= '0000'O;
	const octetstring c2:= '1111'O;

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in hexstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	const hexstring c1:= '0000'H;
	const hexstring c2:= '1111'H;

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in recT
} with {extension "internal"}

type component c {
	port portT myPort;
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

type port portT message {
	in rofT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in setT
} with {extension "internal"}

type component c {
	port portT myPort;
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (set of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (set of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer sofT;

const sofT c1:= { 1, 2, 3 };
const sofT c2:= { 4, 5, 6 };

type port portT message {
	in sofT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

type port portT message {
	in enumT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f1:= 1 };
const uniT c2:= { f1:= 5 };

type port portT message {
	in uniT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template range (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template range (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

const arrint c1:= { 1 };
const arrint c2:= { 5 };

type port portT message {
	in arrint
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {
//TR 728
	alt{
	[] myPort.receive( (c1..c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?range.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

type port portT message {
	in boolean
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 5;

type port portT message {
	in integer
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.0;
const float c2:= 5.0;

type port portT message {
	in float
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '0000'B;
const bitstring c2:= '1111'B;

type port portT message {
	in bitstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '0000'O;
const octetstring c2:= '1111'O;

type port portT message {
	in octetstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '0000'H;
const hexstring c2:= '1111'H;

type port portT message {
	in hexstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "a";
const charstring c2:= "z";

type port portT message {
	in charstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

type port portT message {
	in recT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

type port portT message {
	in rofT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

type port portT message {
	in setT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

type port portT message {
	in enumT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f3:= "a"};
const uniT c2:= { f3:= "z"};

type port portT message {
	in uniT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template superset (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template superset (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

const arrint c1:= { 1 };
const arrint c2:= { 5 };

type port portT message {
	in arrint
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( superset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?superset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const boolean c1:= false;
const boolean c2:= true;

type port portT message {
	in boolean
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const integer c1:= 1;
const integer c2:= 5;

type port portT message {
	in integer
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const float c1:= 1.0;
const float c2:= 5.0;

type port portT message {
	in float
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const bitstring c1:= '0000'B;
const bitstring c2:= '1111'B;

type port portT message {
	in bitstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const octetstring c1:= '0000'O;
const octetstring c2:= '1111'O;

type port portT message {
	in octetstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const hexstring c1:= '0000'H;
const hexstring c2:= '1111'H;

type port portT message {
	in hexstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

const charstring c1:= "a";
const charstring c2:= "z";

type port portT message {
	in charstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

const recT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const recT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

type port portT message {
	in recT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer rofT;

const rofT c1:= { 1, 2, 3 };
const rofT c2:= { 4, 5, 6 };

type port portT message {
	in rofT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

const setT c1:= { f1:= 1, f2:= 2.0, f3:= "a"};
const setT c2:= { f1:= 5, f2:= 7.0, f3:= "z"};

type port portT message {
	in setT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

const enumT c1:= ONE;
const enumT c2:= TWO;

type port portT message {
	in enumT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

const uniT c1:= { f3:= "a"};
const uniT c2:= { f3:= "z"};

type port portT message {
	in uniT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template subset (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template subset (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

const arrint c1:= { 1 };
const arrint c2:= { 5 };

type port portT message {
	in arrint
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( subset(c1,c2) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?subset.+?match.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in boolean
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in integer
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in float
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (record in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (record in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in recT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (set in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (set in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set setT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in setT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

type port portT message {
	in enumT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in uniT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(1) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Length.+?restriction.+?cannot.+?used
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template length-restriction (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template length-restriction (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

const arrint c1:= { 1 };
const arrint c2:= { 5 };

type port portT message {
	in arrint
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? length(10) )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?number.+?elements.+?allowed.+?length.+?restriction.+?contradicts.+?array.+?size
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (boolean in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (boolean in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in boolean
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (integer in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (integer in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in integer
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (float in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (float in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in float
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (bitstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (bitstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in bitstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (octetstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (octetstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in octetstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (hexstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (hexstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in hexstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (charstring in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (charstring in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type port portT message {
	in charstring
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (record of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (record of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record of integer myT;

type port portT message {
	in myT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (set of in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (set of in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type set of integer myT;

type port portT message {
	in myT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (enumerated in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (enumerated in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type enumerated enumT { ONE(1), TWO(2), THREE(3) };

type port portT message {
	in enumT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (union in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (union in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type union uniT{
	integer f1,
	float f2,
	charstring f3
}

type port portT message {
	in uniT
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent )
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Allowed matching mechanisms - inline-template ifpresent (array in function)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Allowed matching mechanisms - inline-template ifpresent (array in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type integer arrint[1];

const arrint c1:= { 1 };
const arrint c2:= { 5 };

type port portT message {
	in arrint
} with {extension "internal"}

type component c {
	port portT myPort;
}

function myFunct() runs on c {

	alt{
	[] myPort.receive( ? ifpresent)
		{}
	}
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Infinite recursive loops
.*---------------------------------------------------------------------*

NOTE: In case of non-constant ele
For example:
template mytype t := { f := t } s
but
var mytype v := { f := v } is not

.*---------------------------------------------------------------------*
:h3.Infinite recursive loops in templates/values
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/21.

Strategy: SA shall detect the infinite recursive loops in templates/values.
Two types of infinite loops are existing:

	x:= x.field;
		and
	x:= { f1:= x... };

All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.1, 2 and 3 steps long circles in definition part
:li D='-'.2, 3 and 4 steps long cross circles in definition part
:li D='-'.3 steps long double cross circles in definition part
:elist.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - one step long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - one step long (in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4
}

template recT temp1:= { f1:= temp1.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - one steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - one steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type integer myint[2];

template myint t := {0,t[1]};


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - two steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - two steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4
}

// TR 696
template recT temp1:= { f1:= temp1.f4, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f1 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - three steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - three steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

// TR 696
template recT temp1:= { f1:= temp1.f4, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f5, f5:= temp1.f1 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - cross two steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - cross two steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

template recT temp1:= { f1:= temp2.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 2 };
template recT temp2:= { f1:= temp1.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 2 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - cross three steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - cross three steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

// TR 696
template recT temp1:= { f1:= temp2.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 2 };
template recT temp2:= { f1:= temp2.f4, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f1, f5:= 2 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - cross four steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - cross four steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

// TR 697
template recT temp1:= { f1:= temp2.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= temp1.f1 };
template recT temp2:= { f1:= temp2.f4, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f5, f5:= 2 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Infinite recursive loops in templates/values - double cross four steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Infinite recursive loops in templates/values - double cross four steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

template recT temp1:= { f1:= temp2.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 7 };
template recT temp2:= { f1:= temp3.f4, f2:= 1.1, f3:= "ERIXON", f4:= 2, f5:= 2 };
template recT temp3:= { f1:= 1, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f1, f5:= 2 };

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Recursive loops in modified template chains
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/22.

Strategy: a modified template shall not refer to itself, either directly or indirectly, that is recursive derivation is not allowed.
All occurances shall be tested, where such a notation can be used.

Tested:	- 1, 2 and 3 steps long modified templates in definition part

.*---------------------------------------------------------------------*
:h4.Recursive loops in modified template chains - one step long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Recursive loops in modified template chains - one step long (in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

template recT temp1:= { f1:= 1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 7 };

template recT temp2 modifies temp1:= { f1:= temp2.f1, f4:= 6};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Recursive loops in modified template chains - two steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Recursive loops in modified template chains - two steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

template recT temp1:= { f1:= 1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 7 };

// TR 696
template recT temp2 modifies temp1:= { f1:= temp2.f4, f4:= temp2.f1};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Recursive loops in modified template chains - three steps long (in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Recursive loops in modified template chains - three steps long (in def.part)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {

type record recT {
	integer f1,
	float f2,
	charstring f3,
	integer f4,
	integer f5
}

// TR 696
template recT temp1:= { f1:= 1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= 7 };
template recT temp2 modifies temp1:= { f1:= temp2.f4, f4:= temp2.f5, f5:= temp2.f1};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)error.+?Circular.+?reference
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value Overflows shall be detected if possible in compile time
.*---------------------------------------------------------------------*

This test case group covers the requirement SA-6/23.

Strategy: SA shall detect any value overflow caused by implementation (for example integer value overflow, assigned number of an enumerated
identifier is greater than the MAX_INT)
All occurances shall be tested, where such a notation can be used.

Tested:
:list.
:li D='-'.simple integer constant and float constant overflows in definition part, control part and function
:li D='-'.simple integer variables and float variables overflows in control part and function
:li D='-'.integer overflowing in definition of an enumerated type
:li D='-'.float overflowing when redefines a timer at start (in control part and function)
:elist.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - integer Overflow (enumerated in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - integer Overflow (enumerated in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	type enumerated enumT { ONE(1), TWO(2), HUGE(99999999999999999999999999999)};

}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The numeric value of enumeration `HUGE' \(99999999999999999999999999999\) is too large for being represented in memory
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - simple float Overflow (const in def.part)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - simple float Overflow (const in def.part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

	// TR 673: fatal error on value overflows
	const float f:= 9.1E+999;

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - simple float Overflow (const in control part)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - simple float Overflow (const in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	const float f:= 9.1E+999;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - simple float Overflow (const in function)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - simple float Overflow (const in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	const float f:= 9.1E+999;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - simple float Overflow (variable in control part)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - simple float Overflow (variable in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	var float f:= 9.1E+999;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - simple float Overflow (variable in function)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - simple float Overflow (variable in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	var float f:= 9.1E+999;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - float Overflow (timer start in control part)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - float Overflow (timer start in control part)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

control{
	timer T1:= 500.0;
	T1.start( 9.1E+999);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Value Overflows shall be detected if possible in compile time - float Overflow (timer start in function)
 TR 673: fatal error on value overflows
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Value Overflows shall be detected if possible in compile time - float Overflow (timer start in function)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {

function myFunct(){
	timer T1:= 500.0;
	T1.start( 9.1E+999);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Overflow
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Constant folding - indexed arrays
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Constant folding - indexed arrays>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
control {
  const integer c_array1[4] := { 1,2,3,4};
  const integer c_array2[4] := { 1,2,3,4};
  const integer c_array3[4] := { 4,3,2,1};
  const integer c_array4_ind[4] := { [0] := 1, [1] := 2, [2] := 3, [3] := 4};
  const integer c_array5_ind[4] := { [3] := 4, [1] := 2, [2] := 3, [0] := 1};


  var integer vl_array5[4] := { 1,2,3,4};
  var boolean b := false;

  if(c_array1 == c_array1) {b:= true;}
  else {b := false;}	

  if({1,2,3,4} == c_array1) {b:= true;}
  else {b := false;}
  if(c_array1 == {1,2,3,4}) {b:= true;}
  else {b := false;}

  if(c_array1 == c_array2) {b:= true;}
  else {b := false;} 

  if(c_array4_ind == c_array4_ind) {b:= true;}
  else {b := false;}

  if(c_array1 == c_array4_ind) {b:= true;}
  else {b := false;}
  if(c_array4_ind == c_array1) {b:= true;}
  else {b := false;}

  if({ [0] := 1, [1] := 2, [2] := 3, [3] := 4} == c_array4_ind) {b:= true;}
  else {b := false;}
  if(c_array4_ind == { [0] := 1, [1] := 2, [2] := 3, [3] := 4}) {b:= true;}
  else {b := false;}

  if(c_array4_ind == c_array5_ind) {b:= true;}
  else {b := false;}

  if(vl_array5 == c_array1) {b:= true;}
  else {b := false;}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 10>
(?im)warning: Control never reaches this code because of previous effective condition\(s\)
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Constant folding - indexed record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Constant folding - indexed record of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
  type record of integer recof;
control {

  const recof c_r1 := { 1,2,3,4};
  const recof c_r2 := { 1,2,3,4};
  const recof c_r3 := { 4,3,2,1};
  const recof c_r4_ind := { [0] := 1, [1] := 2, [2] := 3, [3] := 4};
  const recof c_r5_ind := { [3] := 1, [1] := 2, [2] := 3, [0] := 4};
  const recof c_r6_ind := { [3] := 4, [1] := 2, [2] := 3, [0] := 1};
  const recof c_r8_ind := { [0] := 1, [1] := 2, [2] := 3, [3] := 4};


  var recof vl_r7_ind := { [3] := 4, [1] := 2};

  var recof vl_r10 := { 1,2,3,4};
  var recof vl_r11 := { 1,2,3,4};

  var boolean b := false;

  if(c_r1 == c_r1) {b:= true;}
  else {b:= false;}

  if(c_r1 == c_r2) {b:= true;}
  else {b:= false;}

  if(c_r4_ind == c_r4_ind) {b:= true;}
  else {b:= false;}

  if(c_r1 == c_r4_ind) {b:= true;}
  else {b:= false;}
  if(c_r4_ind == c_r1) {b:= true;}
  else {b:= false;}

  if(c_r1 == c_r6_ind) {b:= true;}
  else {b:= false;}

  if(c_r1 != vl_r7_ind) {b:= true;}
  else { b:= false;}

  if(c_r4_ind == c_r8_ind) {b:= true;}
  else {b:= false;}

  if(vl_r10 == vl_r11) {b:= true;}
  else {b:= false;}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 7>
(?im)warning: Control never reaches this code because of previous effective condition\(s\)
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Constant folding - indexed set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Constant folding - indexed set of>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
	type set of integer mysetof;
control {

  const mysetof c_s1 := {1,2,3,4};
  const mysetof c_s2 := {4,3,2,1};
  const mysetof c_s3 := {1,3,2,4};
  const mysetof c_s4 := {1,2,3,4,5};
  const mysetof c_s5 := {0,1,2,3,4};
  const mysetof c_s6 := {0,1,2,3,4,5}

  const mysetof c_s1_ind := {[0] := 1,[1] := 2,[2] := 3, [3] := 4};
  const mysetof c_s2_ind := {[0] := 1,[3] := 4,[2] := 3, [1] := 2};
  const mysetof c_s3_ind := {[0] := 2,[3] := 1,[2] := 3, [1] := 4};

  var mysetof vl_s1 := {1,2,3,4};

  var boolean b := false;

  if(c_s1 == c_s1) {b:= true;}
  else {b:= false;}

  if(c_s1 == {1,2,3,4}) {b:= true;}
  else {b:= false;}
  if({1,2,3,4} == c_s1) {b:= true;}
  else {b:= false;}

  if(c_s1 == {[0] := 1,[1] := 2,[2] := 3, [3] := 4}) {b:= true;}
  else {b:= false;}
  if({[0] := 1,[1] := 2,[2] := 3, [3] := 4} == c_s1) {b:= true;}
  else {b:= false;}

  if(c_s1 == c_s1_ind)  {b:= true;}
  else {b:= false;}
  if(c_s1_ind == c_s1)  {b:= true;}
  else {b:= false;}

  if(c_s1_ind == c_s2_ind)  {b:= true;}
  else {b:= false;}

  if(c_s1_ind == c_s3_ind)  {b:= true;}
  else {b:= false;}

  if(c_s1 == c_s3_ind)  {b:= true;}
  else {b:= false;}

  if(c_s2_ind == c_s3_ind)  {b:= true;}
  else {b:= false;}

  if(c_s1 == vl_s1) {b:= true;}
  else {b:= false;}
  if(vl_s1 == c_s1) {b:= true;}
  else {b:= false;}

  if(c_s1 == c_s2) {b:= true;}
  else {b:= false;}

  if(c_s1 == c_s3) {b:= true;}
  else {b:= false;}

  if(c_s1 != c_s4) {b:= true;}
  else {b:= false;}

  if(c_s1 != c_s5) {b:= true;}
  else {b:= false;}

  if(c_s1 != c_s6) {b:= true;}
  else {b:= false;}

  if(c_s5 != c_s6) {b:= true;}
  else {b:= false;}
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 17>
(?im)warning: Control never reaches this code because of previous effective condition\(s\)
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 1
 TR HN30230: Value of union is set to unbount if other union possibilities are tried to be accessed.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 1>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union UnionType1{
  UnionType2 girl,
  integer    numero
  }
type union UnionType2{
  Emma   emma,
  Eszter eszter
}

type record Emma { charstring name}
type record Eszter { charstring name}

type component dummy_CT {}
testcase tc_UnboundUnion () runs on dummy_CT{
var UnionType1 vl_e := {girl := {emma := {name := "Emma"}}};
log(log2str("numero: ",vl_e.numero));
}

control
{
  execute(tc_UnboundUnion());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field numero in a value of union type @Temp.UnionType1.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 2
 TR HN30230: Value of union is set to unbount if other union possibilities are tried to be accessed.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 2>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union UnionType1{
  UnionType2 girl,
  integer    numero
  }
type union UnionType2{
  Emma   emma,
  Eszter eszter
}

type record Emma { charstring name}
type record Eszter { charstring name}

type component dummy_CT {}
testcase tc_UnboundUnion () runs on dummy_CT{
var UnionType1 vl_e := {girl := {emma := {name := "Emma"}}};
var integer temp  := vl_e.numero;
}

control
{
  execute(tc_UnboundUnion());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field numero in a value of union type @Temp.UnionType1.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 3
 TR HN30230: Value of union is set to unbount if other union possibilities are tried to be accessed.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 3>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union UnionType1{
  UnionType2 girl,
  integer    numero
  }
type union UnionType2{
  Emma   emma,
  Eszter eszter
}

type record Emma { charstring name}
type record Eszter { charstring name}

type component dummy_CT {}
testcase tc_UnboundUnion () runs on dummy_CT{
var UnionType1 vl_e := {girl := {emma := {name := "Emma"}}};
var integer temp;
temp := vl_e.numero;
}

control
{
  execute(tc_UnboundUnion());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field numero in a value of union type @Temp.UnionType1.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 4
 TR HN30230: Value of union is set to unbount if other union possibilities are tried to be accessed.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 4>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union UnionType1{
  UnionType2 girl,
  integer    numero
  }
type union UnionType2{
  Emma   emma,
  Eszter eszter
}

type record Emma { charstring name}
type record Eszter { charstring name}

function dummy(integer par) {
}

type component dummy_CT {}
testcase tc_UnboundUnion () runs on dummy_CT{
var UnionType1 vl_e := {girl := {emma := {name := "Emma"}}};
dummy(vl_e.numero);
}

control
{
  execute(tc_UnboundUnion());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field numero in a value of union type @Temp.UnionType1.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 5
 TR HN30230: Value of union is set to unbount if other union possibilities are tried to be accessed.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Invalid access to not-selected union field shall cause dyanimc testcase error - access to non-actual union element 5>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union UnionType1{
  UnionType2 girl,
  integer    numero
  }
type union UnionType2{
  Emma   emma,
  Eszter eszter
}

type record Emma { charstring name}
type record Eszter { charstring name}

type component dummy_CT {}
testcase tc_UnboundUnion () runs on dummy_CT{
var UnionType1 vl_e := {girl := {emma := {name := "Emma"}}};
    var integer v[5];
    v[vl_e.numero] := 1;
}

control
{
  execute(tc_UnboundUnion());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field numero in a value of union type @Temp.UnionType1.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record recordInner {integer f1, integer f2};
   type record recordOuter {recordInner f1, integer f2};

   function problem() {
     template recordOuter vt_temp := {f2 := 5};
     template integer t_temp := vt_temp.f1.f1;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?unbound.*?field.+?f1
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound component variable (TR no. HO24162, HO23581)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound component variable (TR no. HO24162, HO23581)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer IList;
 
   type component C {
     var integer i;
     var IList ilist;
   }

   function problem() runs on C {
     action(isbound(i), " i: ", i);
   }
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
  import from ModuleA all;

   function problem() runs on C {
     action(isbound(i), " i: ", i);
     action(isbound(ilist[i]), " ilist[i]: ", ilist[i]);
   }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound field (TR no. HN91136)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound field (TR no. HN91136)>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union bubu {
     integer a,
     integer b
   }

   type record of integer intrec;

   control {
     var bubu i := { a:= 2};
     action(isbound(i.b));
     var intrec vl_rec := {};
     action(isbound(vl_rec[2]));
   }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS POSITIVE>
(?im)Test execution summary: 0 test case was executed. Overall verdict: none
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound bitstring bit
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound bitstring bit>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var bitstring bstr;
    log(isvalue(bstr[0]));
  }
   control {
     execute(tc_temp());
   }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?im)Dynamic test case error: Accessing an element of an unbound bitstring value.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound charstring bit
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound charstring bit>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var charstring cstr;
     log(isvalue(cstr[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?im)Dynamic test case error: Accessing an element of an unbound charstring value.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound hexstring octet
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound hexstring octet>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var hexstring hstr;
    log(isvalue(hstr[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?im)Dynamic test case error: Accessing an element of an unbound hexstring value.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound octetstring octet
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound octetstring octet>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var octetstring ostr;
    log(isvalue(ostr[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_FAIL POSITIVE>
(?im)Dynamic test case error: Accessing an element of an unbound octetstring value.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound universal charstring bit
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound universal charstring bit>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var universal charstring cstr;
    log(isvalue(cstr[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing an element of an unbound universal charstring value.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound union field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound union field>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type union tunion {
    integer x1,
    integer x2
  }
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var tunion temp := {x1 := 1};
    log(isvalue(temp.x2));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Using non-selected field x2 in a value of union type @ModuleA.tunion.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound record of element
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound record of element>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type record of integer t_recof;
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var t_recof temp;
    log(isvalue(temp[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound record of element (overflow)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound record of element (overflow)>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type record of integer t_recof;
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var t_recof temp := {[1] := 1};
    log(isvalue(temp[10]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Index overflow in a value of type @PreGenRecordOf.PREGEN_RECORD_OF_INTEGER: The index is 10, but the value has only 2 elements.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound set of element
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound set of element>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type set of integer t_setof;
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var t_setof temp;
    log(isvalue(temp[0]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing an element in an unbound value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Referencing a unbound set of element (overflow)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Referencing a unbound set of element (overflow)>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type set of integer t_setof;
  type component dummy_CT {}
  testcase tc_temp () runs on dummy_CT{
    var t_setof temp := {[1] := 1};
    log(isvalue(temp[10]));
  }
  control {
    execute(tc_temp());
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
ModuleA
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Index overflow in a value of type @PreGenRecordOf.PREGEN_SET_OF_INTEGER: The index is 10, but the value has only 2 elements.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: ispresent() isbound() DTEs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - ispresent() isbound() DTEs>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}

type record of charstring ROC;
type record of integer  ROI;
type record MyRecord1 {
  integer       i optional,
  float         x optional,
  charstring    c
}

type union MyUnion1 {
  ROC roc,
  integer i,
  ROI roi,
  MyRecord1 r
}

const MyUnion1 c_myunion2:= { i:= 5 }

testcase tc_runtimeDivisionByZero_ispresent() runs on MyComp {
  var MyUnion1 vl_u:= c_myunion2;
  if(ispresent(vl_u)) {setverdict(pass)} else {setverdict(fail)} 
  if(ispresent(vl_u.i)){setverdict(pass)}else {setverdict(fail)}
  if(ispresent(vl_u.i/2)){setverdict(pass)}else {setverdict(fail)}
  if(ispresent(vl_u.i*0)){setverdict(pass)}else {setverdict(fail)}
  if(ispresent(vl_u.i/(vl_u.i-5))){setverdict(fail)}else {setverdict(pass)} //DTE - OK
}

testcase tc_runtimeDivisionByZero() runs on MyComp {
  var MyUnion1 vl_u:= c_myunion2;
  if(isbound(vl_u)) {setverdict(pass)} else {setverdict(fail)} 
  if(isbound(vl_u.i)){setverdict(pass)}else {setverdict(fail)}
  if(isbound(vl_u.i/2)){setverdict(pass)}else {setverdict(fail)}
  if(isbound(vl_u.i*0)){setverdict(pass)}else {setverdict(fail)}
  if(isbound(vl_u.i/(vl_u.i-5))){setverdict(fail)}else {setverdict(pass)} //DTE - OK
}

control
{
  execute(tc_runtimeDivisionByZero());
  execute(tc_runtimeDivisionByZero_ispresent()); 
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Dynamic test case error: Integer division by zero.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 22 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.
