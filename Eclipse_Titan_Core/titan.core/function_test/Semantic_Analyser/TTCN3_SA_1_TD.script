.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Baranyi, Botond
.*   Delic, Adam
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.12/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZR Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Unknown Object
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2005-02-01   ETHESI     New document for TITAN R6
PA2   2005-02-19   ETHESI     Updated after review
A     2005-03-18   ETHESI     Approved
B     2005-12-16   EKRISZA    Updates for TITAN R6D
C     2006-07-31   EKRISZA    Updates for TITAN R6E
D     2007-03-06   EJNOSZA    Updates for TITAN R7A (expected error messages)
E     2009-06-11   EKRISZA    Name correction
F     2010-07-02   EKRISZA    corrected version information.
G     2011-05-05  EKRISZA added new tests
H     2011-10-10   EKRISZA    corrected version information.
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-1/x: Unknown Object.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h2.Test scope
.*---------------------------------------------------------------------*
Ref [1]: SA-1/x: Unknown object
:nl.Explanation: all unknown objects shall be detected by SA.
.*---------------------------------------------------------------------*
:h2.Test strategy
.*---------------------------------------------------------------------*
Test cases are based on TTCN-3 BNF according to the followings:
:list.
:li D='1.'.For each 'basic' definition a complete coverage is done (e.g. for
expressions, assignments, etc.). 'Basic' means that the definition is
used in several places.
:li D='2.'.For each definition a complete coverage is done, except for basic
definitions, in which case only 1-2 examples are covered, not the
whole basic definition. This is to avoid testing all possible subcases
for all possible places it may appear.
:nl.NOTE: a complete coverage means that all occurances are tested where
the specific definition may occur. This is however not complete. Only
one occurance is tested for each construct.
:li D='3.'.Test case names are contsructed following the path in the BNF in TTCN-3
and following the possible notations/subtyping in ASN.1.
:elist.
.*---------------------------------------------------------------------*
:h2.Status
.*---------------------------------------------------------------------*
The following structures are not covered:
:list.
:li D='-'.sub-structures that causes parse error due to limited support of that
part of the language (e.g. interleave construct)
:elist.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Unknown objects
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ArrayDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ArrayDef>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: not yet supported
   type record Type_record {
      integer   field1,
      integer   field2[666-Nonexi]
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      Nonexi    field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->LocalDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->LocalDef>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      // NOTE: treated as a local definition
      Nonexi.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->ModuleId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->ModuleId>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      // NOTE: treated as a module reference because of the objid value
      Nonexi.objid {0 4 0}.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?module.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->Definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->Definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      ModuleA.Nonexi  field6
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType->Field reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType->Field reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record1 {
      boolean field1
   }
   type record Type_record2 {
      integer   field1,
      Type_record1.Nonexi  field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type boolean MyType;
   type record Type_record {
      integer   field1,
      // NOTE: modules are identified by name only yet
      ModuleA.objid {0 4 Nonexi}.MyType  field5
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: SubTypeSpec->AllowedValues
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: SubTypeSpec->AllowedValues>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      integer field7 (3,4,Nonexi)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordDef: SubTypeSpec->StringLength
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordDef: SubTypeSpec->StringLength>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record {
      integer   field1,
      // TR 623: length restriction of charstrings
      charstring field8 length(666-Nonexi07)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ArrayDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ArrayDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: not yet supported
   type union Type_union {
      integer   field1,
      integer   field2[666-Nonexi]
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      Nonexi    field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->LocalDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->LocalDef>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      // NOTE: treated as a local definition
      Nonexi.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->ModuleId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->ModuleId>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      // NOTE: treated as a module reference because of the objid value
      Nonexi.objid {0 4 0}.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?module.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->Definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->Definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      ModuleA.Nonexi  field6
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType->Field reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType->Field reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union1 {
      boolean field1
   }
   type union Type_union2 {
      integer   field1,
      Type_union1.Nonexi  field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type verdicttype MyType;
   type union Type_union {
      integer   field1,
      // NOTE: modules are identified by name only yet
      ModuleA.objid {0 4 Nonexi}.MyType  field5
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: SubTypeSpec->AllowedValues
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: SubTypeSpec->AllowedValues>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      integer field7 (3,4,Nonexi)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->UnionDef: SubTypeSpec->StringLength
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->UnionDef: SubTypeSpec->StringLength>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union {
      integer   field1,
      // TR 623: length restriction of charstrings
      charstring field8 length(666-Nonexi07)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ArrayDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ArrayDef>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: not yet supported
   type set Type_set {
      integer   field1,
      integer   field2[666-Nonexi]
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      Nonexi    field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->LocalDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->LocalDef>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      // NOTE: treated as a local definition
      Nonexi.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->ModuleId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->ModuleId>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      // NOTE: treated as a module reference because of the objid value
      Nonexi.objid {0 4 0}.MyType  field4
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?module.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->Definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->Definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      ModuleA.Nonexi  field6
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType->Field reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType->Field reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set1 {
      boolean field1
   }
   type set Type_set2 {
      integer   field1,
      Type_set1.Nonexi  field2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type boolean MyType;
   type set Type_set {
      integer   field1,
      // NOTE: modules are identified by name only yet
      ModuleA.objid {0 4 Nonexi}.MyType  field5
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: SubTypeSpec->AllowedValues
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: SubTypeSpec->AllowedValues>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      integer field7 (3,4,Nonexi)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetDef: SubTypeSpec->StringLength
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetDef: SubTypeSpec->StringLength>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set {
      integer   field1,
      // TR 623: length restriction of charstrings
      charstring field8 length(666-Nonexi07)
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->LocalDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->LocalDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->ModuleId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->ModuleId>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of Nonexi.MyType MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->Definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->Definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of ModuleA.Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: ReferencedType->Field reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: ReferencedType->Field reference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1
   }
   type record of MyType_record.Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type boolean MyType1;
   type record of ModuleA.objid {0 4 Nonexi}.MyType1 MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: AllowedValues
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: AllowedValues>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType6 (666-Nonexi);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: StringLength1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: StringLength1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // StringLength
   type record length(0..666-Nonexi) of integer MyType1;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->RecordOfDef: StringLength2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->RecordOfDef: StringLength2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 623: length restriction of charstrings
   type record of charstring MyType7 length(0..666-Nonexi);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->LocalDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->LocalDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->ModuleId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->ModuleId>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of Nonexi.MyType MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->Definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->Definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of ModuleA.Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: ReferencedType->Field reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: ReferencedType->Field reference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1
   }
   type set of MyType_record.Nonexi MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: ReferencedType->GlobalModuleId->ObjectIdentifierValue>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type float MyType1;
   type set of ModuleA.objid {0 4 Nonexi}.MyType1 MyType2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: AllowedValues
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: AllowedValues>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of integer MyType6 (666-Nonexi);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: StringLength1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: StringLength1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // StringLength
   type record length(0..666-Nonexi) of integer MyType1;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->SetOfDef: StringLength2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->SetOfDef: StringLength2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 623: length restriction of charstrings
   type set of charstring MyType7 length(0..666-Nonexi);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Record->Module definition part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Record->Module definition part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1 optional,
      boolean field2 optional
   }
   const MyType_record MyConst_record := { field1 := false, field2 := true, nonexi := 666 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Record->In component definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Record->In component definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1 optional,
      boolean field2 optional
   }
   type component MyComp {
   var MyType_record MyConst_record := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Record->In statement block
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Record->In statement block>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1 optional,
      boolean field2 optional
   }
   function MyFunc1() {
      var MyType_record MyWar_record := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Record->In control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Record->In control part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType_record {
      boolean field1 optional,
      boolean field2 optional
   }
   control {
      var MyType_record MyWar_record := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Set->Module definition part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Set->Module definition part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set MyType_set {
      boolean field1 optional,
      boolean field2 optional
   }
   const MyType_set MyConst_set := { field1 := false, field2 := true, nonexi := 666 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Set->In component definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Set->In component definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set MyType_set {
      boolean field1 optional,
      boolean field2 optional
   }
   type component MyComp {
   var MyType_set MyConst_set := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Set->In statement block
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Set->In statement block>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set MyType_set {
      boolean field1 optional,
      boolean field2 optional
   }
   function MyFunc1() {
      var MyType_set MyWar_set := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Set->In control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Set->In control part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set MyType_set {
      boolean field1 optional,
      boolean field2 optional
   }
   control {
      var MyType_set MyWar_set := { field1 := false, field2 := true, nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Union->Module definition part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Union->Module definition part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union MyType_union {
      boolean field1,
      boolean field2
   }
   const MyType_union MyConst_union := { nonexi := 666 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Union->In component definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Union->In component definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union MyType_union {
      boolean field1,
      boolean field2
   }
   type component MyComp {
   var MyType_union MyConst_union := { nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Union->In statement block
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Union->In statement block>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union MyType_union {
      boolean field1,
      boolean field2
   }
   function MyFunc1() {
      var MyType_union MyWar_union := { nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Union->In control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Union->In control part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union MyType_union {
      boolean field1,
      boolean field2
   }
   control {
      var MyType_union MyWar_union := { nonexi := 666 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Enumerated->Module definition part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Enumerated->Module definition part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyType_enumerated { Doom(0), Doom2(1) }
   const MyType_enumerated MyConst_enumerated := nonexi;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Enumerated->In component definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Enumerated->In component definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyType_enumerated { Doom(0), Doom2(1) }
   type component MyComp {
   var MyType_enumerated MyConst_enumerated := nonexi;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Enumerated->In statement block
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Enumerated->In statement block>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyType_enumerated { Doom(0), Doom2(1) }
   function MyFunc1() {
      var MyType_enumerated MyConst_enumerated := nonexi;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->Field References: Enumerated->In control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->Field References: Enumerated->In control part>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyType_enumerated { Doom(0), Doom2(1) }
   control {
      var MyType_enumerated MyConst_enumerated := nonexi;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->PortDef: PortDefAttribs->MessageAttribs->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->PortDef: PortDefAttribs->MessageAttribs->Type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 624: reporting errors in typelists
   type port MyPort1 message { inout Nonexi01, Nonexi02 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->PortDef: PortDefAttribs->ProcedureAttribs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->PortDef: PortDefAttribs->ProcedureAttribs>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 624: reporting errors in typelists
   type port MyPort1 procedure { inout Nonexi01, Nonexi02 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->PortDef: PortDefAttribs->MixedAttribs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->PortDef: PortDefAttribs->MixedAttribs>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 621: limitation on mixed ports should be mentioned in user guide
   type port MyPort1 mixed { inout Nonexi01, Nonexi02 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: PortInstance->PortType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: PortInstance->PortType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp1 { port Nonexi MyPort }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: PortInstance->PortType->ArrayDef: 1 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: PortInstance->PortType->ArrayDef: 1 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   // TR 625: consistent checking of array dimensions
   type component MyComp5 { port MyPortType MyPort[200-Nonexi] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: PortInstance->PortType->ArrayDef: 4 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: PortInstance->PortType->ArrayDef: 4 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   // TR 625: consistent checking of array dimensions
   type component MyComp5 { port MyPortType MyPort[11][666][17+666][200-Nonexi] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: VarInstance->VarType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: VarInstance->VarType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp7 { var Nonexi07 MyVar }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: VarInstance->ArrayDef: 1 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: VarInstance->ArrayDef: 1 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp11 { var integer MyVar[200-Nonexi] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: VarInstance->ArrayDef: 4 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: VarInstance->ArrayDef: 4 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp12 { var integer MyVar[11][666][17+666][200-Nonexi12] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: VarInstance->VarInitialValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: VarInstance->VarInitialValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp13 { var integer MyVar := 1+2+3+Nonexi13; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: TimerInstance: 1 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: TimerInstance: 1 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp14 { timer MyTimer[666-Nonexi14] := { 1.0, 2.0, 3.0, 4.0 } }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: TimerInstance: 4 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: TimerInstance: 4 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp14 {
   timer MyTimer[1][1][1][666-Nonexi14] := {{{ { 1.0, 2.0, 3.0, 4.0, -, -, 1.0 } }}}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: ConstDef->TypeDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: ConstDef->TypeDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp17 { const Nonexi17 MyConst := 666; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: ConstDef->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: ConstDef->Value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp17 { const integer MyConst := 666-Nonexi18; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: ConstDef: 1 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: ConstDef: 1 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp18 { const integer MyConst[666-Nonexi19] := {1,2,3,4,666-18}; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: ConstDef: 4 Dimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: ConstDef: 4 Dimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp18 { const integer MyConst[1][1][1][666-Nonexi19] := {{{ {1,2,3,4,666-18} }}}; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: PortArray (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: PortArray (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp20 { port MyPortType MyPort[10][200+3..3+Nonexi23][2..11] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: PortArray (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: PortArray (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp20 { port MyPortType MyPort[10][Nonexi12+3..3+5][2..11] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: TimerArray (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: TimerArray (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp21 { timer MyTimer[0..16][4..8][666..Nonexi24] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: TimerArray (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: TimerArray (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp21 { timer MyTimer[0..16][4..8][Nonexi24..666] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: VarArray (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: VarArray (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp21 { var integer MyVar[0..16][4..8][666..Nonexi24] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: VarArray (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: VarArray (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp21 { var integer MyVar[0..16][4..8][Nonexi24..666] }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: ConstArray (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: ConstArray (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   type component MyComp21 { const integer MyConst[0..Nonexi24][0..0][1] := {{{10}}} }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TypeDef->ComponentDef: Array index ranges: ConstArray (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeDef->ComponentDef: Array index ranges: ConstArray (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp21 { const integer MyConst[Nonexi24..666][0..0][1] := {{{10}}} }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Integer>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type integer Type_integer_subtyped (-9000, 100, Nonexi01);
   type integer Type_integer_root;
   type Type_integer_root Type_integer_subtypedroot (-100, 0, Nonexi02, 9, -89);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Float
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Float>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type float Type_float_subtyped (-9000.0, 100.0, Nonexi01);
   type float Type_float_root;
   type Type_float_root Type_float_subtypedroot (-100.0, 0.0, Nonexi02, 9.0, -89.0 + 11.1);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Boolean
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Boolean>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type boolean Type_boolean_subtyped (false, Nonexi01);
   type boolean Type_boolean_root;
   type Type_boolean_root Type_boolean_subtypedroot (false, Nonexi02, true);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Objid
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Objid>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type objid Type_objid_subtypedroot1 (objid {0 4 0}, Nonexi);
   type objid Type_objid_subtypedroot2 (objid {0 4 0}, objid {Nonexi 4 0});
   type objid Type_objid_root;
   type Type_objid_root Type_objid_subtypedroot3 (objid {0 4 0}, Nonexi);
   type Type_objid_root Type_objid_subtypedroot4 (objid {0 4 0}, objid {Nonexi 4 0});
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Verdicttype
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Verdicttype>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type verdicttype Type_verdicttype_subtyped (error, Nonexi11, fail);
   type verdicttype Type_verdicttype_root;
   type Type_verdicttype_root Type_verdicttype_subtypedroot (error, Nonexi10, fail);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Bitstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type bitstring Type_bitstring_subtyped ('0011'B & '1100'B, '1'B & Nonexi13, '1111'B);
   type bitstring Type_bitstring_root;
   type Type_bitstring_root Type_bitstring_subtypedroot ('0011'B & '1100'B, '1'B & Nonexi13, '1111'B);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Hexstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 655: strange parse error message
   // type hexstring Type_hexstring_subtyped (''ABDC'H, Nonexi14 & 'A0'H, '0AAA'H);
   type hexstring Type_hexstring_subtyped ('ABDC'H, Nonexi14 & 'A0'H, '0AAA'H);
   type hexstring Type_hexstring_root;
   type Type_hexstring_root Type_hexstring_subtypedroot ('ABDC'H, '00'H & Nonexi14, '0AAA'H);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Octetstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type octetstring Type_octetstring_subtyped ('0011'O, Nonexi17, '1111'O);
   type octetstring Type_octetstring_root;
   type Type_octetstring_root Type_octetstring_subtypedroot ('0011'O, Nonexi16, '1111'O);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type charstring Type_charstring_subtyped ("0011", Nonexi19, "Halflife2");
   type charstring Type_charstring_root;
   type Type_charstring_root Type_charstring_subtypedroot ("0011", Nonexi18, "Halflife2");
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Universal charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Universal charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type universal charstring
        Type_universal_charstring_subtyped ("0011", Nonexi21, "Halflife2");
   type universal charstring Type_universal_charstring_root;
   // TR 605: subtyping not supported for types and it stops code generation
   type Type_universal_charstring_root
        Type_universal_charstring_subtypedroot ("0011", Nonexi20, "Halflife2");
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Record
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Record>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record Type_record_root {
      integer field1 optional
   };
   type Type_record_root Type_record_subtypedroot ( { field1 := 10 }, { field1 := Nonexi22 } );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Record of
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Record of>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Type_recordof_root;
   type Type_recordof_root Type_recordof_subtypedroot ( { 1,2,3}, Nonexi23, {3,4,Nonexi24} );
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Set
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Set>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set Type_set_root {
      integer field1 optional
   };
   type Type_set_root Type_set_subtypedroot ( { field1 := 10 }, { field1 := Nonexi22 } );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Set of
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Set of>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of integer Type_setof_root;
   type Type_setof_root Type_setof_subtypedroot ( { 1,2,3}, Nonexi23, {3,4,Nonexi24} );
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Enumerated>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated Type_enumerated_root { Doom1, Doom2, Doom3 };
   type Type_enumerated_root Type_enumerated_subtypedroot ( Doom3, Nonexi28 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Union
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Union>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Type_union_root {
      integer field1,
      integer field2
   };
   type Type_union_root Type_union_subtypedroot ( { field1 := 10 }, Nonexi29 );

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, list of values: Anytype
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, list of values: Anytype>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type anytype MyType ( 10, 11.0, true, false );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, range: Integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, range: Integer>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type integer Type_integer_subtyped2 (-1976, 10 .. Nonexi02);
   type integer Type_integer_root;
   type Type_integer_root Type_integer_subtypedroot (-1976 .. Nonexi03);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, range: Float
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, range: Float>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type float Type_float_subtyped2 (-1976.0, 10.0..Nonexi05);
   type float Type_float_root;
   type Type_float_root Type_float_subtypedroot (-1976.0 .. Nonexi06);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, range: Charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, range: Charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type charstring Type_charstring_root;
   type Type_charstring_root Type_charstring_subtypedroot (Nonexi07.."c");
   type charstring Type_charstring_subtyped (Nonexi08.."c");
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, range: Universal charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, range: Universal charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type universal charstring Type_universal_charstring_root;
   type Type_universal_charstring_root
        Type_universal_charstring_subtypedroot ("a"..Nonexi09);
   type universal charstring
        Type_universal_charstring_subtyped ("a"..Nonexi10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Bitstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type bitstring Type_bitstring_root;
   type Type_bitstring_root Type_bitstring_subtypedroot length(1..Nonexi01);
   type bitstring Type_bitstring_subtyped length(Nonexi02..10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Hexstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type hexstring Type_hexstring_root;
   type Type_hexstring_root Type_hexstring_subtypedroot length(1..Nonexi03);
   type hexstring Type_hexstring_subtyped length(Nonexi04..10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Octetstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type octetstring Type_octetstring_root;
   type Type_octetstring_root Type_octetstring_subtypedroot length(1..Nonexi05);
   type octetstring Type_octetstring_subtyped length(Nonexi06..10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type charstring Type_charstring_root;
   type Type_charstring_root Type_charstring_subtypedroot length(1..Nonexi07);
   type charstring Type_charstring_subtyped length(Nonexi08..10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Universal charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Universal charstring>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type universal charstring Type_universal_charstring_root;
   type Type_universal_charstring_root
        Type_universal_charstring_subtypedroot length(1..Nonexi09);
   type universal charstring
        Type_universal_charstring_subtyped length(Nonexi10..10);
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Record of
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Record of>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Type_recordof_root;
   type Type_recordof_root Type_recordof_subtypedroot length(1..Nonexi11);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Subtypes, length: Set of
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Subtypes, length: Set of>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of integer Type_setof_root;
   type Type_setof_root Type_setof_subtypedroot length(1..Nonexi12);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->VarIdentifier: StatementBlock
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->VarIdentifier: StatementBlock>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc() { Nonexi01 := 10; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->BasicStatements
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->BasicStatements>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      Nonexi02 := 10;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->StatementBlock
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->StatementBlock>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // TR 670: memory leak when using non existent symbol in do-while loop
      do { Nonexi03 := 10; } while (false);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->Initial
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->Initial>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer i;
      for (Nonexi04:=0; i<10; i:=i+1) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->Step
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->VarIdentifier: ControlStatement->Step>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      for (var integer i:=0; i<10; Nonexi05:=i+1) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference->Field: StatementBlock
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference->Field: StatementBlock>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   // StatementBlock
   function MyFunc() {
      var MyType MyVar;
      MyVar.Nonexi01 := 10;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference->Array: StatementBlock
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference->Array: StatementBlock>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   // StatementBlock
   function MyFunc() {
      var MyType MyVar;
      MyVar.field2[666-Nonexi02] := 10;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference: ControlStatement->BasicStatements
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference: ControlStatement->BasicStatements>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   control {
      var MyType MyVar;
      // BasicStatements
      MyVar.Nonexi03 := 10;
      MyVar.field2[Nonexi04] := 10;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Inner statementBlock->BasicStatements
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Inner statementBlock->BasicStatements>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   control {
      var MyType MyVar;
      do {
         MyVar.Nonexi05 := 10;
         MyVar.field2[Nonexi06] := 10;
      } while (false);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT><RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Initial
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Initial>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }

   control {
      var integer i;
      var MyType MyVar;
      for (MyVar.Nonexi07:=0; i<10; i:=i+1) {}
      for (MyVar.field2[Nonexi08]:=0; i<10; i:=i+1) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT><RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Step
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->VariableRef->ExtendedFieldReference: Step>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   control {
      var MyType MyVar;
      for (var integer i:=0; i<10; MyVar.Nonexi09:=i+1) {}
      for (var integer i:=0; i<10; MyVar.field2[Nonexi10]:=i+1) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: ReferencedValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: ReferencedValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVarInteger;
      MyVarInteger := 10 + Nonexi01 - 170;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: ValueReference->ExtendedFieldReference->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: ValueReference->ExtendedFieldReference->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set MyType {
      integer field1
   }
   control {
      var MyType MyCompoundVar;
      var integer MyIntegerVar;
      // TR 666: Duplicated error message for a non existent field reference
      MyIntegerVar := 10 + MyCompoundVar.Nonexi04;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->CreateOp->ComponentTypeIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->CreateOp->ComponentTypeIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout boolean;
   }
   type component MyComp {port MyPortType MyPort}
   function F() runs on MyComp {
      var MyComp MyCompVar;
      MyCompVar := Nonexi.create;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout boolean;
   }
   type component MyComp {port MyPortType MyPort}
   function F() runs on MyComp {
      var boolean MyVarBoolean;
      MyVarBoolean := false or Nonexi09.running;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->ExtendedFieldReference->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->ExtendedFieldReference->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {timer MyTimer[6]}
   function F() runs on MyComp {
      var boolean MyVarBoolean;
      MyVarBoolean := true and MyTimer[Nonexi10 + 7].running;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: OpCall->ConfigurationOps->RunningOp->ComponentIdentifier->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function F() runs on MyComp {
      var boolean MyVarBoolean;
      MyVarBoolean := Nonexi11().running;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TimerOps->ReadTimerOp->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TimerOps->ReadTimerOp->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var float MyVarFloat;
      MyVarFloat := Nonexi14.read;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TimerOps->ReadTimerOp->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TimerOps->ReadTimerOp->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var float MyVarFloat;
      timer MyTimer[6..8];
      MyVarFloat := MyTimer[Nonexi15].read;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TimerOps->RunningTimerOp->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TimerOps->RunningTimerOp->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var boolean MyVarBoolean;
      MyVarBoolean := true and Nonexi16.running;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TimerOps->RunningTimerOp->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TimerOps->RunningTimerOp->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var boolean MyVarBoolean;
      timer MyTimer[5..9999];
      MyVarBoolean := MyTimer[Nonexi17].running or MyTimer[7].running;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TestcaseInstance->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TestcaseInstance->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var verdicttype MyVarVerdict;
      MyVarVerdict := execute(Nonexi18(1),1.2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: TestcaseInstance->TimerValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: TestcaseInstance->TimerValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   testcase MyTC() runs on MyComp { setverdict(pass); }
   control {
      var verdicttype MyVarVerdict;
      MyVarVerdict := execute(MyTC(),Nonexi * 10.0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: FunctionInstance->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: FunctionInstance->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var boolean MyVarBoolean;
      MyVarBoolean := Nonexi22(false,7,8,8,8,10, 1);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: FunctionInstance->Identifier
.*---------------------------------------------------------------------*
Covered already with 'expression' and 'TemplateInstance'.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->SingleExpression: ActivateOp->AltstepRef->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->SingleExpression: ActivateOp->AltstepRef->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function F() runs on MyComp {
      var default MyVarDefault;
      MyVarDefault := activate(Nonexi25());
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->CompoundExpression: FieldExpressionList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->CompoundExpression: FieldExpressionList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   type record of integer Embedded;
   type record MyType {
      integer field1
   }
   // FieldExpressionList
   // Others are covered by expression
   const MyType MyConstType := {
      field1 := 77 + 1 - 22 / 2 * 23 + Nonexi01
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Assignment->Expression->CompoundExpression: ArrayExpression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Assignment->Expression->CompoundExpression: ArrayExpression>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   control {
      // ArrayExpression
      // Others are covered by expression
      var integer MyVarInteger[2][3] := {{ 1,2, Nonexi01 }, Nonexi02};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Module Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Module Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   const integer c1 := 2 + Nonexi01.Nonexi;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Referenced Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Referenced Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   const integer c1 := 2 + ModuleA.Nonexi02;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->ObjId
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->ObjId>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: SA is not performed for objid values
   const integer c1 := 2 + ModuleA.objid {0 4 Nonexi}.c0;
   const integer c0 := 0;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->NumberForm->ReferencedValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->NumberForm->ReferencedValue>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   const integer c0 := 0;
   const MyType  MyConst2 := { field1 := 4, field2 := { 0,1,2,3,4 } };
   // NOTE: SA is not performed for objid values
   const integer c4 := 2 + ModuleA.objid {0 4 MyConst2.Nonexi04}.c0;
   const integer c5 := 2 + ModuleA.objid {0 4 MyConst2.field2[Nonexi05]}.c0;
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Embedded form
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->Embedded form>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   const integer c0 := 0;
   const MyType  MyConst2 := { field1 := 4, field2 := { 0,1,2,3,4 } };
   // NOTE: SA is not performed for objid values
   const integer c8 := 2 + ModuleA.objid {0 4 ModuleA.objid
                       {0 4 ModuleA.objid {0 4 MyConst2.field2[Nonexi08]}.c0}.c0}.c0;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->GlobalModuleId: GlobalModuleId->NameAndNumberForm
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->GlobalModuleId: GlobalModuleId->NameAndNumberForm>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: SA is not performed for objid values
   const integer c0 := 0;
   const integer c9 := 2 + ModuleA.objid {itu_t(Nonexi09) 4 0}.c0;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->VariableRef: VarIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->VariableRef: VarIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // VarIdentifier
      var integer MyVar;
      MyVar := 2 + Nonexi01;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->VariableRef: ExtendedFieldReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->VariableRef: ExtendedFieldReference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer Embedded;
   type record MyType {
      integer field1,
      Embedded field2
   }
   control {
      var MyType MyVar;
      MyVar.field1 := 2 + MyVar.Nonexi02;
      MyVar.field2[0] := 2 + MyVar.field2[2 + Nonexi03];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->FunctionRef: FunctionIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->FunctionRef: FunctionIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType { float field1 }
   control {
      var MyType MyVar;
      MyVar.field1 := 2.0 + Nonexi01();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Expression->AltstepRef: AltstepIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Expression->AltstepRef: AltstepIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      alt {
         [] Nonexi01() {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleParDef: Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleParDef: Type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   modulepar {
      // Type
      Nonexi01  MyPar1;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleParDef: ConstantExpression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleParDef: ConstantExpression>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   modulepar {
      integer   MyPar5 := 0 + Nonexi05
      // Others are covered in 'expression'
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ConstDef: Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConstDef: Type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // basic type
   const Nonexi01 MyConst1 := 10;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ConstDef: ExtendedFieldReference->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConstDef: ExtendedFieldReference->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 608: More than one error message is shown for a situation
   const integer  MyConst[666-Nonexi05] := { 10 };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ConstDef: Expression in RVALUE
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConstDef: Expression in RVALUE>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   const integer MyConst6 := 100,
                 MyConst7 := Nonexi06;
   // Others are covered in 'expression'
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: ReferencedType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: ReferencedType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template Nonexi01 MyTemplate1 := 10;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer  MyTemplate5(Nonexi05  InPar1) := 10;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: DerivedDef->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: DerivedDef->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer  MyTemplate6 modifies Nonexi06 := 10;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->Expression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->Expression>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate10 := 55 - Nonexi10;
   // Others are covered in 'expression'
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Complement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Complement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate11 := complement (10, Nonexi11);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ValueOrAttribList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ValueOrAttribList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate12 := (10, Nonexi12);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate13 := (10 .. Nonexi13);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SubsetMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SubsetMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of integer MyType;
   template MyType MyTemplate14 := subset (10, Nonexi14);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SupersetMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SupersetMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type set of integer MyType;
   template MyType MyTemplate15 := superset (10, Nonexi15);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->PermutationMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->PermutationMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType2;
   // TR 609: fatal error if permutation is used for integer template
   // template integer MyTemplate16 := permutation (10, Nonexi16);
   template MyType2 MyTemplate16 := { permutation (1,2,3,Nonexi16)};
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template charstring MyTemplate17 := * length (5+Nonexi17);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template charstring MyTemplate17 := * length (2..5+Nonexi17);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate19 := Nonexi19(100);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier->ParValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier->ParValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplateInteger(integer InPar) := InPar;
   template integer MyTemplate22 := MyTemplateInteger(Nonexi22);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->FieldSpecList->FieldReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->FieldSpecList->FieldReference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyTypeRecord { integer field1 };
   template MyTypeRecord MyTemplate23 := { field1 := 10, Nonexi23 := 10 };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?non.+?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->FieldSpecList->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->FieldSpecList->Value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyTypeRecord { integer field1 };
   template MyTypeRecord MyTemplate24 := { field1 := float2int(4.3) + Nonexi24 };
   // others are covered in 'templatebody'
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->ArrayValueOrAttrib
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->ArrayValueOrAttrib>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // NOTE: array types are not yet supported
   type record MyTypeRecord { integer field1[3] };
   template MyTypeRecord.field1 MyTemplate25 := {10, 10, Nonexi};
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateDef: TemplateBody->Nonexistent parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateDef: TemplateBody->Nonexistent parameter>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig1(integer par1, boolean par2);
   template MySig1 MyTemplate26 := { par1 := 666, par2 := false, nonexi := 44.3 }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?to.+?non.*?existent.+?parameter.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: ReferencedType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: ReferencedType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template Nonexi01 MyTemplate1 := 10;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->Expression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->Expression>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template integer MyTemplate10 := 333 - (Nonexi05);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Complement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Complement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template integer MyTemplate11 := complement (10, Nonexi06);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ValueOrAttribList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ValueOrAttribList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template integer MyTemplate12 := (10, Nonexi07);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template integer MyTemplate13 := (10 .. 33+Nonexi08);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SubsetMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SubsetMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type set of integer MyType;
   type component MyComp {
      var template MyType MyTemplate14 := subset (10, 22+Nonexi09);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SupersetMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->SupersetMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type set of integer MyType;
   type component MyComp {
      var template MyType MyTemplate15 := superset (10, Nonexi10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->PermutationMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->PermutationMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type record of integer MyType2;
   type component MyComp {
      var template MyType2 MyTemplate16 := { permutation (1,2,3,Nonexi11)};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template charstring MyTemplate17 := * length (22+Nonexi12);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch->Range
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->SingleValueOrAttrib->ExtraMatchingAttributes->LengthMatch->Range>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template charstring MyTemplate18 := * length (11.. Nonexi13);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->SimpleSpec->TemplateRefWithParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type component MyComp {
      var template integer MyTemplate19 := Nonexi14 + 100*2;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->FieldSpecList->FieldReference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->FieldSpecList->FieldReference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type record MyTypeRecord { integer field1 };
   type component MyComp {
      var template MyTypeRecord MyTemplate23 := { field1 := 10, Nonexi17 := 10 };
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?non.+?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->FieldSpecList->Value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->FieldSpecList->Value>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   type record MyTypeRecord { integer field1 };
   type component MyComp {
      var template MyTypeRecord MyTemplate24 := { field1 := Nonexi18 };
      // others are covered in 'templatebody'
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->ArrayValueOrAttrib
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->ArrayValueOrAttrib>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   // NOTE: array types are not yet supported
   type record MyTypeRecord { integer field1[2..4] };
   type component MyComp {
      var template MyTypeRecord.field1 MyTemplate25 := { 7, Nonexi19, 100 };
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?not.+?supported
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::DynamicTemplateDef: TemplateBody->Nonexistent parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::DynamicTemplateDef: TemplateBody->Nonexistent parameter>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// NOTE: dynamic templates are extensions to the standard
module ModuleA {
   signature MySig1(integer par1, boolean par2);
   type component MyComp {
      var template MySig1 MyTemplate26 := { par1 := 666, par2 := false, nonexi := 44.3 }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?to.+?non.*?existent.+?parameter.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionDef: FunctionFormalParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionDef: FunctionFormalParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1(Nonexi01 InPar) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionDef: FunctionFormalParList->FormalTemplatePar
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionDef: FunctionFormalParList->FormalTemplatePar>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc6(template Nonexi06 InPar) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionDef: RunsOnSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionDef: RunsOnSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc10() runs on Nonexi10 {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionDef: ReturnType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionDef: ReturnType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc14() return Nonexi14 {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::SignatureDef: SignatureFormalParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SignatureDef: SignatureFormalParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySignature1(Nonexi01 InPar);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::SignatureDef: ReturnType
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SignatureDef: ReturnType>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySignature5() return Nonexi05;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::SignatureDef: ExceptionList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SignatureDef: ExceptionList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySignature9() exception (Nonexi09);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TestcaseDef: TestcaseFormalParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TestcaseDef: TestcaseFormalParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   type port MyPortType message { inout MyType; }
   type component MyCompType { port MyPortType MyPort }
   testcase MyTC1(Nonexi01 InPar) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TestcaseDef: TestcaseFormalParList->FormalTemplatePar
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TestcaseDef: TestcaseFormalParList->FormalTemplatePar>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   type port MyPortType message { inout MyType; }
   type component MyCompType { port MyPortType MyPort }
   testcase MyTC5(template Nonexi05 InPar) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TestcaseDef: RunsOnSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TestcaseDef: RunsOnSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   type port MyPortType message { inout MyType; }
   type component MyCompType { port MyPortType MyPort }
   testcase MyTC9() runs on Nonexi9 {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TestcaseDef: SystemSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TestcaseDef: SystemSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   type port MyPortType message { inout MyType; }
   type component MyCompType { port MyPortType MyPort }
   testcase MyTC13() runs on MyCompType system Nonexi13 {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: AltstepFormalParList->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: AltstepFormalParList->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   // others should be covered in 'FormalParList'
   altstep MyAltstep1(Nonexi01 InPar) runs on MyCompType {[] MyPort.receive{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: RunsOnSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: RunsOnSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep02() runs on Nonexi02 {[] any port.receive{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: GuardStatement->AltGuardChar->BooleanExpression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: GuardStatement->AltGuardChar->BooleanExpression>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep03() runs on MyCompType {[false or Nonexi03] MyPort.receive{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: GuardStatement->AltstepInstance->AltstepRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: GuardStatement->AltstepInstance->AltstepRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep04() runs on MyCompType {[] Nonexi()}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: GuardStatement->AltstepInstance->FunctionActualParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: GuardStatement->AltstepInstance->FunctionActualParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep1(integer InPar) runs on MyCompType {[] MyPort.receive{}}
   altstep MyAltstep05() runs on MyCompType {[] MyAltstep1(2 + Nonexi05)}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: GuardStatement->AltstepInstance->GuardOp->TimeoutStatement->TimerRef->TimerIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: GuardStatement->AltstepInstance->GuardOp->TimeoutStatement->TimerRef->TimerIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep06() runs on MyCompType {[] Nonexi06.timeout{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef: GuardStatement->AltstepInstance->GuardOp->TimeoutStatement->TimerRef->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef: GuardStatement->AltstepInstance->GuardOp->TimeoutStatement->TimerRef->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep07() runs on MyCompType {
      timer TimerPar[10];
      [] TimerPar[Nonexi07 + 2].timeout{}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->Port->PortIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->Port->PortIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout float; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep08() runs on MyCompType {[] Nonexi08.receive{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->Port->PortIdentifier->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->Port->PortIdentifier->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout float; }
   type component MyCompType {
      port MyPortType MyPortArray[10];
   }
   altstep MyAltstep09() runs on MyCompType {[] MyPortArray[Nonexi09 + 2].receive{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->ReceiveParameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->ReceiveParameter>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout float; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep10() runs on MyCompType {[] MyPort.receive(Nonexi10 + 2) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->FromClause->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->FromClause->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType1 {
      integer field1
   }
   type port MyPortType message { inout MyType1; }
   type component MyCompType {
      port MyPortType MyPort;
      var MyType1 MyVar1;
   }
   altstep MyAltstep11() runs on MyCompType {[] MyPort.receive from MyVar1.Nonexi11 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi11
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep12() runs on MyCompType {[] MyPort.receive from Nonexi12() {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->PortRedirect->ValueSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->PortRedirect->ValueSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep13() runs on MyCompType {[] MyPort.receive(?) -> value Nonexi13 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->PortRedirect->SenderSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->ReceiveOp: GuardStatement->AltstepInstance->GuardOp->ReceiveStatement->PortReceiveOp->PortRedirect->SenderSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep15() runs on MyCompType {[] MyPort.receive(?) -> sender Nonexi15 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->Port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->Port>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout verdicttype; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep16() runs on MyCompType {[] Nonexi16.trigger {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout float, verdicttype; }
   type component MyCompType {
      port MyPortType MyPortArray[(10-7)*7];
   }
   altstep MyAltstep17() runs on MyCompType {[] MyPortArray[Nonexi17].trigger {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortTriggerOp
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortTriggerOp>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer; in boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   // others should be covered in 'TemplateInstance'
   altstep MyAltstep18() runs on MyCompType {[] MyPort.trigger(Nonexi18 + 2) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->FromClause->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->FromClause->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout MyType1; }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType MyPort;
      var MyType1 MyVar1;
   }
   // GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->FromClause->VariableRef
   // others should be covered in 'VariableRef'
   altstep MyAltstep19() runs on MyCompType {[] MyPort.trigger from MyVar1.Nonexi19 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi19
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   type port MyPortType message { in charstring; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   // others should be covered in 'FunctionRef'
   altstep MyAltstep20() runs on MyCompType {[] MyPort.trigger from ModuleA.objid {0 4 0}.Nonexi20() {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->PortRedirect->ValueSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->PortRedirect->ValueSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout MyType1; }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType MyPort;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep21() runs on MyCompType {[] MyPort.trigger(?) -> value MyVar1.Nonexi21 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi21
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->PortRedirect->SenderSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->TriggerOp: GuardStatement->AltstepInstance->GuardOp->TriggerStatement->PortReceiveOp->PortRedirect->SenderSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout MyType1; }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType MyPort;
      var MyType1 MyVar1;
      var MyCompType MyVar2;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep22() runs on MyCompType {[] MyPort.trigger(?) -> value MyVar1 sender Nonexi22 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi22
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc1();
   type port MyPortType2 procedure { in MyProc1 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port
   altstep MyAltstep24() runs on MyCompType {[] Nonexi24.getcall {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc1();
   type port MyPortType2 procedure { in MyProc1 }
   type component MyCompType {
      port MyPortType2 MyPortArray2[10];
   }
   // GuardStatement->AltstepInstance->GuardOp->GetCallStatement->Port->ArrayOrBitRef
   altstep MyAltstep25() runs on MyCompType {[] MyPortArray2[Nonexi25].getcall {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortTriggerOp
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortTriggerOp>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType1 {
      integer field1
   }
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { in MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'TemplateInstance'
   // TR 612: getcall parameter not supported, parse error
   altstep MyAltstep26() runs on MyCompType {[] MyPort2.getcall(MyProc2:{Nonexi26}) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)parse.+?error
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->FromClause->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->FromClause->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   signature MyProc1();
   type port MyPortType2 procedure { in MyProc1 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep27() runs on MyCompType {[] MyPort2.getcall from MyVar1.Nonexi27 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi27
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->FromClause->FunctionInstance->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   signature MyProc1();
   type port MyPortType2 procedure { in MyProc1 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'FunctionRef'
   altstep MyAltstep28() runs on MyCompType {[] MyPort2.getcall from ModuleA.objid {0 4 0}.Nonexi28() {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ValueSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ValueSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   signature MyProc1();
   type port MyPortType2 procedure { in MyProc1 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   // TR 611: Memory leak in compiler
   // NOTE: fault in TTCN-3 BNF (mockup v1): value redirect shall not be allowed for getcall
   altstep MyAltstep29() runs on MyCompType {[] MyPort2.getcall(?) -> value MyVar1.Nonexi29 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)syntax.+?\berror\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableAssignment1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableAssignment1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { in MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   // TR 610: VariableAssignment is not supported in ParaSpec
   altstep MyAltstep30() runs on MyCompType {[] MyPort2.getcall(MyProc2:{?}) -> param (MyVar1.Nonexi30 := MyParam1) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi30
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableAssignment2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableAssignment2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { in MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // TR 610: VariableAssignment is not supported in ParaSpec
   altstep MyAltstep31() runs on MyCompType {[] MyPort2.getcall(MyProc2:{?}) -> param (MyVar1 := Nonexi31) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?signature.+?not.+?have.+?parameter.+?Nonexi31
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirectWithParam->ParaSpec->VariableList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType1 {
      integer field1
   }
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { in MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'VariableRef'
   // TR 612: getcall parameter not supported, parse error
   altstep MyAltstep32() runs on MyCompType {[] MyPort2.getcall(MyProc2:{?}) -> param (Nonexi32) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirect->SenderSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetcallOp: GuardStatement->AltstepInstance->GuardOp->GetCallStatement->PortReceiveOp->PortRedirect->SenderSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record of integer MyType;
   signature MyProc1();
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType message { inout MyType; inout MyType1; }
   type port MyPortType2 procedure { in MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   // TR 612: getcall parameter not supported, parse error
   altstep MyAltstep33() runs on MyCompType {[] MyPort2.getcall(MyProc2:{?}) -> sender MyVar1.Nonexi33 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi33
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->Port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->Port>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { in MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort;
   }
   altstep MyAltstep34() runs on MyCompType {[] Nonexi34.catch {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPortArray2[10];
   }
   altstep MyAltstep35() runs on MyCompType {[] MyPortArray2[Nonexi35 + 2].catch {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'TemplateInstance'
   altstep MyAltstep36() runs on MyCompType {[] MyPort2.catch(MyProc2, Nonexi36 + 2) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->SignatureIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->SignatureIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'GlobalModuleId'
   // TR 671: segfault and fatal error when using nonexistent signature symbol in catch operation
   altstep MyAltstep37() runs on MyCompType {[] MyPort2.catch(ModuleA.objid {0 4 0}.Nonexi37, 1.0) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->FromClause->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->FromClause->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep38() runs on MyCompType {[] MyPort2.catch from MyVar1.Nonexi38 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non.*?existent.+?field.+?Nonexi38
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->FromClause->FunctionInstance->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->FromClause->FunctionInstance->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // others should be covered in 'FunctionRef'
   altstep MyAltstep39() runs on MyCompType {[] MyPort2.catch from ModuleA.objid {0 4 0}.Nonexi39() {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->PortRedirect->ValueSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->PortRedirect->ValueSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep40() runs on MyCompType {[] MyPort2.catch(MyProc2, float:?) -> value MyVar1.Nonexi40 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi40
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->PortRedirect->SenderSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CatchOp: GuardStatement->AltstepInstance->GuardOp->CatchStatement->PortCatchOp->PortRedirect->SenderSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float, MyType1);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
      var MyCompType MyVar2;
   }
   // others should be covered in 'VariableRef'
   altstep MyAltstep41() runs on MyCompType {[] MyPort2.catch(MyProc2, MyType1: ?) -> value MyVar1 sender Nonexi41 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi41
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->Port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->Port>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc1();
   type port MyPortType2 procedure { inout MyProc1 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep01() runs on MyCompType {[] Nonexi01.getreply {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc1();
   type port MyPortType2 procedure { inout MyProc1 }
   type component MyCompType {
      port MyPortType2 MyPortArray2[10];
   }
   altstep MyAltstep02() runs on MyCompType {[] MyPortArray2[Nonexi02].getreply {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortTriggerOp
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortTriggerOp>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep03() runs on MyCompType {[] MyPort2.getreply(MyProc2:{Nonexi03}) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->ValueClause
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->ValueClause>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) return integer exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep04() runs on MyCompType {[] MyPort2.getreply(MyProc2:{?} value Nonexi04) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->FromClause->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->FromClause->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   altstep MyAltstep05() runs on MyCompType {[] MyPort2.getreply from MyVar1.Nonexi05 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi05
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ValueSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ValueSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) return integer exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   altstep MyAltstep07() runs on MyCompType {[] MyPort2.getreply(MyProc2:{?}) -> value MyVar1.Nonexi07 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?non-existent.+?field.+?Nonexi07
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableAssignment->FieldRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableAssignment->FieldRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(inout MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyCompType MyVar2;
   }
   altstep MyAltstep08() runs on MyCompType {[] MyPort2.getreply(MyProc2:{?}) -> param (MyVar2.Nonexi08 := MyParam1) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Referencing.+?fields.+?component.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableAssignment
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableAssignment>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   altstep MyAltstep09() runs on MyCompType {
        [] MyPort2.getreply(MyProc2:{?})
        -> param (MyVar1 := Nonexi09) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?signature.+?not.+?have.+?parameter.+?Nonexi09
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirectWithParam->ParaSpec->VariableList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(inout MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
      var MyType1 MyVar1;
   }
   altstep MyAltstep10() runs on MyCompType {[] MyPort2.getreply(MyProc2:{?}) -> param (Nonexi10) {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirect->SenderSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->GetreplyOp: GuardStatement->AltstepInstance->GuardOp->GetReplyStatement->PortRedirect->SenderSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type record MyType1 {
      integer field1
   }
   type port MyPortType2 procedure { inout MyProc2 }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep11() runs on MyCompType {[] MyPort2.getreply(MyProc2:{?}) -> sender Nonexi11 {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->DoneOp: GuardStatement->AltstepInstance->GuardOp->DoneStatement->Port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->DoneOp: GuardStatement->AltstepInstance->GuardOp->DoneStatement->Port>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout universal charstring; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep01() runs on MyCompType {[] Nonexi01.done {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->DoneOp: GuardStatement->AltstepInstance->GuardOp->DoneStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->DoneOp: GuardStatement->AltstepInstance->GuardOp->DoneStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyCompType {
      var MyCompType MyCompVar[10000];
   }
   altstep MyAltstep02() runs on MyCompType {[] MyCompVar[44-Nonexi02].done {}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: GuardStatement->AltstepInstance->GuardOp->CheckStatement->Port->PortIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: GuardStatement->AltstepInstance->GuardOp->CheckStatement->Port->PortIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout boolean; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   altstep MyAltstep01() runs on MyCompType {[] Nonexi01.check{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: GuardStatement->AltstepInstance->GuardOp->CheckStatement->Port->PortIdentifier->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: GuardStatement->AltstepInstance->GuardOp->CheckStatement->Port->PortIdentifier->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout bitstring, octetstring, hexstring; }
   type component MyCompType {
      port MyPortType MyPortArray[10];
   }
   altstep MyAltstep02() runs on MyCompType {[] MyPortArray[Nonexi02 + 2].check{}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: Receive
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: Receive>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout float; inout integer; }
   type component MyCompType {
      port MyPortType MyPort;
   }
   // NOTE: just one representative example from each operations
   //       all subcases should already be covered in those operations
   altstep MyAltstep03() runs on MyCompType {
      [] MyPort.check(
         receive(integer:Nonexi01) from Nonexi02()
            -> value Nonexi03
               sender Nonexi04 ) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: Getreply
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: Getreply>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(inout MyType1 MyParam1) return integer exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // NOTE: just one representative example from each operations
   //       all subcases should already be covered in those operations
   altstep MyAltstep04() runs on MyCompType {
      [] MyPort2.check(
         getreply(MyProc2:Nonexi01) from Nonexi02()
               -> value Nonexi03
                  param (Nonexi04)
                  sender Nonexi05) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: Catch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: Catch>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // NOTE: just one representative example from each operations
   //       all subcases should already be covered in those operations
   altstep MyAltstep05() runs on MyCompType {
      [] MyPort2.check(
         catch(MyProc2, integer:Nonexi01) from Nonexi02()
            -> value Nonexi03
               sender Nonexi04 ) {}

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AltstepDef->CheckOp: Getcall
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::AltstepDef->CheckOp: Getcall>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MyProc2(inout MyType1 MyParam1) exception (integer, float);
   type port MyPortType2 procedure { inout MyProc2 }
   type record MyType1 {
      integer field1
   }
   type component MyCompType {
      port MyPortType2 MyPort2;
   }
   // NOTE: just one representative example from each operations
   //       all subcases should already be covered in those operations
   altstep MyAltstep06() runs on MyCompType {
      [] MyPort2.check(
         getcall(MyProc2:Nonexi01) from Nonexi02()
            -> param (Nonexi03)
               sender Nonexi04 ) {}

   }}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->ImportFromSpec->ModuleId->GlobalModuleId->ModuleIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->ImportFromSpec->ModuleId->GlobalModuleId->ModuleIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from Nonexi01 all;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?module.+?identifier.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->ImportFromSpec->ModuleId->GlobalModuleId->ModuleIdentifier->ObjectIdentifierValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->ImportFromSpec->ModuleId->GlobalModuleId->ModuleIdentifier->ObjectIdentifierValue>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // others are covered in 'GlobalModuleId'
   // TR 627: warning message for objid values
   import from ModuleB.objid {0 4 Nonexi02} all;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   type integer ModuleBType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi.+?in.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->LanguageSpec
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->LanguageSpec>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 626: warning message if 'LanguageSpec' is found
   // NOTE: improvement idea, TC should be changed if accepted.
   import from ModuleC language "Nonexi03" all;
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type integer ModuleCType;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->AllWithExcepts
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->AllWithExcepts>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleD all except { type Nonexi04 };
}
<END_MODULE>
<MODULE TTCN ModuleD ModuleD.ttcn>
module ModuleD {
   type integer ModuleDType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi.+?in.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->ImportElement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->ImportElement>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleE { type Nonexi05 };
}
<END_MODULE>
<MODULE TTCN ModuleE ModuleE.ttcn>
module ModuleE {
   type integer ModuleEType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi.+?in.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef->ImportElement->AllWithExcepts
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef->ImportElement->AllWithExcepts>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleF { type all except Nonexi06 };
}
<END_MODULE>
<MODULE TTCN ModuleF ModuleF.ttcn>
module ModuleF {
   type integer ModuleFType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi.+?in.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL NEGATIVE>
(?im)\berror\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ImportDef: nonexistent element in an existing module
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ImportDef: nonexistent element in an existing module>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   const ModuleB.Nonexi07 MyConst := 666;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   type integer ModuleBType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi.+?visible.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ExtFunctionDef->FunctionFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ExtFunctionDef->FunctionFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // others are covered in 'FunctionFormalParList'
   external function MyFunc1 ( Nonexi01 Par1 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ExtFunctionDef->Type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ExtFunctionDef->Type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   // others are covered in 'Type'
   external function MyFunc2 ( ) return ModuleA.objid {0 4 0}.Nonexi02;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ExtConstDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ExtConstDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA.objid {0 4 0} {
   // others are covered in 'Type'
   external const ModuleA.objid {0 4 0}.Nonexi02 MyConst2;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FormalParList: FunctionFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FormalParList: FunctionFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1 (Nonexi01 Par1){};

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FormalParList: TemplateFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FormalParList: TemplateFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate1 (Nonexi05 Par1) := 10;

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FormalParList: SignatureFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FormalParList: SignatureFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySignature1 (Nonexi09 Par1);

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FormalParList: TestcaseFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FormalParList: TestcaseFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   testcase MyTC1 (Nonexi11 Par1) runs on MyComp {};
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FormalParList: AltstepFormalParList
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FormalParList: AltstepFormalParList>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   altstep MyAltstep1 (Nonexi15 Par1) { [] any port.receive {} };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateInstance: InLineTemplate->Type | Signature
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateInstance: InLineTemplate->Type | Signature>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1(template integer Par1) {};
   template integer MyTemplate1(integer Par1) := Par1;
   control {
      MyFunc1(Nonexi01:10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateInstance: DerivedRefWithParList->TemplateRefWithParList->TemplateIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateInstance: DerivedRefWithParList->TemplateRefWithParList->TemplateIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1(template integer Par1) {};
   template integer MyTemplate1(integer Par1) := Par1;
   control {
      MyFunc1(modifies Nonexi04 := 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateInstance: TemplateActualPar
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateInstance: TemplateActualPar>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1(template integer Par1) {};
   template integer MyTemplate1(integer Par1) := Par1;
   control {
      // TR 680: parameterized inline modified template
      MyFunc1(modifies MyTemplate1(Nonexi) := 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::TemplateInstance: embedded TemplateInstance
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TemplateInstance: embedded TemplateInstance>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1(template integer Par1) {};
   template integer MyTemplate1(template integer Par1) := Par1;
   control {
      MyFunc1(modifies MyTemplate1(modifies MyTemplate1(Nonexi08) := 10 ) := 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var Nonexi01 MyVar1 := 10, MyVar2;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVar3[Nonexi02];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Range (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Range (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVar3[999..Nonexi02];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Range (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Range (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVar3[Nonexi02..999];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Multidimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->ArrayDef->Multidimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVar5[1+10][113+333][2+Nonexi05];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?must.+?evaluate.+?integer
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->RVALUE
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->VarInstance->RVALUE>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      var integer MyVar6 := 11-Nonexi06;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer1[Nonexi07];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Range (upper bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Range (upper bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer1[666..Nonexi07];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Range (lower bound)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Range (lower bound)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer1[Nonexi07..666];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Multidimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->ArrayDef->Multidimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer1[1+10][113+333][Nonexi10];
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->RVALUE
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->FunctionLocalInst->TimerInstance->RVALUE>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer4 := Nonexi11;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->TimerRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->TimerRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      Nonexi01.start(1.0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer2[10];
      MyTimer2[Nonexi02 + 1].start(1.0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->ArrayOrBitRef->Multidimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->ArrayOrBitRef->Multidimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // NOTE: pending CR for multidimensional timers, not yet supported
      timer MyTimer2[10][10][10000];
      MyTimer2[2][2][Nonexi02 + 1].start(1.0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->TimerValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StartTimerStatement->TimerValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer1;
      MyTimer1.start(2.0 + Nonexi04);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->TimerRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->TimerRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      Nonexi01.stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer2[10];
      MyTimer2[1].start(1.0);
      MyTimer2[Nonexi02 + 1].stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->ArrayOrBitRef->Multidimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: StopTimerStatement->ArrayOrBitRef->Multidimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // NOTE: pending CR for multidimensional timers, not yet supported
      timer MyTimer2[10][10][10000];
      MyTimer2[2][2][1].start(1.0);
      MyTimer2[2][2][Nonexi02 + 1].stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->TimerRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->TimerRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      Nonexi01.timeout;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      timer MyTimer2[10];
      MyTimer2[1].start(1.0);
      MyTimer2[Nonexi02 + 1].timeout;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->ArrayOrBitRef->Multidimensional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->TimerStatements: TimeoutStatement->ArrayOrBitRef->Multidimensional>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // NOTE: pending CR for multidimensional timers, not yet supported
      timer MyTimer2[10][10][10000];
      MyTimer2[2][2][1].start(10.0);
      MyTimer2[2][2][Nonexi02 + 1].timeout;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->LogStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->LogStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // TR 614: expression in log statement
      log("McHalls was here...", 333 + Nonexi01);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->ForLoop
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->ForLoop>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      for (var Nonexi02 MyVar1 := 1, MyVar2; true; MyVar1:=MyVar1) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->WhileLoop
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->WhileLoop>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      while ( 2 + Nonexi03 > 2 + Nonexi04 ) {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->DoWhileLoop
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->DoWhileLoop>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      do {} while ( 2 + Nonexi05 > 2 + Nonexi06 );
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->ConditionalConstruct
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BasicStatements->ConditionalConstruct>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      if (2 + Nonexi07 > 2 + Nonexi08) {}
      else if (2 + Nonexi09 > 2 + Nonexi10) {}
      else {}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: ReturnStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: ReturnStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1() return integer { return 333 + Nonexi01; }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: DeactivateStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: DeactivateStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }

   testcase MyTC1() runs on MyComp { deactivate(Nonexi02); }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: GotoStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->BehaviourStatements: GotoStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // already covered in expressions:
      // - TestcaseInstance
      // - FunctionInstance
      // AltConstruct already covered in 'AltstepDef'
      // InterleavedConstruct is not supported yet
      // GotoStatement
      goto Nonexi03;
      // ActivateOp already covered
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Label.+?Nonexi.+?used.+?not.+?defined
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ModuleControlPart->ControlStatement->SUTStatements
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ModuleControlPart->ControlStatement->SUTStatements>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      // TR 614: expression in log statement
      action("McHalls was here...", 333 + Nonexi01);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->ComponentIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->ComponentIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType {
      MyComp field1
   }
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      var MyType MyVar;
      map(Nonexi01:MyPort, system:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType {
      MyComp field1
   }
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      var MyType MyVar;
      map(MyVar.Nonexi03:MyPort, system:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?reference.+?to.+?non.*?existent.+?field.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->FunctionInstance
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->FunctionInstance>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType {
      MyComp field1
   }
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      var MyType MyVar;
      map(Nonexi04():MyPort, system:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->Port->PortIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->Port->PortIdentifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType {
      MyComp field1
   }
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      var MyType MyVar := { field1 := MyComp.create };
      map(MyVar.field1:Nonexi05, system:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?component.+?does.+?not.+?have.+?port.+?nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->PortSpec->ComponentRef->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType {
      MyComp field1
   }
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      var MyType MyVar;
      map(MyVar.field1:MyPort2[Nonexi06], system:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->ConnectStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->ConnectStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   // FunctionLocalDef and FunctionLocalInst are already covered
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      // ConnectStatement
      // Nonexi02 shall not be reported as the component type is not known
      connect(Nonexi01():Nonexi02, MyCompInst2[Nonexi03]:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->MapStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->MapStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      // MapStatement already covered in 'PortSpec'
      // Only Nonexi04 shall be reported. Nonexi05 shall not be as the component type is not
      // yet known; Nonexi06 shall not be as system value is not yet known.
      map(Nonexi04():Nonexi05, system:Nonexi06);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi04
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->DisconnectStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->DisconnectStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      // Nonexi08 shall not be reported, component is not known
      disconnect(Nonexi07():Nonexi08, MyCompInst2[Nonexi09]:MyPort);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi07
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi09
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->UnmapStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->UnmapStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      // Nonexi11 shall not be reported, component is not known
      // Nonexi12 shall not be reported, system value is not yet known
      unmap(Nonexi10():Nonexi11, system:Nonexi12);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi10
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->DoneStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->DoneStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      Nonexi13.done;
      Nonexi14().done;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->StartTCStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->StartTCStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      Nonexi15.start(MyFunc2());
      Nonexi16().start(MyFunc2());
      MyCompInst1.start(Nonexi17());
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->StopTCStatement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->ConfigurationStatements->StopTCStatement>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort
   }
   function MyFunc2() runs on MyComp {}
   function MyFunc1() runs on MyComp {
      var MyComp MyCompInst1 := MyComp.create;
      var MyComp MyCompInst2[10];
      Nonexi18.stop;
      Nonexi19().stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// The followings are already covered:
// receive, trigger, getcall, getreply, catch, check
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      Nonexi01.send(10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// The followings are already covered:
// receive, trigger, getcall, getreply, catch, check
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      MyPort2[333+Nonexi02].send(10+0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// The followings are already covered:
// receive, trigger, getcall, getreply, catch, check
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      // others are covered in TemplateInstance
      MyPort.send(10+Nonexi03);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp->ToClause1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp->ToClause1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// The followings are already covered:
// receive, trigger, getcall, getreply, catch, check
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      MyPort.send(10) to Nonexi04;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp->ToClause2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->SendStatement->PortSendOp->ToClause2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
// The followings are already covered:
// receive, trigger, getcall, getreply, catch, check
module ModuleA {
   type port MyPortType message{
      inout integer;
   }
   type component MyComp {
      port MyPortType MyPort;
      port MyPortType MyPort2[10];
   }
   function MyFunc1() runs on MyComp {
      MyPort.send(10) to Nonexi05();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc2() runs on MyComp {
      // CallStatement->Port->Identifier
      // TR 618: calling a noblocking signature without reply-part causes parse error
      Nonexi06.call(MyTemplateSig(1));
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc2() runs on MyComp {
      MyPort4[333+Nonexi07].call(MyTemplateSig(1));
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->CallParameters
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->CallParameters>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc2() runs on MyComp {
      // others are covered in TemplateInstance
      // TR 681: unnecessary checks for signatures in call operation in case of fault
      MyPort3.call(Nonexi10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->ToClause1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->ToClause1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc2() runs on MyComp {
      MyPort3.call(MyTemplateSig(1)) to Nonexi11;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->ToClause2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->CallStatement->PortCallOp->ToClause2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc2() runs on MyComp {
      MyPort3.call(MyTemplateSig(1)) to Nonexi12();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc3() runs on MyComp {
      Nonexi13.reply(MyTemplateSig2(1));
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc3() runs on MyComp {
      MyPort4[333+Nonexi14].reply(MyTemplateSig2(1));
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->CallParameters
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->CallParameters>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc3() runs on MyComp {
      MyPort3.reply(Nonexi16);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ReplyValue
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ReplyValue>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   template MySignature_return MyTemplateSig3(in integer Par) := { Par1 := Par }
   function MyFunc3() runs on MyComp {
      MyPort3.reply(MyTemplateSig3(1) value 333-Nonexi17);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ToClause1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ToClause1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc3() runs on MyComp {
      MyPort3.reply(MyTemplateSig2(1)) to Nonexi18;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ToClause2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ReplyStatement->PortReplyOp->ToClause2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc3() runs on MyComp {
      MyPort3.reply(MyTemplateSig2(1)) to Nonexi19();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      Nonexi20.raise(MySignature_exception, 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      MyPort4[333+Nonexi21].raise(MySignature_exception, 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->Signature
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->Signature>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      MyPort3.raise(Nonexi22, 10);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->TemplateInstance
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->TemplateInstance>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      MyPort3.raise(MySignature_exception, 10 - Nonexi26);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ToClause1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ToClause1>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      MyPort3.raise(MySignature_exception, 10) to Nonexi27;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ToClause2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->RaiseStatement->Port->ToClause2>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      inout MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc4() runs on MyComp {
      MyPort3.raise(MySignature_exception, 10) to Nonexi28();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ClearStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ClearStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc5() runs on MyComp {
      Nonexi29.clear;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ClearStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->ClearStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc5() runs on MyComp {
      MyPort4[333+Nonexi30].clear;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StartStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StartStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc6() runs on MyComp {
      Nonexi31.start;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StartStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StartStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc5() runs on MyComp {
      MyPort4[333+Nonexi32].start;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StopStatement->Port->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StopStatement->Port->Identifier>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc6() runs on MyComp {
      Nonexi31.stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StopStatement->Port->ArrayOrBitRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->CommunicationStatements->StopStatement->Port->ArrayOrBitRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType2 procedure {
      out MySignature_noblock, MySignature_block,
          MySignature_return, MySignature_exception
   }
   type component MyComp {
      port MyPortType2 MyPort3;
      port MyPortType2 MyPort4[10]
   }
   signature MySignature_block(in integer Par1);
   signature MySignature_noblock(in integer Par1) noblock;
   signature MySignature_return(in integer Par1) return integer;
   signature MySignature_exception(in integer Par1) return integer
      exception (integer, float);
   template MySignature_noblock MyTemplateSig(in integer Par) := { Par1:=Par }
   template MySignature_block MyTemplateSig2(in integer Par) := { - }
   function MyFunc5() runs on MyComp {
      MyPort4[333+Nonexi32].stop;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->VerdictStatements->VariableRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->VerdictStatements->VariableRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function MyFunc1() runs on MyComp {
      setverdict(Nonexi01);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::StatementBlock->FunctionStatement->VerdictStatements->FunctionRef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::StatementBlock->FunctionStatement->VerdictStatements->FunctionRef>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function MyFunc1() runs on MyComp {
      setverdict(Nonexi02());
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->ModuleparDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->ModuleparDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // ModuleparDef
   modulepar { integer par1 := 10 }
      with {variant (Nonexi07) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->ImportDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->ImportDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all with {variant (Nonexi12) ""};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->DefOrFieldRef->DefinitionRef->Identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->DefOrFieldRef->DefinitionRef->Identifier>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyType1 {
      integer field1
   } with { variant (Nonexi01, Nonexi02) "" }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 2>
(?im)\berror\b.+Invalid field qualifier
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->DefOrFieldRef->DefinitionRef->FullGroupIdentifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->DefOrFieldRef->DefinitionRef->FullGroupIdentifier>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // TR 622: FullGroupIdentifier causes parse error
   type record MyType2 {
      integer field1
   } with { variant (Nonexi03.Nonexi04) "" }
   // DefOrFieldRef->FieldReference->ArrayOrBitRef not yet supported
   // DefOrFieldRef->AllRef not yet supported
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Invalid field qualifier
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->ConstDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->ConstDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   const integer MyConst := 10 with {variant (Nonexi05) ""};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->ExtConstDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->ExtConstDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   external const integer MyExtConst with {variant (Nonexi14) ""};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->TemplateDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->TemplateDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   template integer MyTemplate := 10 with {variant (Nonexi06) ""};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->FunctionDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->FunctionDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc() {} with {variant (Nonexi08) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->ExtFunctionDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->ExtFunctionDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   external function MyExtFunc() with {variant (Nonexi13) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->SignatureDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->SignatureDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySignature() with {variant (Nonexi09) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->TestcaseDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->TestcaseDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   testcase MyTC() runs on MyComp {} with {variant (Nonexi10) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->AltstepDef
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->AltstepDef>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB { type integer MyINT; }
<END_MODULE>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep() runs on MyComp { [] MyPort.receive {} } with {variant (Nonexi11) ""}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->GroupDef test 1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->GroupDef test 1>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     type integer int1;
   }
   with
   {
     variant (Nonexi14) "";
   };
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::WithStatement->GroupDef test 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::WithStatement->GroupDef test 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     type integer int1;
   }
   with
   {
     variant (int1) "";
   };
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+field qualifiers are only allowed for
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference apply on nonexi
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference apply on nonexi>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      Nonexi.apply();
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference refer to nonexi
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference refer to nonexi>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type function fn_type();
   control {
      var fn_type f := refers(Nonexi);
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference derefer nonexi
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference derefer nonexi>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      execute(derefers(Nonexi)());
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::FunctionReference apply with Nonexi parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::FunctionReference apply with Nonexi parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type function fn_type();
   function fn() { }
   control {
      var fn_type f := refers(fn);
      f.apply(Nonexi);
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Too many parameters.+
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory function parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory function parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function f(in integer i := Nonexi){};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory function parameter 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory function parameter 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function f(integer i:= 1,in integer j := Nonexi, integer k := 1){};
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory altstep parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory altstep parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep(in integer i := Nonexi) runs on MyComp { [] MyPort.receive {} }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory altstep parameter 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory altstep parameter 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep(integer i:= 1,in integer j := Nonexi, integer k := 1) runs on MyComp { [] MyPort.receive {} }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory testcase parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory testcase parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   testcase MyTC(in integer i := Nonexi) runs on MyComp {}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Nonexi as non-mandatory testcase parameter 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Nonexi as non-mandatory testcase parameter 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message {inout integer}
   type component MyComp { port MyPortType MyPort }
   testcase MyTC(integer i:= 1,in integer j := Nonexi, integer k := 1) runs on MyComp {}
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Function call with nonexi non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Function call with nonexi non-mandatory parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function f(integer i:= 1,in integer j := 1, integer k := 1){};
   control{
    f(-,Nonexi,-);
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Function call with nonexi non-mandatory  parameter 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Function call with nonexi non-mandatory parameter 2>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function f(integer i:= 1,in integer j := 1, integer k := 1){};
   control{
    f(-,Nonexi);
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Template parameterised with Nonexi non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Template parameterised with Nonexi non-mandatory parameter>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record rec_type
   {
    integer a,
    integer b
   }
   template rec_type MyTemplate(in integer x:= Nonexi, in integer y := Nonexi):=
   {
     a:=x,
     b:=y
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 2>
(?im)\berror\b.+?no.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 42 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

