.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Lovassy, Arpad
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*   Tatarka, Gabor
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.16/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Type compatibility
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2005-02-15   EGBOTAT    New document for TITAN R6
A     2005-03-18   EGBOTAT    Approved after review
B     2005-12-16   EKRISZA    Updates for TITAN R6D
C     2006-07-31   EKRISZA    Updates for TITAN R6E
D     2007-03-06   EJNOSZA    Updates for TITAN R7A (expected error messages)
E     2009-06-11   EKRISZA    Name correction
F     2010-01-19   EKRISZA    Updated version number for TITAN R8C
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-5/x: Type compatibility.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
Ref [1]: SA-5/x: Type compatibility

.*---------------------------------------------------------------------*
:h2.Type id. is omitted when the value unambigously identifies the type
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/1.

The first few testcases below test each possible port operation with an
ambiguous type. Then several other possible ambiguous types are tested
with one seleced port operation. The last few testcases test other
possibilities of omitted type identifiers.

Type is unambiguous with the port operations call, getcall, reply and
getreply because the signature should be present if an inline template
is used. If the signature is not present in these cases and the testport
has more than one signature in the corresponding type list then the
compiler will always print errors when omitting the signature with
inline templates.

Omitting the signature in port operations raise and catch will cause
parser errors. Ambiguous types can be tested with these port operations
regarding the types listed in the exception list of a specific signature.

.*---------------------------------------------------------------------*
:h3.Omitted type id - send port operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - send port operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPort message {
  inout charstring, universal charstring
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send("ABC");
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)type.+?is.+?ambiguous
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - receive port operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - receive port operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPort message {
  inout charstring, universal charstring
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.receive("ABC");
  alt {
    []myPort.receive("ABC") { }
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)type.+?is.+?ambiguous
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - raise port operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - raise port operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception (charstring, universal charstring);

type port MyPort procedure {
  inout Sig
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.raise(Sig, "abc");
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)type.+?is.+?ambiguous
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - catch port operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - catch port operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception (charstring, universal charstring);

type port MyPort procedure {
  inout Sig
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  alt {
    []myPort.catch(Sig, "abc") { }
  }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)type.+?is.+?ambiguous
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - identical structured types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - identical structured types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record MyRecord1 {
  charstring f_cs,
  integer f_i
}

type record MyRecord2 {
  charstring f_cs,
  integer f_i
}

type port MyPort message {
  inout MyRecord1, MyRecord2
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({ "abc", 1 });
//  myPort.receive({ "def", 2 });
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - ambiguous structured types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - ambiguous structured types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record MyRecord1 {
  charstring f_cs,
  integer f_i
}

type record MyRecord2 {
  universal charstring f_ucs,
  integer f_i
}

type port MyPort message {
  inout MyRecord1, MyRecord2
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({ "abc", 1 });
//  myPort.receive({ "def", 2 });
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - set type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - set type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set MySet1 {
  charstring f_cs,
  integer f_i
}

type set MySet2 {
  integer f_i,
  universal charstring f_ucs
}

type port MyPort message {
  inout MySet1, MySet2
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({ "abc", 1 });
//  myPort.receive({ "def", 2 });
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - enumerated type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - enumerated type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated MyEnum1 { ONE(1), TWO(2), THREE(3) }
type enumerated MyEnum2 { ONE(1), THREE(3), FIVE(5) }

type port MyPort message {
  inout MyEnum1, MyEnum2
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send(ONE);
//  myPort.receive(THREE);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)\bno\b.+?definition.+?ONE
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - record of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record length(3) of integer RI3;
type record length(2..4) of integer RI2_4;

type port MyPort message {
  inout RI3, RI2_4;
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({1,2,3});
//  myPort.receive({1,2,3});
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - empty record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - empty record of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer RI;
type record of float RF;

type port MyPort message {
  inout RI, RF;
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({});
//  myPort.receive({});
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - record of and set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - record of and set of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer RI;
type set of integer SI;

type port MyPort message {
  inout RI, SI;
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({1,2,3});
//  myPort.receive({1,2,3});
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - subtyping
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - subtyping>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type integer UInt4 (0..15);
type integer UInt8 (0..255);

type record MyRecord1 {
  UInt4 field1,
  UInt4 field2
}

type record MyRecord2 {
  UInt8 field1,
  UInt8 field2
}

type port MyPort message {
  inout MyRecord1, MyRecord2;
}

type component MyComponent {
  port MyPort myPort;
}

testcase TC() runs on MyComponent {
  myPort.send({4,4});
//  myPort.receive({8,8});
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - matching identical structured types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - matching identical structured types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record MyRecord1 {
  charstring f_cs,
  integer f_i
}

type record MyRecord2 {
  charstring f_cs,
  integer f_i
}

function F() {
  if(match({"foobar", 1}, {*, ?})) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - comparing enumerations in if statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - comparing enumerations>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated MyEnum1 { ONE(1), TWO(2) }
type enumerated MyEnum2 { ONE(1), THREE(3) }

function F() {
  if(ONE == ONE) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - comparing enumerations in while loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - comparing enumerations in while loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated MyEnum1 { ONE(1), TWO(2), THREE(3) }
type enumerated MyEnum2 { ONE(1), THREE(3), FIVE(5) }

function F() {
  while(ONE != THREE) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - comparing enumerations in for loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - comparing enumerations in for loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated MyEnum1 { ONE(1), TWO(2), THREE(3) }
type enumerated MyEnum2 { ONE(1), THREE(3), FIVE(5) }

function F() {
  for(var integer dummy:=0; ONE < THREE; dummy:=dummy+1) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)operand.+?should.+?\bbe\b.+?integer.+?float.+?\bor\b.+?enumerated.+?value
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted type id - comparing enumerations in do-while loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Omitted type id - comparing enumerations in do-while loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type enumerated MyEnum1 { ONE(1), TWO(2), THREE(3) }
type enumerated MyEnum2 { ONE(1), THREE(3), FIVE(5) }

function F() {
  do { } while(THREE >= ONE);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)cannot.+?determine.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)operand.+?should.+?\bbe\b.+?integer.+?float.+?\bor\b.+?enumerated.+?value
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Type compatibility with evaluated expressions
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/2.
All evaluated expressions shall be compatible with the type that is
expected in the place of the expression.

Not all of the type/expression combinations were tested, but the
testcases try to involve possible TTCN-3 types and expressions.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - addition
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - addition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.0 + 4.0;
  var float FaultyFloat := 3 + 4;
  timer FaultyTimer;
  FaultyTimer.start(1+1);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)value.+?float.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - subtraction
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - subtraction>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.0 - 4.0;
  var objid FaultyObjid := 3 - 4;
  if(2-3) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)objid.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - multiplication
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - multiplication>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.14 * 2.2;
  var float FaultyFloat := 2 * 2;
  timer T:=2.0;
  T.start;
  alt {
    [9.0*1.1]T.timeout { }
  }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - division
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - division>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 4.0 / 4.0;
  var float FaultyFloat := 4 / 2;
  setverdict(1/2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)verdict.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - modulo
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - modulo>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var float FaultyFloat := 4 mod 3;
  if(1 mod 2) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - remainder
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - remainder>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var float FaultyFloat := 4 rem 3;
  if(-1 rem 9) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - string concatenation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - string concatenation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var charstring FaultyCS := '0011'B & '1100'B;
  var universal charstring FaultyUCS := 'A5'H & 'C3A'H;
  var bitstring FaultyBS := "abc" & "def";
  var hexstring FaultyHS := 'ABCD'O & 'CDEF'O;
  var octetstring FaultyOS := "abc" & "def";
  if('1'B & '1'B) { }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)character string.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)bitstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)hexstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)octetstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - less then operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - less then operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3 < 3;
  var float FaultyFloat := 3.14 < 4.0;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - greater then operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - greater then operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3 > 3;
  var float FaultyFloat := 2.2 > 1.7;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - not equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - not equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.3 != 3.3;
  var float FaultyFloat := 2e2 != 200.0;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - less then or equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - less then or equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.3 <= 3.3;
  var float FaultyFloat := 3.33 <= 3.333;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - greater then or equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - greater then or equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := 3.3 >= 3.3;
  var float FaultyFloat := 3.333 >= 3.33;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - logical not operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - logical not operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var boolean Bool := false;
  var integer FaultyInt := not true;
  var bitstring FaultyBS := not Bool;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)bitstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - logical and operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - logical and operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record MyRecord { integer field1 }

function F() {
  var boolean Bool := false;
  var integer FaultyInt := Bool and true;
  var MyRecord myRec := true and true;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?integer.+?expected.+?instead.+?boolean
<END_RESULT>
<RESULT COUNT 1>
(?im)record.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - logical or operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - logical or operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of boolean RecOfBool;

function F() {
  var boolean Bool := true;
  var integer FaultyInt := true or false;
  var RecOfBool FaultyRB := Bool or Bool;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)RecOfBool.+?value.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - logical xor operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - logical xor operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var boolean Bool := false;
  var integer FaultyInt := true xor true;
  timer FaultyTimer := Bool xor true;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - bitwise not operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - bitwise not operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function parF (in charstring Par) { }

function F() {
  var octetstring FaultyOS := not4b 'AA5'H;
  var integer FaultyInt := not4b '1100'B;
  parF(not4b '1'B);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)octetstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)character string.+?value.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - bitwise and operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - bitwise and operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer cInt[3] := { 1, 2, 3 }

function F() {
  var integer FaultyInt1 := '5A2C'O and4b '73BC'O;
  timer FaultyTimer := '999'H and4b '111'H;
  var integer FaultyInt2 := cInt['10'B and4b '01'B];
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected.+?index
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - bitwise or operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - bitwise or operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := '1111'B or4b '0101'B;
  var hexstring FaultyHS := '1234'O or4b '5678'O;
  setverdict('99'O or4b 'A5'O);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)hexstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)verdict.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - bitwise xor operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - bitwise xor operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := '0000'B xor4b '1000'B;
  var bitstring FaultyBS := '234'H xor4b '555'H;
  while('7'H xor4b '5'H) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)bitstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - shift operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - shift operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := '1010'B << 1;
  var bitstring FaultyBS := '234'H >> 2;
  for(var integer C:=0; '1100'B << 2; C:=C+1) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)bitstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Evaluated expression - rotate operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Evaluated expression - rotate operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer FaultyInt := '1010'B <@ 1;
  var bitstring FaultyBS := '234'H @> 2;
  timer FaultyTimer := "abc" <@ 3;
  do { } while("xyz" @> 1);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)bitstring.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)float.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)boolean.+?expected
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.Assignment of arrays with different indices
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h4. Assignment of arrays with different indices - array range 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Assignment of arrays with different indices - array range 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer i1[0 .. 2] := {1, 2, 3};
const integer i2[3] := i1;
const integer i3[0..2]:=i1;

const integer i4[9..11] := {1,2,3};
const integer i5[9..11] := i4;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Assignment of arrays with different indices - array of array range 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Assignment of arrays with different indices - array of array range 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer i1[2][0 .. 2] := {{1, 2, 3},{4,5,6}};
const integer i2[2][3] := i1;
const integer i3[2][0..2]:=i1;

const integer i4[3][9..11] := {{1,2,3},{4,5,6},{7,8,9}};
const integer i5[3][9..11] := i4;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type compatibility of non-structured types
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - integer>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type integer itype1 (0 .. infinity)
type integer itype2 (-infinity .. 0)
type integer itype3 (1,2,4,5, 8 .. 10)
type integer itype4 (6 .. 7)

const integer  i1 := -5;
const itype1   i2 := i1;

const integer  i3 := 5;
const itype2   i4 := i3;

const integer  i5 := 6;
const itype3   i6 := i5;

const itype3   i7 := 5;
const itype4   i8 := i7;

}
<END_MODULE>
<RESULT COUNT 3>
(?im)not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(6..7\) has no common value with subtype \(1..2,4..5,8..10\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - float
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - float>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type float ftype1 (0.0 .. infinity)
type float ftype2 (-infinity .. 0.0)
type float ftype3 (1.0, 2E0, 4.1E-1, 8.0 .. 10.0)
type float ftype4 (6.0 .. 7.0)

const float    f1 := -5.0;
const ftype1   f2 := f1;

const float    f3 := 5.0;
const ftype2   f4 := f3;

const float    f5 := 6.0;
const ftype3   f6 := f5;

const ftype3   f7 := 4.1E-1;
const ftype4   f8 := f7;

}
<END_MODULE>
<RESULT COUNT 3>
(?im)not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(6(\.0)?e0\.\.7(\.0)?e0\) has no common value with subtype \(4\.1e-1,1(\.0)?e0,2(\.0)?e0,8.0e0\.\.1(\.0)?e1\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - char
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - char>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type char ctype1 ("b", "d", "f", "h")
type char ctype2 ("B", "D", "F", "H")

const char     c1 := "a";
const ctype1   c2 := c1;

const char     c3 := "A";
const ctype1   c4 := c3;

}
<END_MODULE>
<RESULT COUNT 2>
(?im)not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - charstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - charstring>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type charstring ctype1 ("b", "d", "f")
type charstring ctype2 ("B", "D", "F")

const charstring     c1 := "a";
const ctype1         c2 := c1;

const charstring     c3 := "A";
const ctype2         c4 := c3;

const ctype1         c5 := "f"
const ctype2         c6 := c5;

}
<END_MODULE>
<RESULT COUNT 3>
(?im)not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - boolean
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - boolean>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type boolean btype1 (true)
type boolean btype2 (false)

const boolean        b1 := false;
const btype1         b2 := b1;

const boolean        b3 := true;
const btype2         b4 := b3;

const btype1         b5 := true;
const btype2         b6 := b5;

}
<END_MODULE>
<RESULT COUNT 2>
(?im)not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(false\) has no common value with subtype \(true\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - bitstring>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type bitstring btype1 ('00'B,'01'B,'10'B)
type bitstring btype2 length(3)
type bitstring btype3 ('000111'B)
type bitstring btype4 length(3 ..5)

const bitstring	b1 := '11'B
const btype1	b2 := b1

const bitstring	b3 := '1101'B
const btype2	b4 := b3

const btype1	b5 := '01'B
const btype2	b6 := b5

const btype3	b7 := '000111'B
const btype1	b8 := b7
const btype2	b9 := b7
const btype4	b10 := b7


}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: '11'B is not a valid value for type `bitstring' which has subtype length\(2\) except \('11'B\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: '1101'B is not a valid value for type `bitstring' which has subtype length\(3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype length\(3\) has no common value with subtype length\(2\) except \('11'B\)
<END_RESULT>
<RESULT COUNT 3>
(?im)error:.+?has no common value with subtype \('000111'B\)
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - hexstring>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type hexstring htype1 ('00'H,'01'H,'10'H)
type hexstring htype2 length(3)
type hexstring htype3 ('000111'H)
type hexstring htype4 length(3 ..5)

const hexstring	h1 := '11'H
const htype1	h2 := h1

const hexstring	h3 := '1101'H
const htype2	h4 := h3

const htype1	h5 := '01'H
const htype2	h6 := h5

const htype3	h7 := '000111'H
const htype1	h8 := h7
const htype2	h9 := h7
const htype4	h10 := h7


}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: '11'H is not a valid value for type `hexstring' which has subtype \('00'H,'01'H,'10'H\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: '1101'H is not a valid value for type `hexstring' which has subtype length\(3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype length\(3\) has no common value with subtype \('00'H,'01'H,'10'H\)
<END_RESULT>
<RESULT COUNT 3>
(?im)error:.+?has no common value with subtype \('000111'H\)
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Type compatibility of non-structured types - octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Type compatibility of non-structured types - octetstring>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type octetstring otype1 ('00'O,'01'O,'10'O)
type octetstring otype2 length(3)
type octetstring otype3 ('000000111111'O)
type octetstring otype4 length(3 ..5)

const octetstring	o1 := '11'O
const otype1		o2 := o1

const octetstring	o3 := '1101'O
const otype2		o4 := o3

const otype1		o5 := '01'O
const otype2		o6 := o5

const otype3		o7 := '000000111111'O
const otype1		o8 := o7
const otype2		o9 := o7
const otype4		o10 := o7


}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: '11'O is not a valid value for type `octetstring' which has subtype \('00'O,'01'O,'10'O\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: '1101'O is not a valid value for type `octetstring' which has subtype length\(3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype length\(3\) has no common value with subtype \('00'O,'01'O,'10'O\)
<END_RESULT>
<RESULT COUNT 3>
(?im)error:.+?has no common value with subtype \('000000111111'O\)
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3. Non-float initialiser
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Template type mismatch in modified template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h4. Template type mismatch in modified template - set of, enum
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template type mismatch in modified template - set of, enum>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of charstring stype;
type enumerated etype {a, b, c}

template stype t := {"a","b"};
template etype t1 modifies t := a;


}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?different.+?type.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Template type mismatch in modified template - enum, integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template type mismatch in modified template - enum, integer>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type enumerated etype {a, b, c}

template etype t := a;
template integer t1 modifies t := 2;


}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?different.+?type.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Template type mismatch in modified template - float, integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template type mismatch in modified template - float, integer>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer t := 4;
template float t1 modifies t := 4.0;


}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?different.+?type.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Template type mismatch in modified template - octetstring, hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template type mismatch in modified template - octetstring, hexstring>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template octetstring t := '1A'O;
template hexstring t1 modifies t := '1A'H;


}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?different.+?type.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Template type mismatch in modified template - bitstring, boolean
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template type mismatch in modified template - bitstring, boolean>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template bitstring t := '1'B;
template boolean t1 modifies t := false;


}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?different.+?type.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3. Incompatible types in 'match'
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3. Inapplicable operator
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on integer constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on integer constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const integer 	i1 :=  1 & 2

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on integer constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on integer constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const integer	i1 := not 1
const integer	i2 := 1 and 2
const integer	i3 := 1 or 2
const integer	i4 := 1 xor 2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on integer constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on integer constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const integer	i1 := not4b 1
const integer	i2 := 1 and4b 2
const integer	i3 := 1 or4b 2
const integer	i4 := 1 xor4b 2


}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on integer constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on integer constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const integer	i1 := 1 << 1
const integer	i2 := 1 >> 1
const integer	i3 := 1 << -1
const integer	i4 := 1 >> -1


}
<END_MODULE>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on integer constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on integer constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const integer	i1 := 1 <@ 1
const integer	i2 := 1 @> 1
const integer	i3 := 1 <@ -1
const integer	i4 := 1 @> -1


}
<END_MODULE>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on float constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on float constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const float 	f1 :=  1.0 & 2E-1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on float constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on float constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const float	f1 := not 1.0
const float	f2 := 1.0 and 2E-1
const float	f3 := 1.0 or 2E-1
const float	f4 := 1.0 xor 2E-1

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on float constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on float constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const float	f1 := not4b 1.0
const float	f2 := 1.0 and4b 2E-1
const float	f3 := 1.0 or4b 2E-1
const float	f4 := 1.0 xor4b 2E-1


}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on float constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on float constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const float	f1 := 1.0 << 1
const float	f2 := 1.0 >> 1
const float	f3 := 1 << 1.0
const float	f4 := 1 >> 1.0


}
<END_MODULE>
<RESULT COUNT 4>
(?im)Left.+?operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)Right.+?operand.+?should.+?be.+?integer.+?value
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on float constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on float constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const float	f1 := 1.0 <@ 1
const float	f2 := 1.0 @> 1
const float	f3 := 1 <@ 1.0
const float	f4 := 1 @> 1.0


}
<END_MODULE>
<RESULT COUNT 4>
(?im)Left.+?operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)Right.+?operand.+?should.+?be.+?integer.+?value
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on boolean constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on boolean constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const boolean b1 := true
const boolean b2 := false

const boolean	b3 := b1 + b2
const boolean	b4 := b1 - b2
const boolean	b5 := b1 * b2
const boolean	b6 := b1 / b2
const boolean	b7 := b1 mod b2
const boolean	b8 := b1 rem b2

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on boolean constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on boolean constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const boolean 	b1 :=  true & false

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on boolean constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on boolean constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const boolean b1 := true
const boolean b2 := false


const boolean	b3 := not4b b1
const boolean	b4 := b1 and4b b2
const boolean	b5 := b1 or4b b2
const boolean	b6 := b1 xor4b b2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on boolean constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on boolean constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const boolean b1 := true

const boolean b2 := b1 << 1
const boolean b3 := b1 >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on boolean constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on boolean constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const boolean b1 := true

const boolean b2 := b1 <@ 1
const boolean b3 := b1 @> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on char constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on char constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const char c1 := "a"
const char c2 := ""

const char	c3 := c1 + c2
const char	c4 := c1 - c2
const char	c5 := c1 * c2
const char	c6 := c1 / c2
const char	c7 := c1 mod c2
const char	c8 := c1 rem c2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on char constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on char constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const char c1 := "a"
const char c2 := ""


const char	c3 := not c2
const char	c4 := c1 and c2
const char	c5 := c1 or c2
const char	c6 := c1 xor c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on char constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on char constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const char c1 := "a"
const char c2 := ""


const char	c3 := not4b c2
const char	c4 := c1 and4b c2
const char	c5 := c1 or4b c2
const char	c6 := c1 xor4b c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on char constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on char constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const char b2 := "a" << 1
const char b3 := "" >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)Left.+?operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on bitstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on bitstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const bitstring b1 := '00001111'B
const bitstring b2 := ''B

const bitstring	b3 := b1 + b2
const bitstring	b4 := b1 - b2
const bitstring	b5 := b1 * b2
const bitstring	b6 := b1 / b2
const bitstring	b7 := b1 mod b2
const bitstring	b8 := b1 rem b2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on bitstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on bitstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const bitstring b1 := '00001111'B
const bitstring b2 := ''B


const bitstring	b3 := not b2
const bitstring	b4 := b1 and b2
const bitstring	b5 := b1 or b2
const bitstring	b6 := b1 xor b2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on hexstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on hexstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const hexstring h1 := '00001111'H
const hexstring h2 := ''H

const hexstring	h3 := h1 + h2
const hexstring	h4 := h1 - h2
const hexstring	h5 := h1 * h2
const hexstring	h6 := h1 / h2
const hexstring	h7 := h1 mod h2
const hexstring	h8 := h1 rem h2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on hexstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on hexstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const hexstring h1 := '00001111'H
const hexstring h2 := ''H


const hexstring	h3 := not h2
const hexstring	h4 := h1 and h2
const hexstring	h5 := h1 or h2
const hexstring	h6 := h1 xor h2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on octetstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on octetstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const octetstring o1 := '00001111'O
const octetstring o2 := ''O

const octetstring	o3 := o1 + o2
const octetstring	o4 := o1 - o2
const octetstring	o5 := o1 * o2
const octetstring	o6 := o1 / o2
const octetstring	o7 := o1 mod o2
const octetstring	o8 := o1 rem o2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on octetstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on octetstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const octetstring o1 := '00001111'O
const octetstring o2 := ''O


const octetstring	o3 := not o2
const octetstring	o4 := o1 and o2
const octetstring	o5 := o1 or o2
const octetstring	o6 := o1 xor o2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on charstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on charstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const charstring c1 := "ABCDEF"
const charstring c2 := ""

const charstring	c3 := c1 + c2
const charstring	c4 := c1 - c2
const charstring	c5 := c1 * c2
const charstring	c6 := c1 / c2
const charstring	c7 := c1 mod c2
const charstring	c8 := c1 rem c2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on charstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on charstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const charstring c1 := "ABCDEF"
const charstring c2 := ""


const charstring	c3 := not c2
const charstring	c4 := c1 and c2
const charstring	c5 := c1 or c2
const charstring	c6 := c1 xor c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on charstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on charstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const charstring c1 := "ABCDEF"
const charstring c2 := ""


const charstring	c3 := not4b c2
const charstring	c4 := c1 and4b c2
const charstring	c5 := c1 or4b c2
const charstring	c6 := c1 xor4b c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on charstring constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on charstring constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const charstring b2 := "ABCDEF" << 1
const charstring b3 := "ABCDEF" >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on record constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on record constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record rtype {integer i}


const rtype r1 := {1}
const rtype r2 := {2}

const rtype	r3 := r1 + r2
const rtype	r4 := r1 - r2
const rtype	r5 := r1 * r2
const rtype	r6 := r1 / r2
const rtype	r7 := r1 mod r2
const rtype	r8 := r1 rem r2

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on set constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on set constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set rtype {integer i}

const rtype r1 := {i := 1}
const rtype r2 := {i := 2}

const rtype	r3 := r1 & r2

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on record of constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on record of constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of integer rtype

const rtype r1 := {1}
const rtype r2 := {2}


const rtype	r3 := not r2
const rtype	r4 := r1 and r2
const rtype	r5 := r1 or r2
const rtype	r6 := r1 xor r2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on set of constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on set of constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of integer rtype

const rtype r1 := {1}
const rtype r2 := {2}


const rtype	r3 := not4b r2
const rtype	r4 := r1 and4b r2
const rtype	r5 := r1 or4b r2
const rtype	r6 := r1 xor4b r2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on array constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on array constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


const bitstring b[3] := {''B,'1'B,'0'B}


const bitstring	b1 := b << 1
const bitstring	b2 := b >> 1


}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on union constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on union constant>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union utype {bitstring b, hexstring h}

const utype u1 := {b := '000111'B}

const utype	u2 := u1 <@ 1
const utype	u3 := u1 @> 1


}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on integer template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on integer template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer 	i1 :=  1 & 2

}
<END_MODULE>
<RESULT LTRT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT FTRT COUNT 2>
(?im)Templates.+?of.+?type.+?`integer'.+?cannot.+?be.+?concatenated
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on integer template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on integer template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer	i1 := not 1
template integer	i2 := 1 and 2
template integer	i3 := 1 or 2
template integer	i4 := 1 xor 2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on integer template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on integer template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer	i1 := not4b 1
template integer	i2 := 1 and4b 2
template integer	i3 := 1 or4b 2
template integer	i4 := 1 xor4b 2


}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on integer template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on integer template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer	i1 := 1 << 1
template integer	i2 := 1 >> 1
template integer	i3 := 1 << -1
template integer	i4 := 1 >> -1


}
<END_MODULE>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on integer template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on integer template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template integer	i1 := 1 <@ 1
template integer	i2 := 1 @> 1
template integer	i3 := 1 <@ -1
template integer	i4 := 1 @> -1


}
<END_MODULE>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on float template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on float template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template float 	f1 :=  1.0 & 2E-1

}
<END_MODULE>
<RESULT LTRT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT FTRT COUNT 2>
(?im)Templates.+?of.+?type.+?`float'.+?cannot.+?be.+?concatenated
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on float template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on float template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template float	f1 := not 1.0
template float	f2 := 1.0 and 2E-1
template float	f3 := 1.0 or 2E-1
template float	f4 := 1.0 xor 2E-1

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on float template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on float template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template float	f1 := not4b 1.0
template float	f2 := 1.0 and4b 2E-1
template float	f3 := 1.0 or4b 2E-1
template float	f4 := 1.0 xor4b 2E-1


}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on float template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on float template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template float	f1 := 1.0 << 1
template float	f2 := 1.0 >> 1
template float	f3 := 1 << 1.0
template float	f4 := 1 >> 1.0


}
<END_MODULE>
<RESULT COUNT 4>
(?im)Left.+?operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)Right.+?operand.+?should.+?be.+?integer.+?value
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on float template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on float template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template float	f1 := 1.0 <@ 1
template float	f2 := 1.0 @> 1
template float	f3 := 1 <@ 1.0
template float	f4 := 1 @> 1.0


}
<END_MODULE>
<RESULT COUNT 4>
(?im)Left.+?operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)Right.+?operand.+?should.+?be.+?integer.+?value
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on boolean template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on boolean template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template boolean b1 := true
template boolean b2 := false

template boolean	b3 := b1 + b2
template boolean	b4 := b1 - b2
template boolean	b5 := b1 * b2
template boolean	b6 := b1 / b2
template boolean	b7 := b1 mod b2
template boolean	b8 := b1 rem b2

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 24>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on boolean template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on boolean template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template boolean 	b1 :=  true & false

}
<END_MODULE>
<RESULT LTRT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT FTRT COUNT 2>
(?im)Templates.+?of.+?type.+?`boolean'.+?cannot.+?be.+?concatenated
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on boolean template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on boolean template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template boolean b1 := true
template boolean b2 := false


template boolean	b3 := not4b b1
template boolean	b4 := b1 and4b b2
template boolean	b5 := b1 or4b b2
template boolean	b6 := b1 xor4b b2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on boolean template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on boolean template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template boolean b1 := true

template boolean b2 := b1 << 1
template boolean b3 := b1 >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on boolean template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on boolean template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template boolean b1 := true

template boolean b2 := b1 <@ 1
template boolean b3 := b1 @> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on char template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on char template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template char c1 := "a"
template char c2 := ""

template char	c3 := c1 + c2
template char	c4 := c1 - c2
template char	c5 := c1 * c2
template char	c6 := c1 / c2
template char	c7 := c1 mod c2
template char	c8 := c1 rem c2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 23>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on char template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on char template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template char c1 := "a"
template char c2 := ""


template char	c3 := not c2
template char	c4 := c1 and c2
template char	c5 := c1 or c2
template char	c6 := c1 xor c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on char template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on char template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template char c1 := "a"
template char c2 := ""


template char	c3 := not4b c2
template char	c4 := c1 and4b c2
template char	c5 := c1 or4b c2
template char	c6 := c1 xor4b c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on char template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on char template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template char b2 := "a" << 1
template char b3 := "" >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on bitstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on bitstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template bitstring b1 := '00001111'B
template bitstring b2 := ''B

template bitstring	b3 := b1 + b2
template bitstring	b4 := b1 - b2
template bitstring	b5 := b1 * b2
template bitstring	b6 := b1 / b2
template bitstring	b7 := b1 mod b2
template bitstring	b8 := b1 rem b2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 23>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on bitstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on bitstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template bitstring b1 := '00001111'B
template bitstring b2 := ''B


template bitstring	b3 := not b2
template bitstring	b4 := b1 and b2
template bitstring	b5 := b1 or b2
template bitstring	b6 := b1 xor b2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on hexstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on hexstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template hexstring h1 := '00001111'H
template hexstring h2 := ''H

template hexstring	h3 := h1 + h2
template hexstring	h4 := h1 - h2
template hexstring	h5 := h1 * h2
template hexstring	h6 := h1 / h2
template hexstring	h7 := h1 mod h2
template hexstring	h8 := h1 rem h2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 23>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on hexstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on hexstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template hexstring h1 := '00001111'H
template hexstring h2 := ''H


template hexstring	h3 := not h2
template hexstring	h4 := h1 and h2
template hexstring	h5 := h1 or h2
template hexstring	h6 := h1 xor h2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on octetstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on octetstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template octetstring o1 := '00001111'O
template octetstring o2 := ''O

template octetstring	o3 := o1 + o2
template octetstring	o4 := o1 - o2
template octetstring	o5 := o1 * o2
template octetstring	o6 := o1 / o2
template octetstring	o7 := o1 mod o2
template octetstring	o8 := o1 rem o2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 23>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on octetstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on octetstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template octetstring o1 := '00001111'O
template octetstring o2 := ''O


template octetstring	o3 := not o2
template octetstring	o4 := o1 and o2
template octetstring	o5 := o1 or o2
template octetstring	o6 := o1 xor o2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on charstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on charstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template charstring c1 := "ABCDEF"
template charstring c2 := ""

template charstring	c3 := c1 + c2
template charstring	c4 := c1 - c2
template charstring	c5 := c1 * c2
template charstring	c6 := c1 / c2
template charstring	c7 := c1 mod c2
template charstring	c8 := c1 rem c2

}
<END_MODULE>
<RESULT COUNT 1>
(?im)did.+?you.+?mean.+?concat.+?operation.+?instead.+?of.+?addition
<END_RESULT>
<RESULT COUNT 6>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 23>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on charstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on charstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template charstring c1 := "ABCDEF"
template charstring c2 := ""


template charstring	c3 := not c2
template charstring	c4 := c1 and c2
template charstring	c5 := c1 or c2
template charstring	c6 := c1 xor c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on charstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on charstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template charstring c1 := "ABCDEF"
template charstring c2 := ""


template charstring	c3 := not4b c2
template charstring	c4 := c1 and4b c2
template charstring	c5 := c1 or4b c2
template charstring	c6 := c1 xor4b c2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - shift operators on charstring template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - shift operators on charstring template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


template charstring b2 := "ABCDEF" << 1
template charstring b3 := "ABCDEF" >> 1

}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - arithmetic operators on record template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - arithmetic operators on record template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record rtype {integer i}


template rtype r1 := {1}
template rtype r2 := {2}

template rtype	r3 := r1 + r2
template rtype	r4 := r1 - r2
template rtype	r5 := r1 * r2
template rtype	r6 := r1 / r2
template rtype	r7 := r1 mod r2
template rtype	r8 := r1 rem r2

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operand.+?should.+?be.+?integer.+?or.+?float.+?value
<END_RESULT>
<RESULT COUNT 4>
(?im)operand.+?should.+?be.+?integer value
<END_RESULT>
<RESULT COUNT 12>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 24>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - concatenation on set template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - concatenation on set template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set rtype {integer i}

template rtype r1 := {i := 1}
template rtype r2 := {i := 2}

template rtype	r3 := r1 & r2

}
<END_MODULE>
<RESULT LTRT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT LTRT COUNT 2>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT FTRT COUNT 2>
(?im)Templates.+?of.+?type.+?`@Temp.rtype'.+?cannot.+?be.+?concatenated
<END_RESULT>
<RESULT LTRT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - logical operators on record of template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - logical operators on record of template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of integer rtype

template rtype r1 := {1}
template rtype r2 := {2}


template rtype	r3 := not r2
template rtype	r4 := r1 and r2
template rtype	r5 := r1 or r2
template rtype	r6 := r1 xor r2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?boolean.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - bitwise operators on set of template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - bitwise operators on set of template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of integer rtype

template rtype r1 := {1}
template rtype r2 := {2}


template rtype	r3 := not4b r2
template rtype	r4 := r1 and4b r2
template rtype	r5 := r1 or4b r2
template rtype	r6 := r1 xor4b r2

}
<END_MODULE>
<RESULT COUNT 7>
(?im)operand.+?should.+?be.+?binary.+?string.+?value
<END_RESULT>
<RESULT COUNT 7>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4. Inapplicable operator - rotate operators on union template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Inapplicable operator - rotate operators on union template>

<COMPILE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union utype {bitstring b, hexstring h}

template utype u1 := {b := '000111'B}

template utype	u2 := u1 <@ 1
template utype	u3 := u1 @> 1


}
<END_MODULE>
<RESULT COUNT 2>
(?im)operand.+?should.+?be.+?string.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)reference.+?to.+?value.+?expected.+?instead.+?of.+?template
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type compatibility between the formal and the actual parameter list
.*---------------------------------------------------------------------*
:p. Explanation:
:nl.  Shall be the same as the order of elements and shall be compatible
      with the types of elements in the actual and the corresponding formal
      parameter list.

:p. Test strategy:
:nl.  - The type compatibility checking covers the order checking, therefore
        the order checking is not necessary.
:nl.  - We made a test for each types of values that are allowed to appear in
        the formal/actual parameter lists of all language elements (template,
        function, altstep, testcase, signature).

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    template MyRec MyTemp( charstring par_1, boolean par_2, integer par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
        MyFunc(MyTemp("r",true,6));        // good
        MyFunc(MyTemp("r",true,6.2));      // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    template MyRec MyTemp( MyRec Par ) := {
        field1 := Par.field1,
        field2 := Par.field2,
        field3 := Par.field3
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
        MyFunc(MyTemp({6,"r",false}));       // good
        MyFunc(MyTemp({"r",false,6.7}));     // error
        MyFunc(MyTemp(false));               // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { charstring field }
    type record MyRec {
        integer    field1,
	address    field2,
	boolean    field3
    }
    template MyRec MyTemp( address par_1, boolean par_2, integer par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
	    MyFunc(MyTemp({"k"},true,6));     // good
	    MyFunc(MyTemp(6,{"k"},true));     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        float      field1,
	charstring field2,
	boolean    field3
    }
    template MyRec MyTemp( charstring par_1, boolean par_2, template float par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
        MyFunc(MyTemp("r",true,6.4));       // good
        MyFunc(MyTemp(6,"r",true));         // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRec {
        float      field1,
	charstring field2,
	MyCT       field3
    }
    template MyRec MyTemp( charstring par_1, MyCT par_2, float par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
	var MyCT myct_1;
	var integer myct_2;
        MyFunc(MyTemp("r",myct_1,6.2));       // good
        MyFunc(MyTemp(6.2,myct_1,"r"));       // error
        MyFunc(MyTemp("r",myct_2,6.2));       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRec {
        float      field1,
	charstring field2,
	default    field3
    }
    template MyRec MyTemp( charstring par_1, default par_2, float par_3 ) := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
    function MyFunc( template MyRec mytemp ) {}
    control {
	var default mydef_1;
	var octetstring mydef_2;
        MyFunc(MyTemp("r",mydef_1,6.2));       // good
        MyFunc(MyTemp(6.2,mydef_1,"r"));       // error
        MyFunc(MyTemp("r",mydef_2,6.2));       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Template: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Template: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    template MyRec MyTemp( charstring par_1 := 1, boolean par_2 := 1, integer par_3 := "r") := {
        field1 := par_3,
        field2 := par_1,
        field3 := par_2
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( charstring par_1, boolean par_2, integer par_3 ) {}
    control {
        MyFunc( "r",true,2 );         // good
        MyFunc( "r",true,6.2 );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    function MyFunc( MyRec par ) {}
    control {
        MyFunc( {6,"r",true} );         // good
        MyFunc( {"r",true,6.2} );       // error
	MyFunc( 5 );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { charstring field }
    function MyFunc( address par_1, octetstring par_2 ) {}
    control {
	    MyFunc( {"k"}, 'A5'O );     // good
	    MyFunc( 'A5'O, "k" );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    function MyFunc( template float par_1, template integer par_2 ) {}
    control {
        MyFunc( MyTemp_1(6.3), MyTemp_2(6) );   // good
        MyFunc( 6.3, 6 );                       // good
        MyFunc( MyTemp_1(6), 6.9 );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc( bitstring par_1, MyCT par_2, float par_3 ) {}
    control {
	var MyCT myct_1;
	var integer myct_2;
        MyFunc( '01001'B, myct_1, 6.2 );    // good
        MyFunc( 7.6, myct_1, '01001'B );    // error
        MyFunc( '01001'B, myct_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPortType message { inout integer }
    type component MyCT {
        port MyPortType port_1;
	var integer port_2;
    }
    function MyCompFunc() runs on MyCT {
        MyFunc( '01001'B, port_1, 6.2 );    // good
        MyFunc( 7.6, port_1, '01001'B );    // error
        MyFunc( '01001'B, port_2, 6.2 );    // error
    }
    function MyFunc( bitstring par_1, MyPortType par_2, float par_3 ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?port.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( hexstring par_1, default par_2, float par_3 ) {}
    control {
	var default mydef_1;
	var charstring mydef_2;
        MyFunc( '7AA'H, mydef_1, 6.2 );     // good
        MyFunc( 6.2, mydef_1, '7AA'H );     // error
        MyFunc( '7AA'H, mydef_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( hexstring par_1, timer par_2, float par_3 ) {}
    control {
	timer T_1;
	var bitstring T_2;
        MyFunc( '7AA'H, T_1, 6.2 );     // good
        MyFunc( 6.2, T_1, '7AA'H );     // error
        MyFunc( '7AA'H, T_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?timer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( charstring par_1 := 1, boolean par_2 := 1, integer par_3 := "r") {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc( charstring par_1, boolean par_2, integer par_3 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
        MyCompFunc( "r",true,2 );         // good
        MyCompFunc( "r",true,6.2 );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    function MyCompFunc( MyRec par ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
        MyCompFunc( {6,"r",true} );         // good
        MyCompFunc( {"r",true,6.2} );       // error
        MyCompFunc( 5 );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { charstring field }
    function MyCompFunc( address par_1, octetstring par_2 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
	    MyCompFunc( {"k"}, 'A5'O );     // good
	    MyCompFunc( 'A5'O, "k" );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    function MyCompFunc( template float par_1, template integer par_2 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
        MyCompFunc( MyTemp_1(6.3), MyTemp_2(6) );   // good
        MyCompFunc( 6.3, 6 );                       // good
        MyCompFunc( MyTemp_1(6), 6.9 );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc( bitstring par_1, MyCT par_2, float par_3 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
	var MyCT myct_1;
	var integer myct_2;
        MyCompFunc( '01001'B, myct_1, 6.2 );    // good
        MyCompFunc( 7.6, myct_1, '01001'B );    // error
        MyCompFunc( '01001'B, myct_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPortType message { inout integer }
    type component MyCT {
        port MyPortType port_1;
	var integer port_2;
    }
    function MyCompFunc( bitstring par_1, MyPortType par_2, float par_3 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
        MyCompFunc( '01001'B, port_1, 6.2 );    // good
        MyCompFunc( 7.6, port_1, '01001'B );    // error
        MyCompFunc( '01001'B, port_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?port.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc( hexstring par_1, default par_2, float par_3 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
	var default mydef_1;
	var charstring mydef_2;
        MyCompFunc( '7AA'H, mydef_1, 6.2 );     // good
        MyCompFunc( 6.2, mydef_1, '7AA'H );     // error
        MyCompFunc( '7AA'H, mydef_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Function_runs_on: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyCompFunc( hexstring par_1, timer par_2, float par_3 ) runs on MyCT {}
    function MyCompFunc1() runs on MyCT {
	timer T_1;
	var bitstring T_2;
        MyCompFunc( '7AA'H, T_1, 6.2 );     // good
        MyCompFunc( 6.2, T_1, '7AA'H );     // error
        MyCompFunc( '7AA'H, T_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?timer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc( charstring par_1, boolean par_2, integer par_3 );
    control {
        MyExtFunc( "r",true,2 );         // good
        MyExtFunc( "r",true,6.2 );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    external function MyExtFunc( MyRec par );
    control {
        MyExtFunc( {6,"r",true} );         // good
        MyExtFunc( {"r",true,6.2} );       // error
	MyExtFunc( 5 );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { charstring field }
    external function MyExtFunc( address par_1, octetstring par_2 );
    control {
	    MyExtFunc( {"k"}, 'A5'O );     // good
	    MyExtFunc( 'A5'O, "k" );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    external function MyExtFunc( template float par_1, template integer par_2 );
    control {
        MyExtFunc( MyTemp_1(6.3), MyTemp_2(6) );   // good
        MyExtFunc( 6.3, 6 );                       // good
        MyExtFunc( MyTemp_1(6), 6.9 );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    external function MyExtFunc( bitstring par_1, MyCT par_2, float par_3 );
    control {
	var MyCT myct_1;
	var integer myct_2;
        MyExtFunc( '01001'B, myct_1, 6.2 );    // good
        MyExtFunc( 7.6, myct_1, '01001'B );    // error
        MyExtFunc( '01001'B, myct_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPortType message { inout integer }
    type component MyCT {
        port MyPortType port_1;
	var integer port_2;
    }
    function MyCompFunc() runs on MyCT {
        MyExtFunc( '01001'B, port_1, 6.2 );    // good
        MyExtFunc( 7.6, port_1, '01001'B );    // error
        MyExtFunc( '01001'B, port_2, 6.2 );    // error
    }
    external function MyExtFunc( bitstring par_1, MyPortType par_2, float par_3 );
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?port.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc( hexstring par_1, default par_2, float par_3 );
    control {
	var default mydef_1;
	var charstring mydef_2;
        MyExtFunc( '7AA'H, mydef_1, 6.2 );     // good
        MyExtFunc( 6.2, mydef_1, '7AA'H );     // error
        MyExtFunc( '7AA'H, mydef_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc( hexstring par_1, timer par_2, float par_3 );
    control {
	timer T_1;
	var bitstring T_2;
        MyExtFunc( '7AA'H, T_1, 6.2 );     // good
        MyExtFunc( 6.2, T_1, '7AA'H );     // error
        MyExtFunc( '7AA'H, T_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?timer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->External Function: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->External Function: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    external function MyExtFunc( charstring par_1 := 1, boolean par_2 := 1, integer par_3 := "r")
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( charstring par_1, boolean par_2, integer par_3 ) {
        [else] {}
    }
    control {
        MyAltstep( "r",true,2 );         // good
        MyAltstep( "r",true,6.2 );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    altstep MyAltstep( MyRec par ) {
        [else] {}
    }
    control {
        MyAltstep( {6,"r",true} );         // good
        MyAltstep( {"r",true,6.2} );       // error
	MyAltstep( 5 );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { charstring field }
    altstep MyAltstep( address par_1, octetstring par_2 ) {
        [else] {}
    }
    control {
	    MyAltstep( {"k"}, 'A5'O );     // good
	    MyAltstep( 'A5'O, "k" );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    altstep MyAltstep( template float par_1, template integer par_2 ) {
        [else] {}
    }
    control {
        MyAltstep( MyTemp_1(6.3), MyTemp_2(6) );   // good
        MyAltstep( 6.3, 6 );                       // good
        MyAltstep( MyTemp_1(6), 6.9 );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAltstep( bitstring par_1, MyCT par_2, float par_3 ) {
        [else] {}
    }
    control {
	var MyCT myct_1;
	var integer myct_2;
        MyAltstep( '01001'B, myct_1, 6.2 );    // good
        MyAltstep( 7.6, myct_1, '01001'B );    // error
        MyAltstep( '01001'B, myct_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPortType message { inout integer }
    type component MyCT {
        port MyPortType port_1;
	var integer port_2;
    }
    function MyCompFunc() runs on MyCT {
        MyAltstep( '01001'B, port_1, 6.2 );    // good
        MyAltstep( 7.6, port_1, '01001'B );    // error
        MyAltstep( '01001'B, port_2, 6.2 );    // error
    }
    altstep MyAltstep( bitstring par_1, MyPortType par_2, float par_3 ) {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?port.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( hexstring par_1, default par_2, float par_3 ) {
        [else] {}
    }
    control {
	var default mydef_1;
	var charstring mydef_2;
        MyAltstep( '7AA'H, mydef_1, 6.2 );     // good
        MyAltstep( 6.2, mydef_1, '7AA'H );     // error
        MyAltstep( '7AA'H, mydef_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( hexstring par_1, timer par_2, float par_3 ) {
        [else] {}
    }
    control {
	timer T_1;
	var bitstring T_2;
        MyAltstep( '7AA'H, T_1, 6.2 );     // good
        MyAltstep( 6.2, T_1, '7AA'H );     // error
        MyAltstep( '7AA'H, T_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?timer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( charstring par_1 := 1, boolean par_2 := 1, integer par_3 := "r"){
      [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep( charstring par_1, boolean par_2, integer par_3 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
        MyCompAltstep( "r",true,2 );         // good
        MyCompAltstep( "r",true,6.2 );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    altstep MyCompAltstep( MyRec par ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
        MyCompAltstep( {6,"r",true} );         // good
        MyCompAltstep( {"r",true,6.2} );       // error
        MyCompAltstep( 5 );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { charstring field }
    altstep MyCompAltstep( address par_1, octetstring par_2 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
	    MyCompAltstep( {"k"}, 'A5'O );     // good
	    MyCompAltstep( 'A5'O, "k" );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    altstep MyCompAltstep( template float par_1, template integer par_2 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
        MyCompAltstep( MyTemp_1(6.3), MyTemp_2(6) );   // good
        MyCompAltstep( 6.3, 6 );                       // good
        MyCompAltstep( MyTemp_1(6), 6.9 );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep( bitstring par_1, MyCT par_2, float par_3 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
	var MyCT myct_1;
	var integer myct_2;
        MyCompAltstep( '01001'B, myct_1, 6.2 );    // good
        MyCompAltstep( 7.6, myct_1, '01001'B );    // error
        MyCompAltstep( '01001'B, myct_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: port type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port MyPortType message { inout integer }
    type component MyCT {
        port MyPortType port_1;
	var integer port_2;
    }
    altstep MyCompAltstep( bitstring par_1, MyPortType par_2, float par_3 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
        MyCompAltstep( '01001'B, port_1, 6.2 );    // good
        MyCompAltstep( 7.6, port_1, '01001'B );    // error
        MyCompAltstep( '01001'B, port_2, 6.2 );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?port.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep( hexstring par_1, default par_2, float par_3 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
	var default mydef_1;
	var charstring mydef_2;
        MyCompAltstep( '7AA'H, mydef_1, 6.2 );     // good
        MyCompAltstep( 6.2, mydef_1, '7AA'H );     // error
        MyCompAltstep( '7AA'H, mydef_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Altstep_runs_on: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyCompAltstep( hexstring par_1, timer par_2, float par_3 ) runs on MyCT {
        [else] {}
    }
    function MyCompFunc() runs on MyCT {
	timer T_1;
	var bitstring T_2;
        MyCompAltstep( '7AA'H, T_1, 6.2 );     // good
        MyCompAltstep( 6.2, T_1, '7AA'H );     // error
        MyCompAltstep( '7AA'H, T_2, 6.2 );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?timer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( charstring par_1, boolean par_2, integer par_3 ) runs on MyCT {}
    control {
        execute ( MyTestcase( "r",true,2 ) );         // good
        execute ( MyTestcase( "r",true,6.2 ) );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    testcase MyTestcase( MyRec par ) runs on MyCT {}
    control {
        execute ( MyTestcase( {6,"r",true} ) );         // good
        execute ( MyTestcase( {"r",true,6.2} ) );       // error
        execute ( MyTestcase( 5 ) );                    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    type record address { charstring field }
    testcase MyTestcase( address par_1, octetstring par_2 ) runs on MyCT {}
    control {
	    execute ( MyTestcase( {"k"}, 'A5'O ) );     // good
	    execute ( MyTestcase( 'A5'O, "k" ) );       // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    template float MyTemp_1( float par ) := par;
    template integer MyTemp_2( integer par ) := par;
    testcase MyTestcase( template float par_1, template integer par_2 ) runs on MyCT {}
    control {
        execute ( MyTestcase( MyTemp_1(6.3), MyTemp_2(6) ) );   // good
        execute ( MyTestcase( 6.3, 6 ) );                       // good
        execute ( MyTestcase( MyTemp_1(6), 6.9 ) );             // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( bitstring par_1, MyCT par_2, float par_3 ) runs on MyCT {}
    control {
	var MyCT myct_1;
	var integer myct_2;
        execute ( MyTestcase( '01001'B, myct_1, 6.2 ) );    // good
        execute ( MyTestcase( 7.6, myct_1, '01001'B ) );    // error
        execute ( MyTestcase( '01001'B, myct_2, 6.2 ) );    // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: default
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: default>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( hexstring par_1, default par_2, float par_3 ) runs on MyCT {}
    control {
	var default mydef_1;
	var charstring mydef_2;
        execute ( MyTestcase( '7AA'H, mydef_1, 6.2 ) );     // good
        execute ( MyTestcase( 6.2, mydef_1, '7AA'H ) );     // error
        execute ( MyTestcase( '7AA'H, mydef_2, 6.2 ) );     // error
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?hexstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?default.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Testcase: basic type as non-mandatory parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Testcase: basic type as non-mandatory parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTestcase( charstring par_1 := 1, boolean par_2 := 1, integer par_3 := "r") runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Signature: basic type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Signature: basic type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig( charstring par_1, boolean par_2, integer par_3 );
    type port MyPortType procedure { inout MySig }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        MyPort.call(MySig:{ "r",true,2 }, 20E-3 + 20E-3) {       //good
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ "r",true,2.6 }, 20E-3 + 20E-3) {     // error
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Signature: user-defined type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Signature: user-defined type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRec {
        integer    field1,
	charstring field2,
	boolean    field3
    }
    signature MySig( MyRec par );
    type port MyPortType procedure { inout MySig }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        MyPort.call(MySig:{ {6,"r",true} }, 20E-3 + 20E-3) {         // good
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ {"r",true,6.2} }, 20E-3 + 20E-3) {       // error
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 6 }, 20E-3 + 20E-3) {                    // error
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?boolean.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Signature: address type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Signature: address type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record address { charstring field }
    signature MySig( address par_1, octetstring par_2 );
    type port MyPortType procedure { inout MySig }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
        MyPort.call(MySig:{ {"k"}, 'A5'O }, 20E-3 + 20E-3) {       // good
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 'A5'O, "k" }, 20E-3 + 20E-3) {         // error
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Record.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::TypeMismatchActualFormalParameterList->Signature: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::TypeMismatchActualFormalParameterList->Signature: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    signature MySig( bitstring par_1, MyCT par_2, float par_3 );
    type port MyPortType procedure { inout MySig }
    type component MyComp {
        port MyPortType MyPort;
    }
    function MyFunc() runs on MyComp {
	var MyCT myct_1;
	var integer myct_2;
        MyPort.call(MySig:{ '01001'B, myct_1, 6.2 }, 20E-3 + 20E-3) {    // good
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ 7.6, myct_1, '01001'B }, 20E-3 + 20E-3) {    // error
            [] MyPort.getreply {}
        }
        MyPort.call(MySig:{ '01001'B, myct_2, 6.2 }, 20E-3 + 20E-3) {    // error
            [] MyPort.getreply {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?float.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?MyCT.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h2.All types shall be compatible with the type that is expected in the place where a type is expected
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/3.


.*---------------------------------------------------------------------*
:h2.Void return type in an expression
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/4.

The first few testcase below test functions with void return type in
expressions in each possible dynamic part. Then several other possible
expressions are tested with a function, testcase or altstep.

Expressions where functions cannot be used were not tested (e.g. halt,
getverdict, etc.).

.*---------------------------------------------------------------------*
:h3.Void return type - experession in control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - experession in control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

control {
  var integer FaultyInt4 := VoidRetType() + 4;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - experession in function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - experession in function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() + 1;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - experession in testcase
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - experession in testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component my_CT {
  timer T:=2.0;
}

function VoidRetType() { }

testcase TC() runs on my_CT
{
  var integer FaultyInt3 := VoidRetType() + 3;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - experession in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - experession in altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component my_CT {
  timer T:=2.0;
}

function VoidRetType() { }

altstep AS() runs on my_CT
{
  var integer FaultyInt2 := VoidRetType() + 2;
  []T.timeout { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - message based port operations
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - message based port operations>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MPort message {
  inout integer
}

type component MyComponent {
  port MPort mPort;
}

function VoidRetType() { }

testcase TC() runs on MyComponent {
  mPort.send(VoidRetType());
  mPort.receive(VoidRetType());
  mPort.trigger(VoidRetType());
  mPort.check(receive(VoidRetType()));
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - procedure based port operations
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - procedure based port operations>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception(integer);
template Sig tSig := { }

type port PPort procedure {
  inout Sig
}

type component MyComponent {
  port PPort pPort;
}

function VoidRetType() { }

testcase TC() runs on MyComponent {
  pPort.call(VoidRetType(), nowait);
  pPort.call(tSig, VoidRetType()) {
    []pPort.catch(timeout) { }
  }
  pPort.getreply(VoidRetType());
  pPort.getcall(VoidRetType());
  pPort.reply(VoidRetType());
  pPort.raise(Sig, VoidRetType());
  pPort.catch(Sig, VoidRetType());
  pPort.check(getreply(VoidRetType()));
}

}
<END_MODULE>
<RESULT COUNT 8>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - addition
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - addition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() + 10;
  var integer FaultyInt2 := 9 + VoidRetType();
  var float FaultyFloat1 := 3.14 + VoidRetType();
  var float FaultyFloat2 := VoidRetType() + 2.0;
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - subtraction
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - subtraction>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() - 10;
  var integer FaultyInt2 := 9 - VoidRetType();
  var float FaultyFloat1 := 3.14 - VoidRetType();
  var float FaultyFloat2 := VoidRetType() - 2.0;
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - multiplication
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - multiplication>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() * 10;
  var integer FaultyInt2 := 9 * VoidRetType();
  var float FaultyFloat1 := 3.14 * VoidRetType();
  var float FaultyFloat2 := VoidRetType() * 2.0;
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - division
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - division>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() / 10;
  var integer FaultyInt2 := 9 / VoidRetType();
  var float FaultyFloat1 := 3.14 / VoidRetType();
  var float FaultyFloat2 := VoidRetType() / 2.0;
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - modulo
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - modulo>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() mod 10;
  var integer FaultyInt2 := 9 mod VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - remainder
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - remainder>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt1 := VoidRetType() rem 10;
  var integer FaultyInt2 := 9 rem VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - string concatenation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - string concatenation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var charstring FaultyCS := "ABC" & VoidRetType() & "def";
  var bitstring FaultyBS := VoidRetType() & '0101'B;
  var hexstring FaultyHS := '123ABCD'H & VoidRetType();
  var octetstring FaultyOS := VoidRetType() & 'A5A5'O;
  var universal charstring FaultyUCS := "abc" & VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := objid { 1 2 3 } == VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - less then operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - less then operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := 0.0 < VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - greater then operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - greater then operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := -32 > VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - not equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - not equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := "ABC" != VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - greater then or equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - greater then or equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := 32.01 >= VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - less then or equal operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - less then or equal operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := VoidRetType() <= 99;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - logical not operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - logical not operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := not VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - logical and operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - logical and operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := VoidRetType() and true;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - logical or operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - logical or operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var boolean FaultyBool := false or VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - logical xor operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - logical xor operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType()
{ }

function Func()
{
  var boolean FaultyBool := VoidRetType() xor true;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - bitwise not operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - bitwise not operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt := not4b VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - bitwise and operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - bitwise and operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var bitstring FaultyBS := VoidRetType() and4b '0101'B;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - bitwise or operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - bitwise or operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType()
{ }

function Func()
{
  var octetstring FaultyOS := 'AA55'O or4b VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - bitwise xor operator
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - bitwise xor operator>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var hexstring FaultyHS := VoidRetType() xor4b '123'H;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - shift operators
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - shift operators>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var bitstring FaultyBS1 := '0011'B << VoidRetType();
  var bitstring FaultyBS2 := VoidRetType() >> 12;
  var hexstring FaultyHS := '123'H << VoidRetType();
  var octetstring FaultyOS := '1234'O << VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - rotate operators
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - rotate operators>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var bitstring FaultyBS1 := '0011'B <@ VoidRetType();
  var bitstring FaultyBS2 := VoidRetType() @> 12;
  var hexstring FaultyHS := '123'H <@ VoidRetType();
  var octetstring FaultyOS := '1234'O <@ VoidRetType();
  var charstring FaultyCS := "ABCDEF" <@ VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - assignment
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - assignment>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer FaultyInt := VoidRetType();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - logging
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - logging>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  log("VoidRetType() returned: ", VoidRetType());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - if/else statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - if/else statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  if(VoidRetType()) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - for loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - for loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  for(var integer Counter:=0; VoidRetType(); Counter:=Counter+1) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - while loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - while loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  while(VoidRetType()) { }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - do while loop
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - do while loop>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  do { } while(VoidRetType());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - array notation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - array notation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  var integer Int[3] := { 1, 2, 3 };
  var integer FaultyInt := Int[VoidRetType()];
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - start timer operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - start timer operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  timer T;
  T.start(VoidRetType());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - actual parameter
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - actual parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function FuncWithParam(in integer Par) { }

function Func()
{
  FuncWithParam(VoidRetType());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - alt guard
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - alt guard>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  timer T;
  T.start(1.0);
  alt {
    [VoidRetType()]T.timeout { }
  }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Void return type - setverdict
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Void return type - setverdict>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function VoidRetType() { }

function Func()
{
  setverdict(VoidRetType());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?expected.+?instead.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Functions and altsteps with different component type
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/5.

Functions, altsteps and testcases can have runs on clause. The testcases
below test the possible usage of these language elements: function
calling, starting a test component with a function, using altsteps
standalone or in alt statements and activating altsteps as default.

.*---------------------------------------------------------------------*
:h3.Different component type - function calling function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - function calling function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

function Fa() runs on A_CT {
  Ta.start;
}

function Fb() runs on B_CT {
  Fa();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs.+?on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - testcase calling function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - testcase calling function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

function Fa() runs on A_CT {
  Ta.start;
}

testcase TCb() runs on B_CT {
  Fa();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs.+?on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - altstep calling function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - altstep calling function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { timer Tb:=3.0; }

function Fa() runs on A_CT {
  Ta.start;
}

altstep TCb() runs on B_CT {
  []Tb.timeout { Fa(); }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs.+?on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - starting a component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - starting a component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

function Fa() runs on A_CT {
  Ta.start;
}

testcase TCb() runs on B_CT {
  var B_CT b_comp;
  b_comp.start(Fa());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)component.+?type.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - altstep in testcase
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - altstep in testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

altstep ASa() runs on A_CT {
  []Ta.timeout { }
}

testcase TCb() runs on B_CT {
  ASa();

  alt {
    []ASa();
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)runs on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - activating an altstep in testcase
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - activating an altstep in testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var default v_default; }

altstep ASa() runs on A_CT {
  []Ta.timeout { }
}

testcase TCb() runs on B_CT {
  v_default := activate(ASa());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - altstep in function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - altstep in function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

altstep ASa() runs on A_CT {
  []Ta.timeout { }
}

function Fb() runs on B_CT {
  ASa();

  alt {
    []ASa();
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)runs on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - activating an altstep in function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - activating an altstep in function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var default v_default; }

altstep ASa() runs on A_CT {
  []Ta.timeout { }
}

function TCb() runs on B_CT {
  v_default := activate(ASa());
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Different component type - altstep in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Different component type - altstep in altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component A_CT { timer Ta:=2.0; }

type component B_CT { var integer I:=3; }

altstep ASa() runs on A_CT {
  []Ta.timeout { }
}

altstep ASb() runs on B_CT {
  []ASa();
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)runs on.+?clause.+?mismatch
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Type list of a port
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/6.
Types used in port operations shall be listed in the type list of the
port definition.

.*---------------------------------------------------------------------*
:h3.Type list of a port - send basic types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - send basic types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyEnum { halflife1(1), halflife2(2) }
   // allow integer only and try to pass everything else
   type port MyPortType1 message { inout integer }
   type port MyPortType2 message { in float; out integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc_send() runs on MyComp {
      timer loc_timer;
      loc_timer.start(0.0027);
      MyPort1.send(666.0 + 1.9 + loc_timer.read);  // float
      MyPort1.send(loc_timer.running or false);    // boolean
      MyPort1.send(objid {0 4 0});                 // objid
      MyPort1.send(pass);                          // verdicttype
      //TR-674: Multiple error messages for send operation
      MyPort1.send(MyEnum:halflife2);                     // enumerated
      // not on the 'out' list
      MyPort2.send(666.0);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)integer.+?expected.+?instead.+?\bof\b.+?MyEnum
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - send string types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - send string types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyEnum { halflife1(1), halflife2(2) }
   // allow integer only and try to pass everything else
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   function MyFunc_send() runs on MyComp {
      MyPort1.send('0011'B & '1100'B & '1'B);      // bitstring
      MyPort1.send('AF07'H & 'FF'H);               // hexstring
      MyPort1.send('0123'O & 'FFE7'O);             // octetstring
      MyPort1.send("McHalls " & "was " & "here");  // charstring
      MyPort1.send("Damn!" & char(0,0,1,113));     // unicharstring
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?value.+?was.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - send other types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - send other types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyRecord { integer field1 }
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep() runs on MyComp {
      [] MyPort1.trigger {}
   }
   function MyFunc_send() runs on MyComp {
      var default MyWar := activate(MyAltstep());
      var MyRecord myRec := {1};
      MyPort1.send(self);                          // component ref
      MyPort1.send(MyWar);                         // default
      MyPort1.send(myRec);    	      	      	   // structured type
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - receive basic types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - receive basic types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyEnum { halflife1(1), halflife2(2) }
   // allow integer only and try to pass everything else
   type port MyPortType1 message { inout integer }
   type port MyPortType2 message { in float; out integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.receive(666.0 + 1.9) {};       	      	  // float
    [] MyPort1.receive(true or false) {};     	      	  // boolean
    [] MyPort1.receive(objid {0 4 0}) {};                 // objid
    [] MyPort1.receive(pass) {};                          // verdicttype
    [] MyPort1.receive(halflife2) {};                     // enumerated
    [] MyPort2.receive(666) {};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bno\b.+?definition.+?halflife2
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - receive string types
.*---------------------------------------------------------------------*

<TC - Type list of a port - receive string types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.receive('0011'B & '1100'B & '1'B) {};      // bitstring
    [] MyPort1.receive('AF07'H & 'FF'H) {};               // hexstring
    [] MyPort1.receive('0123'O & 'FFE7'O) {};             // octetstring
    [] MyPort1.receive("McHalls " & "was " & "here") {};  // charstring
    [] MyPort1.receive("Damn!" & char(0,0,1,113)) {};     // unicharstring
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?value.+?was.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - receive other types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - receive other types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyRecord { integer field1 }
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.receive(MyRecord:{ field1 := 0 }) {};      // nested type
    [] MyPort1.receive(self) {};                          // component ref
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - trigger basic types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - trigger basic types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyEnum { halflife1(1), halflife2(2) }
   // allow integer only and try to pass everything else
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_trigger() runs on MyComp {
    [] MyPort1.trigger(float:?) {};
    [] MyPort1.trigger(boolean:?) {};
    [] MyPort1.trigger(objid:?) {};
    [] MyPort1.trigger(verdicttype:?) {};
    [] MyPort1.trigger(MyEnum:?) {};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - trigger string types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - trigger string types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_trigger() runs on MyComp {
    [] MyPort1.trigger(bitstring:?) {};
    [] MyPort1.trigger(hexstring:?) {};
    [] MyPort1.trigger(octetstring:?) {};
    [] MyPort1.trigger(charstring:?) {};
    [] MyPort1.trigger(universal charstring:?) {};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - trigger other types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - trigger other types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyRecord { integer field1 }
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_trigger() runs on MyComp {
    [] MyPort1.trigger(MyRecord:?) {};
    [] MyPort1.trigger(MyComp:?) {};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - check-receive basic types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - check-receive basic types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type enumerated MyEnum { halflife1(1), halflife2(2) }
   // allow integer only and try to pass everything else
   type port MyPortType1 message { inout integer }
   type port MyPortType2 message { in float; out integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.check(receive(666.0 + 1.9)) {};       	      	  // float
    [] MyPort1.check(receive(true or false)) {};     	      	  // boolean
    [] MyPort1.check(receive(objid {0 4 0})) {};                 // objid
    [] MyPort1.check(receive(pass)) {};                          // verdicttype
    [] MyPort1.check(receive(halflife2)) {};                     // enumerated
    [] MyPort2.check(receive(666)) {};
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)float.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bno\b.+?definition.+?halflife2
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - check-receive string types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - check-receive string types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.check(receive('0011'B & '1100'B & '1'B)) {};      // bitstring
    [] MyPort1.check(receive('AF07'H & 'FF'H)) {};               // hexstring
    [] MyPort1.check(receive('0123'O & 'FFE7'O)) {};             // octetstring
    [] MyPort1.check(receive("McHalls " & "was " & "here")) {};  // charstring
    [] MyPort1.check(receive("Damn!" & char(0,0,1,113))) {};     // unicharstring
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)integer.+?value.+?was.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Type list of a port - check-receive other types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Type list of a port - check-receive other types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyRecord { integer field1 }
   type port MyPortType1 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   altstep MyAltstep_receive() runs on MyComp {
    [] MyPort1.check(receive(MyRecord:{ field1 := 0 })) {};      // nested type
    [] MyPort1.check(receive(self)) {};                          // component ref
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)integer.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Signature list of a port
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-5/7.
Signatures used in port operations shall be listed in the signature list
of the port definition.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - call operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - call operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      MyPort1.call(Sig1:{});
      // not on the 'out' list
      MyPort2.call(Sig2:{},1.0) {
      	[]MyPort2.catch(timeout) { }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - getcall operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - getcall operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
         [] MyPort1.getcall(Sig1:{}) { }
	 [] MyPort2.getcall(Sig1:{}) { }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - reply operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - reply operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      MyPort1.reply(Sig1:{});
      MyPort2.reply(Sig1:{});
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - getreply operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - getreply operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
         [] MyPort1.getreply(Sig1:{}) {}
         [] MyPort2.getreply(Sig2:{}) {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - raise operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - raise operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      MyPort1.raise(Sig1, 3);
      MyPort2.raise(Sig1, 4);
      // not listed exception:
      MyPort1.raise(Sig2, 3.14);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)signature.+?not.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - catch operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - catch operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
        []MyPort1.catch(Sig1, 9) { }
	[]MyPort2.catch(Sig2, 10) { }
	// not listed exception:
	[]MyPort1.catch(Sig2, 9.99) { }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)signature.+?not.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - check-getcall operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - check-getcall operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
         [] MyPort1.check(getcall(Sig1:{})) { }
	 [] MyPort2.check(getcall(Sig1:{})) { }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - check-getreply operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - check-getreply operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
         [] MyPort1.check(getreply(Sig1:{})) {}
         [] MyPort2.check(getreply(Sig2:{})) {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)incompatible.+?explicit.+?type.+?specification
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signature list of a port - check-catch operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signature list of a port - check-catch operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature Sig1() exception(integer);
   signature Sig2() noblock exception(integer);
   type port MyPortType1 procedure { inout Sig2 }
   type port MyPortType2 procedure { in Sig2; out Sig1 }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   // not listed signature for procedure based ops
   function MyFunc_ProcedureBased() runs on MyComp {
      alt {
        []MyPort1.check(catch(Sig1, 9)) { }
	[]MyPort2.check(catch(Sig2, 10)) { }
	// not listed exception:
	[]MyPort1.check(catch(Sig2, 9.99)) { }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)signature.+?not.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Address port - connect operation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Address port - connect operation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyAddressType { // user-defined type
    integer field1,
    boolean field2
    } 

    type MyAddressType address;

    type integer MyMessType;

    type port PortType message {
    //  address MyAddress;
    inout MyMessType;
    } with {extension "address"};
            
    type component TestCaseComp {
    port PortType p;
    var address v_addr:= {5, true}
    }

    testcase tc_connect() runs on TestCaseComp system TestCaseComp {

        var TestCaseComp v_ptcA := TestCaseComp.create alive;
        connect(self:p, v_ptcA:p);
        connect(v_ptcA:p, self:p);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 4>
(?im)address.+?port.+?cannot.+?used.+?connect
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Bitstring concatenation - type restriction on result but not on parameters
.*---------------------------------------------------------------------*
Note: this is a positive test.

:xmp tab=0.

<TC - Bitstring concatenation - type restriction on result but not on parameters>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

  type bitstring B32_Type length(32);
  type bitstring B128_Type length(128);
  type bitstring B256_Type length(256);
  
  const B32_Type tsc_UndefinedB32 := oct2bit ('FFFFFFFF'O);
  const B128_Type tsc_UndefinedB128 := tsc_UndefinedB32 & tsc_UndefinedB32 & tsc_UndefinedB32 & tsc_UndefinedB32;
  const B256_Type tsc_UndefinedB256 := tsc_UndefinedB128 & tsc_UndefinedB128;

}
<END_MODULE>
<RESULT>
(?im)\bnotify\b.+?\bfiles\b.+?\bupdated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 22 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

