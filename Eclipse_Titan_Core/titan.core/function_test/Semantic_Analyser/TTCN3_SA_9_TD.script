.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Raduly, Csaba
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*   Szalai, Gabor
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.xx/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Other requirements
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2005-02-19   ETHGASZ    New document for TITAN R6
A     2005-03-18   ETHGASZ    Approved after review
B     2005-08-16   ETIBHRA    New req. added (SA-9/18,19,20)
C     2007-03-06   EJNOSZA    Updates for TITAN R7A (expected error messages for identifier overloading)
D     2007-06-08   EJNOSZA    Updates for TITAN R7B (expected error messages for identifier overloading)
E     2008-10-01   EKRISZA    Updates for TITAN R7E
F     2010-01-18   EKRISZA    Updated for TITAN R8C
K     2011-10-10   EKRISZA    Updated for TITAN R8H
A     2011-12-12   EKRISZA    Updated for release
A     2012-06-27   EFERKOV    Updated for release
A     2013-01-17   EKRIPND    Updated for release
A	  2015-04-27   ETHBAAT    Updated for release
:exmp.

.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-9/x: Other requirements.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h2.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Module Parameters->Redeclaration of a module parameter SA-9/1
.*---------------------------------------------------------------------*
Requirement: Redeclaration of a module parameter.
:nl.Explanation:
:nl.Redefinition of the module parameter is not allowed.
:nl.
.*---------------------------------------------------------------------*
:h4.Module Parameters->Redeclaration of a module parameter with a different type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Module Parameters->Redeclaration of a module parameter with a different type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   modulepar {
      integer MyTSP1;
      integer MyTSP2 := 10;
      boolean MyTSP1 := false;
      boolean MyTSP2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?duplicate.+?definition.+?MyTSP
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnote\b.+?previous.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Module Parameters->Redeclaration of a module parameter in a different group
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Module Parameters->Redeclaration of a module parameter in a different group>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   modulepar {
      integer MyTSP1;
      integer MyTSP2 := 10;
   }
   modulepar {
      boolean MyTSP1 := false;
      boolean MyTSP2
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?duplicate.+?definition.+?MyTSP
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnote\b.+?previous.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Signatures->Duplicate exception type in a signature SA-9/2
.*---------------------------------------------------------------------*
Requirement: Duplicate exception type in a signature.
:nl.Explanation:
:nl.One or more exception type is listed in a signature more than once.
.*---------------------------------------------------------------------*
:h4.Signatures->Duplicate exception type in a signature
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Signatures->Duplicate exception type in a signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature s() noblock
      exception (
      bitstring, boolean, charstring, universal charstring,
      integer, octetstring, objid, hexstring, verdicttype, float,
      bitstring, boolean, charstring, universal charstring,
      integer, octetstring, objid, hexstring, verdicttype, float);
}
<END_MODULE>
<RESULT IF_PASS COUNT 10>
(?im)\berror\b.+?duplicate.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 10>
(?im)\bnote\b.+?already.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 10>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Signatures-> 'all' shall not be mixed with additional names SA-9/2
.*---------------------------------------------------------------------*
Requirement: 'all' shall not be mixed with additional names in one list.
:nl.Explanation:
:nl.Becasue the 'all' is not supported currently, it can not be tested.
.*---------------------------------------------------------------------*
:h3.Import-> Duplicated module reference in import statements SA-9/3
.*---------------------------------------------------------------------*
Requirement: Duplicated module reference in import statements.
:nl.Explanation:
:nl.A module name is listed more than once to import from.
.*---------------------------------------------------------------------*
:h4.Import->Duplicated module reference in import statements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Import->Duplicated module reference in import statements>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  import from ModuleB all;
  import from ModuleB all;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
  type integer Myint;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)Notify: File `ModuleA.hh' was generated.
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.No signatures in the test suite when using 'all' in port definition SA-9/4
.*---------------------------------------------------------------------*
Requirement: No signatures in the test suite when using 'all' in port
definition.
:nl.Explanation:Using the all keyword in one of the lists associated to a
:nl.port type allows all of signatures defined in the module to be
:nl.received and sent over port. SA shall detect the cases when no
:nl.signatures are defined in the test suite, but receive-like port
:nl.operations (e.g. getcall, getreply, catch) are used.
:nl.NOTE:Because the 'all' is not supported currently, it can not be tested.
:nl.NOTE:TR698
.*---------------------------------------------------------------------*
:h4.No signatures in the test suite when using 'all' in port definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - No signatures in the test suite when using 'all' in port definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 procedure { inout all}
   type component MyComp {
      port MyPortType1 MyPort1;
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Communication operations->Port operation when no ports defined 9/5
.*---------------------------------------------------------------------*
Requirement: Port operation when no ports defined.
:nl.Explanation:
:nl.Port operations on a component that has no ports defined shall be
:nl.detected.
.*---------------------------------------------------------------------*
:h4.Communication operations->Port operation when no ports defined
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Communication operations->Port operation when no ports defined>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig() noblock;
   type component MyComp {
      var integer MyVar;
      var MyComp MyWar1;
   }
   // TR 699: Port and timer operation when no ports or timer defined
	altstep MyAltstep() runs on MyComp {
      [] any port.receive { setverdict(fail); }
      [] any port.trigger { setverdict(fail); }
      [] any port.getcall { setverdict(fail); }
      [] any port.getreply { setverdict(fail); }
      [] any port.catch { setverdict(fail); }
      [] any port.check(-> sender MyWar1) { setverdict(fail); }
      [] any port.check(receive) { setverdict(fail); }
      [] any port.check(getcall) { setverdict(fail); }
      [] any port.check(getreply) { setverdict(fail); }
      [] any port.check(catch) { setverdict(fail); }
      [else] {
         all port.stop;
         all port.start;
         all port.clear;
   all timer.stop;
      }
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Timer operations when no timers defined SA-9/6
.*---------------------------------------------------------------------*
Requirement: Timer operations when no timers defined.
:nl.Explanation:
:nl.Timer operations shall be handled correctly if no timers are defined.
.*---------------------------------------------------------------------*
:h4.Timer operations when no timers defined
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Timer operations when no timers defined>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function MyFunc1() runs on MyComp {
      // valid
      all timer.stop;
      // TR 699: Port and timer operation when no ports or timer defined
		// would block forever
      any timer.timeout;
      if (any timer.running) { setverdict(fail); }
      else { setverdict(pass); }
   }
   testcase MyTC() runs on MyComp {
      MyFunc1();
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Import-> Import from the same module SA-9/7
.*---------------------------------------------------------------------*
Requirement: Import from the same module.
:nl.Explanation:
:nl.A module cannot import from itself.
.*---------------------------------------------------------------------*
:h4.Import->Import from the same module
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Import->Import from the same module>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  import from ModuleA all;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?\bimport\b.+?\bitself\b
<END_RESULT>
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Functions->Return value SA-9/8
.*---------------------------------------------------------------------*
Requirement: Functions->Return value.
:nl.Explanation:
:nl.The keyword return, when used in the body of the function with a
:nl.return type defined in its header, always shall be followed by a value,
:nl.a constant or variable reference or an expression presenting the return
:nl.value.
.*---------------------------------------------------------------------*
:h4.Functions->Return value if no return type defined
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Functions->Return value if no return type defined>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // no return value, but try to return an actual value
   // catched by the parser curently
   function MyFunc1() { if(true) {return '11A7'O;}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?function.+?not.+?have.+?return.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->Missing return value, but return type defined
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Functions->Missing return value, but return type defined>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   // missing return value
   // catched by the parser
   function MyFunc1() return float {if(true) {return;}}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?missing.+?return.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror.+?control.+?might.+?leave.+?without.+?reaching.+?return.+?statement
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->Missing return value, but return type defined indirect case 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->Missing return value, but return type defined indirect case 1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1() {return;}
   function MyFunc2(integer par) return integer {return (par + 10);}
   function MyFunc3() return float {
      if(true) {return MyFunc1();}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror.+?control.+?might.+?leave.+?without.+?reaching.+?return.+?statement
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bexpected\b.+?\bfunction\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->Missing return value, but return type defined indirect case 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->Missing return value, but return type defined indirect case 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1() {return;}
   function MyFunc2(integer par) return integer {return (par + 10);}
   function MyFunc4() return float {
      if(true) {return int2float( MyFunc2(MyFunc1() ));}
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror.+?control.+?might.+?leave.+?without.+?reaching.+?return.+?statement
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bexpected\b.+?\bfunction\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->Missing return value, but return type defined indirect case 3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Functions->Missing return value, but return type defined indirect case 3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc1() {return;}
   control {
      // void return value is not allowed in expression
      var integer MyVar := 666 + MyFunc1() - 666;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bexpected\b.+?\bfunction\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Functions->runs on clause SA-9/9
.*---------------------------------------------------------------------*
Requirement: Functions->runs on clause.
:nl.Explanation:
:nl.A function without runs on clause shall never invoke a function or
:nl.altstep or activate an altstep as default with a runs on clause locally.
:nl.Functions started by using the start test component operation shall
:nl.always have a runs on clause.
:nl.Functions used in the control part of a TTCN-3 module shall have no
:nl.runs on clause.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, referencing to a functions with runs on
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->runs on clause, referencing to a functions with runs on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp() runs on MyComp {return;}
   function NastyFunc01() {
      if (true) { MyFunc_comp(); }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, referencing to an altstep with runs on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Functions->runs on clause, referencing to an altstep with runs on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep_comp() runs on MyComp { [] MyPort.trigger {} }
   function NastyFunc02(inout MyPortType loc_port) {
      if (true) {
         alt {
            [] loc_port.trigger {}
            [] MyAltstep_comp();
         }
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, referencing to a func with runs on,indirect call
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->runs on clause, referencing to a func with runs on,indirect call>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp2() runs on MyComp return integer {return 0;}
   function MyCoolFunction1 (integer par) return integer {return par;}
   function NastyFunc03() return float {
      if (true) { return int2float( MyCoolFunction1(MyFunc_comp2()) ); }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror.+?control.+?might.+?leave.+?without.+?reaching.+?return.+?statement
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, default activation/deactivation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->runs on clause, default activation/deactivation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep_comp() runs on MyComp { [] MyPort.trigger {} }
   function NastyFunc04() {
      var default MyDef := activate(MyAltstep_comp());
      deactivate(MyDef);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bactivate\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, start operations
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->runs on clause, start operations>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp3(integer par) runs on MyComp {}
   function MyFunc_nocomp() {}
   function MyFunc_nocomp2(integer par) return integer { return 0; }
   function MyFunc1() {
      var MyComp MyComponent := MyComp.create;
      var MyComp MyComponent2 := MyComp.create;
      MyComponent.start(MyFunc_nocomp());
      // this should be ok however
      MyComponent2.start(MyFunc_comp3(MyFunc_nocomp2(666)));
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bstarted\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, function called from a template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Functions->runs on clause, function called from a template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp2() runs on MyComp return integer {return 0;}
   template integer MyTemplate := MyFunc_comp2();
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Functions->runs on clause, functions in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Functions->runs on clause, functions in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp() runs on MyComp {return;}
   function MyFunc_comp2() runs on MyComp return integer {return 0;}
   function MyCoolFunction1 (integer par) return integer {return par;}
   control {
      var integer MyVar;
      if (true) {
         MyFunc_comp();
         MyVar := MyCoolFunction1(MyFunc_comp2());
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Altsteps->runs on clause SA-9/9
.*---------------------------------------------------------------------*
Requirement: Altsteps->runs on clause (16.1.0).
:nl.Explanation:
:nl.An altstep without runs on clause shall never invoke a function or
:nl.altstep or activate an altstep as default with a runs on clause locally.
.*---------------------------------------------------------------------*
:h4.Altsteps->runs on clause, referencing to an altstep() with runs on
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Altsteps->runs on clause, referencing to an altstep() with runs on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep_comp() runs on MyComp { [] MyPort.trigger {} }

   altstep NastyAltstep01(inout MyPortType loc_port) {
      [] loc_port.trigger {}
      [] MyAltstep_comp();
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Altsteps->runs on clause, referencing to a function() with runs on
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Altsteps->runs on clause, referencing to a function() with runs on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   function MyFunc_comp() runs on MyComp {}

   altstep NastyAltstep02(inout MyPortType loc_port) {
      [] loc_port.trigger { MyFunc_comp(); }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bcall\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Altsteps->runs on clause, default activation/deactivation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Altsteps->runs on clause, default activation/deactivation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort }
   altstep MyAltstep_comp() runs on MyComp { [] MyPort.trigger {} }

   altstep NastyAltstep03(inout MyPortType loc_port) {
      var default MyDef := activate(MyAltstep_comp());
      [] loc_port.trigger { deactivate(MyDef); }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bcannot\b.+?\bactivate\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Goto statement SA-9/10
.*---------------------------------------------------------------------*
Requirement: Goto statement.
:nl.Explanation:
:nl. - It is not allowed to jump out of or into functions, test cases,
:nl.   altsteps and the control part of a TTCN-3 module
:nl. - It is not allowed to jump into a sequence of statements defined in
:nl.   a compound statement (i.e. alt statement, while loop, for loop,
:nl.   if-else statement, do- while loop and the interleave statement)
:nl. - It is not allowed to use the goto statement within an interleave
:nl.   statement (see the SA-9/20)
:nl. NOTE: the first is covered by scopes implicitly
.*---------------------------------------------------------------------*
:h4.Goto statement, jump into alt statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump into alt statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   control {
      timer Timy;
      var float b;
      var integer locpar;
      Timy.start(1.0);
      alt {
         [b<1.0] Timy.timeout {
            label Label01;
            locpar := locpar + 1; }
      }
      goto Label01;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bnot\b.+?\bdefined\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Goto statement, jump into if-else statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump into if-else statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   control {
      var integer locpar;
      if (true) { label Label04; locpar := 666; }
      else { label Label05; locpar := -666; }
      goto Label04;
      goto Label05;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\blabel\b.+?\bused\b.+?\bnot\b.+?\bdefined\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Goto statement, jump into while statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump into while statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   control {
      var integer locpar;
         while (false) {
            label Label02;
            locpar := 0;
         }
      goto Label02;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bnot\b.+?\bdefined\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Goto statement, jump into do-while statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump into do-while statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   control {
      var integer locpar;
         do {
            label Label02;
            locpar := 0;
         } while (false)
      goto Label02;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bnot\b.+?\bdefined\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Goto statement, jump into for statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump into for statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   control {
      var integer locpar;
         for(var integer j:=1; j<10; j:=j+1) {
            label Label02;
            locpar := 0;
         }
      goto Label02;
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bnot\b.+?\bdefined\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Goto statement, jump over the variable definition case 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump over the variable definition case 1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
function myFunc()
{
  goto L;
  var integer i := 0;
  label L;
  i := i + 1;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?\bJump\b.+?\bcrosses\b
<END_RESULT>
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h4.Goto statement, jump over the variable definition case 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Goto statement, jump over the variable definition case 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
function myFunc(integer par)
{
  for (var integer i := 0; i < 10; i := i + 1) {
    if (i + par > 10) {
      goto L;
      var integer myint1;
    }
    var integer myint2;
  }
  var integer myint3;
  label L;
}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?\bJump\b.+?\bcrosses\b
<END_RESULT>
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Stop operation SA-9/11
.*---------------------------------------------------------------------*
Requirement: Stop operation.
:nl.Explanation:
:nl.The stop statement terminates execution in different ways depending
:nl.on the context in which it is used. When used in the control part of
:nl.a module or in a function used by the control part of a module, it
:nl.terminates the execution of the module control part.
:nl.NOTE: therefore, self.stop shall be detected in the control part or
:nl.function/altstep without runs on clause.
.*---------------------------------------------------------------------*
:h4.Stop operation in altstep without runs on clause
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Stop operation in altstep without runs on clause>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   altstep MyAltstep(inout timer T) {
      [] T.timeout { self.stop; }
   }
}
<END_MODULE>

<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Stop operation in function without runs on clause
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Stop operation in function without runs on clause>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   function MyFunc() {
      log("Dummy");
      self.stop;
   }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Stop operation in control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Stop operation in control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   control {
      if (false) { stop; }
      else { self.stop; }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bself\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bComponent\b.+?\boperation\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Sending/receiving local component definitions SA-9/12
.*---------------------------------------------------------------------*
Requirement: Sending/receiving local component definitions.
:nl.Explanation:
:nl.Data types containing information that is only valid within the same
:nl.component type (e.g. default references) are called local data types.
:nl.These types cannot be sent or received via ports.
.*---------------------------------------------------------------------*
:h4.Sending local component definitions
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Sending local component definitions>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyStruct { integer field1, default field2 }
   type port MyPortType message { inout MyStruct }
   type component MyComp1 { port MyPortType MyPort; }

   altstep MyDefault(inout MyPortType loc_port) {
      [] loc_port.trigger { }
      [else] {}
   }
   function MyFunc1() runs on MyComp1 {
      var MyStruct MyWar := { field1 := 0, field2 := activate(MyDefault(MyPort)) }
      MyPort.send(MyWar);
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Receiving local component definitions
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Receiving local component definitions>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type record MyStruct { integer field1, default field2 }
   type port MyPortType message { inout MyStruct }
   type component MyComp2 { port MyPortType MyPort; }

   altstep MyDefault(inout MyPortType loc_port) {
      [] loc_port.trigger { }
      [else] {}
   }
   function MyFunc2() runs on MyComp2 {
      var MyStruct MyWar := { field1 := 0, field2 := activate(MyDefault(MyPort)) }
      alt {
		[] MyPort.receive(?) -> value MyWar { deactivate(MyWar.field2); }
      }
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Activate->Timers in the parameter list of an activated altstep SA-9/13
.*---------------------------------------------------------------------*
Requirement: Timers in the parameter list of an activated altstep.
:nl.Explanation:
:nl.All timer instances in the actual parameter list shall be declared as
:nl.component type local timers.
.*---------------------------------------------------------------------*
:h4.Activate->Timers in the parameter list of an activated altstep with runs on
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Activate->Timers in the parameter list of an activated altstep with runs on>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort; }

   altstep MyAltstep1(inout MyPortType loc_port, inout timer loc_timer)
      runs on MyComp {
      [] loc_port.trigger { }
      [] loc_timer.timeout { }
      [else] { }
   }
   function MyFunc() runs on MyComp {
      timer loc_timer;
      // TR 700: SA-1.69Timers and variables passed by reference in the parameter list of an activated altstep
		activate(MyAltstep1(MyPort, loc_timer));
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bParameter\b.+?\brefers\b.+?\blocal\b
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Activate->Timers in the parameter list of an activated altstep without runs on
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Activate->Timers in the parameter list of an activated altstep without runs on>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType message { inout integer }
   type component MyComp { port MyPortType MyPort; }

   altstep MyAltstep2(inout MyPortType loc_port, inout timer loc_timer) {
      [] loc_port.trigger { }
      [] loc_timer.timeout { }
      [else] { }
   }
   function MyFunc() runs on MyComp {
      timer loc_timer;
      // TR 700: SA-1.69Timers and variables passed by reference in the parameter list of an activated altstep
		activate(MyAltstep2(MyPort, loc_timer));
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\bParameter\b.+?\brefers\b.+?\blocal\b
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Communication operations->Exceptions timeout SA-9/14
.*---------------------------------------------------------------------*
Requirement: Exceptions.
:nl.Explanation:
:nl.  Catching timeout exceptions shall be restricted to the exception
:nl.handling part of a call. No further matching criteria (including a
:nl.from part) and no assignment part is allowed for a catch operation
:nl.that handles a timeout exception.
.*---------------------------------------------------------------------*
:h4.Communication operations->Exceptions->Timeout with assignment
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Communication operations->Exceptions->Timeout with assignment>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig_block();
   type port MyPortType1 procedure { inout MySig_block}
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   function MyAltstep1(MyComp loc_par) runs on MyComp {
      var MyComp MyWar1;
      MyPort1.call(MySig_block:{},20E-3) {
        [] MyPort1.catch(timeout)  -> sender MyWar1 {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.Communication operations->Exceptions->Timeout with from statement
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Communication operations->Exceptions->Timeout with from statement>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig_block();
   type port MyPortType1 procedure { inout MySig_block}
   type component MyComp {
      port MyPortType1 MyPort1;
   }
   function MyAltstep1(MyComp loc_par) runs on MyComp {
      var MyComp MyWar1;
      MyPort1.call(MySig_block:{},20E-3) {
        [] MyPort1.catch(timeout) from self {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Verdict operations SA-9/15
.*---------------------------------------------------------------------*
Requirement: Verdict operations.
:nl.Explanation:
:nl.The setverdict operation shall only be used with the values pass,
:nl.fail, inconc and none.
:nl.NOTE only the direct assignments can be checked by SA.
.*---------------------------------------------------------------------*
:h4.Verdict operations
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Verdict operations>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type component MyComp {}
   function MyFunc1() runs on MyComp {
      setverdict(error);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\bError\b.+?\bverdict\b.+?\bset\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Checking of ports on connect and map operations SA-9/17
.*---------------------------------------------------------------------*
Requirement: Invalid value is used as component reference.
:nl.Explanation:
:nl.If a messages/signature can be sent/called on one of the ports of a
:nl.map or connect operation, it has to be listed in the in or inout list
:nl.of the other port.
.*---------------------------------------------------------------------*
:h4.Connect operation, incorrect port type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Connect operation, incorrect port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig();
   type port MyPortType1 message { inout boolean }
   type port MyPortType2 procedure { inout MySig }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc1() runs on MyComp {
      connect(self:MyPort1,self:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bconnection\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Connect operation, incorrect signature list case 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Connect operation, incorrect signature list case 1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig();
   signature MySig2();
   type port MyPortType1 procedure { inout MySig,MySig2 }
   type port MyPortType2 procedure { inout MySig }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc1() runs on MyComp {
      connect(self:MyPort1,self:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bconnection\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Connect operation, incorrect signature list case 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Connect operation, incorrect signature list case 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig();
   signature MySig2();
   type port MyPortType1 procedure { out MySig,MySig2 }
   type port MyPortType2 procedure {  in MySig2 out MySig }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc1() runs on MyComp {
      connect(self:MyPort1,self:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bconnection\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Map operation, incorrect signature list case 3
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Map operation, incorrect signature list case 3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   signature MySig();
   signature MySig2();
   type port MyPortType1 procedure { out MySig,MySig2 }
   type port MyPortType2 procedure {  in MySig2 out MySig }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   testcase MyFunc1() runs on MyComp {
      map(self:MyPort1,system:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bmapping\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Connect operation, incorrect variable list case 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Connect operation, incorrect variable list case 1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { inout integer,octetstring }
   type port MyPortType2 message { inout integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc1() runs on MyComp {
      connect(self:MyPort1,self:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bconnection\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Connect operation, incorrect variable list case 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Connect operation, incorrect variable list case 2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { out integer,octetstring }
   type port MyPortType2 message {  in octetstring out integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   function MyFunc1() runs on MyComp {
      connect(self:MyPort1,self:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bconnection\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h4.Map operation, incorrect variable list case 3
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Map operation, incorrect variable list case 3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type port MyPortType1 message { out integer,octetstring }
   type port MyPortType2 message {  in octetstring out integer }
   type component MyComp {
      port MyPortType1 MyPort1;
      port MyPortType2 MyPort2;
   }
   testcase MyFunc1() runs on MyComp {
      map(self:MyPort1,system:MyPort2);
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bmapping\b.+?\bnot\b.+?\bconsistent\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bnot\b.+?\bpresent\b
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

:p.
.*---------------------------------------------------------------------*
:h3.The Select Case statement
.*---------------------------------------------------------------------*
:nl.This test case group covers the requirement SA-9/18.
:p. Explanation:
:nl.- All templateInstance in all list branches shall be of a type compatible
      with the type of the expression in the header. A list branch is selected
      and the block of statements of the selected branch is executed only, if
      any of the templateInstance matches the value of the expression in the
      header of the statement. On executing the block of statements of the
      selected branch (i.e. not jumping out by a go to statement), execution
      continues with the statement following the select case statement.
:nl.- The block of statements of an else branch is always executed if no other
      branch textually preceding the else branch has been selected.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->control part: with integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->control part: with integer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (0)   { vl_int := tsp_int + 10; }
            case (1,3) { vl_int := tsp_int + 100; }
            case (5,9) { vl_int := tsp_int + 1000; }
            case else  { vl_int := tsp_int + 2000 }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->else branch: not at the end
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->else branch: not at the end>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (0)   { vl_int := tsp_int + 10; }
            case (1,3) { vl_int := tsp_int + 100; }
            case else  { vl_int := tsp_int + 2000 }
            case (5,9) { vl_int := tsp_int + 1000; }
            case else  { vl_int := tsp_int + 2000 }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\bwarning\b.+?Control.+?never.+?reaches.+?previous
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->expression: timer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->expression: timer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component CT {}
    testcase TC() runs on CT {
        timer vl_T := 5.6;
        select (vl_T)
        {
            case (0.4,1.2) { setverdict(pass); }
            case else { setverdict(fail); }
        }
    }
    control { execute(TC()); }
}
//error: Reference to a value was expected instead of timer `vl_T1'
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Reference.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->control part: octetstring instead of integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->control part: octetstring instead of integer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 3;
    }
    control {
        var integer vl_int := 0;
        var charstring vl_charstr := "ja";
        select (tsp_int)
        {
            case (0)
                { vl_int := tsp_int + 10; }
            case (1, 3, vl_charstr)
                { vl_int := tsp_int + 100; }
            case (5, 9, 'A5'O, vl_int)
                { vl_int := tsp_int + 1000; }
            case else
                { vl_int := tsp_int + 2000 }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?integer.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?integer.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->function: bitstring instead of charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->function: bitstring instead of charstring>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 3;
    }
    function F( in charstring charstr ) return integer
    {
        var integer vl_int := 0;
        var charstring vl_charstr := "ja";
        select (charstr)
        {
            case ("sdf")
                { vl_int := tsp_int + 10; }
            case ("ha", vl_charstr)
                { vl_int := tsp_int + 100; }
            case ("huha", "aha", '111010111'B)
                { vl_int := tsp_int + 1000; }
            case else
                { vl_int := tsp_int + 2000 }
        }
        return vl_int;
    }

    control
    {
        var integer vl_int := -1;
        select (tsp_int)
        {
            case (0)        { vl_int := F("sdf"); }
            case (3,vl_int) { vl_int := F("ja"); }
            case (5,9)      { vl_int := F("aha"); }
            case else       { vl_int := F("sdfuu"); }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?character string.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->altstep: float instead of octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->altstep: float instead of octetstring>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 3;
    }
    altstep A( in octetstring octet )
    {
        var integer vl_int := 0;
        var octetstring vl_octet := 'AB56FF'O;
        [else] {
            select (octet & 'FF'O)
            {
                case ('1F'O & 'FF'O)
                    { vl_int := tsp_int + 10; }
                case ('A9'O, vl_octet)
                    { vl_int := tsp_int + 100; }
                case ('C5'O, 'CC'O, 5.6)
                    { vl_int := tsp_int + 1000; }
                case else
                    { vl_int := tsp_int + 2000 }
            }
            log("Result:  ", vl_int);
        }
    }
    control
    {
        var integer vl_int := -1;
        select (tsp_int)
        {
            case (0)        { A('FF'O); }
            case (3,vl_int) { A('A9'O); }
            case (5,9)      { A('CC'O); }
            case else       { A('1F'O); }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->function_runs_on: float instead of integer
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->function_runs_on: float instead of integer>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        float tsp_float := 1.9;
        integer tsp_int := 3;
    }
    type component CT {}
    function F() runs on CT return integer
    {
        var integer vl_int := 0;
        var float vl_float := 0.8;
        select (float2int(tsp_float) * tsp_int)
        {
            case (5 * float2int(vl_float))
                { vl_int := tsp_int + 10; }
            case (3, vl_float)
                { vl_int := tsp_int + 100; }
            case (6, 10, 7)
                { vl_int := tsp_int + 1000; }
            case else
                { vl_int := tsp_int + 2000; }
        }
        return vl_int;
    }
    testcase TC() runs on CT
    {
        log("Result:  ", F());
    }
    control { execute ( TC() ); }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?integer.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->altstep_runs_on: octet instead of bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->altstep_runs_on: octet instead of bitstring>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 9;
        bitstring tsp_bitstring := '11010'B;
    }
    type component CT {}
    altstep A() runs on CT
    {
        var integer vl_int;
        var bitstring vl_bitstring := '111011010'B;
        [else] {
            select ('1110'B & tsp_bitstring)
            {
                case ('1001'B, vl_bitstring)
                    { vl_int := tsp_int + 10; }
                case ('1100'B, '11'O)
                    { vl_int := tsp_int + 100; }
                case ('11011'B, '10'B, '111'B)
                    { vl_int := tsp_int + 1000; }
                case else
                    { vl_int := tsp_int + 2000; }
            }
            log("Result:  ", vl_int);
        }
    }
    testcase TC() runs on CT { A() }
    control { execute ( TC() ); }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?bitstring.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->testcase: integer instead of enum
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->testcase: integer instead of enum>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 9;
        Enum tsp_enum := E;
    }
    type enumerated Enum { A,B,C,D,E,F,G }
    type component CT {}
    testcase TC() runs on CT
    {
        var integer vl_int;
        var integer vl_H := 5;
        var Enum vl_enum := B;
        select (tsp_enum)
        {
            case (G)
                { vl_int := tsp_int + 10; }
            case (A,F,vl_enum)
                { vl_int := tsp_int + 100; }
            case (C,D,E,vl_H)
                { vl_int := tsp_int + 1000; }
            case else
                { vl_int := tsp_int + 2000; }
        }
        log("Result:  ", vl_int);
    }
    control { execute ( TC() ); }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Type.+?mismatch.+?Enum.+?was.+?expected
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->control part: scope
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->control part: scope>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5,7)
            {
                vl_int := tsp_int + 100;
                var integer vl_emb := vl_int * 5;
            }
            case else
            {
                vl_int := 0
            }
        }
        log("Result:  ", vl_int);
        log("Embedded:  ", vl_emb);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?vl_emb
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->control part: identifier overloading
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->control part: identifier overloading>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5,7)
            {
                vl_int := 100;
                var integer tsp_int := vl_int * 5;
            }
            case else
            {
                vl_int := 0
            }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?tsp_int.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?tsp_int.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->control part: goto-label
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->control part: goto-label>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5,7)
            {
                vl_int := 100;
                goto L1;
            }
            case else
            {
                label L1;
                vl_int := 0
            }
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Label.+?L1.+?not.+?defined
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->Syntax error_1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->Syntax error_1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
            case (1,3,5,7)
            {
                vl_int := 100;
            }
            case else
            {
                vl_int := 0
            }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->Syntax error_2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->Syntax error_2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5 7)
            {
                vl_int := 100;
            }
            case else
            {
                vl_int := 0
            }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->Syntax error_3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->Syntax error_3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5,7)
                vl_int := 100;
            case else
            {
                vl_int := 0
            }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectCase->Syntax error_4
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectCase->Syntax error_4>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        integer tsp_int := 1;
    }
    control {
        var integer vl_int := 0;
        select (tsp_int)
        {
            case (1,3,5,7)
            {
                vl_int := 100;
            }
            case
            {
                vl_int := 0
            }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:p.
.*---------------------------------------------------------------------*
:h3.Select union statement
.*---------------------------------------------------------------------*
:nl.- In the header part of the select union statement a template instance
      of union type or anytype shall be given
:nl.- The SingleExpression in the header of the select union statement
      shall be of a union type. It shall be at least partially initialized
:nl.- Every Identifier in a case of the select union statement shall be
      an identifier of an alternative of the union type of the template
      instance given to the statement's header. 
:nl.- No two cases in a select union statement shall have the same case
      Identifier or TypeIdentifier.


.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Not union or anytype header
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Not union or anytype header>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Message {
      integer msg1,
      integer msg2,
      integer msg3,
      integer msg4
   }
   function A()
   {
      var integer result;
      var Message msg;
      msg.msg1 := 3;

      select union (result)
      {
          case (msg1)
              { result := 1; }
           case (msg2)
              { result := 2; }
           case (msg3)
              { result := 3; }
           case (msg4)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?head.+?must.+?union.+?anytype
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Branch not member of the union
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Branch not member of the union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Message {
      integer msg1,
      integer msg2,
      integer msg3,
      integer msg4
   }
   function A()
   {
      var integer result;
      var Message msg;
      msg.msg1 := 3;

      select union (msg)
      {
          case (msg1)
              { result := 1; }
           case (msgBAD)
              { result := 2; }
           case (msg3)
              { result := 3; }
           case (msg4)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?msgBAD.+?not.+?alternative.+?Message
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Branch not member of anytype
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Branch not member of anytype>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   function A()
   {
      var integer result;
      var anytype msg;

      select union (msg)
      {
          case (integer)
              { result := 1; }
           case (charstring)
              { result := 2; }
           case (bitstring)
              { result := 3; }
           case (octetstring)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
with {
   extension "anytype integer, charstring, bitstring";
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?octetstring.+?not.+?alternative.+?anytype
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same union field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same union field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Message {
      integer msg1,
      integer msg2,
      integer msg3,
      integer msg4
   }
   function A()
   {
      var integer result;
      var Message msg;
      msg.msg1 := 3;

      select union (msg)
      {
          case (msg1)
              { result := 1; }
           case (msg1)
              { result := 2; }
           case (msg3)
              { result := 3; }
           case (msg4)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?msg1.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same union field v2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same union field v2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Message {
      integer msg1,
      integer msg2,
      integer msg3,
      integer msg4
   }
   function A()
   {
      var integer result;
      var Message msg;
      msg.msg1 := 3;

      select union (msg)
      {
          case (msg1)
              { result := 1; }
           case (msg2, msg1)
              { result := 2; }
           case (msg3)
              { result := 3; }
           case (msg4)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?msg1.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same union field v3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same union field v3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type union Message {
      integer msg1,
      integer msg2,
      integer msg3,
      integer msg4
   }
   function A()
   {
      var integer result;
      var Message msg;
      msg.msg1 := 3;

      select union (msg)
      {
          case (msg1)
              { result := 1; }
           case (msg2, msg2)
              { result := 2; }
           case (msg3)
              { result := 3; }
           case (msg4)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?msg2.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same anytype field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same anytype field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   function A()
   {
      var integer result;
      var anytype msg;

      select union (msg)
      {
          case (integer)
              { result := 1; }
           case (integer)
              { result := 2; }
           case (charstring)
              { result := 3; }
           case (bitstring)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
with {
   extension "anytype integer, charstring, bitstring";
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same anytype field v2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same anytype field v2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   function A()
   {
      var integer result;
      var anytype msg;

      select union (msg)
      {
          case (integer)
              { result := 1; }
           case (charstring, integer)
              { result := 2; }
           case (charstring)
              { result := 3; }
           case (bitstring)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
with {
   extension "anytype integer, charstring, bitstring";
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?integer.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::SelectUnion: Two cases have the same anytype field v3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::SelectUnion: Two cases have the same anytype field v3>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

   function A()
   {
      var integer result;
      var anytype msg;

      select union (msg)
      {
          case (integer)
              { result := 1; }
           case (charstring, charstring)
              { result := 2; }
           case (octetstring)
              { result := 3; }
           case (bitstring)
              { result := 4; }
      }
      log("Result:  ", result);

   }
}
with {
   extension "anytype integer, charstring, bitstring, octetstring";
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?charstring.+?already.+?present.+?union
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


:p.
.*---------------------------------------------------------------------*
:h3.Configuration Operations
.*---------------------------------------------------------------------*
:nl.This test case group covers the requirement SA-9/19.
:p. Explanation:
:nl.- These operations shall only be used in TTCN-3 testcases, functions
      and altsteps (i.e. not in the module control part).
:nl.- The done and killed operations shall not be used in a boolean
      expression (i.e. in the if condition ).
:nl.- The alive and running operations shall not be used to determine an
      alternative (i.e. in the alt condition).
:nl.- Create operation: optionally, a name can be associated with the newly
      created component instance. The name shall be a charstring value.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->create in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->create in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp := ct.create;
        var ct comp1 := ct.create alive;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?create.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->start operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->start operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    function f() runs on ct {};
    control {
        var ct comp;
        comp.start(f());
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->stop operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->stop operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        comp.stop;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-stop operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-stop operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        all component.stop;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->kill operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->kill operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        comp.kill;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-kill operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-kill operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        all component.kill;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->alive operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->alive operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (comp.alive) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-alive operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-alive operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (any component.alive) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-alive operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-alive operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (all component.alive) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->running operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->running operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (comp.running) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-running operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-running operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (any component.running) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-running operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-running operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        if (all component.running) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->done operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->done operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] comp.done {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-done operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-done operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] any component.done {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-done operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-done operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] all component.done {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->killed operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->killed operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] comp.killed {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-killed operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-killed operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] any component.killed {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-killed operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-killed operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    control {
        var ct comp;
        alt { [] all component.killed {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Component.+?operation.+?not.+?allowed.+?control.+?part
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->connect operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->connect operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port Port message { inout integer };
    type component ct { port Port port1; }
    function f() runs on ct {};
    control {
        var ct comp;
        connect(mtc:Port1,comp:Port1);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->disconnect operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->disconnect operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port Port message { inout integer };
    type component ct { port Port port1; }
    function f() runs on ct {};
    control {
        var ct comp;
        disconnect(self:Port1,comp:Port1);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->map operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->map operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port Port message { inout integer };
    type component ct { port Port port1; }
    function f() runs on ct {};
    control {
        var ct comp;
        map(comp:Port1,system:Port1);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->unmap operation in the control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->unmap operation in the control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port Port message { inout integer };
    type component ct { port Port port1; }
    function f() runs on ct {};
    control {
        var ct comp;
        unmap(comp:Port1,system:Port1);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->stop operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->stop operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( comp.stop ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-stop operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-stop operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( all component.stop ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->kill operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->kill operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( comp.kill ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-kill operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-kill operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( all component.kill ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->done operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->done operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( comp.done ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-done operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-done operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( any component.done ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-done operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-done operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( all component.done ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->killed operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->killed operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( comp.killed ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-killed operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-killed operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( any component.killed ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-killed operation in the if condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-killed operation in the if condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        if ( all component.killed ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->stop operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->stop operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] comp.stop {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-stop operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-stop operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] all component.stop {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->kill operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->kill operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] comp.kill {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-kill operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-kill operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] all component.kill {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->alive operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->alive operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] comp.alive {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-alive operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-alive operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] any component.alive {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-alive operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-alive operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] all component.alive {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->running operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->running operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] comp.running {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->any-running operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->any-running operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] any component.running {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->all-running operation in the alt condition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->all-running operation in the alt condition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    testcase tc() runs on ct {
        var ct comp:=ct.create alive;
        alt { [] all component.running {} }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->create name is not charstring
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->create name is not charstring>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    function f() {
        var ct comp := ct.create (5);
        var ct comp1 := ct.create ('01001'B) alive;
    }
    altstep a() {
        var ct comp := ct.create ('3C'O);
        var ct comp1 := ct.create (false) alive;
        [else] {}
    }
    testcase tc() runs on ct {
        var ct comp := ct.create (5.6);
        var ct comp1 := ct.create ('ffb9a'H) alive;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 6>
(?im)\berror\b.+?First.+?operand.+?should.+?be.+?charstring
<END_RESULT>
<RESULT IF_PASS COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::ConfigOper->Scope: component variable - create alive
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ConfigOper->Scope: component variable - create alive>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {};
    testcase tc() runs on ct {
        if (true) {
            var ct comp := ct.create ("alive") alive;
        }
        if ( comp.alive ) {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?comp
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:p.
.*---------------------------------------------------------------------*
:h3.The Interleave statement
.*---------------------------------------------------------------------*
:nl.This test case group covers the requirement SA-9/20.
:p. Explanation:
:nl.- The interleave statement allows to specify the interleaved occurrence
:nl.  and handling of the statements done, killed, timeout, receive, trigger,
      getcall, catch and check.
:nl.- Control transfer statements for, while, do-while, goto, stop, repeat,
:nl.  return, activate, deactivate, direct call of altsteps as alternatives
:nl.  and (direct and indirect) calls of user-defined functions, which include
:nl.  communication operations, shall not be used in interleave statements.
:nl.- It is not allowed to guard branches of an interleave statement with
      Boolean expressions (i.e. the '[ ]' shall always be empty).
:nl.  It is also not allowed to specify else branches in interleaved behaviour.

:p. TTCN-3 language extensions:
:nl.- Loop constructs for, while and do-while loops are accepted and supported
      without any restriction in interleave statements.
:nl.- Statements activate, deactivate and stop can also be used within interleave.
:nl.- The compiler does not check whether a TTCNÂ–3 function invoked from within
      an interleave statement has side-effects. The run-time behaviour is undefined
      if a function with side-effects (e.g. communication operations) is called
      while an interleave statement is being executed.
:nl.- The statement block is optional after the guard operations of interleave
      constructs. A missing statement block has the same meaning as an empty
      statement block. If the statement block is omitted a terminating semi-colon
      must be present after the guard statement.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> standard statements (done,killed,timeout,receive)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> standard statements (done,killed,timeout,receive)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type port Port message { inout integer } with { extension "internal" };
    type component ct {
        timer TT;
        port Port P1;
    }
    template integer M1 := ?;

    function f() {
        timer T;
        var ct comp :=ct.create;
        var ct comp1:=ct.create;
        interleave {
            [] T.timeout {}
            [] comp1.done {}
            [] any component.done {}
            [] all component.done {}
            [] comp.killed {}
            [] any component.killed {}
            [] all component.killed {}
            [] any port.receive {}
        }
    }
    altstep a() {
        timer T;
        var ct comp :=ct.create;
        var ct comp1:=ct.create;
        [else] {
            interleave {
                [] T.timeout {}
                [] comp1.done {}
                [] any component.done {}
                [] all component.done {}
                [] comp.killed {}
                [] any component.killed {}
                [] all component.killed {}
                [] any port.receive {}
            }
        };
    }
    function ff() runs on ct {
        var ct comp :=ct.create;
        var ct comp1:=ct.create;
        interleave {
            [] TT.timeout {}
            [] comp1.done {}
            [] any component.done {}
            [] all component.done {}
            [] comp.killed {}
            [] any component.killed {}
            [] all component.killed {}
            [] P1.receive(M1) {}
            [] any port.receive {}
        }
    }
    altstep aa() runs on ct {
        var ct comp :=ct.create;
        var ct comp1:=ct.create;
        [else] {
            interleave {
                [] TT.timeout {}
                [] comp1.done {}
                [] any component.done {}
                [] all component.done {}
                [] comp.killed {}
                [] any component.killed {}
                [] all component.killed {}
                [] P1.receive(M1) {}
                [] any port.receive {}
            }
        };
    }
    testcase tc() runs on ct {
        var ct comp :=ct.create;
        var ct comp1:=ct.create;
        interleave {
            [] TT.timeout {}
            [] comp1.done {}
            [] any component.done {}
            [] all component.done {}
            [] comp.killed {}
            [] any component.killed {}
            [] all component.killed {}
            [] P1.receive(M1) {}
            [] any port.receive {}
        }
    }
    control {
        timer T;
        interleave {
            [] T.timeout {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> standard statements (trigger,getcall,catch,check)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> standard statements (trigger,getcall,catch,check)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig() exception (integer);
    type port PortM message { inout integer } with { extension "internal" };
    type port PortP procedure { inout MySig } with { extension "internal" };
    type component ct {
        timer TT;
        port PortM P1;
        port PortP P2;
    }
    template integer M1 := ?;

    function f() {
        interleave {
            [] any port.trigger {}
            [] any port.catch {}
            [] any port.getreply {}
            [] any port.getcall {}
            [] any port.check {}
        }
    }
    altstep a() {
        [else] {
            interleave {
                [] any port.trigger {}
                [] any port.catch {}
                [] any port.getreply {}
                [] any port.getcall {}
                [] any port.check {}
            }
        };
    }
    function ff() runs on ct {
        interleave {
            [] P1.trigger(M1) {}
            [] any port.trigger {}
            [] P2.catch(MySig, omit) {}
            [] any port.catch {}
            [] P2.getreply(MySig:{}) {}
            [] any port.getreply {}
            [] P2.getcall(MySig:{}) {}
            [] any port.getcall {}
            [] P2.check(catch(MySig, omit)) {}
            [] any port.check {}
        }
    }
    altstep aa() runs on ct {
        [else] {
            interleave {
                [] P1.trigger(M1) {}
                [] any port.trigger {}
                [] P2.catch(MySig, omit) {}
                [] any port.catch {}
                [] P2.getreply(MySig:{}) {}
                [] any port.getreply {}
                [] P2.getcall(MySig:{}) {}
                [] any port.getcall {}
                [] P2.check(getreply(MySig:{})) {}
                [] any port.check {}
            }
        };
    }
    testcase tc() runs on ct {
        interleave {
            [] P1.trigger(M1) {}
            [] any port.trigger {}
            [] P2.catch(MySig, omit) {}
            [] any port.catch {}
            [] P2.getreply(MySig:{}) {}
            [] any port.getreply {}
            [] P2.getcall(MySig:{}) {}
            [] any port.getcall {}
            [] P2.check(getcall(MySig:{})) {}
            [] any port.check {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> extensions statements (for,while,do-while loops)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> extensions statements (for,while,do-while loops)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig() exception (integer);
    type port PortM message { inout integer } with { extension "internal" };
    type port PortP procedure { inout MySig } with { extension "internal" };
    type component ct {
        port PortM P1;
        port PortP P2;
        var integer i,c:=0;
    }
    template integer M1 := ?;

    function f() {
        var integer j,c:=0;
        interleave {
            [] any port.trigger { for (j:=1; j<100; j:=j+1) {c:=c+j} }
            [] any port.catch { while (c<100) {c:=c+1} }
            [] any port.getreply { do { c:=c+1 } while (c<100); }
        }
    }
    altstep a() {
        var integer j,c:=0;
        [else] {
            interleave {
                [] any port.trigger { for (j:=1; j<100; j:=j+1) {c:=c+j} }
                [] any port.catch { while (c<100) {c:=c+1} }
                [] any port.getreply { do { c:=c+1 } while (c<100); }
            }
        };
    }
    function ff() runs on ct {
        interleave {
            [] P1.trigger(M1) { for (i:=1; i<100; i:=i+1) {c:=c+i} }
            [] P2.catch(MySig, omit) { while (c<100) {c:=c+1} }
            [] P2.getreply(MySig:{}) { do { c:=c+1 } while (c<100); }
        }
    }
    altstep aa() runs on ct {
        [else] {
            interleave {
                [] P1.trigger(M1) { for (i:=1; i<100; i:=i+1) {c:=c+i} }
                [] P2.catch(MySig, omit) { while (c<100) {c:=c+1} }
                [] P2.getreply(MySig:{}) { do { c:=c+1 } while (c<100); }
            }
        };
    }
    testcase tc() runs on ct {
        interleave {
            [] P1.trigger(M1) { for (i:=1; i<100; i:=i+1) {c:=c+i} }
            [] P2.catch(MySig, omit) { while (c<100) {c:=c+1} }
            [] P2.getreply(MySig:{}) { do { c:=c+1 } while (c<100); }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> extensions statements (activate,deactivate,stop)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> extensions statements (activate,deactivate,stop)>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig() exception (integer);
    type port PortM message { inout integer } with { extension "internal" };
    type port PortP procedure { inout MySig } with { extension "internal" };
    type component ct {
        port PortM P1;
        port PortP P2;
        var default vd_DefaultVar := null;
    }
    template integer M1 := ?;

    function f() {
        timer T;
        var default vd_DefaultVar1 := null;
        interleave {
            [] T.timeout { vd_DefaultVar1 := activate(MyDefAltstep()); }
            [] any port.getcall { deactivate(vd_DefaultVar1); }
            [] any port.receive { stop; }
        }
    }
    altstep a() {
        timer T;
        var default vd_DefaultVar1 := null;
        [else] {
            interleave {
                [] T.timeout { vd_DefaultVar1 := activate(MyDefAltstep()); }
                [] any port.getcall { deactivate(vd_DefaultVar1); }
                [] any port.receive { stop; }
            }
        };
    }
    function ff() runs on ct {
        interleave {
            [] P1.receive(M1) { vd_DefaultVar := activate(MyDefAltstep()); }
            [] P2.check(getreply(MySig:{})) { deactivate(vd_DefaultVar); }
            [] P2.getcall(MySig:{}) { stop; }
        }
    }
    altstep aa() runs on ct {
        [else] {
            interleave {
                [] P1.receive(M1) { vd_DefaultVar := activate(MyDefAltstep()); }
                [] P2.check(getreply(MySig:{})) { deactivate(vd_DefaultVar); }
                [] P2.getcall(MySig:{}) { stop; }
            }
        };
    }
    testcase tc() runs on ct {
        interleave {
            [] P1.receive(M1) { vd_DefaultVar := activate(MyDefAltstep()); }
            [] P2.check(getreply(MySig:{})) { deactivate(vd_DefaultVar); }
            [] P2.getcall(MySig:{}) { stop; }
        }
    }
    altstep MyDefAltstep() { [else] {}; }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> function with communication statement
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> function with communication statement>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig() exception (integer);
    type port PortP procedure { inout MySig } with { extension "internal" };
    type component ct {
        timer T;
        port PortP P1;
    }
    function f() runs on ct {
        P1.call(MySig:{}) {
            [] P1.getreply(MySig:{}) {}
        }
    }
    testcase tc() runs on ct {
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [] comp.done { f(); }
            [] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> statement block is optional
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> statement block is optional>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig() exception (integer);
    type port PortM message { inout integer } with { extension "internal" };
    type port PortP procedure { inout MySig } with { extension "internal" };
    type component ct {
        port PortM P1;
        port PortP P2;
        timer T;
    }
    template integer M1 := ?;
    testcase tc() runs on ct {
        var ct comp :=ct.create;
        interleave {
            [] T.timeout;
            [] comp.done;
            [] any component.done;
            [] all component.done;
            [] comp.killed;
            [] any component.killed;
            [] all component.killed;
            [] P1.receive(M1);
            [] any port.receive;
            [] P1.trigger(M1);
            [] any port.trigger;
            [] P2.catch(MySig, omit);
            [] any port.catch;
            [] P2.getreply(MySig:{});
            [] any port.getreply;
            [] P2.getcall(MySig:{});
            [] any port.getcall;
            [] P2.check(getcall(MySig:{}));
            [] any port.check;
        }
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> guard_expression
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> guard_expression>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}
    function f(inout integer x) {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [x<5] T.timeout {}
            [] comp.done {}
            [] comp.killed {}
        }
    }
    function ff(inout integer x) runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] comp.killed {}
            [] T.timeout {}
            [x<2] comp.done {}
        }
    }
    testcase tc(inout integer x) runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [x<5] comp.done {}
            [] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)\berror\b.+?x.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> else
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> else>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    function f() {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [] comp.done {}
            [else] {}
        }
    }
    function ff() runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [else] {}
            [] T.timeout {}
            [] comp.done {}
        }
    }
    testcase tc() runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [] comp.done {}
            [else] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?else.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> repeat
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> repeat>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    testcase tc() runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [] comp.done { repeat; }
            [] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Repeat.+?not.+?allowed.+?interleave
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> goto
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> goto>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    testcase tc() runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout { goto L1; }
            [] comp.done {}
            [] comp.killed {}
        }
        label L1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Goto.+?not.+?allowed.+?interleave
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> label
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> label>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    testcase tc() runs on ct {
        timer T;
        var ct comp :=ct.create;
        goto L1;
        interleave {
            [] T.timeout {}
            [] comp.done { label L1; }
            [] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Label.+?L1.+?not.+?defined
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Label.+?not.+?allowed.+?interleave
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> return
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> return>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    function f() runs on ct return integer {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout { return 5; }
            [] comp.done { return 6; }
            [] comp.killed { return 7; }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)\berror\b.+?Return.+?not.+?allowed.+?interleave
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?function.+?not.+?have.+?return
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {}

    testcase tc() runs on ct {
        timer T;
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {}
            [] comp.done {
                altstep a() {
                    [else] {}
                }
            }
            [] comp.killed {}
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?altstep.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> scope
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> scope>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct { timer T; }

    testcase tc() runs on ct {
        var ct comp :=ct.create;
        var integer vl_int := 1;
        interleave {
            [] T.timeout {
                var integer vl_emb1 := vl_int * 5;
            }
            [] comp.done {
                if (vl_emb1 < 10) {
                    var integer vl_emb2 := vl_int * 15;
                }
                vl_int := vl_emb2 + 1;
            }
            [] comp.killed {}
        }
        log("Result:  ", vl_int);
        log("Embedded_1:  ", vl_emb1);
        log("Embedded_2:  ", vl_emb2);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?vl_emb1
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?vl_emb2
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> identifier overloading
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> identifier overloading>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct {
        timer T;
        var integer vl_int := 1;
    }

    testcase tc() runs on ct {
        var ct comp :=ct.create;
        interleave {
            [] T.timeout {
                var integer vl_emb := vl_int * 5;
            }
            [] comp.done {
                var integer vl_int := 15;
            }
            [] comp.killed {}
        }
        log("Result:  ", vl_int);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?vl_int.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?vl_int.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::Interleave-> syntax error
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Interleave-> syntax error>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component ct { timer T; }
    testcase tc() runs on ct {
        var ct comp :=ct.create;
        interleave
            [] T.timeout {}
            [] comp.done {}
            [] comp.killed {}
    }
    function f() runs on ct {
        var ct comp :=ct.create;
        interleave {
            [ T.timeout {}
            [] comp.done {}
            [] comp.killed {}
        }
    }
    altstep a() runs on ct {
        var ct comp :=ct.create;
        [else] {
            interleave {
                [] T.timeout {}
                [] comp.done {}
                [] comp.killed }
            }
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 5>
(?im)\berror\b.+?syntax.+?error
<END_RESULT>
<RESULT IF_PASS COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3. Redeclaration of a group with a different type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Redeclaration of a group with a different type>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  group g
  {
    type integer my_int
  }
  type charstring g
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Group name .+ clashes with a definition
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. Redeclaration of a group with a different type, reverse order
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Redeclaration of a group with a different type, reverse order>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
  type charstring g
  group g
  {
    type integer my_int
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Group name .+ clashes with a definition
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. Name clash between type and field
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Name clash of type and field>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA { // HL26011
  type record S
  {
    integer S
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?i)\berror\b: Field name clashes with type name
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 42 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 (2005-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.
