.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Baranyi, Botond
.*   Bartha, Norbert
.*   Delic, Adam
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.14/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Elemer Lelik)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Scope Rules
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
________________________________________________________
PA1   2005-02-19   ETIBHRA    New document for TITAN R6
A     2005-03-18   ETIBHRA    Approved after review
B     2006-07-31   EJNOSZA    Updates for TITAN R6E
C     2007-03-06   EJNOSZA    Updates for TITAN R7A (expected error messages for identifier overloading)
D     2007-06-08   EJNOSZA    Updates for TITAN R7B (expected error messages for identifier overloading)
E     2007-10-10   ETHNBA     Updates for TITAN R7C (runs on self tests)
F     2009-06-11   EKRISZA    Name correction
G     2010-07-02  EKRISZA     version update
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the Semantic Analyser functionality of the TTCN-3 compiler:
:nl.SA-1/3: Scope Rules.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.

:np.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope units
.*---------------------------------------------------------------------*
:nl.This test case group covers the requirement SA-3/1.
:p. Explanation:
:nl.- Definitions made in a scope unit are visible only in that scope hierarchy.
:nl.- Scope rule at the "for" statement: see there (ScopeUnits-> For statement).
:p.Test strategy:
:space 1.
:xmp tab=0.
                       Hierarchy of scope units


       Abbreviations:

           MDP: Module Definitons Part
           MCP: Module Control Part
           CT : Component Type
           FUN: Function without runs on-clause
           ALT: Altstep without runs on-clause
           FWR: Function with runs on-clause
           AWR: Altstep with runs on-clause
           TC : Testcase with runs on-clause and optional system-clause
           BS : Block of statements (within a compound statement)
           EBS: Embedded block of statements (within a compound statement)
:exmp.
:space 2.
:xmp tab=0.
                  _____________________________________________
                 |                                             |
  0.        _____|                      MDP                    |_______
           |     |_____________________________________________|       |
         __|__                   __|__                   __|__       __|__
        |     |                 |     |                 |     |     |     |
  1.    | MCP |         ________| CT  |________         | FUN |     | ALT |
        |_____|        |        |_____|        |        |_____|     |_____|
           |         __|__       __|__       __|__         |           |
           |        |     |     |     |     |     |        |           |
  2.       |        | FWR |     | AWR |     | TC  |        |           |
           |        |_____|     |_____|     |_____|        |           |
         __|__       __|__       __|__       __|__       __|__       __|__
        |     |     |     |     |     |     |     |     |     |     |     |
  3.    | BS  |     | BS  |     | BS  |     | BS  |     | BS  |     | BS  |
        |_____|     |_____|     |_____|     |_____|     |_____|     |_____|
         __|__       __|__       __|__       __|__       __|__       __|__
        |     |     |     |     |     |     |     |     |     |     |     |
  4.    | EBS |     | EBS |     | EBS |     | EBS |     | EBS |     | EBS |
        |_____|     |_____|     |_____|     |_____|     |_____|     |_____|
           |           |           |           |           |           |
           |           |           |           |           |           |
:exmp.
:np.
:xmp tab=1.
Test cases are based on TTCN-3 according to the followings:
-  Every bubble on the 1.-2. level is checked with each other.
-  We checked the "const", the "var" and the "timer" definition.
-  First we checked a bubble's BS and EBS branches (except CT), second
   its parent bubbles and then the other bubbles from left to right
   direction on the 1.-2. level.
   In the FUN, ALT, FWR, AWR, TC cases we can use a parameter list.
   There we check "var" and "timer" (except TC for timer) parameters
   just in the same way as when we make a definition in the BS bubble.

-  Example:  FUN bubble
   Every const and var definiton is an integer.
   1. Definition of a const in the FUN's EBS is checked in the BS.
      Definition of a var in the FUN's EBS is checked in the BS.
      Definition of a timer in the FUN's EBS is checked in the BS.
   2. Definition of a const in the FUN's BS is checked in the MDP.
   3. Value parameter of FUN is checked in the MCP.
      Timer parameter in FUN is checked in the MCP.
      Value parameter in FUN is checked in the CT.
      Value parameter in FUN is checked in the ALT.
      Timer parameter in FUN is checked in the ALT.
      Value parameter in FUN is checked in the FWR.
      Timer parameter in FUN is checked in the FWR.
      Value parameter in FUN is checked in the AWR.
      Timer parameter in FUN is checked in the AWR.
      Value parameter in FUN is checked in the TC.
      Timer parameter in FUN is checked in the TC.
   4. Definition of a const in the FUN's BS is checked in the MCP.
      Definition of a var in the FUN's BS is checked in the MCP.
      Definition of a timer in the FUN's BS is checked in the MCP.
   5. Definition of a const in the FUN's BS is checked in the CT.
      Definition of a var in the FUN's BS is checked in the CT.
   6. Definition of a const in the FUN's BS is checked in the ALT.
      Definition of a var in the FUN's BS is checked in the ALT.
      Definition of a timer in the FUN's BS is checked in the ALT.
   7. Definition of a const in the FUN's BS is checked in the FWR.
      Definition of a var in the FUN's BS is checked in the FWR.
      Definition of a timer in the FUN's BS is checked in the FWR.
   8. Definition of a const in the FUN's BS is checked in the AWR.
      Definition of a var in the FUN's BS is checked in the AWR.
      Definition of a timer in the FUN's BS is checked in the AWR.
   9. Definition of a const in the FUN's BS is checked in the TC.
      Definition of a var in the FUN's BS is checked in the TC.
      Definition of a timer in the FUN's BS is checked in the TC.
:exmp.
:p.TODO:
:nl.  We can check the definitions of "const" and "var" for every type.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        var integer MyControlInt := 1;
        if ( true ) {
            const integer MyControlIntConstE := 18;
        }
        MyControlInt := MyControlIntConstE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        var integer MyControlInt := 1;
        if ( true ) {
            var integer MyControlIntE := 18;
        }
        MyControlInt := MyControlIntE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        if ( true ) {
            timer MyControlTimerE := 3.0;
        }
        MyControlTimerE.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyModuleIntConst := MyControlIntConst;
    control {
        const integer MyControlIntConst := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyControlIntConst;
    }
    control {
        const integer MyControlIntConst := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyControlInt;
    }
    control {
        var integer MyControlInt := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        return MyControlIntConst;
    }
    control {
        const integer MyControlIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        return MyControlInt;
     }
    control {
        var integer MyControlInt := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        MyControlTimer.start;
    }
    control {
        timer MyControlTimer := 5.0;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyControlIntConst;
        [] any port.check {};
        [else] {};
    }
    control {
        const integer MyControlIntConst := 5;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        var integer MyAltstepInt := MyControlInt;
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := 5;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
	[] MyControlTimer.timeout {}
        [else] {};
    }
    control {
        timer MyControlTimer := 5.0;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyControlIntConst;
    }
    control {
        const integer MyControlIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyControlInt;
    }
    control {
        var integer MyControlInt := 11;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: timer definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: timer definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyControlTimer.start;
    };
    control {
        timer MyControlTimer := 5.0;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        const integer MyCompAltstepIntConst := MyControlIntConst;
        [] any port.check {};
        [else] {};
    }
    control {
        const integer MyControlIntConst := 5;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := MyControlInt;
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := 5;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: timer definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: timer definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
	[] MyControlTimer.timeout {}
        [else] {};
    }
    control {
        timer MyControlTimer := 5.0;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: const definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: const definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := MyControlIntConst;
    }
    control {
        const integer MyControlIntConst := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: var definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: var definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyControlInt;
    }
    control {
        var integer MyControlInt := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Control part: timer definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Control part: timer definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
	MyControlTimer.start;
    }
    control {
        timer MyControlTimer := 5.0;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyControlTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: const definition -> Definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: const definition -> Definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyModuleIntConst := MyComponentIntConst;
    type component MyCompType {
        const integer MyComponentIntConst := 11;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := 11;
    }
    control {
        const integer MyControlIntConst := MyComponentIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := 11;
    }
    control {
        var integer MyControlInt := MyComponentInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        timer MyComponentTimer := 1.0;
    }
    control {
        MyComponentTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := 11;
    }
    function MyFunc() return integer {
        return MyComponentIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := 11;
    }
    function MyFunc() return integer {
        return MyComponentInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        timer MyComponentTimer := 11.0;
    }
    function MyFunc() {
        MyComponentTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := 11;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyComponentIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := 11;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyComponentInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Component type: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Component type: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        timer MyComponentTimer := 11.0;
    }
    altstep MyAltstep () {
	[] MyComponentTimer.timeout {}
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyComponentTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        if ( true ) {
            const integer MyFuncIntConstE := 18;
        }
        return MyFuncIntConstE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        if ( true ) {
            var integer MyFuncIntE := 18;
        }
        return MyFuncIntE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        if ( true ) {
            timer MyFuncTimerE := 18.0;
        }
        MyFuncTimerE.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyModuleIntConst := MyFuncIntConst;
    function MyFunc() {
        const integer MyFuncIntConst := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (value parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer MyFuncInt ) {}
    control {
        var integer MyControlInt := MyFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (timer parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (timer parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer MyFuncTimer ) {}
    control {
        MyFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Function: (value parameter) -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyFuncInt;
    }
    function MyFunc( integer MyFuncInt ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (value parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer MyFuncInt ) {}
    altstep MyAltstep () {
        var integer MyAltstepInt := MyFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (timer parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (timer parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( timer MyFuncTimer ) {}
    altstep MyAltstep () {
	[] MyFuncTimer.timeout {}
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (value parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyFuncInt;
    }
    function MyFunc( integer MyFuncInt ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (timer parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (timer parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyFuncTimer.start;
    }
    function MyFunc( timer MyFuncTimer ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (value parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := MyFuncInt;
        [] any port.check {};
        [else] {};
    }
    function MyFunc( integer MyFuncInt ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (timer parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (timer parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        [] MyFuncTimer.timeout {}
        [else] {};
    }
    function MyFunc( timer MyFuncTimer ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (value parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (value parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyFuncInt;
    }
    function MyFunc( integer MyFuncInt ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function (timer parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function (timer parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        MyFuncTimer.start;
    }
    function MyFunc( timer MyFuncTimer ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        const integer MyFuncIntConst := 18;
    }
    control {
        const integer MyControlIntConst := MyFuncIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        var integer MyFuncInt := 18;
    }
    control {
        var integer MyControlInt := MyFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        timer MyFuncTimer := 18.6;
    }
    control {
        MyFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyFuncIntConst;
    }
    function MyFunc() {
        const integer MyFuncIntConst := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Function: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyFuncInt;
    }
    function MyFunc() {
        var integer MyFuncInt := 18;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        const integer MyFuncIntConst := 18;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyFuncIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        var integer MyFuncInt := 12;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        timer MyFuncTimer := 12.8;
    }
    altstep MyAltstep () {
	[] MyFuncTimer.timeout {}
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyFuncIntConst;
    }
    function MyFunc() {
        const integer MyFuncIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: var definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyFuncInt;
    }
    function MyFunc() {
        var integer MyFuncInt := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: timer definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: timer definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyFuncTimer.start;
    }
    function MyFunc() {
        timer MyFuncTimer := 1.9;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        const integer MyCompAltstepIntConst := MyFuncIntConst;
        [] any port.check {};
        [else] {};
    }
    function MyFunc() {
        const integer MyFuncIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: var definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := MyFuncInt;
        [] any port.check {};
        [else] {};
    }
    function MyFunc() {
        var integer MyFuncInt := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: timer definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: timer definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        [] MyFuncTimer.timeout {}
        [else] {};
    }
    function MyFunc() {
        timer MyFuncTimer := 1.3;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: const definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: const definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := MyFuncIntConst;
    }
    function MyFunc() {
        const integer MyFuncIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: var definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: var definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyFuncInt;
    }
    function MyFunc() {
        var integer MyFuncInt := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function: timer definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function: timer definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        MyFuncTimer.start;
    }
    function MyFunc() {
        timer MyFuncTimer := 3.8;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep ( timer MyAltstepTimerIn ) {
        [] any port.check {
	    const integer MyAltstepIntConstE := 10;
        };
	[ MyAltstepIntConstE > 1 ] MyAltstepTimerIn.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep ( timer MyAltstepTimerIn ) {
        [] any port.check {
	    var integer MyAltstepIntE := 10;
        };
	[ MyAltstepIntE > 1 ] MyAltstepTimerIn.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        [] any port.check {
            timer MyAltstepTimerE := 10.3;
        };
        [] MyAltstepTimerE.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyModuleIntConst := MyAltstepIntConst;
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 17;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := MyAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep ( timer MyAltstepTimer ) {
        [] any port.check {};
        [else] {};
    }
    control {
        MyAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyAltstepInt;
    }
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        return MyAltstepInt;
    }
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        MyAltstepTimer.start;
    }
    altstep MyAltstep ( timer MyAltstepTimer ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyAltstepInt;
    }
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyAltstepTimer.start;
    }
    altstep MyAltstep ( timer MyAltstepTimer ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := MyAltstepInt;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
	[] MyAltstepTimer.timeout {};
        [else] {};
    }
    altstep MyAltstep ( timer MyAltstepTimer ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (value parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (value parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyAltstepInt;
    }
    altstep MyAltstep ( integer MyAltstepInt ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep (timer parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        MyAltstepTimer.start;
    }
    altstep MyAltstep ( timer MyAltstepTimer ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 17;
        [] any port.check {};
        [else] {};
    }
    control {
        const integer MyControlIntConst := MyAltstepIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        var integer MyAltstepInt := 17;
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := MyAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep () {
        timer MyAltstepTimer := 17.9;
        [] any port.check {};
        [else] {};
    }
    control {
        MyAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyAltstepIntConst;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 17;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyAltstepInt;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := 17;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        return MyAltstepIntConst;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 17;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() return integer {
        return MyAltstepInt;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := 17;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        MyAltstepTimer.start;
    }
    altstep MyAltstep () {
        timer MyAltstepTimer := 17.9;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyAltstepIntConst;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 13;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyAltstepInt;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := 13;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: timer definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: timer definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyAltstepTimer.start;
    }
    altstep MyAltstep () {
        timer MyAltstepTimer := 13.3;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        const integer MyCompAltstepIntConst := MyAltstepIntConst;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 15;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := MyAltstepInt;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := 15;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: timer definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: timer definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
	[] MyAltstepTimer.timeout {};
        [else] {};
    }
    altstep MyAltstep () {
        timer MyAltstepTimer := 15.1;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: const definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: const definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := MyAltstepIntConst;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := 14;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: var definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: var definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyAltstepInt;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := 14;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep: timer definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep: timer definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        MyAltstepTimer.start;
    }
    altstep MyAltstep () {
        timer MyAltstepTimer := 14.1;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        if ( true ) {
            const integer MyCompFuncIntConstE := 21;
        }
        return MyCompFuncIntConstE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        if ( true ) {
            var integer MyCompFuncIntE := 21;
        }
        return MyCompFuncIntE;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        if ( true ) {
            timer MyCompFuncTimerE := 21.1;
        }
        MyCompFuncTimerE.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyCompFuncIntConst;
    }
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyCompFuncInt;
    }
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyCompFuncInt;
    }
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
    control {
        var integer MyControlInt := MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( timer MyCompFuncTimer ) runs on MyCompType {}
    control {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
    function MyFunc() return integer {
        return MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( timer MyCompFuncTimer ) runs on MyCompType {}
    function MyFunc() {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
    altstep MyAltstep () {
        var integer MyAltstepInt := MyCompFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( timer MyCompFuncTimer ) runs on MyCompType {}
    altstep MyAltstep () {
        [] MyCompFuncTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := MyCompFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( timer MyCompFuncTimer ) runs on MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        [] MyCompFuncTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (value parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFuncInt ) runs on MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on (timer parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( timer MyCompFuncTimer ) runs on MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
    control {
        const integer MyControlIntConst := MyCompFuncIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
    control {
        var integer MyControlInt := MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        timer MyCompFuncTimer := 21.6;
    }
    control {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
    function MyFunc() return integer {
        return MyCompFuncIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
    function MyFunc() return integer {
        return MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        timer MyCompFuncTimer := 21.3;
    }
    function MyFunc() {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyCompFuncIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyCompFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        timer MyCompFuncTimer := 21.9;
    }
    altstep MyAltstep () {
        [] MyCompFuncTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := MyCompFuncIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := MyCompFuncInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        timer MyCompFuncTimer := 21.3;
    }
    altstep MyCompAltstep() runs on MyCompType {
        [] MyCompFuncTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: const definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := 21;
    }
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := MyCompFuncIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: var definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := 21;
    }
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyCompFuncInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Function_runs_on: timer definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        timer MyCompFuncTimer := 21.3;
    }
    testcase MyTestcase() runs on MyCompType {
        MyCompFuncTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompFuncTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( timer MyCompAltstepTimerIn ) runs on MyCompType {
        [] any port.check {
	    const integer MyCompAltstepIntConstE := 16;
        };
	[ MyCompAltstepIntConstE > 1 ] MyCompAltstepTimerIn.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( timer MyCompAltstepTimerIn ) runs on MyCompType {
        [] any port.check {
	    var integer MyCompAltstepIntE := 16;
        };
	[ MyCompAltstepIntE > 1 ] MyCompAltstepTimerIn.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        [] any port.check {
	    timer MyCompAltstepTimerE := 16.4;
        };
	[] MyCompAltstepTimerE.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyCompAltstepIntConst;
    }
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyCompAltstepInt;
    }
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyCompAltstepInt;
    }
    altstep MyCompAltstep( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( timer MyCompAltstepTimer ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    control {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    function MyFunc() return integer {
        return MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( timer MyCompAltstepTimer ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    function MyFunc() {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep ( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyCompAltstepInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep ( timer MyCompAltstepTimer ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        [] MyCompAltstepTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := MyCompAltstepInt;
    }
    altstep MyCompAltstep( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyCompAltstepTimer.start;
    }
    altstep MyCompAltstep( timer MyCompAltstepTimer ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (value parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( integer MyCompAltstepInt ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on (timer parameter) -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( timer MyCompAltstepTimer ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
    testcase MyTestcase() runs on MyCompType {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
    control {
        const integer MyControlIntConst := MyCompAltstepIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
    control {
        var integer MyControlInt := MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        timer MyCompAltstepTimer := 16.7;
        [] any port.check {};
        [else] {};
    }
    control {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
    function MyFunc() return integer {
        return MyCompAltstepIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
    function MyFunc() return integer {
        return MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        timer MyCompAltstepTimer := 16.8;
        [] any port.check {};
        [else] {};
    }
    function MyFunc() {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyCompAltstepIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyCompAltstepInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep () runs on MyCompType {
        timer MyCompAltstepTimer := 16.9;
        [] any port.check {};
        [else] {};
    }
    altstep MyAltstep () {
        [] MyCompAltstepTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyCompFuncIntConst := MyCompAltstepIntConst;
    }
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        var integer MyCompFuncInt := MyCompAltstepInt;
    }
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyCompAltstepTimer.start;
    }
    altstep MyCompAltstep() runs on MyCompType {
        timer MyCompAltstepTimer := 16.3;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: const definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := 16;
        [] any port.check {};
        [else] {};
    }
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := MyCompAltstepIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: var definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := 16;
        [] any port.check {};
        [else] {};
    }
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := MyCompAltstepInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Altstep_runs_on: timer definition -> Testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        timer MyCompAltstepTimer := 16.2;
        [] any port.check {};
        [else] {};
    }
    testcase MyTestcase() runs on MyCompType {
        MyCompAltstepTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyCompAltstepTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: embedded case -- const definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: embedded case -- const definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        if ( true ) {
            const integer MyTestcaseIntConstE := 25;
        }
        if ( MyTestcaseIntConstE == 0 ) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConstE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: embedded case -- var definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: embedded case -- var definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        if ( true ) {
            var integer MyTestcaseIntE := 25;
        }
        if ( MyTestcaseIntE == 0 ) {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: embedded case -- timer definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: embedded case -- timer definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        if ( true ) {
            timer MyTestcaseTimerE := 25.9;
        }
        MyTestcaseTimerE.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimerE
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyComponentIntConst := MyTestcaseIntConst;
    }
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyTestcaseInt;
    }
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Component type
.*---------------------------------------------------------------------*
NOTE:
:nl.The implementation does not support the variable initialized with
:nl.another variable in the component type (but it would be possible
:nl.according to TTCN-3 specification ).

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        var integer MyComponentInt := MyTestcaseInt;
    }
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
    control {
        var integer MyControlInt := MyTestcaseInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
    function MyFunc() return integer {
        return MyTestcaseInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
    altstep MyAltstep () {
        var integer MyAltstepInt := MyTestcaseInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyTestcaseInt;
    }
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase (value parameter) -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase (value parameter) -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyTestcaseInt ) runs on MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := MyTestcaseInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
    control {
        const integer MyControlIntConst := MyTestcaseIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
    control {
        var integer MyControlInt := MyTestcaseInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: timer definition -> Control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: timer definition -> Control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        timer MyTestcaseTimer := 25.5;
    }
    control {
        MyTestcaseTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
    function MyFunc() return integer {
        return MyTestcaseIntConst;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
    function MyFunc() return integer {
        return MyTestcaseInt;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: timer definition -> Function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: timer definition -> Function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        timer MyTestcaseTimer := 25.8;
    }
    function MyFunc() {
        MyTestcaseTimer.start;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
    altstep MyAltstep () {
        const integer MyAltstepIntConst := MyTestcaseIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
    altstep MyAltstep () {
        var integer MyAltstepInt := MyTestcaseInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: timer definition -> Altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: timer definition -> Altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        timer MyTestcaseTimer := 25.7;
    }
    altstep MyAltstep () {
        [] MyTestcaseTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyTestcaseIntConst;
    }
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType return integer {
        return MyTestcaseInt;
    }
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: timer definition -> Function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: timer definition -> Function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        MyTestcaseTimer.start;
    }
    testcase MyTestcase() runs on MyCompType {
        timer MyTestcaseTimer := 25.3;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: const definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: const definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyTestcaseIntConst := 25;
    }
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyCompAltstepIntConst := MyTestcaseIntConst;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseIntConst
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: var definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: var definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        var integer MyTestcaseInt := 25;
    }
    altstep MyCompAltstep() runs on MyCompType {
        var integer MyCompAltstepInt := MyTestcaseInt;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseInt
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> Testcase: timer definition -> Altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::ScopeUnits-> Testcase: timer definition -> Altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        timer MyTestcaseTimer := 25.1;
    }
    altstep MyCompAltstep() runs on MyCompType {
        [] MyTestcaseTimer.timeout {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?MyTestcaseTimer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::ScopeUnits-> For statement
.*---------------------------------------------------------------------*
Explanation:
:nl.The index variable of a for loop can be declared before being used
in the for statement or can be declared and initialized in the for
statement header. If the index variable is declared and initialized
in the for statement header, the scope of the index variable is limited
to the loop body, i.e. it is only visible inside the loop body.

:xmp tab=0.

<TC - TTCN-3::ScopeUnits-> For statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        var integer counter1;
	for ( counter1:=1; counter1 < 7; counter1 := counter1+1 ) {
            var integer x1 := counter1;
	}
	for ( var float counter2:=11.7; counter2 > 4.0; counter2 := counter2-1.35 ) {
            var integer x1 := counter1;
	    var float x2 := counter2;
        }
        if ( counter2 < 6.0) {
	    counter1 := 0;
	}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?counter2
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Identifier overloading
.*---------------------------------------------------------------------*
:nl.This test case group covers the requirement SA-3/2.
:p. Explanation:
:nl.TTCN-3 does not support overloading of identifiers i.e. all identifiers
    in the same scope hierarchy shall be unique.

:p.Test strategy:
:nl.- The type and const definition is checked in MDP.
:nl.- Every bubble is checked with its all children (from left to right).
:nl.- The whole branch is checked if a bubble has only one child.
:nl.- We checked "const" identifier (definition), integer identifier
  (parameter) and other identifiers (e.g. function identifier).
:nl.
:nl.- Examples:
:nl.
:nl.    MDP bubble:
:nl.    - Definition of a const in MDP is compared to the identifier in MCP,
          CT, FUN, ALT.
:nl.
:nl.    FUN bubble:
:nl.    - The FUN identifier (name) is checked in the function's parameter list.
:nl.    - The value parameter (integer) is checked in the BS.
:nl.
:nl.    FUN's BS bubble:
:nl.    - Definition of a const is checked in the FUN's EBS.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same type identifier: definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same type identifier: definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyId {}
    type integer MyId;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?MyId
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?MyId.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same type and const id.: definitions part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same type and const id.: definitions part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyId {}
    const integer MyId := 1;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?MyId
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?MyId.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: definitions part--control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: definitions part--control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyIntConst := 1;
    control {
        const integer MyIntConst := 4;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Definitions part const--component type id.
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Definitions part const--component type id.>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyId := 1;
    type component MyId {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?MyId
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?MyId.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: definitions part--component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: definitions part--component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyIntConst := 1;
    type component MyCompType {
        const integer MyIntConst := 3;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Definitions part const--function identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Definitions part const--function identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyId := 1;
    function MyId() {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?MyId
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?MyId.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Definitions part const--function parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Definitions part const--function parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyIntConst := 1;
    function MyFunc( integer MyIntConst ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Definitions part const--altstep identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Definitions part const--altstep identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyId := 1;
    altstep MyId() {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?MyId
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?MyId.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Definitions part const--altstep parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Definitions part const--altstep parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    const integer MyIntConst := 1;
    altstep MyAltstep( integer MyIntConst ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--control part
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    control {
        const integer MyIntConst := 1;
        if ( true ) {
            const integer MyIntConst := 2;
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--function_runs_on id.
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--function_runs_on id.>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyId := 1;
    }
    function MyId() runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyId.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyId.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--function_runs_on par.
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--function_runs_on par.>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyIntConst := 1;
    }
    function MyCompFunc( integer MyIntConst ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--altstep_runs_on id.
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--altstep_runs_on id.>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyId := 1;
    }
    altstep MyId() runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyId.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyId.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--altstep_runs_on par.
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--altstep_runs_on par.>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyIntConst := 1;
    }
    altstep MyAltstep( integer MyIntConst ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--testcase identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--testcase identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyId := 1;
    }
    testcase MyId() runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyId.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyId.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Component type const--testcase parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Component type const--testcase parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {
        const integer MyIntConst := 1;
    }
    testcase MyTestcase( integer MyIntConst ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Function: identifier--parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Function: identifier--parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer MyFunc ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Parameter.+?MyFunc.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?MyFunc.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Function parameter--function const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Function parameter--function const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer MyIntConst ) {
        const integer MyIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc() {
        const integer MyIntConst := 1;
        if ( true ) {
            const integer MyIntConst := 2;
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Altstep: identifier--parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Altstep: identifier--parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( integer MyAltstep ) {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Parameter.+?MyAltstep.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?MyAltstep.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Altstep parameter--altstep const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Altstep parameter--altstep const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep( integer MyIntConst ) {
        const integer MyIntConst := 1;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAltstep() {
        const integer MyIntConst := 1;
        [] any port.check {
            const integer MyIntConst := 3;
        };
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Function_runs_on: identifier--parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Function_runs_on: identifier--parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyCompFunc ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Parameter.+?MyCompFunc.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?MyCompFunc.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Function_runs_on par.--function_runs_on const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Function_runs_on par.--function_runs_on const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc( integer MyIntConst ) runs on MyCompType {
        const integer MyIntConst := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer MyIntConst := 1;
        if ( true ) {
            const integer MyIntConst := 2;
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Altstep_runs_on: identifier--parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Altstep_runs_on: identifier--parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( integer MyCompAltstep ) runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Parameter.+?MyCompAltstep.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?MyCompAltstep.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Altstep_runs_on par.--altstep_runs_on const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Altstep_runs_on par.--altstep_runs_on const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep( integer MyIntConst ) runs on MyCompType {
        const integer MyIntConst := 5;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        const integer MyIntConst := 5;
        [] any port.check {
            const integer MyIntConst := 3;
        };
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Testcase: identifier--parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Testcase: identifier--parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyTestcase ) runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Parameter.+?MyTestcase.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?MyTestcase.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Testcase parameter--testcase const
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Testcase parameter--testcase const>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase( integer MyIntConst ) runs on MyCompType {
        const integer MyIntConst := 3;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Same const id.: embedded case--testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->Same const id.: embedded case--testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer MyIntConst := 3;
        if ( true ) {
            const integer MyIntConst := 2;
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?MyIntConst.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?MyIntConst.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::IdentifierOverloading->Port type
.*---------------------------------------------------------------------*
NOTE: TR684 segfault when a symbol is not found

:xmp tab=0.

<TC - TTCN-3::IdentifierOverloading->Port type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module m {

   type port p message { inout integer }
   type component c { port pt p }

   function f() runs on c return integer {
      alt {
         [] any port.trigger {}
      }
      return 9
   }

   function g() runs on c {
      alt {
         [] p.receive(f()) {}
         [else] {}
      }
   }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?p.+?not.+?unique
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Symbol.+?p.+?already.+?defined.+?higher.+?scope
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?local.+?or.+?imported.+?definition.+?pt
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Identifier overloading in parameter list
.*---------------------------------------------------------------------*
Strategy:
:nl.- Make a testcase for every case where we can use parameter list.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: modulepar
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: modulepar>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    modulepar {
        boolean par_1 := false;
	integer par_2, par_3;
	octetstring par_1
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?definition.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    function MyFunc( integer par_1, integer par_2, boolean par_1 ) {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    function MyFunc( integer par_1, integer par_2, boolean par_1 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: external function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: external function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
	external function MyExtFunc(
	    integer par_1,
	    timer par_2,
	    template boolean par_1
	);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    altstep MyAlt( integer par_1, integer par_2, boolean par_1 ) {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    altstep MyAlt( integer par_1, integer par_2, boolean par_1 ) runs on MyCT {
        [else] {}
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: tetscase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type component MyCT {}
    testcase MyTC( integer par_1, integer par_2, boolean par_1 ) runs on MyCT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyMessageType {
        integer    field1 optional,
        charstring field2,
        boolean    field3,
        integer    field4
    }
    template MyMessageType MyTemplate( integer par_1, boolean par_2, integer par_1 ) := {
        field1 := par_1,
        field2 := ?,
        field3 := par_2,
	field4  := par_1
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?definition.+?par_1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h4.TTCN-3::IdentifierOverloading->ParameterList: signature
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IdentifierOverloading->ParameterList: signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    signature MySig (in integer par_1, out float par_2, inout integer par_2);
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?parameter.+?par_2
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Parameter.+?par_2.+?already.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Ambiguous symbol reference
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-3/3.
:p. Explanation:
:nl.SA shall detect if a symbol reference is ambiguous.

:p.Test strategy:
:nl.  Every test has an explanation for the rule. The testcases are
      clear. See there.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AmbiguousSymbolReference->A.B notation
.*---------------------------------------------------------------------*
Requirement: A.B notation.
:p. Explanation:
:nl.A.B notation may refer to modul A or a local type called A ( where
:nl.the name of the current module may be A or something else ).

:xmp tab=0.

<TC - TTCN-3::AmbiguousSymbolReference->A.B notation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN A A.ttcn>
module A {
    type integer B;
    type record Rec {
        A.B field     // "A" meaning the module identifier
    }
    function Func(Rec FuncIn) return integer {
        return FuncIn.field;
    }
    control {
        var integer X := Func( {5} );
    }
}
<END_MODULE>
<MODULE TTCN AA AA.ttcn>
module AA {
    type boolean B;
    type record AA {
        integer B
    }
    type record Rec {
        AA.B field    // "AA" meaning the record type not the module identifier
    }
    function Func(Rec FuncIn) return integer {
        return FuncIn.field;
    }
    control {
        var integer X := Func( {5} );
    }
}
<END_MODULE>
<MODULE TTCN AAA AAA.ttcn>
module AAA {
    type integer B;
    type record AAA {
        boolean B
    }
    type record Rec {
        AAA.objid{0 4 0}.B field    // "AAA" meaning the record type not the module identifier
    }
    function Func(Rec FuncIn) return integer {
        return FuncIn.field;
    }
    control {
        var integer X := Func( {5} );
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\bwarning\b.+?Definition.+?AA.+?hides.+?module
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AmbiguousSymbolReference->Same name difference objid
.*---------------------------------------------------------------------*
Requirement: A.B notation.
:p. Explanation:
:nl.Two module names are the same but have different objid value, but a
:nl.reference is used only with the module name.
:p. NOTE: Objid is not supported yet in the module name.

:xmp tab=0.

<TC - TTCN-3::AmbiguousSymbolReference->Same name difference objid>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN A0 A0.ttcn>
module A.objid{0 4 0} {
    type integer B;
}
<END_MODULE>
<MODULE TTCN A1 A1.ttcn>
module A.objid{0 4 1} {
    type boolean B;
}
<END_MODULE>
<MODULE TTCN B B.ttcn>
module B {
    import from A.objid{0 4 0} all;
    import from A.objid{0 4 1} all;
    type record Rec1{
        A.objid{0 4 0}.B field1,   //reference is unambiguous
        A.objid{0 4 1}.B field2    //reference is unambiguous
    }
    type record Rec2{
        A.B field1   //reference is ambiguous
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?module.+?identifier.+?A.+?already
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?This.+?first.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::AmbiguousSymbolReference->Two symbols with the same name are imported
.*---------------------------------------------------------------------*
Requirement: A.B notation.
:p. Explanation:
:nl.Two symbols with the same name are imported from two modules. A reference
    like 'A' is ambiguous.

:xmp tab=0.

<TC - TTCN-3::AmbiguousSymbolReference->Two symbols with the same name are imported>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    import from ModuleC all;
    type record ModuleA { T field }
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type integer T;
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
    type integer T;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bwarning\b.+?Definition.+?ModuleA.+?hides.+?module
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?resolve.+?reference.+?unambiguously
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Imports
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-3/4.
:p. Explanation:
:nl.  Special rules applied when importing identifiers.

:p.Test strategy:
:nl.  Every test group has an explanation for the rule. The testcases are
      clear. See there.

:p.TODO:
:nl.  Harmonize the specification and the implementation (e.g. recursive,
      selective import).

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Objid in the modulename in import part
.*---------------------------------------------------------------------*
Requirement: Objid in the modulename in import part (7.5.0).
:p. Explanation:
:nl.If the object identifier is provided as part of the module name (from
    which the definitions are imported from) in the import statement, this
    object identifier shall be used to identify the correct module.
:p. NOTE: objid value is currently ignored, thus only the module name is
    considered when identifying a module.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Attributes of the imported definitions
.*---------------------------------------------------------------------*
Requirement: Attributes of the imported definitions (7.5.0).
:p. Explanation:
:nl.If an imported definition has attributes (defined by means of a with
    statement) then the attributes shall also be imported. If the module has
    global attributes they are associated to definitions without these
    attributes.
:p. NOTE: how to verify? should be covered in codec tests ?

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: control part
.*---------------------------------------------------------------------*
Requirement: Only top-level definitions (7.5.2)
:p. Explanation:
:nl.Only top-level definitions in the module may be imported.
:nl.Definitions which occur at a lower scope (e.g. local constants defined
    in a function) shall not be imported.

:xmp tab=0.

<TC - TTCN-3::Import->Only top-level definitions: control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    control {
        const integer B := 222;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: component type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: component type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type component CT {
        const integer B := 222;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    function FUN() {
        const integer B := 222;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: altstep>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    altstep ALT() {
        const integer B := 222;
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: function_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: function_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type component CT {}
    function FWR() runs on CT {
        const integer B := 222;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: altstep_runs_on
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: altstep_runs_on>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type component CT {}
    altstep AWR() runs on CT {
        const integer B := 222;
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Only top-level definitions: testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Import->Only top-level definitions: testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    const integer MyConst := B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type component CT {}
    testcase TC() runs on CT {
        const integer B := 222;
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?B
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Direct importing
.*---------------------------------------------------------------------*
Requirement: Direct importing (7.5.2).
:p. Explanation:
:nl.Only direct importing from the source module of a definition (i.e.
    the module where the actual definition for the identifier referenced
    in the import statement resides) is allowed.

:xmp tab=0.

<TC - TTCN-3::Import->Direct importing>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   type MyType MyType3;
   type MyType2 MyType4;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   import from ModuleC all;
   type MyType MyType2;
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type integer MyType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?\bMyType\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Field name importing
.*---------------------------------------------------------------------*
Requirement: Field name importing (7.5.2).
:p. Explanation:
:nl.A definition is imported together with its name and all local definitions.
:p. NOTE: A local definition, e.g. a field name of a user-defined record type,
    only has meaning in the context of the definitions in which it is defined,
    e.g. the field name of a record type can only be used to access a field of
    the record type and not outside this context.

:xmp tab=0.

<TC - TTCN-3::Import->Field name importing>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB all;
    control {
        var integer MyInt := field1;
    }
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type record RecType {
        integer field1,
	boolean field2
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?imported.+?definition.+?field1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Transitive importing
.*---------------------------------------------------------------------*
Requirement: Transitive importing (7.5.2).
:p. Explanation:
:nl.A definition is imported together with all information of referenced
    definitions that are necessary for the usage of the referenced definition.
:p. NOTE: Import statement are transitive, e.g. if a module A imports a
    a definition from module B that uses a type reference defined in module C,
    the corresponding information necessary for the the usage of that type
    is automatically imported into module A.

:xmp tab=0.

<TC - TTCN-3::Import->Transitive importing>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   const MyTypeB MyConst := { field1 := 10, field2 := McHalls }
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   import from ModuleC all;
   type record MyTypeB { integer field1, HiddenType field2 };
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type enumerated HiddenType { McHalls(0), was(1), here(9) };
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Non-recursive importing
.*---------------------------------------------------------------------*
Requirement: Non-recursive importing (7.5.2).
:p. Explanation:
:nl.As default, the identifiers of referenced definitions are not
    automatically imported. If the identifiers of the referenced
    definitions are wished to be implicitly imported, the recursive
    directive shall be used.

:xmp tab=0.

<TC - TTCN-3::Import->Non-recursive importing>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   const MyTypeB MyConst := { field1 := 10, field2 := McHalls }
   const HiddenType MyConst2 := was;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   import from ModuleC all;
   type record MyTypeB { integer field1, HiddenType field2 };
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type enumerated HiddenType { McHalls(0), was(1), here(9) };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?\bHiddenType\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?\bwas\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Recursive importing are not transitive in module boundaries
.*---------------------------------------------------------------------*
Requirement: Recursive importing are not transitive in module boundaries (7.5.2).
:p. Explanation:
:nl.As default, the identifiers of referenced definitions are not
    automatically imported. If the identifiers of the referenced definitions
    are wished to be implicitly imported, the recursive directive shall be
    used.
:p.NOTE: since selective importing is not supported, this requirement cannot
         be tested, only that no difference is shown no matter whether 'recursive'
         is used or not.

:xmp tab=0.

<TC - TTCN-3::Import->Recursive importing are not transitive in module boundaries>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB recursive all;
   const MyTypeB MyConst := { field1 := 10, field2 := McHalls }
   const HiddenType MyConst2 := was;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   import from ModuleC all;
   type record MyTypeB { integer field1, HiddenType field2 };
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type enumerated HiddenType { McHalls(0), was(1), here(9) };
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?\bHiddenType\b
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?no.+?definition.+?\bwas\b
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Selective imports
.*---------------------------------------------------------------------*
Requirement: Selective imports (7.5.2.f, 7.5.4, 7.5.7).
:p. Explanation:
:nl.When importing a type, function, altstep or testcase the corresponding
    behaviour specifications and all definitions used inside the behaviour
    specifications remain invisible for the importing module.
:p. NOTE: Selective imports are not supported
:nl.The result is positive but the implementation is inconsistent according
    to the TTCN-3 specification

:xmp tab=0.

<TC - TTCN-3::Import->Selective imports>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    import from ModuleB {
        function TC
    };
    type record RecTypeA {
	    RecTypeB field_1,
	    RecTypeB field_2
    }
    function FWR() runs on CT {}
    control {
        execute ( TC( {15,true} ) );
    }
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
    type record RecTypeB {
        integer field1,
	boolean field2
    }
    type component CT {}
    testcase TC( RecTypeB MyPar ) runs on CT {}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bwarning\b.+?Unsupported.+?selective.+?import
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?Generating.+?code
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Circular imports
.*---------------------------------------------------------------------*
Requirement: Circular imports (7.5.2).
:p. Explanation:
:nl.Circular imports are forbidden
:p. NOTE: Circular imports are allowed and reported as warnings

:xmp tab=0.

<TC - TTCN-3::Import->Circular imports>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   import from ModuleC all;
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   import from ModuleA all;
}
<END_MODULE>
<RESULT IF_PASS COUNT 3>
(?im)\bwarning\b.+?Circular.+?import
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Import from the same module
.*---------------------------------------------------------------------*
Requirement: Import from the same module (7.5).
:p. Explanation:
:nl.A module cannot import from itself.

:xmp tab=0.

<TC - TTCN-3::Import->Import from the same module>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleA all;
   const integer MyConst := 666;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?cannot.+?import.+?itself
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Duplicated import
.*---------------------------------------------------------------------*
Requirement: Duplicated import (7.5).
:p. Explanation:
:nl.A modulename is listed twice to import from, not problem but inefficient.

:xmp tab=0.

<TC - TTCN-3::Import->Duplicated import>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   import from ModuleB all;
   const integer MyConst := 666;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   const integer MyConstB := 666;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)Notify: File `ModuleA.hh' was generated.
<END_RESULT>
<END_TC>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Importing groups
.*---------------------------------------------------------------------*
Requirement: Importing groups (7.5.6).
:p.NOTE: Groups cannot be imported

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Name clash on import->Same identifier is imported
.*---------------------------------------------------------------------*
Requirement: Name clash on import (7.5.8).
:p. Explanation:
:nl.Two identical identifiers are used in two different modules. If these
    identifiers are imported into the same module, it is not possible to
    differentiate them unless they are prefixed with the module's name.

:xmp tab=0.

<TC - TTCN-3::Import->Name clash on import->Same identifier is imported>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   import from ModuleC all;
   // TR 630: Error message is not really applicable
   const MyType MyConst := 10;
   const ModuleB.MyType MyConst2 := 10;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   type integer MyType;
}
<END_MODULE>
<MODULE TTCN ModuleC ModuleC.ttcn>
module ModuleC {
   type integer MyType;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?resolve.+?reference.+?unambiguously
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Import->Name clash on import->A.B notation
.*---------------------------------------------------------------------*
Requirement: Name clash on import (7.5.8).
:p. Explanation:
:nl.A reference cannot be resolved if the imported module "A" uses an
    identifier "B" and there is a local variable or constant whose name
    is "A" and has a field named "B". The notation "A.B" causes confusion.

:xmp tab=0.

<TC - TTCN-3::Import->Name clash on import->A.B notation>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   import from ModuleB all;
   type record MyType { integer B }
   const MyType ModuleB := { B := 10 };
   // TR 631: name clash using the A.B notation
   const integer MyConst1 := ModuleB.B;
   const integer MyConst2 := ModuleA.ModuleB.B;
}
<END_MODULE>
<MODULE TTCN ModuleB ModuleB.ttcn>
module ModuleB {
   const integer B := 666;
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bwarning\b.+?Definition.+?ModuleB.+?hides
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Uniqueness of field names
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-3/5.
:p. Explanation:
:nl.- Field names within compound types shall be unique locally.

:p. Test strategy:
:nl.- Make a testcase for every type where we can use fields.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Uniqueness_Of_Field_Names-> Record type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Uniqueness_Of_Field_Names-> Record type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyRecord {
        integer field1,
	charstring field2,
	integer field1,
	boolean field2 optional
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field2
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field2.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Uniqueness_Of_Field_Names-> Union type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Uniqueness_Of_Field_Names-> Union type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type union MyUnion {
        integer field1,
	charstring field2,
	integer field1,
	boolean field2
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field2
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field2.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Uniqueness_Of_Field_Names-> Set type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Uniqueness_Of_Field_Names-> Set type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type set MySet {
        integer field1,
	charstring field2,
	integer field1,
	boolean field2 optional
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field1
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?name.+?field2
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field2.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::Uniqueness_Of_Field_Names-> Template
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Uniqueness_Of_Field_Names-> Template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type record MyMessageType {
        integer    field1 optional,
        charstring field2,
        boolean    field3,
        integer    field4
    }
    template MyMessageType MyTemplate( integer par_1, boolean par_2, integer par_3 ) := {
        field1 := par_1,
        field2 := ?,
        field3 := par_2,
	field4 := par_1,
	field1 := par_3
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?field.+?field1.+?template
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Field.+?field1.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Uniqueness of enumeration identifiers
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-3/6.
:p. Explanation:
:nl.- Enumeration identifiers shall be unique within the enumerated type.
:nl.- Enumeration identifiers shall only be reused within other sructured
      type definitions (such as element identifiers) and shall not be used
      for identifiers of local or global visibility at the same or a lower
      level of the same branch of the scope hierarchy.

:p. Test strategy:
:nl.- First the same enumeration identifiers are checked in the same
      enumerated type (one case).
:nl.- The MDP bubble (enum definition) is checked with every bubble on the
      1.,2. and 3. levels (left to right direction).
      The whole branch is checked if a bubble has only one child.
      Every testcase is positive but it is not correct result because the
      implementation is inconsistent according to the TTCN-3 specification.

:p. TODO:
:nl.  Harmonize the specification and the implementation.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Duplicated enumeration identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Duplicated enumeration identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W, Monday};
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?Duplicate.+?identifier.+?Monday
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnote\b.+?Previous.+?Monday.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Same level: another type identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Same level: another type identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type integer Monday;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Same level: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Same level: const identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    const integer Monday := 1;
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Control part: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Control part: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    control {
        const integer Monday := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Component type identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Component type identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component Monday {}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Component type: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Component type: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {
        const integer Monday := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Function identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Function identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    function Monday() {}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Function: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Function: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    function MyFunc() {
        const integer Monday := 1;
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Altstep identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Altstep identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    altstep Monday() {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Altstep: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Altstep: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    altstep MyAltstep() {
        const integer Monday := 1;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Function_runs_on identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Function_runs_on identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    function Monday() runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Function_runs_on: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Function_runs_on: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    function MyCompFunc() runs on MyCompType {
        const integer Monday := 3;
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Altstep_runs_on identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Altstep_runs_on identifier>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    altstep Monday() runs on MyCompType {
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Altstep_runs_on: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Altstep_runs_on: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    altstep MyCompAltstep() runs on MyCompType {
        const integer Monday := 1;
        [] any port.check {};
        [else] {};
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Testcase identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Testcase identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    testcase Monday() runs on MyCompType {}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3::UniquenessEnumId-> Testcase: const identifier
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::UniquenessEnumId-> Testcase: const identifier>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
    type enumerated MyEnum {Monday, T, W};
    type component MyCompType {}
    testcase MyTestcase() runs on MyCompType {
        const integer Monday := 3;
    }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bGenerating\b.+?\bcode\b
<END_RESULT>

<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Uniqueness of group names
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-3/7.
:p. Explanation:
:nl.- Group identifiers across the whole module need not necessarily be unique.
      However, all group identifiers on the same level of hierarchy shall be
      unique and sub-groups in a lower level of hierarchy shall not have the
      same name as a group in a higher level of hierarchy.


.*---------------------------------------------------------------------*
:h3. group scope test 1
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group scope test 1 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     type integer int1;
   }
   group grp1 {
     type integer int2;
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Duplicate group with name
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\bnote\b.+Group .+ is already defined here
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. group scope test 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group scope test 2 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     type integer int1
   }
   group grp2 {
     type integer int1
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Duplicate definition with name
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. group scope test 3
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group scope test 3 >
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   type integer int1
   group grp1 {
     type integer int1
   }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\berror\b.+Duplicate definition with name
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. group scope test 4
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group scope test 4 >
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     group grp3 {
     }
   }
   group grp2 {
     group grp3 {
     }
   }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)\berror\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3. group scope test 5
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - group scope test 5 >
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {
   group grp1 {
     group grp3 {
       type integer my_type_1;
     }
   }
   group grp2 {
     group grp3 {
       type charstring my_type_2;
     }
   }
   control
   {
     const my_type_1 i1 := 1;
     const my_type_2 c1 := "";
   }
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)\berror\b
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?im)\bwarning\b
<END_RESULT>
<END_TC>
:exmp.

:np.
.*---------------------------------------------------------------------*
:h2.Runs on self functions
.*---------------------------------------------------------------------*
This test case group covers the requirement SA-x/x.
:p. Explanation:
:nl.- There is no need to predefine and set the component where the function 
      will run any more. Instead the "runs on self" clause can be used in case. 
      This type of function and function reference cannot be a part any of the send
      or receive statement, not compatible with other functions with exacly defined
      runs on clause.
      And also function with runs on clause cannot be the argument of any 
      Component's start().
      

.*---------------------------------------------------------------------*
:h3.TTCN-3:: Runs on self: type mismatch
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Runs on self: type mismatch>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

type function CallbackFunctionRefRunsonLib () runs on Library_CT;
type function CallbackFunctionRefRunsonSelf () runs on self;

type component Library_CT
{
  var CallbackFunctionRefRunsonSelf v_CallbackRef_self := null;
  var CallbackFunctionRefRunsonLib  v_CallbackRef_LibCT := null;
  var integer v_Lib;
}

function f_testFunc() runs on Library_CT
{
  v_CallbackRef_self := v_CallbackRef_LibCT;
  
  v_CallbackRef_LibCT := v_CallbackRef_self;
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Type mismatch: a value of type `@ModuleA.CallbackFunctionRefRunsonSelf' was expected instead of `@ModuleA.CallbackFunctionRefRunsonLib'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: Type mismatch: a value of type `@ModuleA.CallbackFunctionRefRunsonLib' was expected instead of `@ModuleA.CallbackFunctionRefRunsonSelf'
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3:: Runs on self: start
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Runs on self: start>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

type function CallbackFunctionRefRunsonLib () runs on Library_CT;
type function CallbackFunctionRefRunsonSelf () runs on self;

type component Library_CT
{
  var CallbackFunctionRefRunsonSelf v_CallbackRef_self := null;
  var CallbackFunctionRefRunsonLib  v_CallbackRef_LibCT := null;
  var integer v_Lib;
}

function f_testFunc() runs on Library_CT
{
  
  var Library_CT libCT := Library_CT.create;
  
  libCT.start(derefers(v_CallbackRef_self)());
   
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: The argument cannot be a function reference with 'runs on self' clause
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3:: Runs on self: send
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Runs on self: send>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

type port MyPort_PT message
{
  inout myRec_t
}

type function CallbackFunctionRefRunsonLib () runs on Library_CT;
type function CallbackFunctionRefRunsonSelf () runs on self;

type record myRec_t
{
  integer i,
  CallbackFunctionRefRunsonSelf callbSelf
}

type component Library_CT
{
  var CallbackFunctionRefRunsonSelf v_CallbackRef_self := null;
  var CallbackFunctionRefRunsonLib  v_CallbackRef_LibCT := null;
  var integer v_Lib;
  
  port MyPort_PT MyPort;
}

function f_testFunc() runs on Library_CT
{
  
  var myRec_t myrec := {i := 0, callbSelf := refers(f_testFunc)};
  
  MyPort.send(myrec);
   
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Function type `@ModuleA.CallbackFunctionRefRunsonSelf' with 'runs on self' clause cannot be sent or received on a port
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.TTCN-3:: Runs on self: module parameter
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::Runs on self: module parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

type function f_runsonSelf () runs on self;
modulepar f_runsonSelf m_modPar;

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror: Type of module parameter cannot be of function reference type.+?which has runs on self clause
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.3/ETH/RUS-2003:0087 Uen
:nl.Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:li D='[2]'.1/174 02-FCPCA 101 42 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

