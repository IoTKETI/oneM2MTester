.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Baji, Laszlo
.*   Balasko, Jeno
.*   Baranyi, Botond
.*   Bartha, Norbert
.*   Beres, Szabolcs
.*   Czerman, Oliver
.*   Delic, Adam
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Raduly, Csaba
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szabo, Bence Janos
.*   Szalai, Endre
.*   Tatarka, Gabor
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.2x/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27

:prep.ETH/XZ Jeno Balasko
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the TTCN-3 Semantic Analyzer: Adhoc tests
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
-     2005-02-19   EGBOTAT    New document for TITAN R1.6
-     2005-06-30   ETIBHRA    Added select-case, alive, interleave tests
-     2005-08-16   ETIBHRA    Deleted select-case, alive, interleave tests
-     2007-12-03   ETHNBA     TCs for IsBound are added
-     2008-02-05   ETHNBA     IsBound changed to IsValue
-     2009-06-11   EKRISZA    Name correction
-     2010-08-10   EKRISZA    decvalue test added
G     2010-08-13   EKRISZA    updated version number
H     2010-12-14   EKRISZA    updated version number
J     2011-05-26   EKRISZA    updated version number
A     2011-12-12   EKRISZA    Updated for release
B     2012-04-13   EFERKOV    Updated for release
A     2012-06-27   EFERKOV    Updated for release
A     2013-01-17   EKRIPND    Updated for release
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
This document contains adhoc tests for TTCN-3 Semantic Analyser. These test
cases shall be moved to different test descriptions in forthcoming
projects.
.*---------------------------------------------------------------------*
:h2.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Adhoc - Duplicate definition
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - Duplicate definition>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  var integer I, I;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)duplicate.+?definition
<END_RESULT>
<RESULT COUNT 1>
(?im)previous.+?definition
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - Duplicated label
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - Duplicated label>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  label L1;
  goto L1;
  label L1;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)duplicate.+?label
<END_RESULT>
<RESULT COUNT 1>
(?im)previous.+?definition
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - goto label
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - goto label>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  goto L1; // same scope
  label L1;
  while(true) {
    goto L2; // different scope 1 (to higher scope)
    label L3;
  }
  label L2;
  goto L3; // different scope 2 (to lower scope)
  goto L4; // nonexistent label
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)label.+?\bnot\b.+?defined
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - loop alt guards
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - loop alt guards>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  timer T1, T2;
  var boolean b := true;
  T1.start(1.0);
  T2.start(1.1);
  alt {
    // Statement::set_my_ags() -> case S_WHILE
    [b==true] T1.timeout { while(true) { } }
    [b] T2.timeout { while(true) { b:=0; } }
  }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)boolean.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - Embedded statement block
.*---------------------------------------------------------------------*
Note: Statement blocks can be created.
:xmp tab=0.

<TC - Adhoc - Embedded statement block>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  {
    { }
  }
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - function instance
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - function instance>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType message { inout integer }
type component MyComponent { port MyPortType MyPort; }
function F() runs on MyComponent { }

testcase TC() runs on MyComponent {
  var MyComponent C;
  C.start(F(123));
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)\btoo\b.+?many.+?parameters
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - action statement
.*---------------------------------------------------------------------*
Note: this is a positive test. Errors would have been catched by the
parser, thus not increasing code coverage of the semantic analyser.

:xmp tab=0.

<TC - Adhoc - action statement>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() {
  action("qwerty");
}

}
<END_MODULE>
<RESULT>
(?im)\bnotify\b.+?\bfiles\b.+?\bupdated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - start/stop non-port/timer/component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - start/stop non-port/timer/component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType message { inout integer }
type component MyComponent { port MyPortType MyPort; }
function F() runs on MyComponent { }
altstep AS(timer T) {
  []T.timeout { }
}

testcase TC() runs on MyComponent {
  var integer I, J, K;
  I.start(1.0);
  J.start(F());
  K.start;
  I.stop;
  AS.start;
  AS.stop;
}

}
<END_MODULE>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - start port operation with argument
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - start port operation with argument>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType message { inout integer }
type component MyComponent { port MyPortType MyPort; }
function F() runs on MyComponent { }

testcase TC() runs on MyComponent {
  MyPort.start(123.4);
  MyPort.start(F());
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)start.+?port.+?operation.+?cannot.+?have.+?argument
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - return type of signature
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - return type of signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig1() return integer;
signature Sig2();
signature Sig3() return integer;
signature Sig4();
type port MyPortType procedure { inout Sig1, Sig2 }
type component MyComponent { port MyPortType MyPort }

testcase TC() runs on MyComponent {
  MyPort.reply(Sig1:{});
  MyPort.reply(Sig2:{} value "qwerty");
  MyPort.reply(Sig3:{});
  MyPort.reply(Sig4:{} value 1);
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)missing.+?return.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)unexpected.+?return.+?value
<END_RESULT>
<RESULT COUNT 2>
(?im)signature.+?not.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - raising port, signature and default type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - raising port, signature and default type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig1(); // no exception!
type port MyPortType procedure { inout Sig1 }
type component MyComponent { port MyPortType MyPort }

testcase TC() runs on MyComponent {
  var default d;
  // The following is a workaround to get a specific error message.
  var MyPortType portVar;
  MyPort.raise(Sig1, portVar);
  MyPort.raise(Sig1, Sig1:{});
  MyPort.raise(Sig1, d);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)variable.+?cannot.+?\bbe\b.+?defined.+?\bfor\b.+?port
<END_RESULT>
<RESULT COUNT 1>
(?im)raise.+?parameter.+?port.+?cannot.+?\bbe\b.+?exception.+?type
<END_RESULT>
<RESULT COUNT 3>
(?im)signature.+?does.+?\bnot\b.+?have.+?exceptions
<END_RESULT>
<RESULT COUNT 1>
(?im)raise.+?parameter.+?default.+?cannot.+?\bbe\b.+?exception.+?type
<END_RESULT>
<RESULT COUNT 1>
(?im)raise.+?parameter.+?signature.+?cannot.+?\bbe\b.+?exception.+?type
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - any port operation with parameter
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - any port operation with parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception(float);
type port MPortType message { inout integer }
type port PPortType procedure { inout Sig }
type component MyComponent {
  port MPortType MPort;
  port PPortType PPort;
}

testcase TC() runs on MyComponent {
  alt {
    []any port.receive(integer:?) { }
    []any port.check(receive(integer:?)) { }

    []any port.getcall(Sig:{}) { }
    []any port.getreply(Sig:{}) { }
    []any port.catch(Sig, float:?) { }
    []any port.check(getcall(Sig:{})) { }
    []any port.check(getreply(Sig:{})) { }
    []any port.check(catch(Sig, float:?)) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operation.+?\bany\b.+?port.+?cannot.+?have.+?parameter
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - any port operation with redirect
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - any port operation with redirect>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig(inout integer Par) return integer exception(float);
type port MPortType message { inout integer }
type port PPortType procedure { inout Sig }
type component MyComponent {
  port MPortType MPort;
  port PPortType PPort;
}

testcase TC() runs on MyComponent {
  var integer I, J;
  var float F;
  alt {
    []any port.receive(integer:?) -> value I { }
    []any port.check(receive(integer:?) -> value I) { }

    []any port.getcall(Sig:{0}) -> param(I) { }
    []any port.getreply(Sig:{0}) -> value J param(I) { }
    []any port.catch(Sig, float:?) -> value F { }
    []any port.check(getcall(Sig:{0}) -> param(I)) { }
    []any port.check(getreply(Sig:{0}) -> value J param(I)) { }
    []any port.check(catch(Sig, float:?) -> value F) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 8>
(?im)operation.+?\bany\b.+?port.+?cannot.+?have.+?parameter\s*$
<END_RESULT>
<RESULT COUNT 6>
(?im)operation.+?\bany\b.+?port.+?cannot.+?have.+?value.+?redirect
<END_RESULT>
<RESULT COUNT 4>
(?im)operation.+?\bany\b.+?port.+?cannot.+?have.+?parameter.+?redirect
<END_RESULT>
<RESULT COUNT 18>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - message based port operation with procedure based ports
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - message based port operation with procedure based ports>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType procedure { inout Sig }
type component MyComponent { port MyPortType MyPort; }

testcase TC() runs on MyComponent {
  MyPort.send(9);
  alt {
    // TR-682: message based operation on procedure based port and vice versa
    []MyPort.receive { }
    []MyPort.trigger { }
    []MyPort.check(receive) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)message.+?based.+?operation.+?procedure.+?based.+?port
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - procedure based port operation with message based ports
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - procedure based port operation with message based ports>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception(integer);
type port MyPortType message { inout integer }
type component MyComponent { port MyPortType MyPort; }

testcase TC() runs on MyComponent {
  MyPort.call(Sig:{ }, nowait);
  MyPort.reply(Sig:{ });
  MyPort.raise(Sig, 10);
  alt {
    // TR-682: message based operation on procedure based port and vice versa
    []MyPort.check(getcall) { }
    []MyPort.check(getreply(Sig:{ })) { }
    []MyPort.check(catch(Sig, integer: ?)) { }
  }
  alt {
    []MyPort.getcall(Sig:{ }) { }
    []MyPort.getreply(Sig:{ }) { }
    []MyPort.catch(Sig, integer: ?) { }
  }
  MyPort.call(Sig:{ }, 10.0) {
    []MyPort.getreply(Sig:{ }) { }
    []MyPort.catch(timeout) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 11>
(?im)procedure.+?based.+?operation.+?message.+?based.+?port
<END_RESULT>
<RESULT COUNT 1>
(?im)timeout.+?exception.+?message.+?based.+?port
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - blocking call: getreply refers to different port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - blocking call: getreply refers to different port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig() exception(integer);

type port MyPortType1 procedure { inout Sig }
type port MyPortType2 procedure { inout Sig }

type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2
}

testcase TC() runs on MyComponent {
  MyPort1.call(Sig:{ }, 10.0) {
    []MyPort2.getreply(Sig:{ }) { }
    []MyPort2.getreply { }
    []MyPort2.catch(Sig, integer: ?) { }
    []MyPort2.catch { }
    []MyPort2.catch(timeout) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)operation.+?refers.+?\bto\b.+?different.+?port
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - message type not present on outgoing list of port
.*---------------------------------------------------------------------*
Note: this test is similar to one of the testcases in TTCN3_SA_5_TD.script
with the exception that the outgoing list contains more then one message type.
:xmp tab=0.

<TC - Adhoc - message type not present on outgoing list of port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType message { out integer, float, charstring }
type component MyComponent { port MyPortType MyPort; }

testcase TC() runs on MyComponent {
  MyPort.send('0111'B);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)message.+?type.+?\bnot\b.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - inconsistent port connections
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - inconsistent port connections>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType1 message {
  out integer, float, boolean;
  in bitstring;
}
type port MyPortType2 message {
  out bitstring, charstring, octetstring;
  in integer;
}
type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent {
  connect(self:MyPort1, self:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)connection.+?between.+?port.+?types.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 4>
(?im)outgoing.+?message.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - connecting message based port to procedure based port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - connecting message based port to procedure based port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType1 message { inout integer }
type port MyPortType2 procedure { inout Sig }
type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent {
  connect(self:MyPort1, self:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)connection.+?between.+?port.+?types.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?message.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?signature.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - inconsistent port connections (with two components)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - inconsistent port connections (with two components)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType1 message {
  out integer, float, boolean;
  in bitstring;
}
type port MyPortType2 message {
  out bitstring, charstring, octetstring;
  in integer;
}
type component MyComponent1 { port MyPortType1 MyPort1 }
type component MyComponent2 { port MyPortType2 MyPort2 }

testcase TC() runs on MyComponent1 {
  var MyComponent2 comp2;
  connect(self:MyPort1, comp2:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)connection.+?between.+?port.+?types.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 4>
(?im)outgoing.+?message.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - connecting message based port to procedure based port (with two components)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - connecting message based port to procedure based port (with two components)>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType1 message { inout integer }
type port MyPortType2 procedure { inout Sig }

type component MyComponent1 { port MyPortType1 MyPort1 }
type component MyComponent2 { port MyPortType2 MyPort2 }

testcase TC() runs on MyComponent1 {
  var MyComponent2 comp2;
  connect(self:MyPort1, comp2:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)connection.+?between.+?port.+?types.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?message.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?signature.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - mapping internal ports
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - mapping internal ports>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType1 message { inout integer } with { extension "internal" }
type port MyPortType2 procedure { inout Sig } with { extension "internal" }

type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent system MyComponent {
  // note: these will only cause warnings.
  map(self:MyPort1, system:MyPort1);
  map(self:MyPort2, system:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)port.+?type.+?marked.+?\bas\b.+?internal
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - inconsistent port mappings
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - inconsistent port mappings>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType1 message {
  out integer, float, boolean;
  in bitstring;
}
type port MyPortType2 message {
  out bitstring, charstring, octetstring;
  in integer;
}
type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent system MyComponent {
  map(self:MyPort1, system:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)mapping.+?between.+?port.+?type.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 3>
(?im)outgoing.+?message.+?type.+?\bnot\b.+?present.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)incoming.+?message.+?type.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - mapping message based port to procedure based port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - mapping message based port to procedure based port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType1 message { inout integer }
type port MyPortType2 procedure { inout Sig }
type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent system MyComponent {
  map(self:MyPort1, system:MyPort2);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)mapping.+?between.+?port.+?type.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?message.+?\bnot\b.+?present.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)incoming.+?signature.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - mapping procedure based port to message based port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - mapping procedure based port to message based port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type port MyPortType1 message { inout integer }
type port MyPortType2 procedure { inout Sig }
type component MyComponent {
  port MyPortType1 MyPort1;
  port MyPortType2 MyPort2;
}

testcase TC() runs on MyComponent system MyComponent {
  map(self:MyPort2, system:MyPort1);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)mapping.+?between.+?port.+?type.+?\bnot\b.+?consistent
<END_RESULT>
<RESULT COUNT 1>
(?im)outgoing.+?signature.+?\bnot\b.+?present.+?\bon\b.+?outgoing.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)incoming.+?message.+?\bnot\b.+?present.+?\bon\b.+?incoming.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - executing non-testcase
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - executing non-testcase>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F() { }
external function extF();
signature S();
altstep A() {
  timer T;
  []T.timeout { }
}

control {
  var integer I;
  execute(F());
  execute(extF());
  execute(S());
  execute(A());
  execute(I());
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)reference.+?\bto\b.+?testcase.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?im)referenced.+?cannot.+?have.+?actual.+?parameters
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - return statement in control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - return statement in control part>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

control {
  timer T;
  alt {
    []T.timeout { return 0; }
  }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)\bparse\b.+?\berror\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port operation in control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port operation in control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

control {
  alt { // standalone port operations would cause parser error
    []any port.receive { }
    []any port.getcall { }
    []any port.getreply { }
    []any port.catch { }

    []any port.check(receive) { }
    []any port.check(getcall) { }
    []any port.check(getreply) { }
    []any port.check(catch) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 8>
(?im)port.+?operation.+?\bnot\b.+?allowed.+?\bin\b.+?control.+?part
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port operation: redirect to constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port operation: redirect to constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig(inout integer Par) return bitstring exception(charstring);
template Sig tSig := { Par:=? }
type port PPortType procedure { inout Sig }
type port MPortType message { inout integer }
type component MyComponent { port PPortType PPort; port MPortType MPort; }

const integer cI:=0;
const bitstring cBS:=''B;
const charstring cCS:="";

testcase TC() runs on MyComponent {
  alt {
    []MPort.receive(integer:?) -> value cI { }
    []PPort.getcall(tSig) -> param(cI) { }
    []PPort.getreply(tSig value ?) -> value cBS param(cI) { }
    []PPort.check(catch(Sig, charstring:?) -> value cCS) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)reference.+?\bto\b.+?variable.+?\bor\b.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port operation: redirect to type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port operation: redirect to type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig(inout integer Par) return bitstring exception(charstring);
template Sig tSig := { Par:=? }
type port PPortType procedure { inout Sig }
type port MPortType message { inout integer }
type component MyComponent { port PPortType PPort; port MPortType MPort; }

type integer tI;
type bitstring tBS;
type charstring tCS;

testcase TC() runs on MyComponent {
  alt {
    []MPort.receive(integer:?) -> value tI { }
    []PPort.getcall(tSig) -> param(tI) { }
    []PPort.getreply(tSig value ?) -> value tBS param(tI) { }
    []PPort.check(catch(Sig, charstring:?) -> value tCS) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 5>
(?im)reference.+?\bto\b.+?variable.+?\bor\b.+?value.+?parameter.+?expected
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - check port operation: sender redirect
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - check port operation: sender redirect>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MyPortType message { inout integer }
type component MyComponent { port MyPortType MyPort; }

testcase TC() runs on MyComponent {
  var MyComponent Peer;
  alt {
    []MyPort.check (-> sender Peer) { }
  }
}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port operation: '*' in matching template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port operation: '*' in matching template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port PT message {
  inout integer, charstring
}

signature sig() return integer exception (integer, charstring);

type port PT2 procedure {
  inout sig
}

type component CT {
  port PT pt;
  port PT2 pt2;
}

template integer t := *;

testcase TC() runs on CT {
  var integer x;
  alt {
    [] pt.receive(*) { }
    [] pt.receive(integer: *) -> value x { }
    [] pt.receive(t) { }
    [] pt2.getreply(sig: { } value *) -> value x { }
    [] pt2.getreply(sig: { } value integer: *) { }
    [] pt2.getreply(sig: { } value t) -> value x { }
    [] pt2.catch(sig, *) { }
    [] pt2.catch(sig, integer: *) -> value x { }
    [] pt2.catch(sig, t) { }
    [] pt.check(receive(*) -> value x) { }
    [] pt.check(receive(integer: *)) { }
    [] pt.check(receive(t) -> value x) { }
    [] pt2.check(getreply(sig: { } value *)) { }
    [] pt2.check(getreply(sig: { } value integer: *) -> value x) { }
    [] pt2.check(getreply(sig: { } value t)) { }
    [] pt2.check(catch(sig, *) -> value x) { }
    [] pt2.check(catch(sig, integer: *)) { }
    [] pt2.check(catch(sig, t) -> value x) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)Cannot.+?\bdetermine\b.+?the.+?\btype\b.+?of.+?the\b.+?incoming\b.+?message
<END_RESULT>
<RESULT COUNT 2>
(?im)Cannot.+?\bdetermine\b.+?the.+?\btype\b.+?of.+?the\b.+?exception
<END_RESULT>
<RESULT COUNT 18>
(?im)\'\*\'.+?\bcannot\b.+?be.+?\bused\b.+?as.+?matching\b.+?template\b.+?for\b.+?operation
<END_RESULT>
<RESULT COUNT 22>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - component operation in control part
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - component operation in control part>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig(inout integer Par) return bitstring exception(charstring);
template Sig tSig := { Par:=? }
type port PPortType procedure { inout Sig }
type port MPortType message { inout integer }
type component MyComponent { port PPortType PPort; port MPortType MPort; }

function F() runs on MyComponent { }

control {
  var MyComponent C1, C2;
  // TR-683: Create and running component operations in control part
  C2 := MyComponent.create;
  if(C1.running) { }
  alt {
    []C1.done {
      connect(C1:PPort, C2:PPort); // 2 operands -> 2 errors!
      map(C1:MPort, system:MPort); // 2 operands -> 2 errors!
      disconnect(C1:PPort, C2:PPort); // 2 operands -> 2 errors!
      unmap(C1:MPort, system:MPort); // 2 operands -> 2 errors!
      C1.start(F());
    }
  }
  C1.stop;
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)operation.+?create.+?\bnot\b.+?allowed.+?\bin\b.+?control.+?part
<END_RESULT>
<RESULT COUNT 1>
(?im)operation.+?component.+?running.+?\bnot\b.+?allowed.+?\bin\b.+?control.+?part
<END_RESULT>
<RESULT COUNT 11>
(?im)component.+?operation.+?\bnot\b.+?allowed.+?\bin\b.+?control.+?part
<END_RESULT>
<RESULT COUNT 13>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - operations on not allowed component types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - operations on not allowed component types>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type port MPortType message { inout integer }
type component MyComponent { port MPortType MPort; }

function F() runs on MyComponent { }

const MyComponent Null := null;

testcase TC() runs on MyComponent system MyComponent {
  map(Null:MPort, system:MPort);
  unmap(Null:MPort, system:MPort);
  connect(Null:MPort, self:MPort);
  disconnect(self:MPort, Null:MPort);
  map(mtc:MPort, self:MPort);
  connect(self:MPort, system:MPort);
  Null.start(F());
  Null.stop;
  // TR-683: Create and running component operations in control part
  // (in the `note' section: running operation on null component reference)
  if(Null.running) { Null.done; }
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)operand.+?refers.+?\bto\b.+?null.+?component.+?reference
<END_RESULT>
<RESULT COUNT 7>
(?im)null.+?component.+?reference.+?shall.+?not.+?used.+?operation
<END_RESULT>
<RESULT COUNT 1>
(?im)both.+?endpoints.+?are.+?test.+?component.+?ports
<END_RESULT>
<RESULT COUNT 1>
(?im)system.+?component.+?reference.+?shall.+?not.+?used.+?operation
<END_RESULT>
<RESULT COUNT 10>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - create, map/unmap operation on non-component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - create, map/unmap operation on non-component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer cInt := 9;
type integer INT;

function F() runs on INT { }

testcase TC() runs on INT system INT {
  var integer vInt := 10;
  vInt := INT.create;
  map(vInt:MyPort, system:MyPort);
  unmap(vInt:MyPort, system:MyPort);
}

}
<END_MODULE>
<RESULT COUNT 3>
(?im)reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)type.+?\bof\b.+?operand.+?should.+?\bbe\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 1>
(?im)reference.+?\bto\b.+?component.+?type.+?expected
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - connect/disconnect on non-component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - connect/disconnect operation on non-component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer cInt := 9;
type integer INT;

testcase TC() runs on INT system INT {
  var integer vInt := 10;
  connect(vInt:MyPort, cInt:MyPort);
  disconnect(vInt:MyPort, cInt:MyPort);
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)type.+?\bof\b.+?operand.+?should.+?\bbe\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)component.+?reference.+?expected.+?\bas\b.+?operand
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - start/stop operation on non-component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - start/stop operation on non-component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer cInt := 9;
type integer INT;

function F() runs on INT { }

testcase TC() runs on INT system INT {
  var integer vInt := 10;
  vInt.start(F());
  vInt.stop;
}

}
<END_MODULE>
<RESULT COUNT 3>
(?im)reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 2>
(?im)type.+?\bof\b.+?operand.+?should.+?\bbe\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - running/done operation on non-component
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - running/done operation on non-component>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

const integer cInt := 9;
const integer INT := 120;

testcase TC() runs on INT system INT {
  var integer vInt := 10;
  if(vInt.running) {
    vInt.done;
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?type
<END_RESULT>
<RESULT COUNT 1>
(?im)type.+?\bof\b.+?operand.+?should.+?\bbe\b.+?component.+?type
<END_RESULT>
<RESULT COUNT 1>
(?im)component.+?reference.+?expected
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - connect/map on non-port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - connect/map on non-port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component MyComponent { var integer vInt; }

testcase TC() runs on MyComponent system MyComponent {
  var MyComponent C;
  connect(C:vInt, self:vInt);
  map(self:vInt, system:vInt);
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)definition.+?\bis\b.+?variable.+?\bnot\b.+?port
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - send/receive on non-port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - send/receive on non-port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type component MyComponent { var integer vInt; }

testcase TC() runs on MyComponent system MyComponent {
  var integer lInt;
  vInt.send(3);
  alt {
    []lInt.receive(integer:?) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 2>
(?im)reference.+?\bto\b.+?port.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - call/getreply on non-port
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - call/getreply on non-port>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

signature Sig();
type component MyComponent { var integer vInt; }

testcase TC() runs on MyComponent system MyComponent {
  var MyComponent C;
  vInt.call(Sig:{}, 10.0) {
    []vInt.getreply(Sig:{}) { }
    []vInt.catch { }
    []vInt.catch(timeout) { }
  }
}

}
<END_MODULE>
<RESULT COUNT 4>
(?im)reference.+?\bto\b.+?port.+?expected
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - too few or too many parameters to reference
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - too few or too many parameters to reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

function F(in integer A, in float B, in charstring E) { }

function G() {
  F(0, 1.0);
  F(0, 1.0, "two", '0011'B);
}

}
<END_MODULE>
<RESULT COUNT 1>
(?im)\btoo\b.+?few.+?parameters
<END_RESULT>
<RESULT COUNT 1>
(?im)\btoo\b.+?many.+?parameters
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - imported component element hides a definition at module scope
.*---------------------------------------------------------------------*
NOTE: causes only warning messages.
:xmp tab=0.

<TC - Adhoc - imported component element hides a definition at module scope>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN TempA TempA.ttcn>
    module TempA {
      type component MyComponent { const integer Hidden := 9; }
    }
<END_MODULE>
<MODULE TTCN TempB TempB.ttcn>
    module TempB {
      import from TempA all;
      const integer Hidden := 9;
      testcase TC() runs on MyComponent { }
    }
<END_MODULE>
<RESULT COUNT 1>
(?im)warning.+?imported.+?component.+?element.+?definition.+?hides.+?definition.+?\bat\b.+?module.+?scope
<END_RESULT>
<RESULT COUNT 1>
(?im)warning.+?hidden.+?definition.+?\bis\b.+?here
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - constant definition for port and signature
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - constant definition for port and signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  type port MyPortType procedure { inout Sig }
  const Sig cSig := 0;
  const MyPortType cMyPort := 0;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)constant.+?cannot.+?\bbe\b.+?defined.+?for.+?signature
<END_RESULT>
<RESULT COUNT 1>
(?im)constant.+?cannot.+?\bbe\b.+?defined.+?for.+?port.+?type
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - external constant definition for port and signature
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - external constant definition for port and signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  type port MyPortType procedure { inout Sig }
  external const Sig cSig;
  external const MyPortType cMyPort;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)external.+?constant.+?cannot.+?\bbe\b.+?defined.+?for.+?signature
<END_RESULT>
<RESULT COUNT 1>
(?im)external.+?constant.+?cannot.+?\bbe\b.+?defined.+?for.+?port.+?type
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - signature as module parameter
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - signature as module parameter>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  modulepar {
    Sig PSig;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)type.+?\bof\b.+?module.+?parameter.+?cannot.+?\bbe\b.+?signature
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - template definition for port type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - template definition for port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type port MyPortType message { inout integer; }
  template MyPortType tPort := 0;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)template.+?cannot.+?\bbe\b.+?defined.+?\bfor\b.+?port.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - modified template from non-template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - modified template from non-template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record MyRecord { integer I, float F }
  const MyRecord cMyRecord := { 0, 1.0 }
  template MyRecord tMyRecord modifies cMyRecord := { F := 1.1 }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)reference.+?\bto\b.+?template.+?expected.+?\bin\b.+?modifies
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - modified template with parameters
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - modified template with parameters>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record MyRecord { integer I, float F }
  template MyRecord MyBaseT (integer pI, template float pF) := {
    I := pI, F := pF
  }

  // fewer parameters
  template MyRecord MyModifiedT1 (integer pI) modifies MyBaseT := {
    I := pI
  }

  // different kind of parameters
  template MyRecord MyModifiedT2 (template integer pI, float pF)
        modifies MyBaseT:= {
    I := pI
  }

  // different type of parameters
  template MyRecord MyModifiedT3 (charstring pI, template octetstring pF)
        modifies MyBaseT:= {
    I := 0
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)modified.+?template.+?has.+?fewer.+?formal.+?parameters.+?than.+?base.+?template
<END_RESULT>
<RESULT COUNT 2>
(?im)kind.+?\bof\b.+?parameter.+?\bis\b.+?\bnot\b.+?\bthe\b.+?same.+?\bas\b.+?\bin\b.+?base.+?template
<END_RESULT>
<RESULT COUNT 2>
(?im)type.+?\bof\b.+?parameter.+?\bis\b.+?\bnot\b.+?\bthe\b.+?same.+?\bas\b.+?\bin\b.+?base.+?template
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - variable definition for signature
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - variable definition for signature>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  function F() {
    var Sig lSig;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)variable.+?cannot.+?\bbe\b.+?defined.+?for.+?signature
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - template variable for port type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - template variable for port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type port MyPortType message { inout charstring }
  function F() {
    var template MyPortType tMyPort;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)template.+?variable.+?cannot.+?\bbe\b.+?defined.+?for.+?port.+?type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - timer array without default duration
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - timer array without default duration>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  function F() {
    timer MyTimers[10];
    MyTimers.start;
    MyTimers[0].start;
  }
}
<END_MODULE>
<RESULT COUNT 2>
(?im)timer.+?does.+?not.+?have.+?default.+?duration
<END_RESULT>
<RESULT COUNT 1>
(?im)Reference.+?\bto\b.+?timer.+?array.+?without.+?array.+?index
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - timer array with empty array as default duration
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - timer array with empty array as default duration>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  function F() {
    // Def_Timer::has_default_duration()
    timer MyFaultyTimers[10]:={};
    timer MyOkTimers[3] := { 1.0, 1.2, 2.78 };
    MyFaultyTimers[0].start;
    MyOkTimers[2].start;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Too.+?few.+?elements.+?\bin\b.+?default.+?duration.+?\bof\b.+?timer.+?array
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - timer array with default duration of type other then SEQOF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - timer array with default duration of type other then SEQOF>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  function F() {
    timer MyFaultyTimers1[10] := ":)";
    timer MyFaultyTimers2[Nonexi] := '0101'B;
    MyFaultyTimers1[0].start;
    MyFaultyTimers2[0].start;
  }
}
<END_MODULE>
<RESULT COUNT 2>
(?im)array.+?value.+?was.+?expected.+?\bas\b.+?default.+?duration.+?\bof\b.+?timer.+?array
<END_RESULT>
<RESULT COUNT 1>
(?im)\bno\b.+?definition.+?Nonexi
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - reference does not refer to a port type
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - reference does not refer to a port type>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type integer Int;
  const integer cInt:=0;
  type component MyComponent {
    port Int PInt;
    port cInt PcInt;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)type.+?reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?port.+?type
<END_RESULT>
<RESULT COUNT 1>
(?im)reference.+?does.+?\bnot\b.+?refer.+?\bto\b.+?\ba\b\s*type
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port and signature cannot be the return type of a function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port and signature cannot be the return type of a function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  type port MyPort procedure { inout Sig }
  function F() return Sig { }
  function G() return MyPort { }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?\bof\b.+?signature.+?cannot.+?\bbe\b.+?return.+?type.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 1>
(?im)port.+?type.+?cannot.+?\bbe\b.+?return.+?type.+?\bof\b.+?function
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - starting a function with return type `default' on a PTC
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - starting a function with return type `default' on a PTC>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type component MyComponent { }
  type port P message { out RRrof; }
  type record of RR RRrof;
  type record RR { RR2 rr2 optional, aref ar, aref_S arS, aref_C arA }
  type record RR2 { RRrof rrrof optional, default d }

  type altstep aref();
  type altstep aref_C() runs on MyComponent;
  type altstep aref_S() runs on self;

  function F() runs on MyComponent return default { return null; }

  testcase TC() runs on MyComponent {
    var MyComponent C;
    C.start(F());
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Default type cannot be sent or received on a port
<END_RESULT>
<RESULT COUNT 1>
(?im)Altstep type .+ with 'runs on self' clause cannot be sent or received on a port
<END_RESULT>
<RESULT COUNT 1>
(?im)Default type cannot be the return type or embedded in the return type of function .+ if it is started on a parallel test component
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - port and signature cannot be the return type of an external function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - port and signature cannot be the return type of an external function>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  signature Sig();
  type port MyPort procedure { inout Sig }
  external function F() return Sig;
  external function G() return MyPort;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)value.+?\bof\b.+?signature.+?cannot.+?\bbe\b.+?return.+?type.+?\bof\b.+?external.+?function
<END_RESULT>
<RESULT COUNT 1>
(?im)port.+?type.+?cannot.+?\bbe\b.+?return.+?type.+?\bof\b.+?external.+?function
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - reference to omit value
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - reference to omit value>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record MyType1 {
    integer I,
    float F optional
  }
  type record MyType2 {
    integer I optional,
    float F
  }
  template MyType1 T1 := { 1, omit };
  //  TR-702: Optional field in record type
  template MyType2 T2 := { omit, T1.F };
}
<END_MODULE>
<RESULT COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - reference to inactive template field
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - reference to inactive template field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type union MyType {
    integer I,
    float F
  }
  template MyType T1 := { I := 1 }
  template float T2 := T1.F;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)reference.+?\bto\b.+?inactive.+?field.+?\bin\b.+?template
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - reference to field of value list match
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - reference to field of value list match>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type union MyType {
    integer I,
    float F
  }
  template MyType T1 := ({ I := 1 }, { I := 2 }, { F := 3.0 });
  template float T2 := T1.F;
}
<END_MODULE>
<RESULT COUNT 1>
(?im)reference.+?\bto\b.+?field.+?\bof\b.+?value.+?list.+?match
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - valueof operation on field of a template which has no fields
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - valueof operation on field of a template which has no fields>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  template integer tI := 1;
  function F() {
    // TR-691: Three error messages for valueof operation on template's
    //  nonexistent filed
    var integer I := valueof(tI.Nonexi);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)invalid.+?field.+?reference.+?integer.+?does.+?not.+?have.+?fields
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)invalid.+?field.+?reference.+?integer.+?does.+?not.+?have.+?fields
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - referenced template array
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - referenced template array>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type set of integer RI;
  template RI tI := { 0, 1, 2 }
  const charstring cCS := "foobar";
  const bitstring cBS := '0010'B;
  type record OmitType { integer Omit optional }
  template OmitType OmitRec := { omit };
  type record of charstring recofCharstring;

  function F() {
    var integer I := valueof(tI[-1]);
    var integer J := valueof(tI[1274]);

    //  TR-692: Strange error messages with valueof operation used on
    //   record of templates
    var integer K := valueof(tI[Nonexi]);
    var integer L := valueof(tI[valueof(OmitRec.Omit)]);
    var integer M := valueof(tI[omit]);
    var integer N := valueof(OmitRec.Omit);

    if(match(tI[cBS], I)) { }

    var template recofCharstring T:= {"first", "second"};
    const charstring temp := valueof(T[0]);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)non-negative.+?integer.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)index.+?overflow
<END_RESULT>
<RESULT COUNT 1>
(?im)\bno\b.+?definition.+?Nonexi
<END_RESULT>
<RESULT COUNT 2>
(?im)specific.+?value.+?expected.+?instead.+?\bof\b.+?omit
<END_RESULT>
<RESULT COUNT 2>
(?im)value.+?\bor\b.+?expression.+?\bof\b.+?type.+?integer.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)reference.+?\bto\b.+?value.+?expected.+?instead.+?\bof\b.+?template
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)non-negative.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)index.+?overflow
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?im)\bno\b.+?definition.+?Nonexi
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?im)specific.+?value.+?expected.+?instead.+?\bof\b.+?omit
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?im)value.+?\bor\b.+?expression.+?\bof\b.+?type.+?integer.+?expected
<END_RESULT>
<RESULT IF_FAIL COUNT 2>
(?im)reference.+?\bto\b.+?value.+?expected.+?instead.+?\bof\b.+?template
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc - too many/few elements in value list for record template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - too many/few elements in value list for record template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record MyType {
    integer I,
    float F
  }
  template MyType T1 := { 0 }
  template MyType T2 := { 0, 1.0, 2 }
}
<END_MODULE>
<RESULT COUNT 0>
(?im)\berror\b.+?too.+?few.+?elements.+?in.+?value.+?list
<END_RESULT>
<RESULT COUNT 1>
(?im)\berror\b.+?too.+?many.+?elements.+?in.+?value.+?list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3:: IsValue - for a type reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IsValue - for a type reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

    type record length (10) of integer int10;

    type component C1
    {
    }

    testcase tc_isvalue_const() runs on C1
    {
        if ( isvalue(int10) ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bReference to a value or template was expected instead of type `@ModuleA.int10'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3:: IsValue - for a port reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IsValue - for a port reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

    type record length (10) of integer int10;

    type port P1 message
    {
        out integer;
    }

    type component C1
    {
        port P1 p1;
    }

    testcase tc_isvalue_const() runs on C1
    {
        var C1 c1;

        if ( isvalue(p1) ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bReference to a value or template was expected instead of port `@ModuleA.C1.p1'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.TTCN-3:: IsValue - for a testcase reference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TTCN-3::IsValue - for a testcase reference>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN ModuleA ModuleA.ttcn>
module ModuleA {

    type record length (10) of integer int10;

    type component C1
    {
    }

    testcase tc_isvalue_const() runs on C1
    {
        var boolean dontcare1 := isvalue(tc_isvalue_const);
    }
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\bReference to parameterized definition `tc_isvalue_const' without actual parameter list
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bReference to a value or template was expected instead of testcase `@ModuleA.tc_isvalue_const'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT IF_PASS POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>

<END_TC>
:exmp.



.*---------------------------------------------------------------------*
:h3.Adhoc:: Function reference - used in expression, no return value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Function reference - used in expression, no return value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {
  // no return value:
  type function f_FT();
  // a function which happens to be compatible with f_FT
  function f_str(){}
  control {
    var f_FT f := refers(f_str);
    var charstring vl_result :=  f.apply() & "";
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror: Reference.+?value.+?expected.+?invocation.+?behavior.+?no return type\b
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Function reference - incompatible function type used for record func.ref. value
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Function reference - incompatible function type used for record func.ref. value>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN x x.ttcn>
module x {
  type record adat_rekord {
    function (integer par1, integer par2) return integer muv_f,
    function (in integer par) return verdicttype ell_f
  };
  function fn1(integer par1, integer par2) return float { return 1.1; }
  function fn2(in integer par) return verdicttype { return pass; }
  function fff()
  {
    var adat_rekord ar := { refers(fn1), refers(fn2) }
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Function reference - bogus dereference
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Function reference - bogus dereference>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN deref_bogus deref_bogus.ttcn>
module deref_bogus {
  control {
    execute(derefers(Noexi)())
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)There.+?is.+?no.+?local.+?imported.+?definition.+?name
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - no such parameter in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - no such parameter in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN nosuchname nosuchname.ttcn>
module nosuchname {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, "3", pardon := 3);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Function\s+`\S+'\s+has\s+no\s+formal\s+parameter
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - no such parameter in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - no such parameter in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN nosuchname_altstep nosuchname_altstep.ttcn>
module nosuchname_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, "3", pardon := 3);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Altstep\s+`\S+'\s+has\s+no\s+formal\s+parameter
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - no such parameter in testcase
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - no such parameter in testcase>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN nosuchname_testcase nosuchname_testcase.ttcn>
module nosuchname_testcase {
  type component C1 { }
  testcase f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H) runs on C1
  {
    alt{
    [] any timer.timeout { setverdict(pass); }
    }
  }

  control
  {
    execute(f1(1, 2.2, "3", pardon := 3));
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Testcase\s+`\S+'\s+has\s+no\s+?formal\s+?parameter
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - not enough parameters in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - not enough parameters in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN notenough notenough.ttcn>
module notenough {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1();
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Too.+?few.+?parameters:.+?least.+?expected.+?instead
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - not enough parameters in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - not enough parameters in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN notenough_altstep notenough_altstep.ttcn>
module notenough_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1();
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Too.+?few.+?parameters:.+?least.+?expected.+?instead
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - parameter overriding in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - parameter overriding in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN override_override override_override.ttcn>
module override_override {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, "3", par1 := 42, par4 := true);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Formal parameter `\S+' assigned more than once
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - parameter overriding in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - parameter overriding in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN override_altstep override_altstep.ttcn>
module override_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, "3", par1 := 42, par4 := true);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Formal parameter `\S+' assigned more than once
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - too many parameters in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - too many parameters in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN toomany toomany.ttcn>
module toomany {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1(13, 0.99, "foo", true, 'BAADF00D'H, -);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Too.+?many.+?parameters.+?most.+?was.+?expected.+?instead
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - too many parameters in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - too many parameters in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN toomany_altstep toomany_altstep.ttcn>
module toomany_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1(13, 0.99, "foo", true, 'BAADF00D'H, -);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Too.+?many.+?parameters.+?most.+?was.+?expected.+?instead
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - same parameter more than once in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - same parameter more than once in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN twicetobesure twicetobesure.ttcn>
module twicetobesure {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1(1, 1.1, "!!!!11one!!", par4 := true, par4 := true);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Formal.+?parameter.+?assigned.+?more.+?than.+?once
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - same parameter more than once in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - same parameter more than once in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN twicetobesure_altstep twicetobesure_altstep.ttcn>
module twicetobesure_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1(1, 1.1, "!!!!11one!!", par4 := true, par4 := true);
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)Formal.+?parameter.+assigned.+?more.+?than.+?once
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - wrong type for parameters in function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - wrong type for parameters in function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN wrongtype wrongtype.ttcn>
module wrongtype {
  type component C1 { }
  function f1(in integer par1, in float par2, in charstring par3,
              in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, par3 := true, par4 := "true");
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)boolean.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)character.+?string.+?value.+?was.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - TR922
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - TR922>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN TR922 TR922.ttcn>
module TR922 {
type component CT{}

// a do-nothing function
function twoparfn(in integer foo, in integer bar){}

// a function reference
type function twopar(in integer foo, in integer bar);
// an altstep reference
type altstep  twoalt(in integer foo, in integer bar);
// a testcase reference
type testcase twotc(in integer foo, in integer bar) runs on CT;

type record of integer integers;

function f0()
{
  twoparfn( 42, );

  // this is the part the compiler accidentally stumbles upon
  // and considers a named parameter
  var integers not_a_named_param := {};
  some_random_function(some, random, parameter, list);
}

function f1()
{
  var twopar fn := null;
  fn.apply( 42, );

  // this is the part the compiler accidentally stumbles upon
  // and considers a named parameter
  var integers not_a_named_param := {};
  some_random_function(some, random, parameter, list);
}

function f2()
{

  var twoalt alt2;
  alt2.apply(42,);

  // this is the part the compiler accidentally stumbles upon
  // and considers a named parameter
  var integers not_a_named_param := {};
  some_random_function(some, random, parameter, list);

}

function f3()
{
  var twotc tc2 := null;
  execute(derefers(tc2)(42,)));

  // this is the part the compiler accidentally stumbles upon
  // and considers a named parameter
  var integers not_a_named_param := {};
  some_random_function(some, random, parameter, list);
}

control
{
  f0();
  f1();
  f2();
  f3();
}

}
<END_MODULE>
<RESULT COUNT 4>
syntax error, unexpected '\)'
<END_RESULT>
<RESULT COUNT 4>
syntax error, unexpected ';', expecting '\)' or ','
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Named actual parameters - wrong type for the parameters in altstep
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Named actual parameters - wrong type for the parameters in altstep>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN wrongtype_altstep wrongtype_altstep.ttcn>
module wrongtype_altstep {
  type component C1 { }
  altstep f1(in integer par1, in float par2, in charstring par3,
             in boolean par4 := false, in hexstring par5 := 'DECAFBAD'H)
  {
    [] any timer.timeout { setverdict(pass); }
  }

  testcase tc1() runs on C1
  {
    f1(1, 2.2, par3 := true, par4 := "true");
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?im)boolean.+?value.+?expected
<END_RESULT>
<RESULT COUNT 1>
(?im)character.+?string.+?value.+?was.+?expected
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Assignment notation with array indices - unsuitable type indices
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Assignment notation with array indices - unsuitable type indices>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN unsuitable_indices unsuitable_indices.ttcn>
module unsuitable_indices
{
type component empty { }
type record of integer intlist
type set of integer intsetof
type integer intarr[1]
type record intrec { integer f1, integer f2 }
type set intset { integer f1, integer f2 }
testcase tc () runs on empty
{
  var float float_val := 1.0
  var float neg_float_val := -1.0
  var integer neg_int_val := -1
  template intlist a := { 1, 2, 3 }
  template intlist a_m1 modifies a := { [1.0] := 0 }
  template intlist a_m2 modifies a := { [float_val] := 0 }
  template intlist a_m3 modifies a := { [neg_float_val] := 0 }
  template intlist a_m4 modifies a := { [-1] := 0 }
  template intlist a_m5 modifies a := { [neg_int_val] := 0 }
  template intlist a_m6 modifies a := { [-1.0] := 0 }
  var intlist ilist := { 1, 2, 3 }
  ilist := { [1.0] := 0 }
  ilist := { [float_val] := 0 }
  ilist := { [neg_float_val] := 0 }
  ilist := { [-1] := 0 }
  ilist := { [neg_int_val] := 0 }
  ilist := { [-1.0] := 0 }
  var intsetof iset := { 1, 2, 3 }
  iset := { [1.0] := 0 }
  iset := { [float_val] := 0 }
  iset := { [neg_float_val] := 0 }
  iset := { [-1] := 0 }
  iset := { [neg_int_val] := 0 }
  iset := { [-1.0] := 0 }
  var intarr iarr := { 1 }
  iarr := { [1.0] := 0 }
  iarr := { [float_val] := 0 }
  iarr := { [neg_float_val] := 0 }
  iarr := { [-1] := 0 }
  iarr := { [neg_int_val] := 0 }
  iarr := { [-1.0] := 0 }
  var intrec ir := { [0] := 0, [1] := 1 }
  var intset is := { [0] := 0, [1] := 1 }
}
}
<END_MODULE>
<RESULT COUNT 16>
(?is)\berror:.+?A.+?value.+?or.+?expression.+?type.+?integer.+?was.+?expected
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:.+?A.+?non-negative.+?integer.+?expected.+?indexing.+?instead.+?of
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Indexed assignment notation cannot be used for record type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Value list notation cannot be used for set type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Array index underflow: the index value must be at least `0' instead of `-1'
<END_RESULT>
<RESULT COUNT 22>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Arrays with indexed assignment notation - Variables
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Arrays with indexed assignment notation - Variables>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN IndexedArrayVariables IndexedArrayVariables.ttcn>
module IndexedArrayVariables {
type component Empty { }
type integer intarr1[1]
type integer intarr2[1..2]
testcase tc() runs on Empty
{
  // With one dynamic index.
  var integer i := 1
  var intarr1 a1 :=  { [1] := 0 }  // Overflow.
  var intarr1 a2 :=  { [2] := 0 }  // Overflow.
  var intarr1 a3 :=  { [0] := 0, [1] := 1 }  // Overflow and too many elements.
  var intarr1 a4 :=  { [0] := 0, [0] := 0 }  // Same index.
  var intarr1 a5 :=  { [0] := 0, [i] := 0, [0] := 0 }  // Same index.
  var intarr2 a6 :=  { [0] := 0 }  // Underflow.
  var intarr2 a7 :=  { [6] := 6 }  // Overflow.
  var intarr2 a8 :=  { [0] := 0, [1] := 1, [2] := 2 }  // Underflow and too many elements.
  var intarr2 a9 :=  { [1] := 1, [2] := 2, [3] := 4 }  // Overflow and too many elements.
  var intarr2 a10 := { [1] := 1, [1] := 1 }  // Same index.
}
}
<END_MODULE>
<RESULT COUNT 2>
(?is)\berror: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `0' instead of `2'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `0' for components `2' and `1'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `0' for components `3' and `1'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index underflow: the index value must be at least `1' instead of `0'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `6'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `3'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `1' for components `2' and `1'
<END_RESULT>
<RESULT COUNT 10>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify: Errors found in the input module. Code will not be generated.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Arrays with indexed assignment notation - Constants
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Arrays with indexed assignment notation - Constants>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN IndexedArrayConstants IndexedArrayConstants.ttcn>
module IndexedArrayConstants {
type component Empty { }
type integer intarr1[2]
type integer intarr2[2..4]
testcase tc() runs on Empty
{
  const intarr1 a1 := { [3] := 0 }  // Overflow.
  const intarr1 a2 := { [0] := 0 }  // Holes are not allowed.
  const intarr1 a3 := { [0] := 0, [1] := 1, [2] := 2 }  // Overflow and too many elements.
  const intarr1 a4 := { [0] := 0, [0] := 0 }  // Same index.
  const intarr2 a5 := { [0] := 0 }  // Underflow.
  const intarr2 a6 := { [6] := 6 }  // Overflow.
  const intarr2 a7 := { [0] := 0, [1] := 1, [2] := 2 }  // Underflow.
}
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `1' instead of `3'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: It's not allowed to create hole\(s\) in constant values
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `1' instead of `2'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `0' for components `2' and `1'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index underflow: the index value must be at least `2' instead of `0'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `4' instead of `6'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index underflow: the index value must be at least `2' instead of `1'
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify: Errors found in the input module. Code will not be generated.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Arrays with indexed assignment notation - Templates
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Arrays with indexed assignment notation - Templates>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN IndexedArrayTemplates IndexedArrayTemplates.ttcn>
module IndexedArrayTemplates {
type component Empty { }
type integer intarr1[1]
type integer intarr2[1..2]
testcase tc() runs on Empty
{
  template intarr1 a1 := { 1 }
  template intarr1 a2 modifies a1 := { [1] := 0 }  // Overflow.
  template intarr1 a3 modifies a1 := { [0] := 0, [1] := 1 }  // Overflow and too many elements.
  template intarr1 a4 modifies a1 := { [0] := 0, [1] := 1 }  // Overflow and too many elements.
  template intarr1 a5 modifies a1 := { [0] := 0, [0] := 0 }  // Same index.
  template intarr2 a6 := { [0] := 0 }  // Underflow.
  template intarr2 a7 := { [6] := 6 }  // Overflow.
  template intarr2 a8 := { [0] := 0, [1] := 1, [2] := 2 }  // Underflow and too many elements.
  template intarr2 a9 := { [1] := 1, [2] := 2, [3] := 4 }  // Overflow and too many elements.
}
}
<END_MODULE>
<RESULT COUNT 3>
(?is)\berror: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `0' for components `2' and `1'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index underflow: the index value must be at least `1' instead of `0'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `6'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `3'
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify: Errors found in the input module. Code will not be generated.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Arrays with indexed assignment notation - Timers
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::Arrays with indexed assignment notation - Timers>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN IndexedArrayTimers IndexedArrayTimers.ttcn>
module IndexedArrayTimers {
type component Empty { }
testcase tc() runs on Empty
{
  timer a1[1] := { [0] := 0.0, [1] := 1.0 }  // Overflow.
  timer a2[1] := { [0] := 0.0, [0] := 0.0 }  // Same index.
  timer a3[1..2] := { [0] := 0.0 }  // Underflow.
  timer a4[1..2] := { [3] := 3.0 }  // Overflow.
  timer a5[1..2] := { [0] := 0.0, [1] := 1.0, [2] := 2.0 }  // Underflow and too many elements.
  timer a6[1..2] := { [2] := 2.0, [3] := 3.0, [4] := 4.0 }  // Overflow and too many elements.
}
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `0' instead of `1'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `0' for timer array elements `2' and `1'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index underflow: the index value must be at least `1' instead of `0'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `3'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `2' instead of `4'
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<RESULT COUNT 1>
(?im)\bnotify: Errors found in the input module. Code will not be generated.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: replace() predefined function - bad arguments
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::replace() predefined function - bad arguments>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN bad_arguments bad_arguments.ttcn>
module bad_arguments
{
type component empty { }
type record of integer intlist
testcase tc () runs on empty
{
  var integer a := 0
  var charstring cs_1 := "My name is JJ"
  var bitstring bs_1 := '11'B
  var charstring cs_2 := replace("My name is JJ", -1, 2, "xx")
  var intlist il1 := { 1, 2, 3 }
  cs_2 := replace("My name is JJ", 1, 2, '11'B)
  cs_2 := replace("My name is JJ", 100, 2, "x")
  cs_2 := replace("My name is JJ", a, 100, "x")
  cs_2 := replace(cs_1, 1, 2, bs_1)
  cs_2 := replace(cs_1, 1.0, 2, "xx")
  il1 := replace(il1, 1, 1, cs_1[10])
}
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror:.+?Second operand of operation `replace\(\)' should not be negative
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror:.+?Fourth operand of operation `replace\(\)' is of type `bitstring', but a value of type `charstring' was expected here
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Fourth operand of operation `replace\(\)' is of type `charstring', but a value of type `\@bad_arguments.intlist' was expected here
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?The sum of second operand `index' \(100\) and third operand `len' \(2\) is greater than the length of the first operand \(13\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Third operand `len' \(100\) is greater than the length of the first operand \(13\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror:.+?Second operand of operation `replace\(\)' should be integer value
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: runs on self + refers in component type definition
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - runs on self + refers in component type definition>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN MTTSM00016005 MTTSM00016005.ttcn>
module MTTSM00016005
{
  type function FT_f_runsOnSelf() runs on self;
  type component C { const integer ci:=1; }
  type component D extends My_RunsOnSelf_CT { const integer di:=9; }
  type component E {const integer ei:=0; }
  type component My_RunsOnSelf_CT extends C {
    var FT_f_runsOnSelf v_f_runsOnSelf := refers(f_runsOnSomething);
    var FT_f_runsOnSelf v_f_runsOnSelf2 := refers(f_runsOnC);
    var FT_f_runsOnSelf v_f_runsOnSelf3 := refers(f_runsOnD);
    var FT_f_runsOnSelf v_f_runsOnSelf4 := refers(f_runsOnE);
  }
  
  function f_runsOnSomething() runs on My_RunsOnSelf_CT { }
  function f_runsOnC() runs on C { }
  function f_runsOnD() runs on D { }
  function f_runsOnE() runs on E { }
  control { }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Runs on clause mismatch: type `.+FT_f_runsOnSelf' has a 'runs on self' clause and the current component definition is of type `.+My_RunsOnSelf_CT', but function `.+f_runsOnD' runs on `.+D'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Runs on clause mismatch: type `.+FT_f_runsOnSelf' has a 'runs on self' clause and the current component definition is of type `.+My_RunsOnSelf_CT', but function `.+f_runsOnE' runs on `.+E'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - array definitions
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - arrays and large integers>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntArr LargeIntArr.ttcn>
module LargeIntArr
{
  type integer intarr1[2222222222222222222222222222222]
  type integer intarr2[1111111111111111111111111111111..2222222222222222222222222222222]
  type integer intarr3[1111111111111111111111111111111..1]
  type integer intarr4[2..2222222222222222222222222222222]  
  control {
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The array size should be less than `2147483647' instead of `2222222222222222222222222222222'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: The lower bound of an array index should be less than `2147483647' instead of `1111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: The upper bound of an array index should be less than `2147483647' instead of `2222222222222222222222222222222'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - array indexing
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - array indexing>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntIndexing LargeIntIndexing.ttcn>
module LargeIntIndexing
{
  type integer intarr4[4]
  control {
    const integer ci1 := 11111111111111111111111111111111111111
    var intarr4 iarr1 := {1, 2, 3, 4}
    var intarr4 iarr2 := {1, 2, 3, -444444444444444444444444444}
    iarr2[ci1] := 1
    iarr2[12345678910111213141516] := 1
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `3' instead of `11111111111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `3' instead of `12345678910111213141516'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - universal charstring elements
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - universal charstring elements>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntUni LargeIntUni.ttcn>
module LargeIntUni
{
  control {
    var universal charstring vus1 := char(11111111111111111111111111111111, 0, 0, 0) & char(1, 1, 1, 1)
    var universal charstring vus2 := char(-11111111111111111111111111111111, 0, 0, 0) & char(1, 1, 1, 1)
    var universal charstring vus3 := char(11111111111111111111111111111111, 12345678910111213141516171819202, 0, 0) & char(1, 1, 1, -1) & char(11111111111111111111111111111111, 22222222222222222222222222222222, 33333333333333333333333333333333, 44444444444444444444444444444444) 
  }
}
<END_MODULE>
<RESULT COUNT 4>
(?is)\berror: The first number of quadruple \(group\) must be within the range 0 .. 127 instead of 11111111111111111111111111111111
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: at or before token `-': syntax error, unexpected '-', expecting Number
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The second number of quadruple \(plane\) must be within the range 0 .. 255 instead of 12345678910111213141516171819202
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The second number of quadruple \(plane\) must be within the range 0 .. 255 instead of 22222222222222222222222222222222
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The third number of quadruple \(row\) must be within the range 0 .. 255 instead of 33333333333333333333333333333333
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The fourth number of quadruple \(cell\) must be within the range 0 .. 255 instead of 44444444444444444444444444444444
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - timer arrays
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - timer arrays>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntTimer LargeIntTimer.ttcn>
module LargeIntTimer
{
  control {
    const integer ci1 := 11111111111111111111111111111111111111
    var integer vi1 := ci1
    timer tarr1[1] := {[11111111111111111111111111111111111111] := 1}
    timer tarr2[vi1] := {[22222222222222222222222222222222222222] := 1, [vi1] := vi1, [vi1 + 1] := 11111111111111111111111111111111111111}  
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `0' instead of `11111111111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Reference to a constant value was expected instead of variable `vi1'
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: A value or expression of type float was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: An integer value less than `2147483647' was expected for indexing timer array instead of `22222222222222222222222222222222222222'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - indexed notation
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - indexed notation>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntIndexed LargeIntIndexed.ttcn>
module LargeIntIndexed
{
  type record of integer intlist
  type set of integer intset
  type integer intarr4[4]
  template intlist itemp1 := {11111111111111111111111111111111, 11, 111}
  template intlist itemp2 := {[11111111111111111111111111111111] := 1}
  template intlist itemp3 := {[valueof(itemp1[1])] := 1, [1] := 1, [11111111111111111111111111111111] := 1, [11] := 1, [11111111111111111111111111111111] := 1 }
  template intset itemp4 := {[11111111111111111111111111111111] := 1}
  template intset itemp5 := {[valueof(itemp1[1])] := 1, [1] := 1, [11111111111111111111111111111111] := 1, [11] := 1, [11111111111111111111111111111111] := 1 }
  template intarr4 itemp6 := {[12345678910111213141516171819202] := 1}
  template intarr4 itemp7 := {[0] := 1, [12345678910111213141516171819202] := 1, [11111111111111111111111111111111] := 1, [1] := 1, [1] := 1}
  control {
  }
}
<END_MODULE>
<RESULT COUNT 3>
(?is)\berror: An integer value less than `2147483647' was expected for indexing type `.+?intlist' instead of `11111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: An integer value less than `2147483647' was expected for indexing type `.+?intset' instead of `11111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Array index overflow: the index value must be at most `3' instead of `12345678910111213141516171819202'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Array index overflow: the index value must be at most `3' instead of `11111111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Duplicate index value `1' for components `5' and `4'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - the substr() predefined function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - the substr() predefined function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntSubstr LargeIntSubstr.ttcn>
module LargeIntSubstr
{
  control {
    var charstring cs1 := substr("example1", 11111111111111111111111111111111, 1)
    var charstring cs2 := substr("example2", 1, 11111111111111111111111111111111)
    var charstring cs3 := substr("example3", 12345678910111213141516171819202, 11111111111111111111111111111111)
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The sum of second operand `index' \(11111111111111111111111111111111\) and third operand `returncount' \(1\) is greater than the length of the first operand \(8\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The sum of second operand `index' \(1\) and third operand `returncount' \(11111111111111111111111111111111\) is greater than the length of the first operand \(8\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The sum of second operand `index' \(12345678910111213141516171819202\) and third operand `returncount' \(11111111111111111111111111111111\) is greater than the length of the first operand \(8\)
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - enumerations
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - enumerations>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntEnum LargeIntEnum.ttcn>
module LargeIntEnum
{
  type enumerated enum1 {first(1111111111111111111111111111)}
  control {
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The numeric value of enumeration `first' \(1111111111111111111111111111\) is too large for being represented in memory
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - integer subtypes
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - integer subtypes>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntSubtypes LargeIntSubtypes.ttcn>
module LargeIntSubtypes
{
  type integer int1 (12345678910111213141516171819..0)
  type integer int2 (0..12345678910111213141516171819)
  type integer int3 (12345678910111213141516171819..12345678910111213141516171819)
  type integer int4[4] (12345678910111213141516171819)
  control {
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: lower boundary is bigger than upper boundary in integer subtype range
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - value range templates
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - value range templates>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntRange LargeIntRange.ttcn>
module LargeIntRange
{
  template integer itemp1 := (12345678910111213141516..1)
  template integer itemp2 := (12345678910111213141516..1234567891011121314151617)
  template integer itemp3 := (1..1234567891011121314151617)
  template integer itemp4 := (11111111111111111111111111)
  control {
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The lower boundary is higher than the upper boundary
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - the replace() predefined function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - the replace() predefined function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntReplace LargeIntReplace.ttcn>
module LargeIntReplace
{
  control {
    var charstring cs1 := "exampletext1"
    var charstring cs2 := "exampletext2"
    cs1 := replace("exampletext1", 11111111111111111111111111111111, 1, "hello")
    cs1 := replace("exampletext1", 1, 11111111111111111111111111111111, "hello")
    cs1 := replace("exampletext1", 11111111111111111111111111111111, 11111111111111111111111111111111, "hello")
    cs1 := replace("exampletext1", 11111111111111111111111111111111, 11111111111111111111111111111111, cs2)
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The sum of second operand `index' \(11111111111111111111111111111111\) and third operand `len' \(1\) is greater than the length of the first operand \(12\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The sum of second operand `index' \(1\) and third operand `len' \(11111111111111111111111111111111\) is greater than the length of the first operand \(12\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: The sum of second operand `index' \(11111111111111111111111111111111\) and third operand `len' \(11111111111111111111111111111111\) is greater than the length of the first operand \(12\)
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - other predefined functions
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - other predefined functions>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntPredef LargeIntPredef.ttcn>
module LargeIntPredef
{
  control {
    var charstring cs1
    var bitstring bs1
    var hexstring hs1
    var octetstring os1
    var universal charstring us1
    var float r1
    bs1 := int2bit(1234567891011121314151617181920, 1)
    bs1 := int2bit(1, 1234567891011121314151617181920)
    bs1 := int2bit(1234567891011121314151617181920, 1234567891011121314151617181920)
    hs1 := int2hex(1234567891011121314151617181920, 1)
    hs1 := int2hex(1, 1234567891011121314151617181920)
    hs1 := int2hex(1234567891011121314151617181920, 1234567891011121314151617181920)
    os1 := int2oct(1234567891011121314151617181920, 1)
    os1 := int2oct(1, 1234567891011121314151617181920)
    os1 := int2oct(1234567891011121314151617181920, 1234567891011121314151617181920)
    cs1 := regexp("Hello, World!", "(Hello, World!)*", 1234567891011121314151617181920)
    cs1 := int2char(1234567891011121314151617181920)
    us1 := int2unichar(1234567891011121314151617181920)
  }
}
<END_MODULE>
<RESULT COUNT 3>
(?is)\berror: Value 1234567891011121314151617181920 does not fit in length 1
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror: The length of the resulting string is too large for being represented in memory
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The operand of operation `int2char\(\)' should be in range 0..127
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: First operand of operation `int2unichar\(\)' should be in range 0..2147483647
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The the third operand of `regexp\(\)' is too large: The requested group index is 1234567891011121314151617181920, but the pattern contains only 1 group
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - length restrictions
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - length restrictions>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntLenRest LargeIntLenRest.ttcn>
module LargeIntLenRest
{
  type record of integer intlist
  type set of integer intset
  type integer intarr[1]
  template intlist ilent1 := {1, 2, 3} length(12345678910111213141516)
  template intlist ilent2 := {1, 12345678910111213141516} length(1..12345678910111213141516)
  template intlist ilent3 := {1, 2, 3} length(-2..-12345678910111213141516)
  template intlist ilent4 := {1, 2, 3} length(12345678910111213141516..1)
  template intlist ilent5 := {1, 2, 3} length(12345678910111213141516..12345678910111213141516)
  template intarr iat1 := {1} length(1111111111111111111111111111)
  template intarr iat2 := {1} length(1..1111111111111111111111111111)
  template intarr iat3 := {1} length(1111111111111111111111111111..1)
  template intarr iat4 := {1} length(1111111111111111111111111111..1111111111111111111111111111)
  control {
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: There are fewer \(3\) elements in the template than it is allowed by the length restriction \(12345678910111213141516\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: There are fewer \(3\) elements in the template than it is allowed by the length restriction \(at least 12345678910111213141516\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The upper boundary of the length restriction must be a non-negative integer value instead of -12345678910111213141516
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The lower boundary of the length restriction must be a non-negative integer value instead of -2
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The upper boundary of the length restriction \(1\) cannot be smaller than the lower boundary \(1111111111111111111111111111\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: An integer value less than `2147483647' was expected as the upper boundary of the length restriction instead of `1111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: An integer value less than `2147483647' was expected as the lower boundary of the length restriction instead of `1111111111111111111111111111'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The number of elements allowed by the length restriction \(1111111111111111111111111111\) contradicts the array size \(1\)
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: large integers - basic operations
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - large integers - basic operations>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN LargeIntBasic LargeIntBasic.ttcn>
module LargeIntBasic
{
  control {
    var bitstring bs1
    var charstring cs1
    bs1 := bs1 << 1234567891011121314151617181920
    bs1 := bs1 >> 1234567891011121314151617181920
    cs1 := cs1 <@ 1234567891011121314151617181920
    cs1 := cs1 @> 1234567891011121314151617181920
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Right operand of operation `<<' should be less than `2147483647' instead of `1234567891011121314151617181920'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Right operand of operation `>>' should be less than `2147483647' instead of `1234567891011121314151617181920'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Right operand of operation `<@' should be less than `2147483647' instead of `1234567891011121314151617181920'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Right operand of operation `@>' should be less than `2147483647' instead of `1234567891011121314151617181920'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: TR 921 - indexing string type template variables
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - TR 921 - indexing string type template variables>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN TR921 TR921.ttcn>
module TR921
{
  control {
    var template octetstring ost := '11'O
    var template charstring cst := "11"
    var template bitstring bst := '11'B
    var template hexstring hst := '11'H
    var template universal charstring ust := "11"
    // Octetstring.
    ost[0] := '11'O 
    ost := ost[1]  
    if ('11'O == ost[0]) { }
    if (ost[0] == '11'O) { }
    log(ost[0]);
    // Charstring.
    cst[0] := "11"
    cst := cst[1]  
    if ("11" == cst[0]) { }
    if (cst[0] == "11") { }
    log(cst[0]);
    // Bitstring.
    bst[0] := '11'B
    bst := bst[1]  
    if ('11'B == bst[0]) { }
    if (bst[0] == '11'B) { }
    log(bst[0]);
    // Hexstring.
    hst[0] := '11'H
    hst := hst[1]  
    if ('11'H == hst[0]) { }
    if (hst[0] == '11'H) { }
    log(hst[0]);
    // Universal charstring.
    ust[0] := "11"
    ust := ust[1]  
    if ("11" == ust[0]) { }
    if (ust[0] == "11") { }
    log(ust[0]);
  }
}
<END_MODULE>
<RESULT COUNT 2>
(?is)\berror: Reference to a value was expected instead of template variable `ost'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to template variable `ost' can not be indexed
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to a value was expected instead of template variable `cst'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to template variable `cst' can not be indexed
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to a value was expected instead of template variable `bst'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to template variable `bst' can not be indexed
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to a value was expected instead of template variable `hst'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to template variable `hst' can not be indexed
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to a value was expected instead of template variable `ust'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference to template variable `ust' can not be indexed
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: pattern concatenation - pattern concatenation mistakes
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - pattern concatenation - pattern concatenation mistakes>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN PatternCat PatternCat.ttcn>
module PatternCat
{
function myfunc(in integer i) return charstring { return "xyz" }
function myfuncp(in integer i) return charstring { return "xyz" }
type record srec { charstring s }
type record of srec slist

control {
  var integer myvar := 123
  var charstring cs := "xyz"
  var octetstring os := '0123'O
  var slist mylist
  var srec myrec := { "xyz" }
  mylist[0].s := "xyz"

  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & 12 }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & 12 & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & refers(myfunc) }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & refers(myfunc) & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & myfunc() & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & myfunc() }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & myfuncp(1) }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & myfuncp(1) & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & myfuncp(myvar) & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & myfuncp(myvar) }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & myvar }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & myvar & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & slist }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & slist & "utoljara" }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & "utoljara" & os }
  { var template charstring myt := pattern "valami" & cs & "megegyszer" & os & "utoljara" }
}
}
<END_MODULE>
<RESULT COUNT 2>
(?is)\berror: at or before token `12': syntax error, unexpected Number, expecting Identifier or Cstring
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: at or before token `refers': syntax error, unexpected RefersKeyword, expecting Identifier or Cstring
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror: at or before token `\(': syntax error, unexpected '\('
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Sample tests for structured types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Sample test for structured types>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat1 Compat1.ttcn>
module Compat1 {
type record myrec1 { integer a }
type record myrec2 { integer a }
type record length(2) of integer myrecof1
type record of integer myrecof2
type record length(4) of integer myrecof3
template myrecof3 t_myrecof3 := { 1, 2, 3, 4 }
type integer myarr1[4]
type union myuni1 {
  myrecof1 f1,
  myrecof2 f2
}
type union myuni2 {
  myrecof2 f1,
  myrecof1 f2
}

control {
var myrec1 r1 := { 1 }
var myrec2 r2

r2 := r1
var myrecof1 ro1 := { 1, 2 }
var myrecof2 ro2 := { }
var myrecof3 ro3 := { 1, 2, 3, 4 }
var myarr1 ar1 := { 1, 2, 3, 4 }
var myuni1 uni1
var myuni2 uni2
ro1 := ar1             // !OK -> Incompatible dimension/subtype.
if (r1 == r2)     { }  //  OK
if (ro1 == ro3)   { }  // !OK -> Incompatible subtypes.
if (uni1 == uni2) { }  //  OK -> Can be compatible at run-time.
ro2 := substr(myrec1 : t_myrecof3, 0, 1)  // !OK
}
}
<END_MODULE>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat1.myrec2' was expected instead of `\@Compat1.myrec1'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat1.myrecof1' was expected instead of `integer\[4\]'
<END_RESULT>
<RESULT LTRT COUNT 2>
(?is)\berror: The operands of operation `==' should be of compatible types
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat1.myrecof1' and `integer\[4\]' are not compatible: Incompatible record of/SEQUENCE OF subtypes
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Type mismatch: `@Compat1.myrecof1' and `@Compat1.myrecof3' are not compatible: Incompatible record of/SEQUENCE OF subtypes
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value or template of type `\@Compat1.myrec1' was expected instead of `\@Compat1.myrecof3'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: First operand of operation `substr\(\)' should be a string, `record of' or `set of' value
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Simple records and others
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Records and others>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat2 Compat2.ttcn>
module Compat2 {
type port MyPort message {
  inout myrec1
  inout myrec2        //  OK
  inout myrec1_alias  // !OK
}
type component Empty {
  timer T
  port MyPort P
}
type record myrec1 { integer a }
type myrec1 myrec1_alias  // Only a "typedef".
type record myrec2 { integer a }
type record myrec3 { integer a optional }
type record myrec4 { integer a, integer b }
type set myset1 { integer a }
type set of integer mysetof1
type record of integer myrecof1
type record length(1) of integer myrecof2
type record length(2) of integer myrecof3
type integer myarr1[1]
type union myuni1 {
  myrec1 a,
  myrec2 b
}
type union myuni2 {
  myrec2 a,
  myrec1 b
}
testcase tc1_Compat2(in myrec1 p1) runs on Empty {
  // For template instances the compatibility check is reversed.
  var myrec4 rec4 := { 1, 2 }
  activate(as1_Compat2(myrec2 : { 1 }))  //  OK
  activate(as1_Compat2(myrec3 : { 1 }))  // !OK
  activate(as1_Compat2(rec4))            // !OK
  P.send(rec4)     // !OK
  P.receive(rec4)  // !OK
}
function f1_Compat2(in myrec1 p1) { }
function f2_Compat2() return myrec1 {
  var myrec2 l_rec2
  var myrec3 l_rec3
  var myrec4 l_rec4
  if (l_rec2.a > l_rec2.a)       { return l_rec2 }  //  OK
  else if (l_rec2.a == l_rec2.a) { return l_rec3 }  // !OK
  else if (l_rec2.a < l_rec2.a)  { return l_rec4 }  // !OK
  else { return { 1 } }
}
altstep as1_Compat2(in myrec1 p1) runs on Empty { [p1.a > p1.a] T.timeout { } }
control {
  var myrec1 rec1 := { 1 }
  var myrec2 rec2 := rec1  //  OK
  var myrec3 rec3 := { omit }
  var myrec4 rec4 := { rec1.a, rec2.a }
  var myset1 set1 := { 1 }
  var mysetof1 setof1 := { 1 }
  var myrecof1 recof1 := { 1 }
  var myrecof2 recof2 := { 1 }
  var myrecof3 recof3 := { 1, 2 }
  var myarr1 arr1 := { 1 }
  var myarr2 arr2 := { 1, 2 }
  var myuni1 uni1 := { a := { 1 } }
  var myuni2 uni2 := { b := { 1 } }
  var anytype any1 := { myrec1 := { 1 } }

  // Records <-> records.
  rec2 := rec3  //  OK
  if (rec2 == rec3 or rec2 != rec3) { }  //  OK
  execute(tc1_Compat2(rec2))  //  OK
  execute(tc1_Compat2(rec3))  // !OK
  execute(tc1_Compat2(rec4))  // !OK
  f1_Compat2(rec2)  //  OK
  f1_Compat2(rec3)  // !OK
  f1_Compat2(rec4)  // !OK

  // Records <-> sets.
  set1 := rec1  // !OK
  rec1 := set1  // !OK
  execute(tc1_Compat2(set1))  // !OK
  f1_Compat2(set1)            // !OK
  if (set1 == rec1 or rec1 != set1) { }  // !OK

  // Records <-> set ofs.
  setof1 := rec1
  rec1 := setof1
  execute(tc1_Compat2(setof1))  // !OK
  f1_Compat2(setof1)            // !OK
  if (setof1 == rec1 or rec1 != setof1) { }  // !OK

  // Records <-> record ofs.
  recof1 := rec1  //  OK
  rec1 := recof1  //  OK
  execute(tc1_Compat2(recof1))  //  OK
  f1_Compat2(recof1)            //  OK
  if (recof1 == rec1 or rec1 != recof1) { }  //  OK

  // Records <-> record ofs (good restriction).
  recof2 := rec1  //  OK
  rec1 := recof2  //  OK
  execute(tc1_Compat2(recof2))  //  OK
  f1_Compat2(recof2)            //  OK
  if (recof2 == rec1 or rec1 != recof2) { }  //  OK

  // Records <-> record ofs (bad restriction).
  recof3 := rec1  // !OK
  rec1 := recof3  // !OK
  execute(tc1_Compat2(recof3))  // !OK
  f1_Compat2(recof3)            // !OK
  if (recof3 == rec1 or rec1 != recof3) { }  // !OK

  // Records <-> arrays (good dimension).
  arr1 := rec1  //  OK
  rec1 := arr1  //  OK
  execute(tc1_Compat2(arr1))  //  OK
  f1_Compat2(arr1)            //  OK
  if (arr1 == rec1 or rec1 != arr1) { }  //  OK

  // Records <-> arrays (bad dimension).
  arr1 := rec4  // !OK
  rec4 := arr1  // !OK
  if (arr1 == rec4 or rec4 != arr1) { }  // !OK

  // Records <-> unions.
  uni1 := rec1  // !OK
  rec1 := uni1  // !OK
  if (uni1 == rec1 or rec1 != uni1) { }  // !OK

  // Records <-> anytypes.
  rec1 := any1  // !OK
  any1 := rec1  // !OK
  if (any1 == rec1 or rec1 != any1) { }  // !OK

  // Unions <-> unions.
  uni1 := uni2  //  OK
  uni2 := uni1  //  OK
  if (uni1 == uni2 or uni2 == uni1) { }  //  OK

  // Unions <-> anytypes.
  uni1 := any1  // !OK
  any1 := uni1  // !OK
  if (uni1 == any1 or any1 == uni1) { }  // !OK
}
} with { extension "anytype myrec1, myrec2" }
<END_MODULE>
<RESULT FTRT COUNT 1>
(?is)\berror: Duplicate incoming message type `\@Compat2.myrec1'
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Duplicate outgoing message type `\@Compat2.myrec1'
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\bnote: Type `\@Compat2.myrec1' is already listed here
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Message type `\@Compat2.myrec4' is not present on the outgoing list of port type `\@Compat2.MyPort'
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Message type `\@Compat2.myrec4' is not present on the incoming list of port of type `\@Compat2.MyPort'
<END_RESULT>
<RESULT FTRT COUNT 3>
(?is)\berror: Type mismatch: `\@Compat2.myrec2.a' of type `integer' and `\@Compat2.myrec3.a' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 4>
(?is)\berror: Type mismatch: `\@Compat2.myrec1.a' of type `integer' and `\@Compat2.myrec3.a' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 4>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.myrec4' are not compatible: The number of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 4>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.myset1' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myset1' and `\@Compat2.myrec1' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 4>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.mysetof1' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.mysetof1' and `\@Compat2.myrec1' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 4>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.myrecof3' are not compatible: Incompatible record of/SEQUENCE OF subtypes
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myrecof3' and `\@Compat2.myrec1' are not compatible: Incompatible record of/SEQUENCE OF subtypes
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `integer\[1\]' and `\@Compat2.myrec4' are not compatible: The dimension of the array must be >= than the number of mandatory fields in the record/SEQUENCE type
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myrec4' and `integer\[1\]' are not compatible: The dimension of the array must be >= than the number of mandatory fields in the record/SEQUENCE type
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myuni1' and `\@Compat2.myrec1' are not compatible: union/CHOICE/anytype types are compatible only with other union/CHOICE/anytype types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.myuni1' are not compatible: union/CHOICE/anytype types are compatible only with other union/CHOICE/anytype types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myrec1' and `\@Compat2.anytype' are not compatible: union/CHOICE/anytype types are compatible only with other union/CHOICE/anytype types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.anytype' and `\@Compat2.myrec1' are not compatible: Type anytype is compatible only with other anytype types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.myuni1' and `\@Compat2.anytype' are not compatible: Type anytype is compatible only with other anytype types
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat2.anytype' and `\@Compat2.myuni1' are not compatible: Type anytype is compatible only with other anytype types
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Standard compile-time errors
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Standard compile-time errors>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat3 Compat3.ttcn>
// Compile-time errors from the standard.
module Compat3 {
type record AType {
  integer a(0..10) optional,
  integer b(0..10) optional,
  boolean c
}

type record BType {
  integer a optional,
  integer b(0..10) optional,
  boolean c
}

type record CType {
  integer d optional,
  integer e optional,
  boolean f
}

type record DType {
  integer a optional,
  integer b optional,
  boolean c optional
}

type record EType {
  integer a optional,
  integer b optional,
  boolean c,
  float d optional
}

type set FType {
  integer a optional,
  integer b optional,
  boolean c
}

type union U1 { integer i }
type union U2 { integer i, boolean b }

control {
  var AType MyVarA := { -, 1, true }
  var BType MyVarB := { omit, 2, true }
  var CType MyVarC := { 3, omit, true }
  var DType MyVarD := { 4, 4, true }
  var EType MyVarE := { 5, 5, true, omit }
  var U1 u1 := { i := 1 }
  var U2 u2 := u1

  MyVarA := MyVarB  //  OK
  MyVarC := MyVarB  //  OK
  MyVarA := MyVarD  // !OK
  MyVarA := MyVarE  // !OK

  var FType MyVarF := { a := 1, c := true }
  MyVarF := MyVarA     // !OK
  u1 := u2             //  OK
  var anytype x := u1  // !OK
}
} with { extension "anytype integer" }
<END_MODULE>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat3.AType.c' of type `boolean' and `\@Compat3.DType.c' of type `boolean' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat3.AType' and `\@Compat3.EType' are not compatible: The number of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat3.FType' and `\@Compat3.AType' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types  
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `@Compat3.anytype' and `\@Compat3.U1' are not compatible: Type anytype is compatible only with other anytype types
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - More complex types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - More complex types>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat4 Compat4.ttcn>
module Compat4 {
type record myrec1 {
  integer f1 optional,
  integer f2,
  boolean f3
}
type record myrec2 {
  integer f1,
  integer f2,
  boolean f3
}
type record of myrec1 mylist1
type myrec2 myarr2[2]
type mylist1 myarr1[2]  // Top-level 1.
type record of myarr2 mylist2  // Top-level 2.
control {
  var myarr1 arr1 := {
    { { omit, 99, false }, { 1, 100, true } },
    { { 1, 2, false }, { 0, 1, false } }
  }
  var mylist2 ml2 := {
    { { 1, 2, false }, { 11, 22, false } },
    { { -1, -2, true }, { -11, -22, true } }
  }
  arr1 := ml2  // !OK
  ml2 := arr1  // !OK
  if (arr1 == ml2 or ml2 != arr1) { }  // !OK
}
}
<END_MODULE>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat4.mylist1\[2\]\[\].f1' of type `integer' and `\@Compat4.mylist2\[\].f1' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 2>
(?is)\berror: Type mismatch: `\@Compat4.mylist2\[\].f1' of type `integer' and `\@Compat4.mylist1\[2\]\[\].f1' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Arrays and other list types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Arrays and other list types>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat5 Compat5.ttcn>
module Compat5 {
const integer i1[2 .. 4] := { 1, 2, 3 }
const integer i2[3] := i1
const integer i3[1..3] := i1
const integer i1[2][1..2] := { { 1, 2 }, { 3, 4 } };
const integer i2[2][0..1] := i1;
control {
}
}
<END_MODULE>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `integer\[3\]' and `integer\[2..4\]' are not compatible: Array types should have the same dimension
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `integer\[1..3\]' and `integer\[2..4\]' are not compatible: Array types should have the same dimension
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `integer\[2\]\[0..1\]' and `integer\[2..4\]' are not compatible: Array types should have the same dimension
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `integer\[3\]' was expected instead of `integer\[2..4\]'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `integer\[1..3\]' was expected instead of `integer\[2..4\]'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `integer\[2\]\[0..1\]' was expected instead of `integer\[2..4\]'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Templates of all kind
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Templates of all kind>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat6 Compat6.ttcn>
module Compat6 {
type record rtype { integer i, boolean b }
type set stype { integer i, boolean b }
type record r2type { integer i1, integer i2 }
type set of integer s2type

template rtype t := { 1, true }
template stype t1 modifies t := { b := false }
template r2type u := { 1, 2 };
template s2type u1 modifies u := { 2, 1 };

// Test for the first bug (TR 955).
type record of integer b1_intlist
type set of integer b1_intset
const b1_intlist c_b1 := { 1, 2, 3 }
template b1_intset t_b1 := { 3, 2, 1 }

control {
  var template rtype tv1
  var template r2type tv2
  tv1 := tv2
  if (match(valueof(t), u1)) { }
  if (match(c_b1, t_b1)) { }
}
}
<END_MODULE>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.stype' and `\@Compat6.rtype' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.s2type' and `\@Compat6.r2type' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.rtype.b' of type `boolean' and `\@Compat6.r2type.i2' of type `integer' are not compatible
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.s2type' and `\@Compat6.rtype' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.b1_intset' and `\@Compat6.b1_intlist' are not compatible: set/SET and set of/SET OF types are compatible only with other set/SET set of/SET OF types
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: The modified template has different type than base template `\@Compat6.t': `\@Compat6.rtype' was expected instead of `\@Compat6.stype'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: The modified template has different type than base template `\@Compat6.u': `\@Compat6.r2type' was expected instead of `\@Compat6.s2type'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value or template of type `\@Compat6.rtype' was expected instead of `\@Compat6.r2type'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value or template of type `\@Compat6.s2type' was expected instead of `\@Compat6.rtype'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat6.b1_intset' was expected instead of `\@Compat6.b1_intlist'
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Type Compatibility - Recursive types
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Type Compatibility - Recursive types>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Compat6 Compat6.ttcn>
module Compat6 {
type record of recR recofR
type record recR { recofR rof optional }
type record c1   { recR f1 }
type record c11  { c1 f1 }
type record c2   { recofR f1 }
type record c22  { c2 f1 }
// "Normal" use.
type record A {
  integer f1,
  B f2 optional
}
type record B {
  A f1 optional,
  integer f2
}
control {
  // Make sure that we don't stuck in an infinite recursion.
  var recofR v_rof := { { omit } }
  var recR v_r := { rof := omit }
  var c11 cc1 := { f1 := { { omit } } }
  var c22 cc2 := { f1 := { { { omit } } } }
  cc1 := cc2
  if (cc1 == cc2) { }
  v_r := v_rof
  if (v_r.rof == omit) { }
  v_rof := v_r
  if (cc1 == v_r or v_rof == cc2) { }  // Just to get an error...
  var A a := { f1 := 1, f2 := { f1 := { 1, omit }, f2 := 11 } }
  var B b := { f1 := a, f2 := 1 }
  if (a == b and not b != a) { }
}
}
<END_MODULE>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.c11.f1' of type `\@Compat6.c1' and `\@Compat6.recR.rof' of type `\@Compat6.recofR' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.recofR\[\].rof' of type `\@Compat6.recofR' and `\@Compat6.c22.f1.f1' of type `\@Compat6.recofR' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.A.f1' of type `integer' and `\@Compat6.B.f1' of type `\@Compat6.A' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT FTRT COUNT 1>
(?is)\berror: Type mismatch: `\@Compat6.B.f1' of type `\@Compat6.A' and `\@Compat6.A.f1' of type `integer' are not compatible: The optionality of fields in record/SEQUENCE types must be the same
<END_RESULT>
<RESULT LTRT COUNT 4>
(?is)\berror: The operands of operation `==' should be of compatible types
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: The operands of operation `!=' should be of compatible types
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat6.c11' was expected instead of `\@Compat6.c22'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat6.recR' was expected instead of `\@Compat6.recofR'
<END_RESULT>
<RESULT LTRT COUNT 1>
(?is)\berror: Type mismatch: a value of type `\@Compat6.recofR' was expected instead of `\@Compat6.recR'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Default values of modified parametrized templates
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Default values of modified parametrized templates>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN TDefPar TDefPar.ttcn>
module TDefPar {
// Negative tests for ETSI CR5091.

type record MyRecordType {
  integer field1 optional,
  charstring field2,
  boolean field3
}

// For value parameters.

template MyRecordType MyTemplate1(integer p_int) := {
  field1 := 1,
  field2 := "",
  field3 := true
}
 
template MyRecordType MyTemplate2(integer p_int := -) modifies MyTemplate1 := {
  field1 := -1
}

template MyRecordType MyTemplate3(integer p_int := -) := {
  1, "", true
}

template MyRecordType MyTemplate4(integer p_int := 1, charstring p_str, boolean p_bool) := {
  p_int, p_str, p_bool
}

template MyRecordType MyTemplate5(integer p_int := -, charstring p_str := -, boolean p_bool := -) modifies MyTemplate4 := {
  p_int, p_str, p_bool
}

template MyRecordType MyTemplate6(integer p_int := 1, charstring p_str, boolean p_bool, octetstring p_ostr := -) modifies MyTemplate4 := {
  p_int, p_str, p_bool
}

// For template parameters.

template MyRecordType TMyTemplate1(template integer p_int) := {
  field1 := 1,
  field2 := "",
  field3 := true
}
 
template MyRecordType TMyTemplate2(template integer p_int := -) modifies TMyTemplate1 := {
  field1 := -1
}

template MyRecordType TMyTemplate3(template integer p_int := -) := {
  1, "", true
}

template MyRecordType TMyTemplate4(template integer p_int := 1, template charstring p_str, template boolean p_bool) := {
  p_int, p_str, p_bool
}

template MyRecordType TMyTemplate5(template integer p_int := -, template charstring p_str := -, template boolean p_bool := -) modifies TMyTemplate4 := {
  p_int, p_str, p_bool
}

template MyRecordType TMyTemplate6(template integer p_int := 1, template charstring p_str, template boolean p_bool, template octetstring p_ostr := -) modifies TMyTemplate4 := {
  p_int, p_str, p_bool
}

template MyRecordType TMyTemplate7(template integer p_int := 0) modifies MyRecordType := {
  field1 := p_int
}

type component Empty { timer T := 1.0 }

testcase TC1(in integer p1 := -) runs on Empty { }
testcase TC2(in template integer p1 := -) runs on Empty { }

function Func1(in integer p1 := -) { }
function Func2(in template integer p1 := -) { }

altstep Alt1(in integer p1 := -) runs on Empty { [1 > 2] T.timeout { } }
altstep Alt2(in template integer p1 := -) runs on Empty { [1 > 2] T.timeout { } }


}
<END_MODULE>
<RESULT COUNT 8>
(?is)\berror: Not used symbol \(`-'\) doesn't have the corresponding default parameter in the base template
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Only modified templates are allowed to use the not used symbol \(`-'\) as the default parameter
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror: integer value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: character string value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: boolean value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: octetstring value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Reference to a template was expected in the `modifies' definition instead of type `\@TDefPar.MyRecordType'
<END_RESULT>
<RESULT COUNT 19>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: __SCOPE__ macro
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - __SCOPE__ macro>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN TDefPar TDefPar.ttcn>
module TDefPar {
// Negative tests for __SCOPE__ macro.

type enumerated Dummy { Dummy1, Dummy2 };

type record MyRecord {
  charstring field1,
  charstring field2 (__SCOPE__) optional
};

type record MyRecord2 {
  MyRecord field1,
  charstring field2 (__SCOPE__)
};


template MyRecord t_MyTemplate := {
  field1 := __SCOPE__,
  //field2 := __SCOPE__ //NOK MyRecord not equal with t_MyTemplate
  field2 := "MyRecord"
}

template MyRecord2 t_MyTemplate2 := {
  field1 := {
    field1 := __SCOPE__,
    field2 := __SCOPE__ 
  },
  field2 := __SCOPE__
}

}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: "t_MyTemplate2" is not a valid value for type `charstring' which has subtype \("MyRecord"\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: "t_MyTemplate2" is not a valid value for type `charstring' which has subtype \("MyRecord2"\)
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: public/private/friend
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - public/private/friend>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{

public modulepar charstring ts_m1:="public";
private modulepar charstring ts_m2:="private";
friend modulepar charstring ts_m3:="friend";

friend module module2;

private import from module2 all;//OK
private import from module3 all;//OK
private import from module4 all;//OK

const module2Type akarmi1 := 1; //OK, type is implicitly public
const module2TypePublic akarmi2 := 2; //OK, type is explicitly public
const module2TypeFriend akarmi3 := 3; //OK, module1 is friend of module2
const module2TypePrivate akarmi4 := 4; //NOK, module2TypePrivate is private to module2 

group g_MyGroup{
  const module3Type akarmi5 := 5; //OK, type is implicitly public
  const module3TypePublic akarmi6 := 6; //OK, type is explicitly public
  const module3TypeFriend akarmi7 := 7; //NOK, module1 is NOT a friend of module3
  const module3TypePrivate akarmi8 := 8; //NOK, module2TypePrivate is private to module2
}

function MyFunc1() runs on Lib4_CT {} //OK
function MyFunc2() runs on Lib4Friend_CT {} //OK, module1 is friend for module4
function MyFunc3() runs on Lib4Private_CT {} //NOK, the *name* Lib4Private_CT is not visible for module1, thus fails at checking the runs on clause, whatever is the content!


function f_set2_Lib4_1() runs on Lib4_CT { v_Lib4_1 := 0 } //OK
function f_set2_Lib4_2() runs on Lib4_CT { v_Lib4_2 := 0 } //OK
function f_set2_Lib4_3() runs on Lib4_CT { v_Lib4_3 := 0 } //OK
function f_set2_Lib4Friend_1() runs on Lib4Friend_CT { v_Lib4Friend_1 := 0 } //OK
function f_set2_Lib4Friend_2() runs on Lib4Friend_CT { v_Lib4Friend_2 := 0 } //OK
function f_set2_Lib4Friend_3() runs on Lib4Friend_CT { v_Lib4Friend_3 := 0 } //OK


type component User_CT extends Lib4_CT {};
function f_set3_Lib4_1() runs on User_CT { v_Lib4_1 := 0 } //OK
function f_set3_Lib4_2() runs on User_CT { v_Lib4_2 := 0 } //OK
function f_set3_Lib4_3() runs on User_CT { v_Lib4_3 := 0 } //NOK, v_Lib4_3 is private, can be used in functions with "Lib4_CT" in their runs on (but not in children)

//in short: visibility of the component type definition (name) and allowed use of the component
//type definitions are two different things. Component type visibility is checked when checking
//the runs on clause. Component definition visibility is checked  (after a successful runs on
//check), when the definition is used within the body of the function


//All setter functions of module4 are public, hence can be called from any function
//with a compatible runs on clause 
function f_MyFunc_1() runs on User_CT { f_set_Lib4_1() } //OK
function f_MyFunc_2() runs on User_CT { f_set_Lib4_2() } //OK
function f_MyFunc_3() runs on User_CT { f_set_Lib4_3() } //OK

type component UserFriend_CT extends Lib4Friend_CT {}; //OK
function f_MyFuncFriend_1() runs on UserFriend_CT { f_set_Lib4Friend_1() } //OK
function f_MyFuncFriend_2() runs on UserFriend_CT { f_set_Lib4Friend_2() } //OK
function f_MyFuncFriend_3() runs on UserFriend_CT { f_set_Lib4Friend_3() } //OK


type component UserPrivate_CT extends Lib4Private_CT {}; //NOK, the name Lib4Private_CT is not visible in module1
function f_MyFuncPrivate_1() runs on UserPrivate_CT { f_set_Lib4Private_1() } //NOK, UserPrivate_CT has an error
function f_MyFuncPrivate_2() runs on UserPrivate_CT { f_set_Lib4Private_2() } //NOK, UserPrivate_CT has an error
function f_MyFuncPrivate_3() runs on UserPrivate_CT { f_set_Lib4Private_3() } //NOK, UserPrivate_CT has an error

control {
var Lib4Private_CT v_Lib4Private := Lib4Private_CT.create; // NOK, the name Lib4Privae_CT is not visible in module1
}

}  // end of module1

<END_MODULE>
<MODULE TTCN module2 module2.ttcn>
module module2
{
friend module module1;
public group g_Group1{
  type integer module2Type;
  public type integer module2TypePublic;
  friend type integer module2TypeFriend;
  private type integer module2TypePrivate;
}

/*private*/ group g_Group2{
  type integer module2Type2;
  public type integer module2TypePublic2;
  friend type integer module2TypeFriend2;
  private type integer module2TypePrivate2;
}

/*friend*/ group g_Group3{
  type integer module2Type3;
  public type integer module2TypePublic3;
  friend type integer module2TypeFriend3;
  private type integer module2TypePrivate3;
}

}  // end of module2

<END_MODULE>
<MODULE TTCN module3 module3.ttcn>
module module3
{
type integer module3Type;
public type integer module3TypePublic;
friend type integer module3TypeFriend;
private type integer module3TypePrivate;

public type port pPublic message { inout charstring; } with {extension "internal"}
private type port pPrivate message { inout charstring; } with {extension "internal"}
friend type port pFriend message { inout charstring; } with {extension "internal"}
}  // end of module3

<END_MODULE>
<MODULE TTCN module4 module4.ttcn>
module module4
{
friend module module1;

type component Lib4_CT {
  var integer v_Lib4_1;
  public var integer v_Lib4_2;
  private var integer v_Lib4_3;
}
friend type component Lib4Friend_CT {
  var integer v_Lib4Friend_1;
  public var integer v_Lib4Friend_2;
  private var integer v_Lib4Friend_3;
}
private type component Lib4Private_CT {
  var integer v_Lib4Private_1;
  public var integer v_Lib4Private_2;
  private var integer v_Lib4Private_3;
}

function f_set_Lib4_1() runs on Lib4_CT { v_Lib4_1 := 0 } //OK
function f_set_Lib4_2() runs on Lib4_CT { v_Lib4_2 := 0 } //OK
function f_set_Lib4_3() runs on Lib4_CT { v_Lib4_3 := 0 } //OK
function f_set_Lib4Friend_1() runs on Lib4Friend_CT { v_Lib4Friend_1 := 0 } //OK
function f_set_Lib4Friend_2() runs on Lib4Friend_CT { v_Lib4Friend_2 := 0 } //OK
function f_set_Lib4Friend_3() runs on Lib4Friend_CT { v_Lib4Friend_3 := 0 } //OK

//These functions cannot be called or started outside module4, though they are public!
//See module1
function f_set_Lib4Private_1() runs on Lib4Private_CT { v_Lib4Private_1 := 0 } //OK
function f_set_Lib4Private_2() runs on Lib4Private_CT { v_Lib4Private_2 := 0 } //OK
function f_set_Lib4Private_3() runs on Lib4Private_CT { v_Lib4Private_3 := 0 } //OK
}  // end of module4

<END_MODULE>
<MODULE TTCN module5 module5.ttcn>
module module5
{
/*public*/ import from module2 all;//NOK no public import
}
<END_MODULE>
<MODULE TTCN module6 module6.ttcn>
module module6
{
/*friend*/ import from module2 all;//NOK no friend import
}
<END_MODULE>

<RESULT COUNT 1>
(?is)\berror: There is no local or imported definition with name `module2TypePrivate'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: There is no local or imported definition with name `module3TypeFriend'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: There is no local or imported definition with name `module3TypePrivate'
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: There is no local or imported definition with name `Lib4Private_CT'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The member definition `v_Lib4_3' in component type `User_CT' is not visible in this scope
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Runs on clause mismatch: A definition that runs on component type `@module1.UserPrivate_CT' cannot call function `@module4.f_set_Lib4Private_1', which runs on `@module4.Lib4Private_CT'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Runs on clause mismatch: A definition that runs on component type `@module1.UserPrivate_CT' cannot call function `@module4.f_set_Lib4Private_2', which runs on `@module4.Lib4Private_CT'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Runs on clause mismatch: A definition that runs on component type `@module1.UserPrivate_CT' cannot call function `@module4.f_set_Lib4Private_3', which runs on `@module4.Lib4Private_CT'
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Operation `create()' is not allowed in control part
<ENd RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Verdicts
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Verdicts>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type verdicttype myv1 (pass, fail, none)
  type myv1 myv2 (inconc)
  // No error for disjunct types.
  type verdicttype myv3 (myv1, myv2)
  type myv3 myv4 (myv3, myv3, myv3)
  const myv1 c_myv1 := inconc
  const myv2 c_myv2 := c_myv1
  template myv1 t_myv1 := inconc
  template myv2 t_myv2 := t_myv1
  template myv1 t_myv3 := (inconc)
  
  modulepar myv1 mp1 := inconc
  
  function fv1() return myv1 { return inconc }
  function fv2(in myv1 p1 := inconc) { }
  
  control {
    var template myv1 vt_myv1 := inconc
    var template myv1 vt_myv2 := t_myv2
    var template myv2 vt_myv3 := fv1()  // No error.
    var myv1 v_myv1 := inconc
    var myv1 v_myv2 := valueof(t_myv2)
    var myv2 v_myv3 := fv1()
  }
}
<END_MODULE>
<RESULT COUNT 8>
(?is)\berror: inconc is not a valid value for type `verdicttype' which has subtype \(none,pass,fail\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(inconc\) is not subset of subtype \(none,pass,fail\)
<END_RESULT>
<RESULT COUNT 9>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Booleans
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Booleans>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type boolean myb1 (true)
  type myb1 myb2 (false)
  type boolean myb3 (myb1, myb2)
  const myb1 c_myb1 := false
  const myb2 c_myb2 := c_myb1
  template myb1 t_myb1 := false
  template myb2 t_myb2 := t_myb1
  template myb1 t_myb3 := (false)
  
  modulepar myb1 mp1 := false
  
  function fb1() return myb1 { return false }
  function fb2(in myb1 p1 := false) { }
  
  control {
    var template myb1 vt_myb1 := false
    var template myb1 vt_myb2 := t_myb2
    var template myb2 vt_myb3 := fb1()
    var myb1 v_myb1 := false
    var myb1 v_myb2 := valueof(t_myb2)
    var myb2 v_myb3 := fb1()
  }
}
<END_MODULE>
<RESULT COUNT 8>
(?is)\berror: false is not a valid value for type `boolean' which has subtype \(true\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(false\) is not subset of subtype \(true\)
<END_RESULT>
<RESULT COUNT 9>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Integers
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Integers>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type integer myi1 (1, 2, 3)
  type myi1 myi2 (4)
  type myi1 myi3 (4..8)
  type myi1 myi4 (4..8, 16)
  type integer myi5 (myi1, myi2)
  type integer myi6 (1, 2, myi7)
  type integer myi7 (myi6, 1, 2)
  type integer myi8 (myi1, 99, 101)
  
  const myi1 c_myi1 := 4
  const myi2 c_myi2 := c_myi1
  const myi8 c_myi3 := 100
  
  template myi1 t_myi1 := 4
  template myi2 t_myi2 := t_myi1
  template myi1 t_myi3 := (4)
  template myi8 t_myi4 := c_myi3
  
  modulepar myi1 mp1 := 4
  modulepar myi5 mp2 := 32  // No error.
  
  function fi1() return myi1 { return 4 }
  function fi2(in myi1 p1 := 4) { }
  
  control {
    var template myi1 vt_myi1 := 4
    var template myi1 vt_myi2 := t_myi2
    var template myi2 vt_myi3 := fi1()
    var template myi8 vt_myi4 := 100
    var myi1 v_myi1 := 4
    // It seems, that no additional error is reported here.
    var myi1 v_myi2 := valueof(t_myi2)
    var myi2 v_myi3 := fi1()
    var myi8 v_myi4 := 100
  }
}
<END_MODULE>
<RESULT COUNT 4>
(?is)\berror: 100 is not a valid value for type `integer' which has subtype \(1..3,99,101\)
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror: 4 is not a valid value for type `integer' which has subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4\) is not subset of subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4..8\) is not subset of subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4..8,16\) is not subset of subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: While checking circular type references in subtype definitions: Circular reference: `\@module1.myi6' -> `\@module1.myi7' -> `\@module1.myi6'
<END_RESULT>
<RESULT COUNT 16>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Floats
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Floats>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type float myf1 (1.0, 2.0, 3.0)
  type myf1 myf2 (4.0)
  type myf1 myf3 (4.0..8.0)
  type myf1 myf4 (4.0..8.0, 16.0)
  type float myf5 (myf1, myf2)

  const myf1 c_myf1 := 4.0
  const myf2 c_myf2 := c_myf1

  template myf1 t_myf1 := 4.0
  template myf2 t_myf2 := t_myf1
  template myf1 t_myf3 := (4.0)
  
  modulepar myf1 mp1 := 4.0
  modulepar myf5 mp2 := 32.0  // No error.
  
  function ff1() return myf1 { return 4.0 }
  function ff2(in myf1 p1 := 4.0) { }
  
  control {
    var template myf1 vt_myf1 := 4.0
    var template myf1 vt_myf2 := t_myf2
    var template myf2 vt_myf3 := ff1()
    var myf1 v_myf1 := 4.0
    var myf1 v_myf2 := valueof(t_myf2)
    var myf2 v_myf3 := ff1()
  }
}
<END_MODULE>
<RESULT COUNT 8>
(?is)\berror: 4.0e0 is not a valid value for type `float' which has subtype \(1.0e0,2.0e0,3.0e0\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4.0e0\) is not subset of subtype \(1.0e0,2.0e0,3.0e0\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4.0e0..8.0e0\) is not subset of subtype \(1.0e0,2.0e0,3.0e0\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(4.0e0..8.0e0,1.6e1\) is not subset of subtype \(1.0e0,2.0e0,3.0e0\)
<END_RESULT>
<RESULT COUNT 11>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Charstrings
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Charstrings>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type charstring myc1 ("ich", "du", "er")
  type charstring myc2 length(1)
  type myc1 myc3 length(1)
  type myc1 myc4 ("a".."z")  // No error message.
  type myc1 myc5 ("a".."z", "sie")
  type charstring myc6 (myc1, myc2)
  type myc1 myc7 (pattern "itstoolong")
  type myc1 myc8 (pattern "i*h")
  
  const myc1 c_myc1 := "sie"
  const myc2 c_myc2 := "sie"
  const myc8 c_myc3 := "ich"
  
  template myc1 t_myc1 := "sie"
  template myc2 t_myc2 := "sie"
  template myc2 t_myc3 := t_myc1
  template myc1 t_myc4 := ("sie")
    
  function fc1() return myc1 { return "sie" }
  function fc2(in myc1 p1 := "sie") { }
    
  control {
    var template myc1 vt_myc1 := "sie"
    var template myc2 vt_myc2 := "sie"
    var template myc2 vt_myc3 := fc1()
    var myc1 v_myc1 := "sie"
    // Additional `(' characters in the error message.
    var myc2 v_myc2 := "sie"
    var myc2 v_myc3 := fc1()
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Mixing of value list and range subtyping is not allowed for type `charstring'
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror: "sie" is not a valid value for type `charstring' which has subtype \("du","er","ich"\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: "sie" is not a valid value for type `charstring' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: The subtype is an empty set
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Subtype mismatch: subtype length\(1\) has no common value with subtype \("du","er","ich"\)
<END_RESULT>
<RESULT COUNT 17>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Universal Charstrings
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Universal Charstrings>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type universal charstring myu1 (char(0, 0, 0, 0), char(0, 0, 0, 1))
  type universal charstring myu2 length(1)
  type myu1 myu3 length(2) 
  type universal charstring myu4 (myu1, myu2)
  type universal charstring myu5 (pattern "abc?\q{0, 0, 1, 113}")
  const myu1 c_myu1 := char(0, 0, 1, 0)
  const myu2 c_myu2 := char(0, 0, 1, 0) & char(0, 0, 1, 0)
  template myu1 t_myu1 := char(0, 0, 1, 0)
  template myu2 t_myu2 := char(0, 0, 1, 0) & char(0, 0, 1, 0)
  template myu2 t_myu3 := t_myu1
  template myu1 t_myu4 := (char(0, 0, 1, 0))
  
  function fu1() return myu1 { return char(0, 0, 1, 0) & char(0, 0, 1, 0) }
  function fu2(in myu1 p1 := char(0, 0, 1, 0) & char(0, 0, 1, 0)) { }
    
  control {
    var template myu1 vt_myu1 := char(0, 0, 1, 0)
    var template myu2 vt_myu2 := char(0, 0, 1, 0) & char(0, 0, 1, 0)
    var template myu2 vt_myu3 := fu1()
    var myu1 v_myu1 := char(0, 0, 1, 0)
    var myu2 v_myu2 := char(0, 0, 1, 0) & char(0, 0, 1, 0)
    var myu2 v_myu3 := fu1()
  }
}
<END_MODULE>
<RESULT COUNT 5>
(?is)\berror: char\(0, 0, 1, 0\) is not a valid value for type `universal charstring' which has subtype \(char\(0, 0, 0, 0\),char\(0, 0, 0, 1\)\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: char\(0, 0, 1, 0\) & char\(0, 0, 1, 0\) is not a valid value for type `universal charstring' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: char\(0, 0, 1, 0\) & char\(0, 0, 1, 0\) is not a valid value for type `universal charstring' which has subtype \(char\(0, 0, 0, 0\),char\(0, 0, 0, 1\)\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype is an empty set
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Bitstrings
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Bitstrings>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type bitstring myb1 ('00'B, '01'B)
  type bitstring myb2 length(1)
  // The consistent `The subtype is an empty set' error message may be better.
  type myb1 myb3 length(1) 
  type bitstring myb4 (myb1, myb2)
  const myb1 c_myb1 := '10'B
  const myb2 c_myb2 := '10'B
  template myb1 t_myb1 := '10'B
  template myb2 t_myb2 := '10'B
  template myb2 t_myb3 := t_myb1
  template myb1 t_myb4 := ('10'B)
  
  function fb1() return myb1 { return '10'B }
  function fb2(in myb1 p1 := '00'B) { }
  
  control {
    var template myb1 vt_myb1 := '10'B
    var template myb2 vt_myb2 := '10'B
    // It's not yet checked.
    var template myb2 vt_myb3 := fb1()
    var myb1 v_myb1 := '10'B
    var myb2 v_myb2 := '10'B
    var myb2 v_myb3 := fb1()
  }
}
<END_MODULE>
<RESULT COUNT 6>
(?is)\berror: '10'B is not a valid value for type `bitstring' which has subtype \('00'B,'01'B\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: '10'B is not a valid value for type `bitstring' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype length\(1\) is not subset of subtype \('00'B,'01'B\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Subtype mismatch: subtype length\(1\) has no common value with subtype \('00'B,'01'B\)
<END_RESULT>
<RESULT COUNT 14>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Hexstrings
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Hexstrings>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type hexstring myh1 ('00'H, '01'H)
  type hexstring myh2 length(1)
  type myh1 myh3 length(1)
  type hexstring myh4 (myh1, myh2)
  const myh1 c_myh1 := '10'H
  const myh2 c_myh2 := '10'H
  template myh1 t_myh1 := '10'H
  template myh2 t_myh2 := '10'H
  template myh2 t_myh3 := t_myh1
  template myh1 t_myh4 := ('10'H)
  
  function fh1() return myh1 { return '00'H }
  function fh2(in myh1 p1 := '00'H) { }
  
  control {
    var template myh1 vt_myh1 := '10'H
    var template myh2 vt_myh2 := '10'H
    var template myh2 vt_myh3 := fh1()
    var myh1 v_myh1 := '10'H
    var myh2 v_myh2 := '10'H
    var myh2 v_myh3 := fh1()
  }
}
<END_MODULE>
<RESULT COUNT 5>
(?is)\berror: '10'H is not a valid value for type `hexstring' which has subtype \('00'H,'01'H\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: '10'H is not a valid value for type `hexstring' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype length\(1\) is not subset of subtype \('00'H,'01'H\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Subtype mismatch: subtype length\(1\) has no common value with subtype \('00'H,'01'H\)
<END_RESULT>
<RESULT COUNT 13>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Octetstrings
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Octetstrings>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type octetstring myo1 ('00'O, '01'O)
  type octetstring myo2 length(1)
  type myo1 myo3 length(2)
  type octetstring myo4 (myo1, myo2)
  const myo1 c_myo1 := '10'O
  const myo2 c_myo2 := '1010'O
  const myo3 c_myo3 := '10'O
  template myo1 t_myo1 := '10'O
  template myo2 t_myo2 := '1010'O
  template myo2 t_myo3 := t_myo1
  template myo1 t_myo4 := ('10'O)
  template myo3 t_myo5 := '10'O
  
  function fo1() return myo1 { return '1010'O }
  function fo2(in myo1 p1 := '1010'O) { }
  
  control {
    var template myo1 vt_myo1 := '10'O
    var template myo2 vt_myo2 := '1010'O
    var template myo3 vt_myo3 := '10'O
    var template myo1 vt_myo4 := fo1()
    var myo1 v_myo1 := '10'O
    var myo2 v_myo2 := '1010'O
    var myo3 v_myo3 := '10'O
    var myo1 v_myo4 := fo1()
  }
}
<END_MODULE>
<RESULT COUNT 5>
(?is)\berror: '10'O is not a valid value for type `octetstring' which has subtype \('00'O,'01'O\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror: '1010'O is not a valid value for type `octetstring' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype length\(2\) is not subset of subtype \('00'O,'01'O\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: '1010'O is not a valid value for type `octetstring' which has subtype \('00'O,'01'O\)
<END_RESULT>
<RESULT COUNT 12>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Objids
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Objids>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type objid myo1 (objid{itu_t(0) identified_organization(4) etsi(0)})
  const myo1 c_myo1 := objid{0 0 0}
  template myo1 t_myo1 := objid{0 0 0}
  
  control {
    var template myo1 vt_myo1 := objid{0 0 0}
    var myo1 v_myo1 := objid{0 0 0}
  }
}
<END_MODULE>
<RESULT COUNT 4>
(?is)\berror: objid \{ 0 0 0 \} is not a valid value for type `objid' which has subtype \(objid \{ 0 4 0 \}\)
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Anytypes
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Anytypes>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type anytype mya1 ({integer := 0})
  type anytype mya2
  type integer myint1 (1, 2, 3)
  type mya2.myint1 myint2 (1..2)
  
  const mya1 c_mya1 := {integer := 1}
  const mya2.myint1 c_mya2 := 100
  const myint2 c_myi1 := 3
  
  template mya1 t_mya1 := {integer := 1}
  
  control {
    var template mya1 vt_mya1 := {integer := 1}
    var mya1 v_mya1 := {integer := 1}
  }
} with { extension "anytype integer, myint1" }
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: 3 is not a valid value for type `integer' which has subtype \(1..2\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: \{ integer := 1 \} is not a valid value for type `\@module1.anytype' which has subtype \(\{ integer := 0 \}\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: 100 is not a valid value for type `integer' which has subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Unions
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Unions>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type union myu1 {
    integer f1,
    charstring f2
  }
  type myu1 myu2 ({f1 := 0}, {f2 := ""})
  type myu1 myu3 ({f1 := 100}, {f1 := 200})
  type myu1 myu4 (myu3.interestingfieldreferencenotcheckedbutpossible)
  type myu1 myu5 (myu3, myu4)
  
  const myu2 c_myu1 := {f1 := 1}
  const myu5 c_myu2 := {f1 := 1}
  
  // Union subtypes are not checked for templates.  We should expect 4 error
  // messages instead of 2.  It should be fixed later.  This applies for
  // record, set and union types as well.
  template myu2 t_myu1 := {f1 := 1}
  template myu5 t_myu2 := {f1 := valueof(t_myu1.f1)}
  
  control {
    var template myu2 vt_myu1 := {f1 := 1}
    var template myu5 vt_myu2 := {f1 := vt_myu1.f1}
    var myu2 v_myu1 := {f1 := 1}
    var myu5 v_myu2 := {f1 := v_myu1.f1}  // Check?
  }
}
<END_MODULE>
<RESULT COUNT 2>
(?is)\berror: \{ f1 := 1 \} is not a valid value for type `\@module1.myu1' which has subtype \(\{ f1 := 0 \},\{ f2 := "" \}\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Reference to non-existent field `interestingfieldreferencenotcheckedbutpossible' in type `\@module1.myu1'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Records
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Records>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type record myr1 {
    integer f1,
    charstring f2
  }
  type integer myi1 (11, 22, 33)
  type myr1 myr2 ({0, ""}, {0, " "})
  type myr1 myr3 ({0.0, ""})
  type myr1 myr4 (myr1, myr3)
  type myr2 myr5 (myr2, myr2, {0, ""}, {0, ""})
  type record myr6 {
    integer f1 (1, 2, 3),
    charstring f2 length(3)
  }

  // Only the constants are checked regarding subtypes.
  const myr2 c_myr1 := {1, ""}
  const myr4 c_myr2 := {1, ""}

  template myr2 t_myr1 := {1, ""}
  template myr4 t_myr2 := {1, ""}
  template myr6 t_myr3(in myi1 p1) := {p1, "abc"}

  function fr1() return myr2 { return {0, "1"} }
  function fr2(in myr2 p1 := {0, "1"}) { }
  
  control {
    var template myr2 vt_myr1 := {1, ""}
    var template myr5 vt_myr2 := {1, "1"}  // No error.  Why?
    var myr2 v_myr1 := {1, ""}
    var myr5 v_myr2 := {1, "1"}  // It's an error for all non-templates.
    var myr6 v_myr3 := {1, "abcdefghijk"}
    if (valueof(vt_myr1) == valueof(vt_myr2)) { }
    if (v_myr1 == v_myr2) { }
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: integer value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Type referenced by `myr1' does not have a subtype
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: \{ f1 := 1, f2 := "1" \} is not a valid value for type `\@module1.myr1' which has subtype \(\{ f1 := 0, f2 := "" \},\{ f1 := 0, f2 := " " \}\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: \{ f1 := 1, f2 := "" \} is not a valid value for type `\@module1.myr1' which has subtype \(\{ f1 := 0, f2 := "" \},\{ f1 := 0, f2 := " " \}\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: \{ f1 := 0, f2 := "1" \} is not a valid value for type `\@module1.myr1' which has subtype \(\{ f1 := 0, f2 := "" \},\{ f1 := 0, f2 := " " \}\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(1..3\) has no common value with subtype \(11,22,33\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: \"abcdefghijk\" is not a valid value for type `charstring' which has subtype length\(3\)
<END_RESULT>
<RESULT COUNT 9>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Sets
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Sets>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type set mys1 {
    integer f1,
    charstring f2
  }
  type integer myi1 (11, 22, 33)
  type mys1 mys2 ({f1 := 0, f2 := ""}, {f1 := 0, f2 := " "})
  type set mys3 {
    integer f1 (1, 2, 3),
    charstring f2 length(3)
  }
  type mys1 myr4 (mys2)
  type mys2 mys5 (mys2, mys2, {f1 := 0, f2 := ""}, {f1 := 0, f2 := ""})
  
  const mys2 c_mys1 := {f1 := 1, f2 := ""}
  const myr4 c_mys2 := {f1 := c_mys1.f1, f2 := c_mys1.f2}
  const mys5 c_mys3 := {f1 := 1, f2 := ""}
  
  template mys2 t_mys1 := {f1 := 1, f2 := ""}
  template mys3 t_mys2(in myi1 p1) := {f1 := p1, f2 := "abc"}
  template mys3 t_mys3(in integer p1) modifies t_mys2 := {f1 := 100}
  
  control {
    var template mys2 vt_mys1 := {f1 := 1, f2 := ""}
    var mys2 v_mys1 := {f1 := 1, f2 := ""}
    var mys3 v_mys2 := {f1 := 1, f2 := "itstoolong"}
    v_mys2.f1 := 100
    v_mys2.f2 := "itstoolong"
    // `if (v_mys1 == v_mys2) { }' should be an error in both runtimes.
    // Currently, there is no error from the function-test runtime.
  }
}
<END_MODULE>
<RESULT COUNT 4>
(?is)\berror: \{ f1 := 1, f2 := "" \} is not a valid value for type `\@module1.mys1' which has subtype \(\{ f1 := 0, f2 := "" \},\{ f1 := 0, f2 := " " \}\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(1..3\) has no common value with subtype \(11,22,33\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: \"itstoolong\" is not a valid value for type `charstring' which has subtype length\(3\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: 100 is not a valid value for type `integer' which has subtype \(1..3\)
<END_RESULT>
<RESULT COUNT 9>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Recordofs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Recordofs>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type record length(1) of integer myro1
  type record length(4..8) of integer myro2
  type record length(5) of record length(5) of record length(5) of record length(5) of integer myro3
  type myro3 myro4 ({1}, {2})
  type myro1 myro5 (myro1, {1, 2})
  type myro1 myro6 (myro1, myro1, {1}, {1}, {2}, {2})
  type myro5 myro7 ({1})  // No error for erroneous parent type.
  type myro7 myro8 (myro2)

  const myro1 c_myro1 := {0, 1}
  const myro2 c_myro2 := {0, 1}
  const myro6 c_myro3 := {c_myro1[0]}

  template myro1 t_myro1 := {0, 1}
  template myro2 t_myro2 := {0, 1}
  template myro6 t_myro3 := {0}
  
  modulepar myro1 mp1 := {0, 1}
  modulepar myro2 mp2 := {0, 1}
  modulepar myro6 mp3 := {}
  
  function fro1() return myro1 { return {0, 1} }
  function fro2(in myro1 p1 := {0, 1}) { }
  
  control {
    var template myro1 vt_myro1 := {0, 1}
    var template myro2 vt_myro2 := {0, 1}
    var myro1 v_myro1 := {0, 1}
    var myro2 v_myro2 := {0, 1}
    if (valueof(vt_myro1) == valueof(vt_myro2)) { }
    if (v_myro1 == v_myro2) { }
    if (match(fro1(), t_myro2)) { }
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(\{ 1, 2 \}\) union length\(1\) is not subset of subtype length\(1\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: There must not be more than 1 elements in the list
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror: \{ 0, 1 \} is not a valid value for type `\@module1.myro1' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: \{ 0, 1 \} is not a valid value for type `\@module1.myro2' which has subtype length\(4..8\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: At least 4 elements must be present in the list
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(\{ <erroneous> \},\{ <erroneous> \}\) is not subset of subtype length\(5\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: record of value was expected
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: \{  \} is not a valid value for type `\@module1.myro1' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Type mismatch: `\@module1.myro1' and `\@module1.myro2' are not compatible: Incompatible record of/SEQUENCE OF subtypes
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Reference `myro2' must refer to a type which has the same root type as this type
<END_RESULT>
<RESULT COUNT 21>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Setofs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Setofs>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type set length(1) of integer myso1
  type set length(4..8) of integer myso2
  type set of integer myso3 (myso1, myso2)
  type myso1 myso4 (myso1, {1, 2})
  type myso1 myso5 (myso1, myso1, {1}, {1}, {2}, {2})
  type myso4 myso6 ({1})  // No error for erroneous parent type.
  type myso6 myso7 (myso2)

  template myso1 t_myso1 := {0, 1}
  template myso2 t_myso2 := {0, 1}
  template myso5 t_myso3 := {0}
  
  const myso1 c_myso1 := {0, 1}
  const myso2 c_myso2 := {0, 1}
  const myso5 c_myso3 := {c_myso1[0]}

  modulepar myso1 mp1 := {0, 1}
  modulepar myso2 mp2 := {0, 1}
  modulepar myso5 mp3 := {}
  
  function fso1() return myso1 { return {0, 1} }
  function fso2(in myso1 p1 := {0, 1}) { }
  
  control {
    var template myso1 vt_myso1 := {0, 1}
    var template myso2 vt_myso2 := {0, 1}
    var myso1 v_myso1 := {0, 1}
    var myso2 v_myso2 := {0, 1}
    if (valueof(vt_myso1) == valueof(vt_myso2)) { }
    if (v_myso1 == v_myso2) { }
    if (match(fso1(), t_myso2)) { }
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Reference `myso1' must refer to a type which has the same root type as this type
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Reference `myso2' must refer to a type which has the same root type as this type
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(\{ 1, 2 \}\) union length\(1\) is not subset of subtype length\(1\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: There must not be more than 1 elements in the list
<END_RESULT>
<RESULT COUNT 5>
(?is)\berror: \{ 0, 1 \} is not a valid value for type `\@module1.myso1' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: At least 4 elements must be present in the list
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: \{ 0, 1 \} is not a valid value for type `\@module1.myso2' which has subtype length\(4..8\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: \{  \} is not a valid value for type `\@module1.myso1' which has subtype length\(1\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Type mismatch: `\@module1.myso1' and `\@module1.myso2' are not compatible: Incompatible set of/SET OF subtypes
<END_RESULT>
<RESULT COUNT 20>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Arrays
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Arrays>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  // The length subtyping is not for `integer', it's an `integer[1]' array.
  type integer mya1[1] length(2)
  type mya1 mya2 (0, 1)
  type mya1 mya3 ({0, 1}, {2, 3})
  type mya3 mya4 (mya1, mya2, mya3)

  template mya1 t_mya1 := {2}
  template mya3 t_mya2 := {2, 3}

  const mya1 c_mya1 := {2}
  const mya3 c_mya2 := {c_mya1[0], 3}
  const mya1 c_mya3[1] := {c_mya1}  // Shouldn't be allowed.
  
  control {
    var template mya1 vt_mya1 := {2}
    var template mya3 vt_mya2 := {vt_mya1[0], 3}
    var template mya1 vt_mya3[1] := {vt_mya1}  // Shouldn't be allowed.
    var mya1 v_mya1 := {2}
    var mya3 v_mya2 := {2, 3}
    var mya1 v_mya3[1] := {v_mya1}  // Shouldn't be allowed.
    if (valueof(vt_mya1) == valueof(vt_mya2)) { }
    if (v_mya1 == v_mya2) { }
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: Length subtyping is not allowed for type `integer'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror: Subtype constraints are not applicable to type `integer\[1\]'
<END_RESULT>
<RESULT COUNT 2>
(?is)\berror: Too many elements in the array value: 1 was expected instead of 2
<END_RESULT>
<RESULT COUNT 8>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


*---------------------------------------------------------------------*
:h3.Adhoc:: Special float values
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Special float values>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  const float cf_pinf := infinity;
  const float cf_minf := -infinity;
  const float cf_nan  := not_a_number;

  type float MyFlt (-infinity..infinity);
  type float MyFlt2 (not_a_number);

  control {
    var MyFlt vf1;
    var MyFlt2 vf2;
    vf1 := not_a_number;
    vf2 := 1.0;
    vf2 := vf1;
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: NaN is not a valid value for type `float' which has subtype \(-INF..INF\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: 1.0e0 is not a valid value for type `float' which has subtype \(NaN\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: Subtype mismatch: subtype \(NaN\) has no common value with subtype \(-INF..INF\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


*---------------------------------------------------------------------*
:h3.Adhoc:: Exclusive ranges - integer type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Exclusive ranges - integer type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type integer MyInt1 (!-infinity..!10);
  type integer MyInt2 (!-10..!infinity);
  type integer MyInt3 (!1..!2);
  type integer MyInt4 (!1..!10,!10..!20);
  const MyInt4 c_myint4 := 10;
  type MyInt4 MyInt5 (2..19);
  type integer MyInt6 (MyInt4,10);
  const MyInt6 c_myint6a := 10;
  const MyInt6 c_myint6b := 20;
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: invalid lower boundary, -infinity cannot be excluded from an integer subtype range
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: invalid upper boundary, infinity cannot be excluded from an integer subtype range
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: lower boundary is bigger than upper boundary in integer subtype range
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: 10 is not a valid value for type `integer' which has subtype \(2..9,11..19\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: The subtype restriction is not a subset of the restriction on the parent type. Subtype \(2..19\) is not subset of subtype \(2..9,11..19\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: 20 is not a valid value for type `integer' which has subtype \(2..19\)
<END_RESULT>
<RESULT COUNT 6>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


*---------------------------------------------------------------------*
:h3.Adhoc:: Exclusive ranges - float type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Exclusive ranges - float type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type float MyFlt1 (!-infinity..!-infinity);
  type float MyFlt2 (!infinity..!infinity);
  type float MyFlt3 (not_a_number..!infinity);
  type float MyFlt4 (!-infinity..!infinity);
  const MyFlt4 c_myflt4a := -infinity;
  const MyFlt4 c_myflt4b := infinity;
  const MyFlt4 c_myflt4c := not_a_number;
  type float MyFlt5 (MyFlt4, -infinity, infinity, not_a_number);
  type float MyFlt6 (-infinity..!0.0,!0.0..infinity);
  const MyFlt6 c_myflt6 := 0.0;
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: !-infinity is not a valid upper boundary
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: !infinity is not a valid lower boundary
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: lower boundary cannot be not_a_number in float subtype range
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: -INF is not a valid value for type `float' which has subtype \(!-INF..!INF\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: INF is not a valid value for type `float' which has subtype \(!-INF..!INF\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: NaN is not a valid value for type `float' which has subtype \(!-INF..!INF\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\bwarning: The subtype of type `float' is a full set, it does not constrain the root type.
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: 0.0e0 is not a valid value for type `float' which has subtype \(-INF..!0.0e0,!0.0e0..INF\)
<END_RESULT>
<RESULT COUNT 7>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


*---------------------------------------------------------------------*
:h3.Adhoc:: Exclusive ranges - charstring type
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Exclusive ranges - charstring type>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  type charstring MyStr1 (!"a".."a");
  type charstring MyStr2 (!"a"..!"b");
  type charstring MyStr3 (!"a"..!"c",!"c"..!"z");
  const MyStr3 c_mystr3 := "c";
  type charstring MyStr4 ("c".."c",!"0".."9");
  type charstring MyStr5 (MyStr3, MyStr4);
  const MyStr5 c_mystr5a := "c";
  const MyStr5 c_mystr5b := "0";
}
<END_MODULE>
<RESULT COUNT 2>
(?is)\berror: lower boundary is bigger than upper boundary in charstring subtype range
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: "c" is not a valid value for type `charstring' which has subtype from\("b","d".."y"\)
<END_RESULT>
<RESULT COUNT 1>
(?is)\berror: "0" is not a valid value for type `charstring' which has subtype \(from\("b","d".."y"\) union from\("1".."9","c"\)\)
<END_RESULT>
<RESULT COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: invalid syntax - equality followed by negation
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - invalid syntax - equality followed by negation>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  function X() {
    var boolean x,y;
    if (x != not y) {}
  }
}
<END_MODULE>
<RESULT COUNT 1>
(?is)\berror: The operation `not' is not allowed to be the second operand of operation `!='
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: special float values
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - special float values>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
const float a := infinity;
const float b := not_a_number;
const float c := 0.0 / b;
control {
  var float d := rnd( a );
  var float e := rnd( b );
  timer t1 := a;
  timer t2 := b;
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: The operand of operation `rnd \(seed\)' cannot be INF, it must be a numeric value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: The operand of operation `rnd \(seed\)' cannot be NaN, it must be a numeric value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: A non-negative float value was expected as timer duration instead of `INF'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: A non-negative float value was expected as timer duration instead of `NaN'
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.Adhoc:: template restrictions (TR: HL77646)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - template restrictions (TR: HL77646)>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record of integer MyRecOfInt;
  template(value) integer t_MyInt := 1
  template(value) MyRecOfInt t_MyRecOfInt := {[2]:= t_MyInt }
  type record R
  {
    integer i,
    integer o optional,
    ROF rof
  }
  type record of C ROF;
  type union C
  {
    integer i,
    boolean b
  }
  control
  {
    var template(value) R tr1;
    var template R tr2 := { 1, omit, { {b:=true}, {i:=1}, {b:=(true,false)} } }
    tr1 := tr2;
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS>
(?im)warning: Inadequate restriction on the referenced template variable `tr2', this may cause a dynamic test case error at runtime
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Restriction `value' on template of type @Temp.R violated.
<END_RESULT>

<END_TC>
:exmp.


.*---------------------------------------------------------------------*
:h3.Adhoc:: template restrictions (TR: HL77646) 2
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - template restrictions (TR: HL77646) 2>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  type record R {}
  type record of R ROF;
  type record of R ROF2;
  type union C
  {
    integer i,
    ROF r
  }
  control
  {
    var template(value) C t1;
    var template(present) C t2 := { r := { [2] := {} }  }
    t1 := t2;
    var template(value) ROF2 t11;
    var template(present) ROF2 t21 := { {}, ({},{}) }
    t11 := t21;
  }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS>
(?im)warning: Inadequate restriction on the referenced template variable `.+', this may cause a dynamic test case error at runtime
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Restriction `value' on template of type @Temp.ROF2 violated.
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: constant parameter in decvalue function
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - constant parameter in decvalue function>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
type integer myint with {encode "RAW"}
type record R {
  myint i
} with {encode "XML"};

const bitstring c_bs0 := ''B;

control {
 var R v_r;
 var integer ret := decvalue(c_bs0, v_r);
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to 'constant' cannot be used as the first operand of the 'decvalue' operation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: extra checks for decvalue (HM59355)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - extra checks for decvalue (HM59355)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.ttcn>
module x {
type record MyEmptyRecord { } with { encode "XML" }
control {
  var bitstring s
  var integer i
  var template MyEmptyRecord t
  i := decvalue(s, MyEmptyRecord)
  // Original error: expected unqualified-id before '.' token
  i := decvalue(s, t)
  // Original error: 'class x::MyEmptyRecord_template' has no member named 'decode'
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to 'type' cannot be used.
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to 'template variable' cannot be used.
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: SIGSEGV on missing modules (HM62166)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - SIGSEGV on missing modules (HM62166)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN x x.asn>
Example DEFINITIONS ::= BEGIN
IMPORTS
X FROM Y
MyType FROM Z {itu-t(0)};
EXTENSION ::= CLASS {&id Code}
myExtension EXTENSION ::= {IDENTIFIED BY global : {itu-t(0)}}
END
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: There is no module with identifier \`Y\'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: There is no module with identifier \`Z\'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: There is no assignment or imported symbol with name \`Code\' in module \`Example\'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Cannot recognize fieldspec
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Unexpected \`\<upperidentifier\>\'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Superfluous part detected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Check the syntax of objectclass \(consider using debug messages\)
<END_RESULT>
<RESULT IF_PASS COUNT 7>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - Octetstring TR (TR:?)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - Octetstring TR (TR:?)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
  const octetstring c_PcapMagic_LittleEndian := 'd4c3b2a1'O;
  const octetstring c_PcapMagic_BigEndian    := 'a1b2c3d4'O;
  type octetstring PcapMagic1 ('d4c3b2a1'O, 'a1b2c3d4'O);
  type octetstring PcapMagic2 (c_PcapMagic_BigEndian, c_PcapMagic_LittleEndian);

  control {}
}
<END_MODULE>
<RESULT COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - String indexing (TR:?)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - String indexing (TR:?)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
type octetstring OCT1 length(1);
type octetstring OCT2 length(2);

const OCT2 long_octet := '0102'O;
const OCT1 short_octet := long_octet[0];

type port myport message { inout OCT1; } with { extension "internal" };
type port myport2 message { inout OCT2; } with { extension "internal" };
type component mycomp {
  port myport p;
  port myport2 p2;
};

function myfunc() runs on mycomp
{
  var OCT1 o1;
  var OCT2 o2;
  p.receive(OCT1:?) -> value o2[0];
  p2.receive(OCT2:?) -> value o1;
  p2.receive(OCT2:?) -> value o2[0];
  
  o1 := o2;
  o2 := o1;

  o1 := o2[1];
  o2[0] := o1;

  o2 := o2[2];
  o2[0] := o2;
  
  o2 := myfunc12(o1,o2);

  o2[0] := myfunc12(o1,o2);

  o2[0] := o1[0];

  o1[0] := myfunc12(o1,o2);

  o1 := myfunc12(o2,o1);
  o1 := myfunc12in(o2,o1);
  o1 := myfunc12out(o2,o1);
  o2 := myfunc12(o1,o2);
}

function myfunc12(inout OCT1 p_o1, inout OCT2 p_o2) return OCT1
{
  return p_o2[0];
}

function myfunc12in(in OCT1 p_o1, in OCT2 p_o2) return OCT1
{
  return p_o2[0];
}

function myfunc12out(out OCT1 p_o1, out OCT2 p_o2) return OCT1
{
  return p_o2[0];
}

function myfunc12err(inout OCT1 p_o1, inout OCT2 p_o2) return OCT2
{
  return p_o2[0];
}

control {
  var OCT2 o2 := 'BABE'O;
  var integer i := oct2int(o2[0]); // HQ38022
}
}
<END_MODULE>
<RESULT IF_PASS LTRT COUNT 2>
(?im)error: Subtype mismatch: subtype length\(2\) has no common value with a string element
<END_RESULT>
RESULT IF_PASS FTRT COUNT 3>
(?im)error: Subtype mismatch: subtype length\(2\) has no common value with a string element
<END_RESULT>
<RESULT IF_PASS COUNT LTRT 6>
(?im)error: Subtype mismatch: subtype length\(2\) has no common value with subtype length\(1\)
<END_RESULT>
<RESULT IF_PASS COUNT FTRT 7>
(?im)error: Subtype mismatch: subtype length\(2\) has no common value with subtype length\(1\)
<END_RESULT>
<RESULT IF_PASS COUNT 4>
(?im)error: Subtype mismatch: subtype length\(1\) has no common value with subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Subtype mismatch: string element has no common value with subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to a string element of type `octetstring' cannot be used in this context
<END_RESULT>
<RESULT COUNT LTRT 15>
(?is)\berror:
<END_RESULT>
<RESULT COUNT FTRT 17>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Subtyping - function references
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Subtyping - function references>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
type octetstring OCT1 length(1);
type octetstring OCT2 length(2);

const OCT2 long_octet := '0102'O;
const OCT1 short_octet := long_octet[0];

type function myfunctype(inout OCT2 p_o1, inout OCT1 p_o2) return OCT2

function myfunc(inout OCT1 p_o1, inout OCT2 p_o2) return OCT1
{
  return p_o2[0];
}

control {
  var myfunctype f := refers(myfunc);
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: Subtype mismatch: subtype length\(2\) has no common value with subtype length\(1\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Subtype mismatch: subtype length\(1\) has no common value with subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Return type subtype mismatch: subtype length\(2\) has no common value with subtype length\(1\)
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Values - Valueof TR (TR:HM93087)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Values - Valueof TR (TR:HM93087)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
type record rec {
integer f
}
control {
if (valueof(rec:{1}) == {1}) { }
} 
}
<END_MODULE>
<RESULT COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Recursion - recursion TR (TR:HM93170)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Recursion - recursion TR (TR:HM93170)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1
{
type record recT {
integer f1,
float f2,
charstring f3,
integer f4,
integer f5
}

template recT temp1:= { f1:= temp2.f1, f2:= 1.1, f3:= "ERIXON", f4:= 1, f5:= temp1.f1 };
template recT temp2:= { f1:= temp2.f4, f2:= 1.1, f3:= "ERIXON", f4:= temp1.f5, f5:= 2 }; 

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.temp2.f4' -> `\@module1.temp1.f5' -> `\@module1.temp1.f1' -> `\@module1.temp2.f1' -> `\@module1.temp2.f4'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.temp1.f1' -> `\@module1.temp2.f1' -> `\@module1.temp2.f4' -> `\@module1.temp1.f5' -> `\@module1.temp1.f1'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.temp1.f5' -> `\@module1.temp1.f1' -> `\@module1.temp2.f1' -> `\@module1.temp2.f4' -> `\@module1.temp1.f5'
<END_RESULT>
<RESULT COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

*---------------------------------------------------------------------*
:h3.Adhoc:: Recursion - union  TR (TR:HM93077)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Recursion - union  TR (TR:HM93077)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN module1 module1.ttcn>
module module1 {
type union ValidUnion0 {
	integer i
}

type union ValidUnion1 {
	ValidUnion1 u1,
	integer i,
	ValidUnion0 u2
}

type union InvalidUnion0 {	
	InvalidUnion0 u1
}

type union InvalidUnion1 { 
	InvalidUnion2 u1
}

type union InvalidUnion2 {
	InvalidUnion1 u1
}

type union InvalidUnion3 {
	InvalidUnion3 u1,
	InvalidUnion3 u2,
	InvalidUnion3 u3
}

type union InvalidUnion4 {
	InvalidRecord0 r1
}

type record InvalidRecord0 {
	InvalidRecord0 r1
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidUnion0' -> `\@module1.InvalidUnion0.u1' -> `\@module1.InvalidUnion0'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidUnion2' -> `\@module1.InvalidUnion2.u1' -> `@\module1.InvalidUnion1' -> `\@module1.InvalidUnion1.u1' -> `\@module1.InvalidUnion2'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidUnion3' -> `\@module1.InvalidUnion3.u1' -> `\@module1.InvalidUnion3'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidUnion3' -> `\@module1.InvalidUnion3.u2' -> `\@module1.InvalidUnion3'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidUnion3' -> `\@module1.InvalidUnion3.u3' -> `\@module1.InvalidUnion3'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: While checking embedded recursions: Circular reference: `\@module1.InvalidRecord0' -> `\@module1.InvalidRecord0.r1' -> `\@module1.InvalidRecord0'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)\bnotify: Errors found in the input module. Code will not be generated.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Negative testing semantic check error messages
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Negative testing semantic check error messages>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE ASN Virag Virag.asn>
Virag DEFINITIONS ::=
BEGIN
IMPORTS ;
MySeqOf ::= SEQUENCE OF INTEGER
MySeq ::= SEQUENCE {
  i INTEGER,
  b BOOLEAN 
}
MyUnion ::= CHOICE {
  i INTEGER,
  b BOOLEAN,
  s MySeq
}
MyCharstring1 ::= VisibleString
MyCharstring2 ::= IA5String
END
<END_MODULE>

<MODULE TTCN virag virag.ttcn>
module virag
{
import from Virag all;
group text_grp {
type record MYREC
{
  integer i,
  boolean b,
  MYREC r optional
}
type record of integer MYROFI;
type union MYU {
  integer i,
  boolean b,
  MYREC r
}
}
with { encode "TEXT" variant "" }
type record MYREC2 { integer i }
const MYREC c_myrec1 := {i:=1}
with {
  erroneous "value := 2"
  erroneous (x) "value := 2"
  erroneous (i, r.i, r.r.i) "value := 2"
}
const MYREC c_myrec2 := {i:=1} with { erroneous (b) "after := omit" }
const MYREC c_myrec3 := {i:=1} with { erroneous (b) "before := omit" }
const MYREC c_myrec4 := {i:=1} with { erroneous (b) "value := omit all" }
const MYREC c_myrec5 := {i:=1} with { erroneous (b) "value := 123 all" }
const MYREC c_myrec6 := {i:=1} with { erroneous (b) "value := {1,2,3}" }
const MYREC c_myrec7 := {i:=1} with { erroneous (b) "value := nonexi" }
const MYREC c_myrec8 := {i:=1} with { erroneous (b) "value(raw) := 123" }
const MYREC c_myrec9 := {i:=1} with { erroneous (b) "value := MYROFI:'A'H" }
const MYREC c_myrec10 := {i:=1} with { erroneous (b) "value := MYROFI:{1,2,*}" }
const MYREC c_myrec11 := {i:=1} with {
  erroneous (b) "after := omit all"
  erroneous (r) "value := 0"
}
const MYREC c_myrec12 := {i:=1} with {
  erroneous (r) "before := omit all"
  erroneous (b) "value := 0"
}
const MYU c_myu13 := {i:=1} with { erroneous (b) "after := omit all" erroneous (r) "value:=12" }
const MYU c_myu14 := {i:=1} with { erroneous (b) "value := omit" }
const MYREC c_myrec15 := {i:=1} with {
  erroneous (r) "after := omit all"
  erroneous (i) "before := omit all"
}
const MYREC c_myrec16 := {i:=1} with {
  erroneous (b,b) "value := 1"
  erroneous (b,b) "after := 1"
  erroneous (b,b) "before := 1"
}
const MYREC c_myrec17 := {i:=1} with {
  erroneous (r.b) "value := 1"
  erroneous (r) "value := 1"
}
const MYREC c_myrec18 := {i:=1} with {
  erroneous (b) "before := omit all"
  erroneous (r) "before := omit all"
}
const MYREC c_myrec19 := {i:=1} with {
  erroneous (b) "value := 1"
  erroneous (r) "before := omit all"
}
const MYREC c_myrec20 := {i:=1} with {
  erroneous (b) "after := omit all"
  erroneous (i) "after := omit all"
}
const MYREC c_myrec21 := {i:=1} with {
  erroneous (r) "value := 1"
  erroneous (b) "after := omit all"
}
const MYREC c_myrec22 := {i:=1} with {
  erroneous (r) "value := omit"
  erroneous (r.i) "value := 1"
}
const MYREC2 c_myrec23 := {i:=1} with { erroneous (i) "value(raw) := ""proba""" }
const MYREC2 c_myrec24 := {i:=1} with { erroneous (i) "value(raw) := universal charstring:""proba""" }
const MYREC2 c_myrec25 := {i:=1} with { erroneous (i) "value(raw) := '1010'B" }
const MYREC c_myrec26 := {i:=1} with { erroneous (b) "value := MyCharstring1:""haha""" }
const MYREC c_myrec27 := {i:=1} with { erroneous (b) "value := MYREC2:{i:=1}" }
function fv() {} with{erroneous ""}
control {} with{erroneous ""}
} with{erroneous ""}
<END_MODULE>

<RESULT FTRT COUNT 1>
(?im)\berror: At least one qualifier must be specified for the `erroneous' attribute
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Reference to non-existent field `x' in type `@virag.MYREC'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Keyword `all' is expected after `omit' when omitting all fields after the specified field
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Keyword `all' is expected after `omit' when omitting all fields before the specified field
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Unexpected `all' keyword after `omit' when omitting one field
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Unexpected `all' keyword after the in-line template
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Cannot determine the type of the in-line template
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: There is no local or imported definition with name `nonexi'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: An in-line template of type `integer' cannot be used as a `raw' erroneous value
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: record of value was expected
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: A specific value without matching symbols was expected
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Field `r' cannot be referenced because all fields after field `b' have been omitted
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Field `b' cannot be referenced because all fields before field `r' have been omitted
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Indicator `after' cannot be used with reference `b' which points to a field of a union type
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: There is nothing to omit after the last field \(r\) of a record/set type
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Reference to field `r' with indicator `value' would invalidate previously specified erroneous data
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: There is nothing to omit before the first field \(i\)
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Duplicate reference to field `b' with indicator `value'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Duplicate reference to field `b' with indicator `after'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Duplicate reference to field `b' with indicator `before'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Duplicate rule for omitting all fields before the specified field. Used on field `r' but previously already used on field `b'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Omitting fields before field `r' would invalidate previously specified erroneous data
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Duplicate rule for omitting all fields after the specified field. Used on field `i' but previously already used on field `b'
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Omitting fields after field `b' would invalidate previously specified erroneous data
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Field `r.i' is embedded into a field which was previously overwritten or omitted
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: A `raw' charstring value was used for erroneous type `@virag.MYREC2' which has no TEXT, XER or JSON encodings.
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: A `raw' universal charstring value was used for erroneous type `@virag.MYREC2' which has no XER or JSON encodings.
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: A `raw' bitstring value was used for erroneous type `@virag.MYREC2' which has no RAW encoding.
<END_RESULT>

<RESULT FTRT COUNT 1>
(?im)\berror: Type `@virag.MYREC2' and type `@virag.MYREC' have no common encoding
<END_RESULT>

<RESULT COUNT 3>
(?im)\berror: The `erroneous' attribute can be used only on template and constant definitions
<END_RESULT>

<RESULT FTRT COUNT 32>
(?is)\berror:
<END_RESULT>


<RESULT LTRT COUNT 27>
(?im)\berror: `erroneous' attributes can be used only with the Function Test Runtime
<END_RESULT>

<RESULT LTRT COUNT 27>
(?im)\bnote: If you need negative testing use the -R flag when generating the makefile
<END_RESULT>

<RESULT LTRT COUNT 30>
(?is)\berror:
<END_RESULT>
<RESULT LTRT COUNT 27>
(?is)\bnote:
<END_RESULT>

<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Syntax errors in logfiles (TR HN52781)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Syntax errors in logfiles (TR HN52781)>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
control { }
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
very_unknown_module_parameter := "should be logged normally"
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)Error while setting parameter field 'very_unknown_module_parameter' to '"should be logged normally"': Module parameter cannot be set, because module `very_unknown_module_parameter' does not exist, and no parameter with name `very_unknown_module_parameter' exists in any module.
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: testcase.stop
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - testcase.stop>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
testcase TC() runs on MyComp {
  testcase.stop("Is it a Bird?! Is it a Plane?! No!! It's a dynamic test case error!!!");
}
control
{
  execute(TC());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: testcase.stop
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Is it a Bird\?! Is it a Plane\?! No!! It's a dynamic test case error!!!
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Indexing of string template variables (CR_TR00018474)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Indexing of string template variables (CR_TR00018474)>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
template charstring tcs := "doggee"
template bitstring tbs := '11001100'B
template hexstring ths := 'AABBCCDDEEFF'H
template octetstring tos := 'AABBCCDD'O
template universal charstring tus := char(0, 0, 0, 75) & char(0, 0, 0, 65)

function fsi_charstrings(in template charstring vtc) {}
function fsi_bitstrings(in template bitstring vtb) {}
function fsi_hexstrings(in template hexstring vth) {}
function fsi_octetstrings(in template octetstring vto) {}
function fsi_universal_charstrings(in template universal charstring vtu) {}

testcase TC_charstrings() runs on MyComp {
  var template charstring vtc := "fisherman"
  vtc[0] := vtc[1]  // Compile error, string template variables cannot be indexed on the right hand side.
  vtc[0] := tcs[1]  // Compile error, string templates cannot be indexed at all.
  tcs[0] := "D"  // Compile error, string templates cannot be indexed at all.
  vtc[0] := *  // Compile error, ANY_OR_OMIT can never be assigned to an element of a string template variable.
  vtc[0] := ?  // Compile error, ANY_VALUE can never be assigned to an element of a string template variable, it would "become" a pattern otherwise.
  fsi_charstrings(vtc[0])  // Compile error, string template variables cannot be indexed on the right hand side.
}

testcase TC_bitstrings() runs on MyComp {
  var template bitstring vtb := '0011110000'B
  vtb[0] := vtb[1]
  vtb[0] := tbs[1]
  tbs[0] := '1'B
  vtb[0] := *
  vtb[0] := ?
  vtb[0] := '*'B
  vtb[1] := '?'B
  fsi_bitstrings(vtb[0])
}

testcase TC_hexstrings() runs on MyComp {
  var template hexstring vth := 'AABBCCDDEE'H
  vth[0] := vth[1]
  vth[0] := ths[1]
  ths[0] := 'B'H
  vth[0] := *
  vth[0] := ?
  vth[0] := '*'H
  vth[1] := '?'H
  fsi_hexstrings(vth[0])
}

testcase TC_octetstrings() runs on MyComp {
  var template octetstring vto := 'ABBAABBA'O
  vto[0] := vto[1]
  vto[0] := tos[1]
  tos[0] := 'BB'O
  vto[0] := *
  vto[0] := ?
  vto[0] := '*'O
  vto[1] := '?'O
  fsi_octetstrings(vto[0])
}

testcase TC_universal_charstrings() runs on MyComp {
  var template universal charstring vtu := "fisherman"
  vtu[0] := vtu[1]
  vtu[0] := tus[1]
  tus[0] := "F"
  vtu[0] := *
  vtu[0] := ?
  fsi_universal_charstrings(vtu[0])
}

}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to template variable `vtc' can not be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to a variable or template variable was expected instead of template `@Temp.tcs'
<END_RESULT>
<RESULT IF_PASS COUNT 16>
(?im)error: A template body with matching symbols cannot be assigned to an element of a template variable
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to template variable `vtb' can not be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Invalid array element reference: type `bitstring' cannot be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to a variable or template variable was expected instead of template `@Temp.tbs'
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to template variable `vth' can not be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to template variable `vto' can not be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?im)error: Reference to template variable `vtu' can not be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Invalid array element reference: type `hexstring' cannot be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Invalid array element reference: type `octetstring' cannot be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Invalid array element reference: type `universal charstring' cannot be indexed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to a variable or template variable was expected instead of template `@Temp.ths'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to a variable or template variable was expected instead of template `@Temp.tos'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: Reference to a variable or template variable was expected instead of template `@Temp.tus'
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: Indexing of string template variables DTEs (CR_TR00018474)
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Indexing of string template variables DTEs (CR_TR00018474)>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}

testcase TC_bitstrings() runs on MyComp {
  var template bitstring vtb := '0*?1'B  // It's a pattern, cannot be indexed, runtime error.
  vtb[0] := '1'B
  setverdict(pass)
}

testcase TC_hexstrings() runs on MyComp {
  var template hexstring vth := 'AABB?CC'H  // It's a pattern, cannot be indexed, runtime error.
  vth[0] := 'B'H
  setverdict(pass)
}

testcase TC_octetstrings() runs on MyComp {
  var template octetstring vto := 'AABB??*'O  // It's a pattern, cannot be indexed, runtime error.
  vto[0] := 'BB'O
  setverdict(pass)
}

control
{
  execute(TC_bitstrings());
  execute(TC_hexstrings());
  execute(TC_octetstrings());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing a bitstring element of a non-specific bitstring template.
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing a hexstring element of a non-specific hexstring template.
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Dynamic test case error: Accessing an octetstring element of a non-specific octetstring template.
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - TR HO69261 Incorrect code generated for create with optional parameters
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - TR HO69261 Incorrect code generated for create with optional parameters>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type record Rec {
  charstring cs optional
}
type component CT {}

testcase tc() runs on CT
{
  var Rec r := {cs := "12.0.0.1"};
  var CT c1 := CT.create(r.cs);
  var CT c2 := CT.create(-, r.cs);
  var CT c3 := CT.create(r.cs, r.cs);
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - sizeof()/lengthof() DTEs
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - sizeof()/lengthof() DTEs>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component CT {}
type record of integer  ROI;
testcase tc_sizeof_lengthof_standard1() runs on CT {
  var template ROI tr_roI1 := { 1, permutation(2, 3), ? } 
  if(lengthof(tr_roI1)==4) { setverdict(pass)}else { setverdict(fail) };
  template ROI tr_roI2 := {1, *, (2, 3) } 
  if(lengthof(tr_roI2)==3){ setverdict(pass)}else { setverdict(fail) }; //DTE!!!!
}

testcase tc_sizeof_lengthof_standard2() runs on CT {
  if(lengthof('1*F'H) ==3){ setverdict(pass)}else { setverdict(fail) }; //DTE???
}

control {
  execute(tc_sizeof_lengthof_standard1())
  execute(tc_sizeof_lengthof_standard2())
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror: Performing lengthof() operation on a template of type \@Temp.ROI with no exact length.
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror: Performing lengthof() operation on a hexstring template with no exact length.
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - sizeof()/lengthof() compilation errors
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - Adhoc - sizeof()/lengthof() compilation errors>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type record of integer  ROI;
type component CT {}
testcase tc_sizeof_lengthof_standard1() runs on CT {
  template ROI tr_roI4 := { 1, 2, 3, * } length(1..2) ; //compilation error
  if(lengthof(tr_roI4)==3) { setverdict(fail) };
}
}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror: There are more (at least 3) elements in the template than it is allowed by the length restriction (at most 2)
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - Additional RAW attribute checks for LENGTHTO
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - Additional RAW attribute checks for LENGTHTO>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type union myu_ok { integer a, integer b }
type union myu_nok { integer a, charstring b }
type record of integer mylist
type record myr1 {
  boolean f1,
  integer f2,
  charstring f3
} with {
  variant (f2) "LENGTHTO (f3)"
}
type record myr2 {
  integer f1,
  myu_ok f2,
  charstring f3
} with {
  variant (f2) "LENGTHTO (f3)"
}
type record myr3 {
  integer f1,
  myu_nok f2,
  charstring f3
} with {
  variant (f2) "LENGTHTO (f3)"
}
type record myr4 {
  integer f1,
  mylist f2,
  charstring f3
} with {
  variant (f2) "LENGTHTO (f3)"
}
type record myr5 {
  charstring f1,
  charstring f2
} with {
  variant (f1) "LENGTHTO (f2)"
}
} with { encode "RAW" }
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror: The union type LENGTHTO field must contain only integer fields
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: The LENGTHTO field must be an integer or union type instead of `\@Temp.mylist'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: The LENGTHTO field must be an integer or union type instead of `charstring'
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - HQ43433 decode parameter check 
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - HQ43433 decode parameter check>

<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp
{

  // type definition incl. RAW attribute
  type set S 
  {
    integer i
  } with {
    variant (i) "BYTEORDER(last)";
  }

  // wrapper functions for encoding/decoding
  function enc(S s) return bitstring {
    var bitstring bs;
    bs := encvalue(s);
    return bs;
}

// BUG: TITAN SA does NOT report error when @m.dec.bs is not declared inout
// Instead, the compiler generates erronous C++ code which brakes C++ 
// compilation at function invocation (line marked below)
function dec(/*inout*/ bitstring bs) return S {
  var S s;
  var integer i;
  // decvalue 1st par should be inout by standard?
  i := decvalue(bs, s);
  return s;
}

function dec2(in bitstring bs) return S {
  var S s;
  var integer i;
  // decvalue 1st par should be inout by standard?
  i := decvalue(bs, s);
  return s;
}

function dec3(out bitstring bs) return S {
  var S s;
  var integer i;
  var bitstring vl_bs:=bs;
  // decvalue 1st par should be inout by standard?
  i := decvalue(bs, s);
  return s;
}

// inout
function dec_inout(inout bitstring bs) return S {
  var S s;
  var integer i;
  // decvalue 1st par should be inout by standard?
  i := decvalue(bs, s);
  return s;
}

type component MyComp {}

testcase tc_default() runs on MyComp {
  var S s := { i := 2 };
  var S s_mod;
  var bitstring bs;
  log("original:",s);
  bs := enc(s);
  log("encoded:",bs);
  s_mod := dec(bs);
  log("decoded:",s_mod);
  if(match(s,s_mod)) {setverdict(pass);} else {setverdict(fail)}
  bs[1] := '1'B;
  log(bs);
}
testcase tc_in() runs on MyComp {
  var S s := { i := 2 };
  var S s_mod;
  var bitstring bs;
  log("original:",s);
  bs := enc(s);
  log("encoded:",bs);
  s_mod := dec2(bs);
  log("decoded:",s_mod);
  if(match(s,s_mod)) {setverdict(pass);} else {setverdict(fail)}
  
}
/* debate: out fv can use out param!! TR???
testcase tc_out() runs on MyComp {
  var S s := { i := 2 };
  var S s_mod;
  var bitstring bs;
  log("original:",s);
  bs := enc(s);
  log("encoded:",bs);
  s_mod := dec3(bs);
  log("decoded:",s_mod);
  if(match(s,s_mod)) {setverdict(pass);} else {setverdict(fail)}
}
*/

testcase tc_inout() runs on MyComp {
  var S s := { i := 2 };
  var S s_mod;
  var bitstring bs;
  log("original:",s);
  bs := enc(s);
  log("encoded:",bs);
  s_mod := dec_inout(bs);
  log("decoded:",s_mod);
  if(match(s,s_mod)) {setverdict(pass);} else {setverdict(fail)}
}


//======Another example=====
type integer MyType

const MyType c_MyType := 42;
const bitstring c_encoded := '00110011'B;

function f_decvalue_inpar( bitstring p_bit) {
  var MyType v_MyType;
  var bitstring vl_original:=p_bit;
  log( "Original input:",p_bit);
  log ("errCode: ",decvalue (p_bit,v_MyType),"  ", vl_original, " is decodedTo: ",v_MyType, " remained:",
p_bit)
  if(v_MyType==51 and p_bit==''B) { setverdict(pass)} else {setverdict(fail)}
}


function f_decvalue_inoutpar( inout bitstring p_bit) {
  var MyType v_MyType;
  var bitstring vl_original:=p_bit;
  log( "Original input:",p_bit);
  log ("errCode: ",decvalue (p_bit,v_MyType),"  ", vl_original, " is decodedTo: ",v_MyType, " remained:",
p_bit)
  if(v_MyType==51 and p_bit==''B) { setverdict(pass)} else {setverdict(fail)} 
}

testcase tc_2() runs on MyComp {
  var bitstring v_bit := c_encoded;
  f_decvalue_inoutpar(v_bit);
  f_decvalue_inpar(c_encoded);   
}

control 
{
  execute(tc_default());
  execute(tc_in());
  //execute(tc_out());
  execute(tc_inout());
  execute(tc_2());
}

} with {
  encode "RAW"
}


<END_MODULE>

<MODULE CFG Temp Temp.cfg>

[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>

<RESULT>
Overall verdict: pass
<END_RESULT>


<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - @try @catch blocks no errors
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - @try @catch blocks no errors>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
function fv1() {
  @try {}
  @catch(e) {}
}
function fv2() return integer {
  @try {
    log(1);
    return 1;
  }
  @catch(e) {
    @try {
      log(e);
      return 2;
    }
    @catch(e2) {
      log(e2);
      return 3;
    }
  }
}
testcase tc() runs on MyComp {
  @try {
    @try {}
    @catch(e) {}
  }
  @catch(e) {}
  @try {}
  @catch(e) {}
}
control {
  @try {}
  @catch(e) {}
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - @try @catch blocks semantic errors
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - @try @catch blocks semantic errors>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
function fv1() {
  var integer e;
  @try {}
  @catch(e) {}
}
function fv2() return integer {
  @try {
    log(1);
    return 1;
  }
  log(0);
  @catch(e) {
    @try {
      log(2);
      return 2;
    }
    @catch(e) {
      log(3);
      return 3;
    }
  }
}
testcase tc() runs on MyComp {
  @catch(e) {}
  @try {
    @try {}
  }
  @catch(e) {
    var integer i := e;
  }
}
control {
  @try {}
  @catch(dte_str) {
    const charstring dte_str := "";
  }
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?is)\berror: Definition with identifier `e' is not unique in the scope hierarchy
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror: `try' statement block must be followed by a `catch' block
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror: `catch' statement block must be preceded by a `try' block
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: The function has return type, but control might leave it without reaching a return statement
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: Duplicate definition with identifier `dte_str'
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: Type mismatch: a value of type `integer' was expected instead of `charstring'
<END_RESULT>
<RESULT IF_PASS COUNT 9>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: @try @catch blocks catching DTEs
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - @try @catch blocks catching DTEs>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
function safe_str2int(in charstring int_str, in integer defval) return integer {
  @try {
    return str2int(int_str);
  }
  @catch(err) {
    return defval;
  }
}
testcase TC1() runs on MyComp {
  if (safe_str2int("bread", -1)==-1) { setverdict(pass); }
  else { setverdict(fail); }
}
testcase TC2() runs on MyComp {
  var integer myEvilUnboundVariable;
  @try {
    myEvilUnboundVariable := myEvilUnboundVariable + 1;
    setverdict(fail);
  }
  @catch(e) {
    setverdict(pass);
  }
}
testcase TC3() runs on MyComp {
  @try {
    var integer i := 0;
    i := 10 / i;
    setverdict(fail);
  }
  @catch(e) {
    if (match(e, pattern "*division by zero*")) { setverdict(pass); }
    else { setverdict(fail); }
  }
}
control
{
  execute(TC1());
  execute(TC2());
  execute(TC3());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)Dynamic test case error:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Overall verdict: pass
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: @lazy parameters - no errors
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - @lazy parameters - no errors>
<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp
{
type component MyComp {}
const charstring c := "c";
testcase TC() runs on MyComp {
  var charstring a := "a";
  var charstring b := "b";
  var integer i1 := 100;
  var integer i2 := 20;
  var integer i3 := 3;
  MyFunc2(a&b&c&log2str(i1+i2+i3));
  setverdict(pass);
}
function MyFunc(in @lazy charstring str) {
  log(str);
  str := "huhuhu";
  log(str&str);
}
function MyFunc2(in @lazy charstring sz) {
  MyFunc(sz);
}
function MyFn1(in @lazy charstring str) return charstring {
  return str;
}
function MyFn2(in @lazy charstring s) return charstring {
  return MyFn2(s&MyFn1(s));
}
function MyFuncNormalEval(in charstring str, boolean b) {
  if (b) {
    var charstring s := str;
    if (s=="") { log(s); }
  }
}
function MyFuncLazyEval(in @lazy charstring str, boolean b) {
  if (b) {
    var charstring s := str;
    if (s=="") { log(s); }
  }
}
function Fdefaultpar( @lazy integer pi := 123 ) { log(pi); }
function FuncTemplate(in template @lazy charstring tp) {
  tp := "huhu";
  log(tp);
}
function FuncTempl(in template @lazy charstring tp) {
  tp := ?;
  FuncTemplate(tp);
}
type record REC {
  REC rec optional,
  integer i
}
template REC trec(template @lazy integer pi) := {
  rec := *,
  i := pi
}
function usingRECfield(@lazy integer pi) {
  log(pi);
}
type record of integer RECOFINT;
type record RECINT {
  RECOFINT ints optional,
  RECINT next optional
}
function usingRECINTfield(@lazy integer pi) {
  var integer ii := pi + 100;
  log(ii);
}
control {
  var template REC vrec := trec(?);
  var REC r := { rec:={ rec:={ rec:=omit, i:=3 }, i:=2 }, i:=1 }
  usingRECfield(r.rec.rec.i);
  var integer idx1 := 2;
  var integer idx2 := 4;
  var RECINT vrecint := { ints:=omit, next:={ ints:={1,2,3,4,5}, next:=omit} }
  usingRECINTfield(vrecint.next.ints[idx1+idx2-3]);
  FuncTemplate(?);
  FuncTempl(*);
  Fdefaultpar();
  execute(TC());
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)error
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: @lazy parameters - no runtime error
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - @lazy parameters - no runtime error>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp {}
function DTEfunc(in charstring s) return charstring {
  testcase.stop;
  return s;
}
function LazyFunc(in boolean b, in @lazy charstring s) return charstring {
  if (b) {
    return "lazy";
  } else {
    return s;
  }
}
testcase LazyTC() runs on MyComp {
  log(LazyFunc(true, DTEfunc("x")));
  setverdict(pass);
}
control {
  execute(LazyTC());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)Dynamic test case error:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Overall verdict: pass
<END_RESULT>
<END_TC>
:exmp.

.*--------------------------------------------------------------------------*
:h3.Adhoc - @lazy parameters - semantic errors
.*--------------------------------------------------------------------------*
:xmp tab=0.

<TC - @lazy parameters - semantic errors>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type function FT(in charstring str);
function FTinst(in @lazy charstring str) {}
type function FT2(in @lazy charstring str);
control {
   var FT ft1 := refers(FTinst);
   ft1.apply("hehe");
}
}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?is)\berror: Formal parameter `str' cannot be \@lazy, not supported in this case.
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror: Parameter evaluation type \(normal, \@lazy or \@fuzzy\) mismatch
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: @lazy parameters - correct lazy evaluation
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - @lazy parameters - correct lazy evaluation>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component MyComp2 {
  var integer ci := 0;
}
function FN2() runs on MyComp2 return integer {
  if (ci==0) { testcase.stop("ci==0 error!"); }
  return ci;
}
function Lazy2(in @lazy integer pi) runs on MyComp2 {
  ci := 11;
  var integer vi := pi; // evaluated: 3*11 = 33
  if (vi!=33) { setverdict(fail); }
  ci := 0;
  vi := pi; // not evaled -> 33
  if (vi!=33) { setverdict(fail); }
}
testcase TC2() runs on MyComp2 {
  Lazy2(3*FN2());
  setverdict(pass);
}
control {
  execute(TC2());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)Dynamic test case error:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Overall verdict: pass
<END_RESULT>
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h3.Adhoc:: modulepar invalid simple type: port
.*---------------------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::modulepar invalid type - port>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  modulepar comp_CT tsp_Comp;
  modulepar port_PT tsp_Port;
  modulepar default_DT  tsp_Def;
  type component comp_CT {
	var integer v_int := 0;
  }
  type port port_PT message {
	inout charstring
  }
  type default default_DT;
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT><END_TC>
:exmp.

.*-----------------------------------------------------------*
:h3.Adhoc:: modulepar invalid type: circular type definition
.*-----------------------------------------------------------*
:xmp tab=0.
<TC - Adhoc::modulepar invalid type - circular type definition>
<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
  modulepar invalidRec tsp_Rec;
  type record invalidRec {
    integer varI,
    invalidSet varSet,
    charstring varStr
  }
  type set invalidSet {
    invalidRec varRec,
    comp_CT varCT,
    charstring varStr
  }
  type component comp_CT {
	var integer v_int := 0;
  }
}
<END_MODULE>
<RESULT IF_FAIL COUNT 1>
(?im)\bcircular\b.+?\breference\b
<END_RESULT>
<RESULT IF_FAIL COUNT 1>
(?is)\berror:
<END_RESULT>
<RESULT IF_FAIL POSITIVE>
(?im)\bnotify\b.+?\bcode\b.+?\bnot\b.+?\bgenerated\b
<END_RESULT><END_TC>
:exmp.

.*-----------------------------------------------------------*
:h3.Adhoc:: record of [-] in type reference
.*-----------------------------------------------------------*
:xmp tab=0.
<TC - record of [-] in type reference>
<EXECUTE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type record GetResponseX { 
  record of record {
    charstring pcB,
    charstring pcB_1
  } pcB_list
}
type record MyRecord {
  GetResponseX.pcB_list[-] field1
}
type record of GetResponseX.pcB_list[-] MyPcB_list;
type GetResponseX.pcB_list[-].pcB MyCharType;
type port PCOType message {
  inout charstring;
} with {extension "internal"}
type component MTCType {
  const GetResponseX.pcB_list[-] cl_myRecord := cg_RecofElem;
  const GetResponseX.pcB_list[-].pcB cl_myChar := "O";
  var GetResponseX.pcB_list[-] vl_myRecValue;
  var GetResponseX.pcB_list[-].pcB vl_myCharValue1;
  var template GetResponseX.pcB_list[-] vl_myRecTempl1;
  var template GetResponseX.pcB_list[-].pcB vl_myCharTempl;
  port PCOType MyPCO_PT;
}
const GetResponseX.pcB_list[-] cg_RecofElem := {
  pcB := "0",
  pcB_1 := "1"
}
modulepar GetResponseX.pcB_list[-] tsp_RecofElem := {
  pcB := "0",
  pcB_1 := "1"
}
template GetResponseX.pcB_list[-] t_RecofElem := {
  pcB := "0",
  pcB_1 := "1"
}
function x (GetResponseX.pcB_list[-] pl_elem, template GetResponseX.pcB_list[-] plt_elem) {
  const GetResponseX.pcB_list[-] cl_myRecord1 := cg_RecofElem;
  const GetResponseX.pcB_list[-].pcB cl_myChar1 := "O";
  var GetResponseX.pcB_list[-] vl_myRecValue1;
  var GetResponseX.pcB_list[-].pcB vl_myCharValue2;
  var template GetResponseX.pcB_list[-] vl_myRecTempl2;
  var template GetResponseX.pcB_list[-].pcB vl_myCharTempl;
}
testcase tc(GetResponseX.pcB_list[-] pl_elem) runs on MTCType {
  const GetResponseX.pcB_list[-] cl_myRecord2 := cg_RecofElem;
  const GetResponseX.pcB_list[-].pcB cl_myChar2 := "O";
  var GetResponseX.pcB_list[-] vl_myRecValue2;
  var GetResponseX.pcB_list[-].pcB vl_myCharValue;
  var template GetResponseX.pcB_list[-] vl_myRecTempl3;
  var template GetResponseX.pcB_list[-].pcB vl_myCharTempl3;
  if (pl_elem.pcB == "0") { setverdict(pass)}
  else { setverdict (fail);}
}
altstep as_x (GetResponseX.pcB_list[-] pl_elem, template GetResponseX.pcB_list[-] plt_elem) runs on MTCType {
  const GetResponseX.pcB_list[-] cl_myRecord3 := cg_RecofElem;
  const GetResponseX.pcB_list[-].pcB cl_myChar3 := "O";
  var GetResponseX.pcB_list[-] vl_myRecValue3;
  var GetResponseX.pcB_list[-].pcB vl_myCharValue;
  var template GetResponseX.pcB_list[-] vl_myRecTempl4;
  var template GetResponseX.pcB_list[-].pcB vl_myCharTempl4;
  [] MyPCO_PT.receive { }
}
control 
{
  const GetResponseX.pcB_list[-] cl_myRecord4 := cg_RecofElem;
  const GetResponseX.pcB_list[-].pcB cl_myChar4 := "O";
  var GetResponseX.pcB_list[-] vl_myRecValue2;
  var GetResponseX.pcB_list[-].pcB vl_myCharValue;
  var template GetResponseX.pcB_list[-] vl_myRecTempl2;
  var template GetResponseX.pcB_list[-].pcB vl_myCharTempl2;
  var GetResponseX.pcB_list[-] v_RecofElem := {
    pcB := "0",
    pcB_1 := "1"
  }
execute (tc(v_RecofElem));
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
FileMask := LOG_ALL
ConsoleMask := LOG_ALL
[EXECUTE]
Temp
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)Dynamic test case error:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Overall verdict: pass
<END_RESULT>
<END_TC>
:exmp.

.*-----------------------------------------------------------*
:h3.Adhoc:: HP36129: Check for component name correctness
.*-----------------------------------------------------------*
:xmp tab=0.
<TC - HP36129: Check for component name correctness>
<EXECUTE_PARALLEL>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type port PT message {
  inout charstring;
} with { extension "internal" }
type component C { 
  port PT PCO;
}
function f1() runs on C{
  log("Halo");
}
testcase tc() runs on C {
  var C comp := C.create("Alma-a.!ta");
  comp.start(f1());
  all component.done;
  setverdict(pass);
}
control {
  execute(tc());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
"Alma-a.!ta".FileMask := WARNING
ConsoleMask := LOG_ALL
[EXECUTE]
Temp.control
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?im)Dynamic test case error:
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)Overall verdict: pass
<END_RESULT>
<END_TC>
:exmp.

*-----------------------------------------------------------*
:h3.Adhoc:: HT23335: Type Infinity is not a valid value for type `integer' which as subtype (-1..65535)  
.*-----------------------------------------------------------*
:xmp tab=0.
<TC - HT23335: Type Infinity is not a valid value for type `integer' which as subtype (-1..65535)>

<COMPILE>
<VERDICT_LEAF FAIL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
const integer limes_i := 65535;
const float limes_f2 := 65535.0;
const float limes_f1 := -1.0;
type record MyRecI {
  integer inum (-1..limes_i)
};
type record MyRecF {
  float fnum (limes_f1..limes_f2)
};

template MyRecI t1 := { inum := (0..infinity) };
template MyRecF t2 := { fnum := (-infinity..0.0) };

}
<END_MODULE>
<RESULT IF_FAIL COUNT 2>
(?im)\Infinity is not a valid value for type\b
<END_RESULT>
<END_TC>
:exmp.

:etext.
