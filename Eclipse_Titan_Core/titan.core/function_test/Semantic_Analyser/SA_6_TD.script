.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Forstner, Matyas
.*   Hanko, Matyas
.*   Harai, Tibor
.*   Kovacs, Ferenc
.*   Palugyai, Sandor
.*   Raduly, Csaba
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.
:rev.
:date.2010.07.02.

:prep.ETH/RZX Ferenc Kovacs
:appr.ETH/RZ (Gyula Koos)
:checked.ETHGRY

:title.Test description of the Semantic Analyzer: Old test cases
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
       2010-07-02  EKRISZA      support for non-complete record/record ofs.
-     2005-02-19   ESNDPAL     New document for TITAN R6
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
This document contains old test cases from the previous TITAN project
for TTCN-3 Semantic Analyser. These test cases shall be moved to
different test descriptions in forthcoming projects.

.*---------------------------------------------------------------------*
:h2.Positive test cases for Compound types
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Positive test cases regarding value list notation - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Positive test cases regarding value list notation - constant>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r optional}
type record bTest  {integer i , charstring c optional}

type union uTest {aTest a, bTest b}

const aTest c1 := {1, "a", {2, "b"}}
const aTest c2 := {1, "a", {2, omit}}
const aTest c3 := {1, "a", omit}

const aTest c4 := {1, "a", {i := 2, c := "b"}}
const aTest c5 := {i := 1, c := "a", r := {2, omit}}

const bTest c6 := {2, "b"}
const aTest c7 := {1, "a", c6}

const uTest u1 := {a := {1, "a", {2, "b"}}}
const uTest u2 := {a := {1, "a", {i := 2, c := "b"}}}
const uTest u3 := {a := {i := 1, c := "a", r := {2, omit}}}
const uTest u4 := {a := {1, "a", c6}}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Positive test cases regarding value list notation - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Positive test cases regarding value list notation - template>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r optional}
type record bTest  {integer i , charstring c optional}

type union uTest {aTest a, bTest b}

template aTest c1 := {1, "a", {2, "b"}}
template aTest c2 := {1, "a", {2, omit}}
template aTest c3 := {1, "a", omit}

template aTest c4 := {1, "a", {i := 2, c := "b"}}
template aTest c5 := {i := 1, c := "a", r := {2, omit}}

template bTest c6 := {2, "b"}
template aTest c7 := {1, "a", c6}

template uTest u1 := {a := {1, "a", {2, "b"}}}
template uTest u2 := {a := {1, "a", {i := 2, c := "b"}}}
template uTest u3 := {a := {i := 1, c := "a", r := {2, omit}}}
template uTest u4 := {a := {1, "a", c6}}



}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Wrong order in value list notation (type)
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Record fields in wrong order - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Record fields in wrong order - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}

const aTest con := {{2, "bTest"},"aTest", 1}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Record.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i, charstring c}

const aTest con := {1, "aTest",{"bTest",3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted field in wrong place - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted field in wrong place - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i optional, charstring c}

const aTest con := {1, "aTest", {"bTest", omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order inside record of - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order inside record of - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type record bTest  {integer i , charstring c}

const aTest con := {{1, "aTest"}, {"bTest",2}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}

type union cTest {aTest a, bTest b}

const cTest con := {b := {1, 2}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in record of - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in record of - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type set bTest  {integer i, boolean b}
const aTest con := {1, {b := true, i := 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Set.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {integer i , charstring c}
type union cTest {integer i, bTest b}

const cTest con := {b := {"aTest", "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong values in record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong values in record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {integer i , cTest u}
type union cTest {integer i, boolean b}

const bTest con := {1, 2}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?union.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value with wrong type in record - constant1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value with wrong type in record - constant1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type integer iType (1, 2, 3, 4)
type record bTest  {iType i}

const bTest con := {true}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value with wrong type in record - constant2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value with wrong type in record - constant2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type integer iType (1, 2, 3, 4)
type record bTest  {iType i}

const bTest con := {str2int("6")}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, bitstring - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, bitstring - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , bitstring b}

const aTest con := {1, {2, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?bitstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, hexstring - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, hexstring - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , hexstring h}

const aTest con := {1, {2, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?hexstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, octetstring - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, octetstring - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , octetstring o}

const aTest con := {1, {2, 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?octetstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, boolean - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, boolean - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , boolean b}

const aTest con := {1, {2, 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?boolean.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Record fields in wrong order - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Record fields in wrong order - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}

template aTest con := {{2, "bTest"},"aTest", 1}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?value.+?list.+?notation.+?cannot.+?used.+?for.+?type.+?integer
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Record.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i, charstring c}

template aTest con := {1, "aTest",{"bTest",3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted field in wrong place - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted field in wrong place - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i optional, charstring c}

template aTest con := {1, "aTest", {"bTest", omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order inside record of - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order inside record of - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type record bTest  {integer i , charstring c}

template aTest con := {{1, "aTest"}, {"bTest",2}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Contained record fields in wrong order inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Contained record fields in wrong order inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}

type union cTest {aTest a, bTest b}

template cTest con := {b := {1, 2}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in record of - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in record of - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type set bTest  {integer i, boolean b}
template aTest con := {1, {b := true, i := 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Set.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {integer i , charstring c}
type union cTest {integer i, bTest b}

template cTest con := {b := {"aTest", "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong values in record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong values in record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {integer i , cTest u}
type union cTest {integer i, boolean b}

template bTest con := {1, 2}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?union.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value with wrong type in record - template1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value with wrong type in record - template1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type integer iType (1, 2, 3, 4)
type record bTest  {iType i}

template bTest con := {true}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?integer.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value with wrong type in record - template2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value with wrong type in record - template2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type integer iType (1, 2, 3, 4)
type record bTest  {iType i}

template bTest con := {str2int("6")}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?not.+?valid.+?value.+?for.+?subtype
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, bitstring - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, bitstring - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , bitstring b}

template aTest con := {1, {2, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?bitstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, hexstring - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, hexstring - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , hexstring h}

template aTest con := {1, {2, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?hexstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, octetstring - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, octetstring - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , octetstring o}

template aTest con := {1, {2, 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?octetstring.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong value in contained record, boolean - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong value in contained record, boolean - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , boolean b}

template aTest con := {1, {2, 1}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?boolean.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Wrong order in value list notation (number)
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Extra value at the end of value list in record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value at the end of value list in record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
const aTest con := {2, "aTest", {1, "bTest"}, 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value at the beginning of value list in record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value at the beginning of value list in record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
const aTest con := {1, 2, "aTest", {3, "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?record.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in contained record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in contained record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
const aTest con := {2, "aTest", {3, "bTest", '0010010'B}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record defined empty - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record defined empty - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {}
const aTest con := {1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in contained record defined empty - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in contained record defined empty - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest {integer i, bTest b}
type record bTest  {}
const aTest con := {2, {2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in contained record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in contained record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c optional}
const aTest con := {2, "aTest", {3}}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r optional}
type record bTest  {integer i , charstring c optional}
const aTest con := {2, "aTest"}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record of with length restriction - constant1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record of with length restriction - constant1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (0) of integer bTest;
const aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(0\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record of with length restriction - constant2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record of with length restriction - constant2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (2) of integer bTest;
const aTest con := {1, {1, 1, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1, 1, 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in record of with length restriction - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in record of with length restriction - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (2) of integer bTest;
const aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in set of with length restriction - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in set of with length restriction - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest s optional}
type set length (2) of integer bTest;
const aTest con := {1, {1,1,1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1, 1, 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in set of with length restriction - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in set of with length restriction - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest s optional}
type set length (2) of integer bTest;
const aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(2\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra values in set of with length restriction - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra values in set of with length restriction - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest
type set length (0) of integer bTest;
const aTest con := {{1}, {1,1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(0\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1, 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(0\)
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing values in set of with length restriction - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing values in set of with length restriction - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest
type set length (3) of integer bTest;
const aTest con := {{}, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error: \{  \} is not a valid value for type `\@Temp.bTest' which has subtype length\(3\)
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error: \{ 1 \} is not a valid value for type `\@Temp.bTest' which has subtype length\(3\)
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {}
type union cTest {integer i, bTest b}
const cTest con := {b := {1, 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in contained record inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in contained record inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , integer ii}
type union cTest {aTest a, integer i}
const cTest con := {a := {1, {1}}}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value at the end of value list in record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value at the end of value list in record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
template aTest con := {2, "aTest", {1, "bTest"}, 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value at the beginning of value list in record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value at the beginning of value list in record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
template aTest con := {1, 2, "aTest", {3, "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?character.+?string.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Record.+?value.+?expected
<END_RESULT>
<RESULT IF_PASS COUNT 3>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in contained record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in contained record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c}
template aTest con := {2, "aTest", {3, "bTest", '0010010'B}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record defined empty - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record defined empty - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {}
template aTest con := {1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in contained record defined empty - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in contained record defined empty - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest {integer i, bTest b}
type record bTest  {}
template aTest con := {2, {2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in contained record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in contained record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c optional}
template aTest con := {2, "aTest", {3}}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)error.+?Too.+?few.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r optional}
type record bTest  {integer i , charstring c optional}
template aTest con := {2, "aTest"}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)error.+?Too.+?few.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record of with length restriction - template1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record of with length restriction - template1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (0) of integer bTest;
template aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?There.+?must.+?not.+?be.+?than.+?0.+?elements
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record of with length restriction - template2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record of with length restriction - template2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (2) of integer bTest;
template aTest con := {1, {1, 1, 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?There.+?must.+?not.+?be.+?than.+?2.+?elements
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in record of with length restriction - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in record of with length restriction - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record length (2) of integer bTest;
template aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?At.+?least.+?2.+?elements.+?must.+?be.+?present
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in set of with length restriction - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in set of with length restriction - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest s optional}
type set length (2) of integer bTest;
template aTest con := {1, {1,1,1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?There.+?must.+?not.+?be.+?than.+?2.+?elements
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in set of with length restriction - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in set of with length restriction - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest s optional}
type set length (2) of integer bTest;
template aTest con := {1, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)\berror\b.+?At.+?least.+?2.+?elements.+?must.+?be.+?present
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra values in set of with length restriction - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra values in set of with length restriction - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest
type set length (0) of integer bTest;
template aTest con := {{1}, {1,1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?There.+?must.+?not.+?be.+?than.+?0.+?elements
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing values in set of with length restriction - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing values in set of with length restriction - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest
type set length (3) of integer bTest;
template aTest con := {{}, {1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 2>
(?im)\berror\b.+?At.+?least.+?3.+?elements.+?must.+?be.+?present
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Extra value in record inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Extra value in record inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {}
type union cTest {integer i, bTest b}
template cTest con := {b := {1, 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Too.+?many.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing value in contained record inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing value in contained record inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , integer ii}
type union cTest {aTest a, integer i}
template cTest con := {a := {1, {1}}}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?im)error.+?Too.+?few.+?elements.+?in.+?value.+?list.+?notation
<END_RESULT>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Wrong order in assignment notation
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Fields of record in wrong order - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields of record in wrong order - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
	const aTest con :=  {c := "aTest", i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?record.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Fields of contained record in wrong order - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields of contained record in wrong order - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {c := "bTest",i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?record.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Fields in record inside union in wrong order - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields in record inside union in wrong order - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}
const cTest con := {b := {c := "bTest", i := 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?record.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Fields in record inside union in wrong order - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields in record inside union in wrong order - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}
template cTest tem := {a := { i := 1, c := "aTest", r := {c := "bTest", i:= 1}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Fields of record in wrong order - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields of record in wrong order - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
	template aTest tem :=  {c := "aTest", i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Fields of contained record in wrong order - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fields of contained record in wrong order - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
	template aTest tem :=  {i := 1, r := {c := "bTest",i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?in.+?template.+?record
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Uninitialized field in record or set at declaration
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Missing field from record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
	const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from contained record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from contained record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}
	const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from contained set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from contained set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field from record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field from record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

	const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field from set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field from set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

	const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Uninitialised constant assigned to record field - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Uninitialised constant assigned to record field - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set of integer bTest;
	const bTest con1 := {1,2, -}
	const aTest con :=  {i := con1[2], r := omit}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Not.+?used.+?symbol.+?is.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
	template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from contained record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from contained record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
	template aTest tem :=  {i := 1, r := {c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}
	template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field from contained set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field from contained set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
	template aTest tem :=  {i := 1, r := {i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field from record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field from record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

	template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field from set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field from set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

	template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Uninitialised constant assigned to record field - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Uninitialised constant assigned to record field - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set of integer bTest;
	template bTest tem1 := {1,2, -}
	template aTest tem :=  {i := tem1[2], r := omit}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Not.+?used.+?symbol.+?is.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Duplicate initialization of field in assigment notation
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Duplicate field in record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
	const aTest con :=  {i := 1, i := 2, c := "aTest"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {i := 2, i:= 3, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
	const aTest con :=  { r := {i:= 2, c := "bTest"}, i := 1, r := {i:= 3, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {i:= 3, c := "bTest", i:= 4}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate optional field in record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate optional field in record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
	const aTest con :=  {i := 1, r := {i := 3, c := omit, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate optional field in set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate optional field in set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
	const aTest con :=  {i := 1, r := {i := 3, c := omit, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?already.+?given.+?here
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Reference to non-existent field in assignment notation
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

const aTest con :=  {i := 1, b := 2, c := "aTest"}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}

const aTest con :=  {i := 1, r := {i := 2, b:= 3, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in set1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in set1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}

const aTest con :=  {i := 1, c := "aTest", b := 2}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in set2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in set2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
	const aTest con :=  {i := 1, r := {i:= 3, c := "bTest", b:= 4}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union cTest {integer i, boolean b}
const cTest con := {c := "abc"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in record inside union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in record inside union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {integer i , charstring c}
type union cTest {integer i, bTest b}
const cTest con := {b := {i :=1, c := "bTest", ii := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in contained union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in contained union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union cTest {integer i, boolean b}
type record of cTest bTest

const bTest con := {{c :=1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in empty record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in empty record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest {}

const bTest con := {c := 1}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Reference to non-existent field in empty set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Reference to non-existent field in empty set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set bTest {}

const bTest con := {c := 1}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Omit value in mandatory field
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}

const aTest con :=  {i := omit, c := "aTest"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

const aTest con :=  {i := omit, c := "aTest"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}
const aTest con :=  {i := 1, r := {i := 2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type record bTest  {integer i , charstring c}
const aTest con :=  {i := 1, r := {i := 2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained record in union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained record in union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {charstring c}
type union cTest {integer i, bTest b}
const cTest con := {b := {omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}

template aTest tem :=  {i := omit, c := "aTest"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem :=  {i := omit, c := "aTest"}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

template aTest tem :=  {i := 1, r := {i := 2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type record bTest  {integer i , charstring c}

template aTest tem :=  {i := 1, r := {i := 2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omit value in mandatory field of contained record in union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omit value in mandatory field of contained record in union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record bTest  {charstring c}
type union cTest {integer i, bTest b}
template cTest tem := {b := {omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Missing optional field in assignment notation
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Missing optional field in set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

const aTest con :=  {i := 1, r := {i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

const aTest con :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained record - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained record - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

const aTest con :=  {i := 1, r := {i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem :=  {i := 1, r := {i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

template aTest tem :=  {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained record - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained record - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem :=  {i := 1, r := {i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained record inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained record inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

type union uType {aTest a, bTest b}

const uType u := {a := {i := 1, r := {i:=2}}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in contained record inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in contained record inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

type union uType {aTest a, bTest b}

template uType u := {a := {i := 1, r := {i:=2}}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Value list notation for union and set
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Value list notation for set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

const aTest con :=  {1, {i :=2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?cannot.+?be.+?used.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation for contained set - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for contained set - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

const aTest con :=  {1, {2, omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?cannot.+?be.+?used.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation for contained set inside union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for contained set inside union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set bTest  {integer i , charstring c optional}
type union uTest {integer i, bTest b}

const uTest u :=  {b := {1, "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?cannot.+?be.+?used.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation for set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem :=  {1, {i :=2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation for contained set - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for contained set - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem :=  {1, {2, omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation for contained set inside union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation for contained set inside union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type set bTest  {integer i , charstring c optional}
type union uTest {integer i, bTest b}

template uTest u :=  {b := {1, "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.More than one union element is specified
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.More than one element is defined in union - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in union - constant>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union uTest {integer i, boolean b}

const uTest con := {i := 1, b := true}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Only.+?one.+?field.+?expected.+?in.+?union.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one element is defined in contained union - constant1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in contained union - constant1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, uTest u}
type union uTest {integer i, boolean b}

const aTest con:= { i := 1, u := {i := 1, b := true}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Only.+?one.+?field.+?expected.+?in.+?union.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one element is defined in contained union - constant2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in contained union - constant2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, cTest u}
type union cTest {integer i, boolean b}

const aTest con := { i := 1, u := {i := 1, b := true, c := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Only.+?one.+?field.+?expected.+?in.+?union.+?value
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one element is defined in union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type union uTest {integer i, boolean b}

template uTest tem := {i := 1, b := true}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?template.+?for.+?union.+?type.+?must.+?contain.+?exactly.+?one.+?selected.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one element is defined in contained union - template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in contained union - template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, uTest u}
type union uTest {integer i, boolean b}

template aTest tem:= { i := 1, u := {i := 1, b := true}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?template.+?for.+?union.+?type.+?must.+?contain.+?exactly.+?one.+?selected.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one element is defined in contained union - template_2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one element is defined in contained union - template_2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, cTest u}
type union cTest {integer i, boolean b}

template aTest tem := { i := 1, u := {i := 1, b := true, c := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?template.+?for.+?union.+?type.+?must.+?contain.+?exactly.+?one.+?selected.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?union.+?template
<END_RESULT>
<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Missing fields in template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Missing field in template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}

template aTest tem := {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}

template aTest tem := {i:= 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}

template aTest tem := {i := 1, r := {i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}

template aTest tem := {i := 1, r := {i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in union template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in union template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}
type union uTest {aTest a, bTest b}

template uTest tem := { a := {i := 1, r := { i:= 2}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in union template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in union template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c}
type union uTest {aTest a, bTest b}

template uTest tem := { a := {i := 1, r := { i:= 2}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in template - set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - set of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of integer aTest;

template aTest tem := {1, -, 3}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing field in template - record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing field in template - record of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of integer aTest;

template aTest tem := {-, 2, 3}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Missing optional fields in template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Missing optional field in template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c, bTest r optional}
type set bTest  {integer i , charstring c}

template aTest tem := { c := "aTest", i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}

template aTest tem := { i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside union - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside union - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record bTest  {integer i , charstring c}
type union cTest {aTest a, bTest b}

template cTest tem := { a := {i := 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside union - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside union - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := { a := {i := 1, r :={i := 2}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside union - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside union - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c}
type union cTest {aTest a, bTest b}

template cTest tem := { a := {i := 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside union - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside union - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := { a := {i := 1, r :={i := 2}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside record of>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type record bTest  {integer i , charstring c optional}

template aTest tem := {{1,"bTest"},{i:=2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Missing optional field in template inside set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Missing optional field in template inside set of >

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest;
type set bTest  {integer i , charstring c optional}

template aTest tem := {{i := 1, c := "bTest"},{i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 0>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Omitted mandatory field in template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := omit, r := {i := 2, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r optional}
type set bTest  {integer i , charstring c optional}

template aTest tem := { i := omit, r := {i := 2, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := omit, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := omit, c := omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in record of template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in record of template >

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of bTest aTest;
type record bTest  {integer i , charstring c optional}

template aTest tem := { {1, omit}, {omit, "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in set of template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in set of template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of bTest aTest;
type record bTest  {integer i , charstring c optional}

template aTest tem := { {i := 1, c :=  omit}, {i := omit, c := "bTest"}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in union template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in union template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union cTest {integer i, boolean b}

template cTest tem := {i := omit}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?value.+?not.+?allowed
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in union template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in union template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := omit, r := {2, "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in union template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in union template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := omit, r := {2, "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in union template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in union template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {omit, "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in union template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in union template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := { i := omit, c := omit}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Omitted mandatory field in modified union template
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Omitted mandatory field in modified union template>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r optional}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := { r := { i := omit, c := "bTest"}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Order mismatch in record template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Order mismatch in a record template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Order mismatch in a record template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {r := {i := 2, c := omit}, i := 1 }


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Order mismatch in a record template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Order mismatch in a record template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {c := omit, i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Order mismatch in a record template - record in union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Order mismatch in a record template - record in union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c, bTest r optional}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := {r := {i := 2, c := omit}, i := 1}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record.+?type
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Order mismatch in a record template - contained record in union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Order mismatch in a record template - contained record in union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r }
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := omit, r := {c := omit, i := 2}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?omit.+?not.+?allowed.+?context
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?record.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.non-existent or duplicate field in template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Duplicate field in template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit}, i := 3}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit}, i := 3}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit, i := 3}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {c := omit, i := 2, i := 3}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit}, n := 3}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?record.+?template
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit}, n := 3}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?template.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {i := 2, c := omit, n := 3}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?record.+?template
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := {i := 1, r := {c := omit, i := 2, n := 3}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?template.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in modified template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in modified template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}

template aTest tem := { i := 1, c := "aTest"}
template aTest tem1 modifies tem := { i := 1, i := 2}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in modified template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in modified template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem := { i := 1, c := "aTest"}
template aTest tem1 modifies tem := { i := 1, i := 2}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in modified template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in modified template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := { r := { i := 2, c := omit, i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in modified template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in modified template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := { r := { i := 2, c := omit, i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in modified template - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in modified template - set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, charstring c}

template aTest tem := { i := 1, c := "aTest"}
template aTest tem1 modifies tem := { n := omit }


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?template.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in modified template - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in modified template - record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem := { i := 1, c := "aTest"}
template aTest tem1 modifies tem := { i := 1, n := 2}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?record.+?template
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in modified template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in modified template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := { r := { i := 2, c := omit, n := omit }}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?template.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in modified template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in modified template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := { r := { i := 2, c := omit, n := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?record.+?template
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in union template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in union template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {i := 2, c := omit, c := "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?record.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Duplicate field in union template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Duplicate field in union template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {i := 2, c := omit, c := "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Duplicate.+?set.+?field
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)note.+?Field.+?is.+?already.+?given.+?here
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in union template - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in union template - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {i := 2, c := omit, n := 3}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?record.+?template
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.non-existent field in union template - contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  non-existent field in union template - contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {i := 2, c := omit, n := 3}}}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field.+?in.+?template.+?set
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Union template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.More than one field in union template - two insted of one
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one field in union template - two insted of one>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union uTest {integer i, boolean b, charstring c}

template uTest u := {i := 1, b := true}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?template.+?for.+?union.+?type.+?must.+?contain.+?exactly.+?one.+?selected.+?field
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.More than one field in union template - three insted of one
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  More than one field in union template - three insted of one>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type union uTest {integer i, boolean b, charstring c}

template uTest u := {i := 1, b := true, c := "c"}

}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?template.+?for.+?union.+?type.+?must.+?contain.+?exactly.+?one.+?selected.+?field
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Template for recursive types
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Template for recursive types - valueof()
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template for recursive types - valueof()>
<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
// TR 701: Segfault when there is a circular reference, where valueof() is involved

type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c}

template aTest tem := tem1;

template aTest tem1 := valueof(tem);


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Template for recursive types - contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template for recursive types - contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

// TR 690: segmentation fault
type record aTest  {integer i, uTest u}
type union uTest {aTest a, integer i}

template uTest tem1 := {a := {1,tem.u}}
template uTest tem  := tem1;


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Reference.+?to.+?non-existent.+?field
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Template for recursive types - sizeof() on record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template for recursive types - sizeof() on record of>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of integer rtype;

template rtype r := {1, 2, sizeof(r)}

}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Template for recursive types - sizeof() on set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Template for recursive types - sizeof() on set of>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set of integer rtype;

template rtype r := {1, 2, sizeof(r)}


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Value list notation in set template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Value list notation in set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation in set >

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i, charstring c optional}

template aTest tem := {1, {2, omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation in contained set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation in contained set>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i, charstring c optional}

template aTest tem := {1, {2, omit}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation in set inside union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation in set inside union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type set aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := {1, {2, "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Value list notation in contained set inside union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Value list notation in contained set inside union>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type set bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := {1, {2, "bTest"}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Value.+?list.+?notation.+?not.+?allowed.+?for.+?set.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.recursive derivation in a modified template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Recursive derivation in a modified template1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Recursive derivation in a modified template1>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem modifies tem1 := {i := 2}
template aTest tem1 modifies tem := {i := 1}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Recursive derivation in a modified template2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Recursive derivation in a modified template2>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}
template aTest tem modifies tem1 := {i := tem.i}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?There.+?is.+?no.+?local.+?or.+?imported.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Wrong order of fields in modified template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Wrong order of fields in modified template - in record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong order of fields in modified template - in record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i , charstring c optional}

template aTest tem := { i := 1, c := omit}
template aTest tem1 modifies tem := {c := omit, i := 3}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?for.+?record.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong order of fields in modified template - in contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong order of fields in modified template - in contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}

template aTest tem := { i := 1, r := {i := 2, c := omit}}
template aTest tem1 modifies tem := {i := 3, r := {c := omit,i := 3}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?for.+?record.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong order of fields in modified union template - in record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong order of fields in modified union template - in record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i , charstring c optional}

type union cTest {aTest a, integer i}

template cTest tem := {a := { i := 1, c := "aTest"}}
template cTest tem1 modifies tem := {a := {c := omit, i := 2}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?for.+?record.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Wrong order of fields in modified union template - in contained record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Wrong order of fields in modified union template - in contained record>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, bTest r}
type record bTest  {integer i , charstring c optional}
type union cTest {aTest a, bTest b}

template cTest tem := {a := { i := 1, r := {i := 2, c := omit}}}
template cTest tem1 modifies tem := {a := { i := 1, r := {c := omit, i := 3}}}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Field.+?cannot.+?appear.+?after.+?field.+?in.+?template.+?for.+?record.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Modified template cannot refer to itself
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Modified template refers to itself
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Modified template refers to itself >

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem1 modifies tem1 := {i := 2}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<<RESULT IF_PASS COUNT 1>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Modified template refers to itself - record field
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Modified template refers to itself - record field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

template aTest tem1 modifies tem := {i := tem1.i}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?There.+?is.+?no.+?local.+?or.+?imported.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?Circular.+?reference
<END_RESULT>
<<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Modified template refers to itself - record of field
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Modified template refers to itself - record of field>

<COMPILE>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record of integer aTest;

template aTest tem1 modifies tem := {i := tem1[i]}


}
<END_MODULE>
<RESULT IF_PASS COUNT 1>
(?im)error.+?There.+?is.+?no.+?local.+?or.+?imported.+?definition
<END_RESULT>
<RESULT IF_PASS COUNT 1>
(?im)error.+?assignment.+?notation.+?cannot.+?used.+?for.+?record.+?of.+?type
<END_RESULT>
<<RESULT IF_PASS COUNT 2>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.First argument of match is not a value
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h2.Second argument of match is not a template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h2.Argument of valueof is not a template
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.Argument of valueof is not a template - constant
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Argument of valueof is not a template - constant>

<COMPILEGCC>
<VERDICT_LEAF PASS>
<MODULE TTCN Temp Temp.ttcn>
module Temp {


type record aTest  {integer i, charstring c}

const aTest con  := { i := 1, c := "aTest"}
const aTest con1 := valueof(con);


}
<END_MODULE>
<RESULT IF_PASS NEGATIVE>
(?is)\berror:
<END_RESULT>
<END_TC>

:exmp.

:etext.
