.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Endre
.*   Szalai, Gabor
.*
.******************************************************************************/
:text.
:lang eng.
.*
:docname.Test Description
:docno.21/152 91-CRL 113 200/3 Uen
:rev.A
:date.2013-01-17
.*
:prep.ETH/XZR Krisztian Pandi
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY
.*
:title.Test Description - Text based coding for TTCN-3 Test Executor
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.

This file is obsolate, don't modify, improve it anymore!

This TD contains test cases related to TTCN3 Executor's Text coder function.
A faster version is located in the  TEXT_1_TD.fast_script file.
DON'T YOU DARE TO WRITE AN INSPECTION RECORD ABOUT THIS FILE.

:exmp.

:p.:us.Revision Information:eus.

:xmp nokeep.
:us.History:eus.

REV   DATE         PREPARED   CHANGE
===   ==========   ========   ======
A     2005-01-10   ETHGHASZ   New document
B     2005-10-11   EKRISZA    Updated for group support.
C     2007-03-06   EDMDELI    Implicit message encoding
D     2008-10-01   EFERKOV    Big integers
E     2011-01-24   EKRISZA     Restructured to use more efficient script.
F     2011-10-10   EKRISZA     Updated for release.
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.

.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Basic types - Charstring
.*---------------------------------------------------------------------*
This test case group covers the encoding attributes of type charstring
.*---------------------------------------------------------------------*
:h3.Length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fixed length encoding>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(length=5)"};

} with {encode "TEXT"}

const TEXT_PDU 		i := "HALI"
const charstring 	o := " HALI"
const TEXT_PDU  expected_res:=" HALI"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.Convert
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Convert string to lower case during encoding>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(convert=lower_case)"};

} with {encode "TEXT"}

const TEXT_PDU 		i := "HALI"
const charstring 	o := "hali"
const TEXT_PDU  expected_res:="hali"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

:xmp tab=0.

<TC -  Convert string to upper case during encoding>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(convert=upper_case)"};

} with {encode "TEXT"}

const TEXT_PDU 		i := "hali"
const charstring 	o := "HALI"
const TEXT_PDU  expected_res:="HALI"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

:xmp tab=0.

<TC -  Convert string to lower case during encoding and upper case during decoding>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(convert=lower_case,
                                                     convert=upper_case)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="HALI"
const charstring 	o := "hali"
const TEXT_PDU  expected_res:="HALI"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.


:xmp tab=0.

<TC -  Convert string to upper case during encoding and lower case during decoding>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(convert=upper_case,
                                                     convert=lower_case)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="hali"
const charstring 	o := "HALI"
const TEXT_PDU  expected_res:="hali"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Justification
.*---------------------------------------------------------------------*

:xmp tab=0.

<TC -  Left justification>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(just=left;length=5)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="hali"
const charstring 	o := "hali "
const TEXT_PDU  expected_res:="hali "

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

:xmp tab=0.

<TC -  Center justification>

<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(just=center;length=6)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="hali"
const charstring 	o := " hali "
const TEXT_PDU  expected_res:=" hali "

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

:xmp tab=0.

<TC -  Right justification>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(just=right;length=5)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="hali"
const charstring 	o := " hali"
const TEXT_PDU  expected_res:=" hali"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Select token
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Case sensitive selection>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(,,'[\d]#(4)[a-e]#(4)')"};

} with {encode "TEXT"}

const TEXT_PDU  i:="1234abcd"
const charstring 	o := "1234abcdfrd"
const TEXT_PDU  expected_res:="1234abcd"
<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  Case insensitive selection>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "TEXT_CODING(,convert=lower_case,
                                       '[\d]#(4)[a-e]#(4)', case_insensitive)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="1234abcd"
const charstring 	o := "1234aBCdfrd"
const TEXT_PDU  expected_res:="1234abcd"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Basic types - Integer
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Length
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Fixed length>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING(length=5)"};

} with {encode "TEXT"}

const TEXT_PDU  i:=249
const charstring 	o := "  249"
const TEXT_PDU  expected_res:=249

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  variable length>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING()"};

} with {encode "TEXT"}

const TEXT_PDU  i:=12249
const charstring 	o := "12249"
const TEXT_PDU  expected_res:=12249

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Leading zero's
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding without leading zero>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING(length=7)"};

} with {encode "TEXT"}

const TEXT_PDU  i:=12249
const charstring 	o := "  12249"
const TEXT_PDU  expected_res:=12249

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  encoding with leading zero>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING(leading0=true;length=7)"};

} with {encode "TEXT"}

const TEXT_PDU  i:=12249
const charstring 	o := "0012249"
const TEXT_PDU  expected_res:=12249

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  encoding negativ integer with leading zero>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING(leading0=true;length=7)"};

} with {encode "TEXT"}

const TEXT_PDU  i:=-12249
const charstring 	o := "-012249"
const TEXT_PDU  expected_res:=-12249

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h3.Select token
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Selection of integer value>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type integer TEXT_PDU with { variant "TEXT_CODING(,,
                                       '[1-4]#(1,)')"};

} with {encode "TEXT"}

const TEXT_PDU  i:=123423
const charstring 	o := "123423567aBCdfrd"
const TEXT_PDU  expected_res:=123423

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.

.*---------------------------------------------------------------------*
:h2.Basic types - Boolean
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Basic encoding of true value>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type boolean TEXT_PDU with { variant "TEXT_CODING()"};

} with {encode "TEXT"}

const TEXT_PDU  i:=true
const charstring 	o := "true"
const TEXT_PDU  expected_res:=true

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  Basic encoding of false value>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type boolean TEXT_PDU with { variant "TEXT_CODING()"};

} with {encode "TEXT"}

const TEXT_PDU  i:=false
const charstring 	o := "false"
const TEXT_PDU  expected_res:=false

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  Encoding and decoding of given tokens 1>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type boolean TEXT_PDU with { variant "TEXT_CODING(true:'YES';false:'NO')"};

} with {encode "TEXT"}

const TEXT_PDU  i:=false
const charstring 	o := "NO"
const TEXT_PDU  expected_res:=false

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  Encoding and decoding of given tokens 2>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type boolean TEXT_PDU with { variant "TEXT_CODING(true:'YES';false:'NO',
                           true:'good';false:{'bad',case_insensitive})"};

} with {encode "TEXT"}

const TEXT_PDU  i:=false
const charstring 	o1 := "NO"
const charstring 	o := "Bad"
const TEXT_PDU  expected_res:=false

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if( res==o1 and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Basic types - Enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Basic encoding of enumerated values>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type enumerated TEXT_PDU {egy,ketto,harom}
                         with { variant "TEXT_CODING()"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:=egy
  var charstring 	o := "egy"
  var TEXT_PDU  expected_res:=egy
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  i:=harom
  o := "harom"
  expected_res:=harom
  res:=enc_TEXT_PDU(i);
  dec_pdu:=dec_TEXT_PDU(o);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
:xmp tab=0.

<TC -  Encoding of given enumerated values>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type enumerated TEXT_PDU {egy,ketto,harom}
     with { variant "TEXT_CODING(egy:'haho';harom:'har',
                                 egy:'(haho)|(H)';ketto:{,case_insensitive};
                                 harom:{'hArom',case_insensitive})"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:=egy
  var charstring 	o := "haho"
  var charstring 	o1 := "H"
  var TEXT_PDU  expected_res:=egy
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu2:=dec_TEXT_PDU(o1);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if( res==o and dec_pdu==expected_res and dec_pdu2==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  i:=ketto
  o := "ketto"
  o1:="KettO"
  expected_res:=ketto
  res:=enc_TEXT_PDU(i);
  dec_pdu:=dec_TEXT_PDU(o1);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  i:=harom
  o := "har"
  o1:="haRoM"
  expected_res:=harom
  res:=enc_TEXT_PDU(i);
  dec_pdu:=dec_TEXT_PDU(o1);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h2.Leading, separation and trailing token
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Leading token
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Coding with leading token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "BEGIN('Header:')"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const charstring 	o := "Header:value"
const TEXT_PDU  expected_res:="value"
<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with leading token, case insensitive decoding>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "BEGIN('Header:',, case_insensitive)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const charstring 	o := "heADer:value"
const TEXT_PDU  expected_res:="value"
<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with leading token, using decoding matching pattern>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "BEGIN('Header:','(T:)|(Header:)')"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const TEXT_PDU  expected_res:="value"

<TTCN_TC:EXEC>
  var charstring 	o := "T:value"
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}
  o := "Header:value"
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Trailing token
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Coding with trailing token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "END(':close')"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const charstring 	o := "value:close"
const TEXT_PDU  expected_res:="value"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with trailing token, case insensitive decoding>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "END(':close',, case_insensitive)"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const charstring 	o := "value:CloSe"
const TEXT_PDU  expected_res:="value"

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with leading token, using decoding matching pattern>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type charstring TEXT_PDU with { variant "END(':close','(:T)|(:close)')"};

} with {encode "TEXT"}

const TEXT_PDU  i:="value"
const TEXT_PDU  expected_res:="value"

<TTCN_TC:EXEC>
  var charstring 	o := "value:close"
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  o := "value:T"
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Field separator token
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Coding with separator token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record TEXT_PDU {
  charstring f1,
  charstring f2
} with { variant "SEPARATOR('\n\r')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1",f2:="value2"}
const charstring 	o := "value1\n\rvalue2"
const TEXT_PDU  expected_res:={f1:="value1",f2:="value2"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with separator token, case insensitive decoding>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record TEXT_PDU {
  charstring f1,
  charstring f2
} with { variant "SEPARATOR(':FieldSep\n\r',,case_insensitive)"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1",f2:="value2"}
const charstring 	o := "value1:FiELDsep\n\rvalue2"
const TEXT_PDU  expected_res:={f1:="value1",f2:="value2"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Coding with separator token, using decoding matching pattern>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record TEXT_PDU {
  charstring f1,
  charstring f2
} with { variant "SEPARATOR(':FieldSep\n\r','(\n\r)|(:FieldSep\n\r)')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1",f2:="value2"}
const TEXT_PDU  expected_res:={f1:="value1",f2:="value2"}

<TTCN_TC:EXEC>
  var charstring 	o := "value1:FieldSep\n\rvalue2"
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  o := "value1\n\rvalue2"
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h2.Coding of compound types
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Record with BEGIN/END token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record TEXT_PDU {
  charstring f1
} with { variant "BEGIN('Head:'),END(':end')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1"}
const charstring 	o := "Head:value1:end"
const TEXT_PDU  expected_res:={f1:="value1"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Record with record fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type record TEXT_PDU {
  rec1 f1,
  charstring f2
} with { variant "BEGIN('PDU:'),END(':UDP')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
const charstring 	o := "PDU:Head:v1,v2:endvalue1:UDP"
const TEXT_PDU  expected_res:={f1:={field1:="v1",field2:="v2"},f2:="value1"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Record with optional fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type record TEXT_PDU {
  rec1 f1 optional,
  charstring f2
} with { variant "BEGIN('PDU:'),END(':UDP')"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring 	o := "PDU:Head:v1,v2:endvalue1:UDP"
  var TEXT_PDU  expected_res:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  i:={f1:=omit,f2:="value1"}
  o := "PDU:value1:UDP"
  expected_res:={f1:=omit,f2:="value1"}
  res:=enc_TEXT_PDU(i);
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Set with BEGIN/END token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type set TEXT_PDU {
  charstring f1
} with { variant "BEGIN('Head:'),END(':end')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1"}
const charstring 	o := "Head:value1:end"
const TEXT_PDU  expected_res:={f1:="value1"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Set with record fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type set rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type set TEXT_PDU {
  rec1 f1,
  charstring f2
} with { variant "BEGIN('PDU:'),END(':UDP'),SEPARATOR(',')"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring 	o := "PDU:Head:v1,v2:end,value1:UDP"
  var charstring 	o2 := "PDU:value1,Head:v1,v2:end:UDP"
  var TEXT_PDU  expected_res:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);
  var TEXT_PDU dec_pdu2:=dec_TEXT_PDU(o2);

  if(dec_pdu==expected_res and dec_pdu2==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Set with optional fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type set TEXT_PDU {
  rec1 f1 optional,
  charstring f2
} with { variant "BEGIN('PDU:'),END(':UDP')"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring 	o := "PDU:Head:v1,v2:endvalue1:UDP"
  var TEXT_PDU  expected_res:={f1:={field1:="v1",field2:="v2"},f2:="value1"}
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  i:={f1:=omit,f2:="value1"}
  o := "PDU:value1:UDP"
  expected_res:={f1:=omit,f2:="value1"}
  res:=enc_TEXT_PDU(i);
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.

:xmp tab=0.

<TC -  Set with set of type fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type set of charstring sof with {variant "SEPARATOR(',')"}

type set TEXT_PDU {
  charstring f1,
  charstring f2 optional,
  sof f3,
  sof f4 optional,
  sof f5,
  charstring f6
} with { variant "BEGIN('Head:'),END(':end')";
         variant (f1) "BEGIN('f1:')";
         variant (f2) "BEGIN('f2:')";
         variant (f3) "BEGIN('f3:')";
         variant (f4) "BEGIN('f4:'),TEXT_CODING(,repeatable=true)";
         variant (f5) "BEGIN('f5:'),TEXT_CODING(,repeatable=true)";
         variant (f6) "BEGIN('f6:')";
         variant "SEPARATOR(';')" };

} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1",
                    f2:=omit,
                    f3:={"sof1","sof1a","sof1b"},
                    f4:={"sof2","sof2a","sof2b"},
                    f5:={"sof3","sof3a","sof3b"},
                    f6:="value6" }

<TTCN_TC:EXEC>
  var charstring 	o := "Head:f1:value1;f3:sof1,sof1a,sof1b;f4:sof2,sof2a,sof2b;f5:sof3,sof3a,sof3b;f6:value6:end"
  var TEXT_PDU  expected_res:={f1:="value1",
                    f2:=omit,
                    f3:={"sof1","sof1a","sof1b"},
                    f4:={"sof2","sof2a","sof2b"},
                    f5:={"sof3","sof3a","sof3b"},
                    f6:="value6" }
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  o := "Head:f5:sof3a,sof3b;f3:sof1,sof1a,sof1b;f4:sof2;f1:value1;f4:sof2a,sof2b;f5:sof3;f6:value6:end"
  expected_res:={f1:="value1",
                    f2:=omit,
                    f3:={"sof1","sof1a","sof1b"},
                    f4:={"sof2","sof2a","sof2b"},
                    f5:={"sof3","sof3a","sof3b"},
                    f6:="value6" }
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}
  o := "Head:f5:sof3a,sof3b;f3:sof1,sof1a,sof1b;f1:value1;f5:sof3;f6:value6:end"
  expected_res:={f1:="value1",
                    f2:=omit,
                    f3:={"sof1","sof1a","sof1b"},
                    f4:=omit,
                    f5:={"sof3","sof3a","sof3b"},
                    f6:="value6" }
  dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Record/Set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Record of with BEGIN/END token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record of charstring TEXT_PDU
     with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={"value1","value2","value3"}
const charstring 	o := "Head:value1,value2,value3:end"
const TEXT_PDU  expected_res:={"value1","value2","value3"}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Record of with record fields>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type record of rec1 TEXT_PDU  with { variant "BEGIN('PDU:'),END(':UDP')"};

} with {encode "TEXT"}

const TEXT_PDU  i:={{field1:="v1",field2:="v2"},{field1:="v3",field2:="v4"}}
const charstring 	o := "PDU:Head:v1,v2:endHead:v3,v4:end:UDP"
const TEXT_PDU  expected_res:={{field1:="v1",field2:="v2"},{field1:="v3",field2:="v4"}}

<TTCN_TC:EXEC>
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(res);

  if( res==o and dec_pdu==expected_res){
    setverdict(pass);
  } else {
    log ("enc_TEXT_PDU(i)=     "  , res) ;
    log ("dec_TEXT_PDU(res)=     "  , dec_pdu) ;
    setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

<TC -  Empty record of>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type record rec1{
  charstring field1,
  charstring field2
} with { variant "BEGIN('Head:'),END(':end'),SEPARATOR(',')"};

type record of rec1 TEXT_PDU  with { variant "BEGIN('PDU:'),END(':UDP')"};

} with {encode "TEXT"}

<TTCN_TC:EXEC>
  var TEXT_PDU  i:={}
  var charstring 	o := "PDU::UDP"
  var TEXT_PDU  expected_res:={}
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
.*---------------------------------------------------------------------*
:h3.Union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Union with BEGIN/END token>
<STATIC>

external function enc_TEXT_PDU(in TEXT_PDU pdu) return charstring with { extension "prototype(convert) encode(TEXT)" }
external function dec_TEXT_PDU(in charstring oct) return TEXT_PDU with { extension "prototype(convert) decode(TEXT)" }

group TEXT_group{

type union TEXT_PDU {
  charstring f1,
  charstring f2
} with { variant "BEGIN('Head:'),END(':end')";
            variant (f1) "BEGIN('f1:'),END(':1f')"
            variant (f2) "BEGIN('f2:'),END(':2f')" };
} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1"}

<TTCN_TC:EXEC>
  var charstring 	o := "Head:f1:value1:1f:end"
  var TEXT_PDU  expected_res:={f1:="value1"}
  var charstring res:=enc_TEXT_PDU(i);
  var TEXT_PDU dec_pdu:=dec_TEXT_PDU(o);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  o := "Head:f2:value2:2f:end"
  expected_res:={f2:="value2"}
  dec_pdu:=dec_TEXT_PDU(o);
  //log(o);
  //log(dec_pdu);
  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.


.*---------------------------------------------------------------------*
:h3.Fast
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  implicit message encoding: prototype fast>
<STATIC>

external function fast_enc_TEXT_PDU(in TEXT_PDU pdu, out charstring cs) with { extension "prototype(fast) encode(TEXT)" }
external function fast_dec_TEXT_PDU(in charstring cs, out TEXT_PDU pdu) with { extension "prototype(fast) decode(TEXT)" }

group TEXT_group{

type union TEXT_PDU {
  charstring f1,
  charstring f2
} with { variant "BEGIN('Head:'),END(':end')";
            variant (f1) "BEGIN('f1:'),END(':1f')"
            variant (f2) "BEGIN('f2:'),END(':2f')" };
} with {encode "TEXT"}

const TEXT_PDU  i:={f1:="value1"}

<TTCN_TC:EXEC>
  var charstring 	o := "Head:f1:value1:1f:end"
  var TEXT_PDU  expected_res:={f1:="value1"}
  var charstring res;
  fast_enc_TEXT_PDU(i, res);
  var TEXT_PDU dec_pdu;
  fast_dec_TEXT_PDU(o, dec_pdu);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

  o := "Head:f2:value2:2f:end"
  expected_res:={f2:="value2"}
  fast_dec_TEXT_PDU(o, dec_pdu);

  if(dec_pdu==expected_res){
    setverdict(pass);
  } else {setverdict(fail);}

<RESULT>
Overall verdict: pass
<END_TC>
:exmp.
:xmp tab=0.

.*---------------------------------------------------------------------*
:h3.Backtrack
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - implicit message encoding: prototype backtrack>
<STATIC>

external function fast_enc_TEXT_PDU(in TEXT_PDU pdu, out charstring cs) 
  with { extension "prototype(fast) encode(TEXT)" }
external function backtrack_dec_TEXT_PDU(in charstring cs, out TEXT_PDU pdu) return integer 
  with { extension "prototype(backtrack) decode(TEXT) errorbehavior(ALL:WARNING)" }

type integer TEXT_PDU with { variant "TEXT_CODING()" }

<TTCN_TC:EXEC>
    
  var TEXT_PDU bs := 42;
  var TEXT_PDU decoded_bs;
  var charstring enc_bs;
  var integer ret_val;
  var charstring invalid_enc_bs := "bruhaha";

  fast_enc_TEXT_PDU(bs, enc_bs);
  ret_val := backtrack_dec_TEXT_PDU(enc_bs, decoded_bs);
  if (ret_val==0) { setverdict(pass); } else { setverdict(fail); }
  if (decoded_bs==bs) { setverdict(pass); } else { setverdict(fail); }
  ret_val := backtrack_dec_TEXT_PDU(invalid_enc_bs, decoded_bs);
  if (ret_val==1) { setverdict(pass); } else { setverdict(fail); }

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Sliding
.*---------------------------------------------------------------------*
:xmp tab=0.


<TC - implicit message encoding: prototype sliding>
<STATIC>

external function sliding_dec_TEXT_PDU(inout charstring cs, out TEXT_PDU pdu) return integer 
  with { extension "prototype(sliding) decode(TEXT) errorbehavior(ALL:WARNING)" }

type integer TEXT_PDU with { variant "TEXT_CODING(length=4)" }

<TTCN_TC:EXEC>
  
  var TEXT_PDU out_pdu;
  var charstring enc_pdu1 := "  42  21";
  var integer ret_val;  

  ret_val := sliding_dec_TEXT_PDU(enc_pdu1, out_pdu);
  if (ret_val==0 and out_pdu==42) { setverdict(pass); } else { setverdict(fail); }
  ret_val := sliding_dec_TEXT_PDU(enc_pdu1, out_pdu);
  if (ret_val==0 and out_pdu==21) { setverdict(pass); } else { setverdict(fail); }  
  ret_val := sliding_dec_TEXT_PDU(enc_pdu1, out_pdu);

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Encoding/decoding of big integers
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Big integer fields
.*---------------------------------------------------------------------*
:xmp tab=0.


<TC - big integers: big integer fields>
<STATIC>

external function enc_text(in rec_text r) return charstring
  with { extension "encode(TEXT) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_text(in charstring r) return rec_text
  with { extension "decode(TEXT) prototype(convert) errorbehavior(ALL:WARNING)" }

type integer myint1 with {
  variant "BEGIN('<myint>')"
  variant "END('</myint>')"
  encode "TEXT" }

type integer myint2 with {
  variant "BEGIN('<myint_dummy>')"
  variant "END('</myint_dummy>')"
  variant "TEXT_CODING(length=128;leading0=true)"
  encode "TEXT" }

type integer myint3 with {
  variant "BEGIN('<myint_super>')"
  variant "END('</myint_super>')"
  encode "TEXT" }

type integer myint4 with {
  variant "TEXT_CODING(length=256)"
  variant "BEGIN('<myint_pad>')"
  variant "END('</myint_pad>')"
  encode "TEXT" }

type record rec_text {
  myint1 int1,
  myint1 int2,
  myint2 int3 optional,
  myint3 int4 optional,
  myint4 int5 optional
} with {
  variant "BEGIN('<rec_text>')"
  // `variant "SEPARATOR(',')"' is not necessary if the fields can be found
  // unambigously.
  variant "END('</rec_text>')"
  encode "TEXT" }

<TTCN_TC:EXEC>
  const integer a := 214748364799
  const integer b := 214748364788
  const integer c := 0
  // Implicit `omit' would be great.
  var rec_text myrec1 := {int1 := 214748364799, int2 := 214748364788, int3 := omit, int4 := omit, int5 := omit}
  var rec_text myrec2 := {214748364799, 214748364788, omit, omit, omit}
  var rec_text myrec3 := {214748364799, 0, omit, omit, omit}
  var rec_text myrec4 := {int1 := 214748364799, int2 := 0, int3 := omit, int4 := omit, int5 := omit}
  var rec_text myrec5 := {int1 := 0, int2 := 214748364788, int3 := omit, int4 := omit, int5 := omit}
  var rec_text myrec6 := {0, 214748364788, omit, omit, omit}
  var rec_text myrec7 := {0, 0, omit, omit, omit}
  var rec_text myrec8 := {int1 := 0, int2 := 0, int3 := omit, int4 := omit, int5 := omit}
  var rec_text myrec9 := {int1 := a, int2 := b, int3 := omit, int4 := omit, int5 := omit}
  var rec_text myrec10 := {a, b, omit, omit, omit}  
  // The original `sprintf' encoder encodes negative values `-' <padding>
  // `0123456'.  We should work similarly.
  var rec_text myrec11 := {
    int1 := -11111111111111111111111111111,
    int2 := 22222222222222222222222222222, 
    int3 := -33333333333333333333333333333,
    int4 := 2147483648,
    int5 := -2147483648 }
  var rec_text myrec12 := {int1 := 0, int2 := 0, int3 := 0, int4 := -1111111111111111111111111111111, int5 := -1234567891011121314151617181920}
  var rec_text myrec13 := {-0, -0, -0, -0, -0}
  var rec_text myrec14 := {-0, -1, 1234567891011121314151617181920, -1111111111111111111111111111111, -0}
  var rec_text myrec15 := {int1 := 1111111111111111111111111111111, int2 := -1234567891011121314151617181920, int3 := 0, int4 := -0, int5 := -111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111}  
  var charstring ret_val
  ret_val := enc_text(myrec1)
  if (dec_text(ret_val) == myrec1) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 214748364799, int2 := 214748364788, int3 := omit, int4 := omit, int5 := omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec2)
  if (dec_text(ret_val) == myrec2) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {214748364799, 214748364788, omit, omit, omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec3)
  if (dec_text(ret_val) == myrec3) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {214748364799, 0, omit, omit, omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec4)
  if (dec_text(ret_val) == myrec4) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 214748364799, int2 := 0, int3 := omit, int4 := omit, int5 := omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec5)
  if (dec_text(ret_val) == myrec5) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 0, int2 := 214748364788, int3 := omit, int4 := omit, int5 := omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec6)
  if (dec_text(ret_val) == myrec6) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {0, 214748364788, omit, omit, omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec7)
  if (dec_text(ret_val) == myrec7) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {0, 0, omit, omit, omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec8)
  if (dec_text(ret_val) == myrec8) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 0, int2 := 0, int3 := omit, int4 := omit, int5 := omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec9)
  if (dec_text(ret_val) == myrec9) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := a, int2 := b, int3 := omit, int4 := omit, int5 := omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec10)
  if (dec_text(ret_val) == myrec10) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {a, b, omit, omit, omit}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec11)
  if (dec_text(ret_val) == myrec11) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := -11111111111111111111111111111, int2 := 22222222222222222222222222222, int3 := -33333333333333333333333333333, int4 := 2147483648, int5 := -2147483648}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec12)
  if (dec_text(ret_val) == myrec12) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 0, int2 := 0, int3 := 0, int4 := -1111111111111111111111111111111, int5 := -1234567891011121314151617181920}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec13)
  if (dec_text(ret_val) == myrec13) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {-0, -0, -0, -0, -0}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec14)
  if (dec_text(ret_val) == myrec14) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {-0, -1, 1234567891011121314151617181920, -1111111111111111111111111111111, -0}) { setverdict(pass) } else { setverdict(fail) }
  ret_val := enc_text(myrec15)
  if (dec_text(ret_val) == myrec15) { setverdict(pass) } else { setverdict(fail) }
  if (dec_text(ret_val) == {int1 := 1111111111111111111111111111111, int2 := -1234567891011121314151617181920, int3 := 0, int4 := -0, int5 := -111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111}) { setverdict(pass) } else { setverdict(fail) }

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Sliding encoding/decoding of big integers
.*---------------------------------------------------------------------*
:xmp tab=0.


<TC - big integers: sliding encoding/decoding of big integers>
<STATIC>

external function dec_text_sliding(inout charstring r, out myint5 s) return integer 
  with { extension "prototype(sliding) decode(TEXT) errorbehavior(ALL:WARNING)" }

type integer myint5 with { variant "TEXT_CODING(length=25)" }

<TTCN_TC:EXEC>
  var myint5 decoded
  var charstring encoded := "  12345678910111213141516    -11111111111111111111"
  var integer ret_val
  var template integer intt := 12345678910111213141516
  ret_val := dec_text_sliding(encoded, decoded)
  if (ret_val == 0 and decoded == 12345678910111213141516) {setverdict(pass)}
  else {setverdict(fail)}
  ret_val := dec_text_sliding(encoded, decoded)
  if (ret_val == 0 and decoded == -11111111111111111111) {setverdict(pass)}
  else {setverdict(fail)}
  ret_val := dec_text_sliding(encoded, decoded)
  if (match(12345678910111213141516, intt)) {setverdict(pass)}
  else {setverdict(fail)}

<RESULT>
Overall verdict: pass
<END_TC>

:exmp.
.*---------------------------------------------------------------------*
:h1.REFERENCES
.*---------------------------------------------------------------------*
:nl. Requirement specification(s):
:nl.-------------------------------
:list.
:li. 3/ETH/RUS-2003:0087 Uen - Requirement Specification for TITAN's TTCN-3 Semantic Analyser
:elist.

:etext.
