.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Beres, Szabolcs
.*   Delic, Adam
.*   Kovacs, Ferenc
.*   Szabados, Kristof
.*
.******************************************************************************/
:text.
:lang eng.
.*
:docname.Test Description
:docno.8/152 91-CRL 113 200/5 Uen
:rev.C
:date.2015-04-27
.*
:prep.ETH/XZR Kristof Szabados (+36 1 437 7256)
:appr.ETH/XZ (Roland Gecse)
:checked.ETHBAAT
.*
:title.Test Description - BER coder
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.

This TD contains unified test cases related to TTCN3 Executor's BER coder function.
The original test cases can be found in the BER_EncDec_TD.script file.
The reason for the unification was to get a really fast version of the tests.

:exmp.

:p.:us.Revision Information:eus.

:xmp nokeep.
:us.History:eus.

REV   DATE         PREPARED   CHANGE
===   ==========   ========   ======
A     2003-10-31   ETHEKR     New document
B     2007-03-06   EDMDELI    Implicit message encoding
C     2007-03-21   EJNOSZA    Bugfix in a testcase for implicit msg. enc.
D     2008-10-01   EFERKOV    Big integers
E     2010-01-18   EKRISZA    Updated for TITAN R8C
F     2011-06-18   EKRISZA    Added tests for errors
A     2011-12-12   EKRISZA     Updated for release
PB1   2011-01-30   ETHBAAT    Editorial changes

:exmp.


.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester

:exmp.
:np.
.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Testing FIELDLENGTH Attribute
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN, (unified test)
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. DER + CER coding without AUTOMATIC TAGGING (unified test)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN, (unified test)>

<STATIC:ASN>

TempA

DEFINITIONS ::=

BEGIN

  IMPORTS;

  BERPDU1 ::= BOOLEAN
  BERPDU2 ::= [0] EXPLICIT BOOLEAN
  BERPDU3 ::= [PRIVATE 1] EXPLICIT BOOLEAN
  BERPDU4 ::= [APPLICATION 2] EXPLICIT BOOLEAN
  BERPDU5 ::= [0] IMPLICIT BOOLEAN
  BERPDU6 ::= [PRIVATE 1] IMPLICIT BOOLEAN
  BERPDU7 ::= [APPLICATION 2] IMPLICIT BOOLEAN

  BERPDU8 ::= INTEGER
  BERPDU9 ::= [0] EXPLICIT INTEGER
  BERPDU10 ::= [PRIVATE 1] EXPLICIT INTEGER
  BERPDU11 ::= [APPLICATION 2] EXPLICIT INTEGER
  BERPDU12 ::= [0] IMPLICIT INTEGER
  BERPDU13 ::= [PRIVATE 1] IMPLICIT INTEGER
  BERPDU14 ::= [APPLICATION 2] IMPLICIT INTEGER
  BERPDU15 ::= [30] EXPLICIT INTEGER
  BERPDU16 ::= [31] EXPLICIT INTEGER
  BERPDU17 ::= [127] EXPLICIT INTEGER
  BERPDU18 ::= [128] EXPLICIT INTEGER
  BERPDU19 ::= [16383] EXPLICIT INTEGER
  BERPDU20 ::= [16384] EXPLICIT INTEGER

  BERPDU21 ::= ENUMERATED {first(-5), second(0), third(9)}
  BERPDU22 ::= ENUMERATED {first, second, third}
  BERPDU23 ::= ENUMERATED {first, second(0),third}
  BERPDU24 ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
  BERPDU25 ::= [21] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
  BERPDU26 ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
  BERPDU27 ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

  BERPDU28 ::= REAL
  BERPDU29 ::= [0] IMPLICIT REAL
  BERPDU30 ::= [0] EXPLICIT REAL

  BERPDU31 ::= BIT STRING
  BERPDU32 ::= [0] IMPLICIT BIT STRING
  BERPDU33 ::= [0] EXPLICIT BIT STRING

  BERPDU34 ::= OCTET STRING
  BERPDU35 ::= [0] IMPLICIT OCTET STRING
  BERPDU36 ::= [0] EXPLICIT OCTET STRING
  BERPDU37 ::= NULL
  BERPDU38 ::= [0] EXPLICIT NULL
  BERPDU39 ::= [PRIVATE 1] EXPLICIT NULL
  BERPDU40 ::= [APPLICATION 2] EXPLICIT NULL
  BERPDU41 ::= [0] IMPLICIT NULL
  BERPDU42 ::= [PRIVATE 1] IMPLICIT NULL
  BERPDU43 ::= [APPLICATION 2] IMPLICIT NULL

  BERPDU44 ::= SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

  BERPDU45 ::= SEQUENCE
      {   
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

  BERPDU48 ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }

  BERPDU49 ::= SEQUENCE
      {   
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }

  BERPDU50 ::= [0] SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

  BERPDU54 ::= [0] SEQUENCE
      {   
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }

  BERPDU65 ::= SEQUENCE
      {   
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,
	c   INTEGER OPTIONAL

      }

  BERPDU67 ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }

  myOBJID-67 OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}

  BERPDU69 ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	--e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	l   SET { x3 BIT STRING,
		  y3 NULL},
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }

  myOBJID-69 OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}

  BERPDU71 ::= SEQUENCE OF INTEGER
  BERPDU72 ::= SEQUENCE OF BOOLEAN
  BERPDU73 ::= SEQUENCE OF OCTET STRING
  BERPDU74 ::= SEQUENCE OF SEQUENCE {a INTEGER, b BOOLEAN}
  BERPDU75 ::= SEQUENCE OF SET {a INTEGER, b BOOLEAN} 
  BERPDU76 ::= SEQUENCE OF SEQUENCE OF INTEGER
  BERPDU77 ::= SEQUENCE OF CHOICE{a INTEGER, b BOOLEAN}
  BERPDU78 ::= SEQUENCE OF SET OF INTEGER
  BERPDU79 ::= [0] SEQUENCE OF BOOLEAN
  BERPDU82 ::= SET
   {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
   }
 BERPDU83 ::= SET 
  {   
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
  }
  BERPDU84 ::= SET
      {   
	
	c   INTEGER OPTIONAL,
	b   BOOLEAN DEFAULT TRUE
      }


  myBooleanValue1-1 BERPDU1 ::= TRUE 
  myBooleanValue2-1 BERPDU1 ::= FALSE 

  myBooleanValue1-2 BERPDU2 ::= TRUE 
  myBooleanValue1-3 BERPDU3 ::= TRUE

  myBooleanValue1-4 BERPDU4 ::= TRUE 
  myBooleanValue1-5 BERPDU5 ::= TRUE
  myBooleanValue1-6 BERPDU6 ::= FALSE 
  myBooleanValue2-6 BERPDU6 ::= TRUE
  myBooleanValue1-7 BERPDU6 ::= FALSE 
  myBooleanValue2-7 BERPDU6 ::= TRUE

  b8-8 BERPDU8 ::= 5
  b9-8 BERPDU8 ::= 0
  b10-8 BERPDU8 ::= 127
  b11-8 BERPDU8 ::= -128
  b12-8 BERPDU8 ::= -5
  b13-8 BERPDU8 ::= 128
  b14-8 BERPDU8 ::= -129

  b8-9  BERPDU9 ::= 5
  b9-9  BERPDU9 ::= 0
  b10-9 BERPDU9 ::= 127
  b11-9 BERPDU9 ::= -128
  b12-9 BERPDU9 ::= -5
  b13-9 BERPDU9 ::= 128
  b14-9 BERPDU9 ::= -129 

  b8-10  BERPDU10 ::= 5
  b9-10  BERPDU10 ::= 0
  b10-10 BERPDU10 ::= 127
  b11-10 BERPDU10 ::= -128
  b12-10 BERPDU10 ::= -5
  b13-10 BERPDU10 ::= 128
  b14-10 BERPDU10 ::= -129

  b8-11  BERPDU11 ::= 5
  b9-11  BERPDU11 ::= 0
  b10-11 BERPDU11 ::= 127
  b11-11 BERPDU11 ::= -128
  b12-11 BERPDU11 ::= -5
  b13-11 BERPDU11 ::= 128
  b14-11 BERPDU11 ::= -129

  b8-12  BERPDU12 ::= 5
  b9-12  BERPDU12 ::= 0
  b10-12 BERPDU12 ::= 127
  b11-12 BERPDU12 ::= -128
  b12-12 BERPDU12 ::= -5
  b13-12 BERPDU12 ::= 128
  b14-12 BERPDU12 ::= -129

  b8-13  BERPDU13 ::= 5
  b9-13  BERPDU13 ::= 0
  b10-13 BERPDU13 ::= 127
  b11-13 BERPDU13 ::= -128
  b12-13 BERPDU13 ::= -5
  b13-13 BERPDU13 ::= 128
  b14-13 BERPDU13 ::= -129

  b8-14  BERPDU14 ::= 5
  b9-14  BERPDU14 ::= 0
  b10-14 BERPDU14 ::= 127
  b11-14 BERPDU14 ::= -128
  b12-14 BERPDU14 ::= -5
  b13-14 BERPDU14 ::= 128
  b14-14 BERPDU14 ::= -129

  b2-15 BERPDU15 ::= 5

  b7-24 BERPDU24 ::= first
  b8-24 BERPDU24 ::= third
  b9-24 BERPDU24 ::= fourth
  b10-24 BERPDU24 ::= fifth
  b11-24 BERPDU24 ::= sixth
  b12-24 BERPDU24 ::= second

  b2-26 BERPDU26 ::= first
  b3-26 BERPDU26 ::= second
  b4-26 BERPDU26 ::= third
  b5-26 BERPDU26 ::= fourth
  b6-26 BERPDU26 ::= fifth
  b7-26 BERPDU26 ::= sixth

  b1-27 BERPDU27 ::= first
  b2-27 BERPDU27 ::= second
  b3-27 BERPDU27 ::= third
  b4-27 BERPDU27 ::= fourth
  b5-27 BERPDU27 ::= fifth
  b6-27 BERPDU27 ::= sixth
 
  b1-28 BERPDU28 ::= 0
  b2-28 BERPDU28 ::= 0.0
  b3-28 BERPDU28 ::= 0E0
  b4-28 BERPDU28 ::= 0.0E0
  b5-28 BERPDU28 ::= 0e0
  b6-28 BERPDU28 ::= 0.0e0
  b7-28 BERPDU28 ::= 0E+0
  b8-28 BERPDU28 ::= 0.0E+0
  b9-28 BERPDU28 ::=  0e+0
  b10-28 BERPDU28 ::= 0.0e+0
  b11-28 BERPDU28 ::= 0E-0
  b12-28 BERPDU28 ::= 0.0E-0
  b13-28 BERPDU28 ::= 0e-0
  b14-28 BERPDU28 ::= 0.0e-0
  b15-28 BERPDU28 ::= 1
  b16-28 BERPDU28 ::= 1e0
  b17-28 BERPDU28 ::= 1E0
  b18-28 BERPDU28 ::= 1.0e0
  b19-28 BERPDU28 ::= 1.0E0
  b20-28 BERPDU28 ::= 1e+0
  b21-28 BERPDU28 ::= 1E+0
  b22-28 BERPDU28 ::= 1.0e+0
  b23-28 BERPDU28 ::= 1.0E+0
  b24-28 BERPDU28 ::= 1e-0
  b25-28 BERPDU28 ::= 1E-0
  b26-28 BERPDU28 ::= 1.0e-0
  b27-28 BERPDU28 ::= 1.0E-0
  b28-28 BERPDU28 ::= 2
  b29-28 BERPDU28 ::= 2.0
  b30-28 BERPDU28 ::= -1
  b31-28 BERPDU28 ::= -1e0
  b32-28 BERPDU28 ::= -1E0
  b33-28 BERPDU28 ::= -1.0e0
  b34-28 BERPDU28 ::= -1.0E0
  b35-28 BERPDU28 ::= -1e+0
  b36-28 BERPDU28 ::= -1E+0
  b37-28 BERPDU28 ::= -1.0e+0
  b38-28 BERPDU28 ::= -1.0E+0
  b39-28 BERPDU28 ::= -1e-0
  b40-28 BERPDU28 ::= -1E-0
  b41-28 BERPDU28 ::= -1.0e-0
  b42-28 BERPDU28 ::= -1.0E-0
  b43-28 BERPDU28 ::= -1.0
  b44-28 BERPDU28 ::= 1.000
  b45-28 BERPDU28 ::= -1.000
  b46-28 BERPDU28 ::= 12
  b47-28 BERPDU28 ::= 12.0
  b48-28 BERPDU28 ::= 12.0E0
  b49-28 BERPDU28 ::= 1.2E1
  b50-28 BERPDU28 ::= 0.12E2
  b51-28 BERPDU28 ::= 1.2E1
  b52-28 BERPDU28 ::= 0.12E2
  b53-28 BERPDU28 ::= 0.34
  b54-28 BERPDU28 ::= 0.344
  b55-28 BERPDU28 ::= 0.345
  b56-28 BERPDU28 ::= 0.034
  b57-28 BERPDU28 ::= 0.0034
  b58-28 BERPDU28 ::= 0.304
  b59-28 BERPDU28 ::= 0.1234567890
  b60-28 BERPDU28 ::= 0.123456789
  b61-28 BERPDU28 ::= 0.0123456789
  b62-28 BERPDU28 ::= 123456789.0
  b63-28 BERPDU28 ::= 123456789
  b64-28 BERPDU28 ::= 1234567890
  b65-28 BERPDU28 ::= 1234567890.0
  b66-28 BERPDU28 ::= 1234567890.00
  b67-28 BERPDU28 ::= 12345678900.0
  b68-28 BERPDU28 ::= 12345678900.0
  b69-28 BERPDU28 ::= 12345678900.00
  b70-28 BERPDU28 ::= -12
  b71-28 BERPDU28 ::= -12.0
  b72-28 BERPDU28 ::= -12.0E0
  b73-28 BERPDU28 ::= -1.2E1
  b74-28 BERPDU28 ::= -0.12E2
  b75-28 BERPDU28 ::= -1.2E1
  b76-28 BERPDU28 ::= -0.12E2
  b77-28 BERPDU28 ::= -0.34
  b78-28 BERPDU28 ::= -0.344
  b79-28 BERPDU28 ::= -0.345
  b80-28 BERPDU28 ::= -0.034
  b81-28 BERPDU28 ::= -0.0034
  b82-28 BERPDU28 ::= -0.304
  b83-28 BERPDU28 ::= -0.1234567890
  b84-28 BERPDU28 ::= -0.123456789
  b85-28 BERPDU28 ::= -0.0123456789
  b86-28 BERPDU28 ::= -123456789.0
  b87-28 BERPDU28 ::= -123456789
  b88-28 BERPDU28 ::= -1234567890
  b89-28 BERPDU28 ::= -1234567890.0
  b90-28 BERPDU28 ::= -1234567890.00
  b91-28 BERPDU28 ::= -12345678900.0
  b92-28 BERPDU28 ::= -12345678900.0
  b93-28 BERPDU28 ::= -12345678900.00
  b94-28 BERPDU28 ::= PLUS-INFINITY
  b95-28 BERPDU28 ::= MINUS-INFINITY
  
  b-29 BERPDU29 ::= 1
  b-30 BERPDU30 ::= 1

  b6-31 BERPDU31 ::= 
'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H
b7-31 BERPDU31 ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H
b8-31 BERPDU31 ::= ''B
b9-31 BERPDU31 ::='1'B
b10-31 BERPDU31 ::='11'B
b11-31 BERPDU31 ::='1010101'B
b12-31 BERPDU31 ::='10101011010101'B
b13-31 BERPDU31 ::='10101010'B
b14-31 BERPDU31 ::='1010101010101010'B
b15-31 BERPDU31 ::='111100001'B
b16-31 BERPDU31 ::='111100001111100001'B
b17-31 BERPDU31 ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H 
b18-31 BERPDU31 ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H 
b19-31 BERPDU31 ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H 

b-32 BERPDU32 ::='1'B

b5-34 BERPDU34 ::=''H
b6-34 BERPDU34 ::='FFFF'H
b7-34 BERPDU34 ::='FFFFFFFF'H
b8-34 BERPDU34 ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H
b9-34 BERPDU34 ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H
b10-34 BERPDU34 ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H
myIntegerValue-34 BERPDU34 ::='FFFF'H 
myIntegerValue-35 BERPDU35 ::='FFFF'H
myIntegerValue-36 BERPDU36 ::='FFFF'H

myNullValue-37 BERPDU37 ::= NULL
myNullValue-38 BERPDU38 ::= NULL
myNullValue-39 BERPDU39 ::= NULL
myNullValue-40 BERPDU40 ::= NULL
myNullValue-41 BERPDU41 ::= NULL
myNullValue-42 BERPDU42 ::= NULL
myNullValue-43 BERPDU43 ::= NULL



END

<STATIC>


type component Test_CT {}

<TTCN_TC:PURE_EXEC>

import from TempA all;
external function enc_DER_PDU1(in BERPDU1 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU1(in BERPDU1 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

external function enc_DER_PDU2(in BERPDU2 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU2(in BERPDU2 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU3(in BERPDU3 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU3(in BERPDU3 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU4(in BERPDU4 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU4(in BERPDU4 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU5(in BERPDU5 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU5(in BERPDU5 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU6(in BERPDU6 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU6(in BERPDU6 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU7(in BERPDU7 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU7(in BERPDU7 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU8(in BERPDU8 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU8(in BERPDU8 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU9(in BERPDU9 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU9(in BERPDU9 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU10(in BERPDU10 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU10(in BERPDU10 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU11(in BERPDU11 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU11(in BERPDU11 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU12(in BERPDU12 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU12(in BERPDU12 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU13(in BERPDU13 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU13(in BERPDU13 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU14(in BERPDU14 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU14(in BERPDU14 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU15(in BERPDU15 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU15(in BERPDU15 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU16(in BERPDU16 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU16(in BERPDU16 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU17(in BERPDU17 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU17(in BERPDU17 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU18(in BERPDU18 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU18(in BERPDU18 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU19(in BERPDU19 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU19(in BERPDU19 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU20(in BERPDU20 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU20(in BERPDU20 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU21(in BERPDU21 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU21(in BERPDU21 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU22(in BERPDU22 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU22(in BERPDU22 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU23(in BERPDU23 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU23(in BERPDU23 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU24(in BERPDU24 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU24(in BERPDU24 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU25(in BERPDU25 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU25(in BERPDU25 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU26(in BERPDU26 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU26(in BERPDU26 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU27(in BERPDU27 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU27(in BERPDU27 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU28(in BERPDU28 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU28(in BERPDU28 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU29(in BERPDU29 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU29(in BERPDU29 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU30(in BERPDU30 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU30(in BERPDU30 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU31(in BERPDU31 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU31(in BERPDU31 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU32(in BERPDU32 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU32(in BERPDU32 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU33(in BERPDU33 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU33(in BERPDU33 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU34(in BERPDU34 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU34(in BERPDU34 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU35(in BERPDU35 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU35(in BERPDU35 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU36(in BERPDU36 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU36(in BERPDU36 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU37(in BERPDU37 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU37(in BERPDU37 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU38(in BERPDU38 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU38(in BERPDU38 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU39(in BERPDU39 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU39(in BERPDU39 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU40(in BERPDU40 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU40(in BERPDU40 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU41(in BERPDU41 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU41(in BERPDU41 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU42(in BERPDU42 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU42(in BERPDU42 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU43(in BERPDU43 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU43(in BERPDU43 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU44(in BERPDU44 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU44(in BERPDU44 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU45(in BERPDU45 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU45(in BERPDU45 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU48(in BERPDU48 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU48(in BERPDU48 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU49(in BERPDU49 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU49(in BERPDU49 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU50(in BERPDU50 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU50(in BERPDU50 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU54(in BERPDU54 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU54(in BERPDU54 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU65(in BERPDU65 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU65(in BERPDU65 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU67(in BERPDU67 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU67(in BERPDU67 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU71(in BERPDU71 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU71(in BERPDU71 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU72(in BERPDU72 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU72(in BERPDU72 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU73(in BERPDU73 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU73(in BERPDU73 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU74(in BERPDU74 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU74(in BERPDU74 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU75(in BERPDU75 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU75(in BERPDU75 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU76(in BERPDU76 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU76(in BERPDU76 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU77(in BERPDU77 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU77(in BERPDU77 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU78(in BERPDU78 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU78(in BERPDU78 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU79(in BERPDU79 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU79(in BERPDU79 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU82(in BERPDU82 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU82(in BERPDU82 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU83(in BERPDU83 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU83(in BERPDU83 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function enc_DER_PDU84(in BERPDU84 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU84(in BERPDU84 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

external function dec_BER_PDU1(in octetstring stream) return BERPDU1 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU2(in octetstring stream) return BERPDU2 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU3(in octetstring stream) return BERPDU3 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU4(in octetstring stream) return BERPDU4 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU5(in octetstring stream) return BERPDU5 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU6(in octetstring stream) return BERPDU6 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU7(in octetstring stream) return BERPDU7 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU8(in octetstring stream) return BERPDU8 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU9(in octetstring stream) return BERPDU9 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU10(in octetstring stream) return BERPDU10 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU11(in octetstring stream) return BERPDU11 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU12(in octetstring stream) return BERPDU12 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU13(in octetstring stream) return BERPDU13 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU14(in octetstring stream) return BERPDU14 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU15(in octetstring stream) return BERPDU15 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU16(in octetstring stream) return BERPDU16 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU17(in octetstring stream) return BERPDU17 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU18(in octetstring stream) return BERPDU18 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU19(in octetstring stream) return BERPDU19 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU20(in octetstring stream) return BERPDU20 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU21(in octetstring stream) return BERPDU21 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU22(in octetstring stream) return BERPDU22 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU23(in octetstring stream) return BERPDU23 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU24(in octetstring stream) return BERPDU24 with { extension "prototype(convert) decode(BER)" }
//external function dec_BER_PDU25(in octetstring stream) return BERPDU25 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU26(in octetstring stream) return BERPDU26 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU27(in octetstring stream) return BERPDU27 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU28(in octetstring stream) return BERPDU28 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU29(in octetstring stream) return BERPDU29 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU30(in octetstring stream) return BERPDU30 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU31(in octetstring stream) return BERPDU31 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU32(in octetstring stream) return BERPDU32 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU33(in octetstring stream) return BERPDU33 with { extension "prototype(convert) decode(BER:BER_ACCEPT_ALL)" }
external function dec_BER_PDU34(in octetstring stream) return BERPDU34 with { extension "prototype(convert) decode(BER:BER_ACCEPT_ALL)" }
external function dec_BER_PDU35(in octetstring stream) return BERPDU35 with { extension "prototype(convert) decode(BER)" } 
external function dec_BER_PDU36(in octetstring stream) return BERPDU36 with { extension "prototype(convert) decode(BER:BER_ACCEPT_ALL)" } 
external function dec_BER_PDU37(in octetstring stream) return BERPDU37 with { extension "prototype(convert) decode(BER)" } 
external function dec_BER_PDU38(in octetstring stream) return BERPDU38 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU39(in octetstring stream) return BERPDU39 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU40(in octetstring stream) return BERPDU40 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU41(in octetstring stream) return BERPDU41 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU42(in octetstring stream) return BERPDU42 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU43(in octetstring stream) return BERPDU43 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU44(in octetstring stream) return BERPDU44 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU45(in octetstring stream) return BERPDU45 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU48(in octetstring stream) return BERPDU48 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU49(in octetstring stream) return BERPDU49 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU50(in octetstring stream) return BERPDU50 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU54(in octetstring stream) return BERPDU54 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU65(in octetstring stream) return BERPDU65 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU67(in octetstring stream) return BERPDU67 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU69(in octetstring stream) return BERPDU69 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU71(in octetstring stream) return BERPDU71 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU72(in octetstring stream) return BERPDU72 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU73(in octetstring stream) return BERPDU73 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU74(in octetstring stream) return BERPDU74 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU75(in octetstring stream) return BERPDU75 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU76(in octetstring stream) return BERPDU76 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU77(in octetstring stream) return BERPDU77 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU78(in octetstring stream) return BERPDU78 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU79(in octetstring stream) return BERPDU79 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU82(in octetstring stream) return BERPDU82 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU83(in octetstring stream) return BERPDU83 with { extension "prototype(convert) decode(BER)" }
external function dec_BER_PDU84(in octetstring stream) return BERPDU84 with { extension "prototype(convert) decode(BER)" }

//*********************************************
// TESTCASES
//*********************************************

//===========================================
// DER + CER encoding of BOOLEAN TRUE, FALSE
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN() runs on Test_CT {
  const BERPDU1 b1 := true
  const BERPDU1 b2 := false  
  if ((enc_DER_PDU1(b1) == '0101FF'O)and(enc_CER_PDU1(b1) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU1(b2) == '010100'O)and(enc_CER_PDU1(b2) == '010100'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
// DER + CER encoding of BOOLEAN  with Context Specific TAG, EXPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_ContextSpecTag_Explicit() runs on Test_CT {
  const BERPDU2 b := true
  if ((enc_DER_PDU2(b) == 'A0030101FF'O)and(enc_CER_PDU2(b) == 'A0800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
// DER + CER encoding of BOOLEAN  with  PRIVATE  TAG, EXPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_PrivateTag_Explicit() runs on Test_CT {
  const BERPDU3 b := true

 if ((enc_DER_PDU3(b) == 'E1030101FF'O)and(enc_CER_PDU3(b) == 'E1800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

}

//===========================================
// DER + CER encoding of BOOLEAN  with APPLICATION TAG, EXPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_ApplicationTag_Explicit() runs on Test_CT {
  const BERPDU4 b := true
  if ((enc_DER_PDU4(b) == '62030101FF'O)and(enc_CER_PDU4(b) == '62800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
// DER + CER encoding of BOOLEAN  with Context Specific TAG, IMPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_ContextSpecTag_Implicit() runs on Test_CT {
  const BERPDU5 b := false
  if ((enc_DER_PDU5(b) == '800100'O)and(enc_CER_PDU5(b) == '800100'O)) {setverdict(pass);} else {setverdict(fail);}
}
//===========================================
// DER + CER encoding of BOOLEAN  with Private TAG, IMPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_PrivateTag_Implicit() runs on Test_CT {
  const BERPDU6 b := false
  if ((enc_DER_PDU6(b) == 'C10100'O)and(enc_CER_PDU6(b) == 'C10100'O)) {setverdict(pass);} else {setverdict(fail);}
}
//===========================================
// DER + CER encoding of BOOLEAN  with Application TAG, IMPLICIT
//===========================================
testcase tc_DER_CER_encoding_of_BOOLEAN_with_ApplicationTag_Implicit() runs on Test_CT {
  const BERPDU7 b := true
  if ((enc_DER_PDU7(b) == '4201FF'O)and(enc_CER_PDU7(b) == '4201FF'O)) {setverdict(pass);} else {setverdict(fail);}
}
//===========================================
// DECODING BOOLEAN, CER+DER, (unified test)
//===========================================
testcase tc_BER_decoding_of_BOOLEAN() runs on Test_CT {
  if (dec_BER_PDU1('0101FF'O) == myBooleanValue1_1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU1('010100'O) == myBooleanValue2_1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU1('01810101'O) == myBooleanValue1_1){setverdict(pass);} else {setverdict(fail);} //(LENGTH OF LENGTH = 1)
  if (dec_BER_PDU1('0182000100'O) == myBooleanValue2_1){setverdict(pass);} else {setverdict(fail);}//(LENGTH OF LENGTH = 2)
}

//===========================================
// DECODING [0] EXPLICIT BOOLEAN, DER, (unified test)
//===========================================
testcase tc_DER_decoding_of_BOOLEAN_Explicit() runs on Test_CT {
  if (dec_BER_PDU2('A0030101FF'O) == myBooleanValue1_2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU2('A0800101FF0000'O) == myBooleanValue1_2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU2('A081030101FF'O) == myBooleanValue1_2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU2('A0810401810199'O) == myBooleanValue1_2){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
// DECODING  [PRIVATE 1] EXPLICIT BOOLEAN, DER-CER, (unified test)
//===========================================
testcase tc_BER_decoding_of_BOOLEAN_with_PrivateTag_Explicit() runs on Test_CT {
  if (dec_BER_PDU3('E1030101FF'O) == myBooleanValue1_3){setverdict(pass);} else {setverdict(fail);}//DER
  if (dec_BER_PDU3('E1800101FF0000'O) == myBooleanValue1_3){setverdict(pass);} else {setverdict(fail);}//CER
  if (dec_BER_PDU3('E181030101FF'O) == myBooleanValue1_3){setverdict(pass);} else {setverdict(fail);} //long
  if (dec_BER_PDU3('E1810401810199'O) == myBooleanValue1_3){setverdict(pass);} else {setverdict(fail);} //long
}

//===========================================
// DER + CER decoding of BOOLEAN  with APPLICATION TAG, EXPLICIT
//===========================================
testcase tc_DER_CER_decoding_of_BOOLEAN_with_ApplicationTag_Explicit() runs on Test_CT {
  if (dec_BER_PDU4('62030101FF'O) == myBooleanValue1_4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU4('62800101FF0000'O) == myBooleanValue1_4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU4('6281030101FF'O) == myBooleanValue1_4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU4('62810401810199'O) == myBooleanValue1_4){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
// DECODING [0] IMPLICIT BOOLEAN ,(unified)
//===========================================
testcase tc_DER_CER_decoding_of_BOOLEAN_with_ContextSpecTag_Implicit() runs on Test_CT {
  if (dec_BER_PDU5('8001FF'O) == myBooleanValue1_5){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU5('80810133'O) == myBooleanValue1_5){setverdict(pass);} else {setverdict(fail);}  
}
//===========================================
// DECODING  [PRIVATE 1] IMPLICIT BOOLEAN,(unified)
//===========================================
testcase tc_DER_CER_decoding_of_BOOLEAN_with_PrivateTag_Implicit() runs on Test_CT {
  if (dec_BER_PDU6('C10100'O) == myBooleanValue1_6){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU6('C1810105'O) == myBooleanValue2_6){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
// DECODING [APPLICATION 2] IMPLICIT BOOLEAN,(unified) 
//===========================================
testcase tc_DER_CER_decoding_of_BOOLEAN_with_ApplicationTag_Implicit() runs on Test_CT {
  if (dec_BER_PDU7('420100'O) == myBooleanValue1_7){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU7('42810188'O) == myBooleanValue2_7){setverdict(pass);} else {setverdict(fail);}
}



//===========================================
//  DER + CER coding of integer (unified) 
//===========================================

testcase tc_DER_CER_coding_of_INTEGER() runs on Test_CT {
  const BERPDU8 b1_8 := 5
  const BERPDU8 b2_8 := 0
  const BERPDU8 b3_8 := 127
  const BERPDU8 b4_8 := -128
  const BERPDU8 b5_8 := -5
  const BERPDU8 b6_8 := 128
  const BERPDU8 b7_8 := -129
  if ((enc_DER_PDU8(b1_8) == '020105'O)and(enc_CER_PDU8(b1_8) == '020105'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b2_8) == '020100'O)and(enc_CER_PDU8(b2_8) == '020100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b3_8) == '02017F'O)and(enc_CER_PDU8(b3_8) == '02017F'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b4_8) == '020180'O)and(enc_CER_PDU8(b4_8) == '020180'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b5_8) == '0201FB'O)and(enc_CER_PDU8(b5_8) == '0201FB'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b6_8) == '02020080'O)and(enc_CER_PDU8(b6_8) == '02020080'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU8(b7_8) == '0202FF7F'O)and(enc_CER_PDU8(b7_8) == '0202FF7F'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('020105'O) == b8_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02810105'O) == b8_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0282000105'O) == b8_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('020100'O) == b9_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02810100'O) == b9_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0282000100'O) == b9_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02017F'O) == b10_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0281017F'O) == b10_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('028200017F'O) == b10_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('020180'O) == b11_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02810180'O) == b11_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0282000180'O) == b11_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0201FB'O) == b12_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('028101FB'O) == b12_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02820001FB'O) == b12_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02020080'O) == b13_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0281020080'O) == b13_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('028200020080'O) == b13_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('0202FF7F'O) == b14_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('028102FF7F'O) == b14_8){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU8('02820002FF7F'O) == b14_8){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer with Context Specific TAG, EXPLICIT (unified) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag_Explicit() runs on Test_CT {
  const BERPDU9 b1_9 := 5
  const BERPDU9 b2_9 := 0
  const BERPDU9 b3_9 := 127
  const BERPDU9 b4_9 := -128
  const BERPDU9 b5_9 := -5
  const BERPDU9 b6_9 := 128
  const BERPDU9 b7_9 := -129
  if ((enc_DER_PDU9(b1_9) == 'A003020105'O)and(enc_CER_PDU9(b1_9) == 'A0800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b2_9) == 'A003020100'O)and(enc_CER_PDU9(b2_9) == 'A0800201000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b3_9) == 'A00302017F'O)and(enc_CER_PDU9(b3_9) == 'A08002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b4_9) == 'A003020180'O)and(enc_CER_PDU9(b4_9) == 'A0800201800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b5_9) == 'A0030201FB'O)and(enc_CER_PDU9(b5_9) == 'A0800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b6_9) == 'A00402020080'O)and(enc_CER_PDU9(b6_9) == 'A080020200800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU9(b7_9) == 'A0040202FF7F'O)and(enc_CER_PDU9(b7_9) == 'A0800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020105'O) == b8_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0800201050000'O) == b8_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020105'O) == b8_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08103020105'O) == b8_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0810402810105'O) == b8_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020100'O) == b9_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0800201000000'O) == b9_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020100'O) == b9_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08103020100'O) == b9_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0810402810100'O) == b9_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A00302017F'O) == b10_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08002017F0000'O) == b10_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A00302017F'O) == b10_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0810302017F'O) == b10_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A081040281017F'O) == b10_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020180'O) == b11_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0800201800000'O) == b11_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A003020180'O) == b11_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08103020180'O) == b11_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0810402810180'O) == b11_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0030201FB'O) == b12_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0800201FB0000'O) == b12_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0030201FB'O) == b12_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A081030201FB'O) == b12_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08104028101FB'O) == b12_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A00402020080'O) == b13_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A080020200800000'O) == b13_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A00402020080'O) == b13_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0810402020080'O) == b13_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A081050281020080'O) == b13_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0040202FF7F'O) == b14_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0800202FF7F0000'O) == b14_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A0040202FF7F'O) == b14_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A081040202FF7F'O) == b14_9){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU9('A08105028102FF7F'O) == b14_9){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer with PRIVATE TAG, EXPLICIT (unified) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_PrivateTag_Explicit() runs on Test_CT {
  const BERPDU10 b1_10 := 5
  const BERPDU10 b2_10 := 0
  const BERPDU10 b3_10 := 127
  const BERPDU10 b4_10 := -128
  const BERPDU10 b5_10 := -5
  const BERPDU10 b6_10 := 128
  const BERPDU10 b7_10 := -129
  if ((enc_DER_PDU10(b1_10) == 'E103020105'O)and(enc_CER_PDU10(b1_10) == 'E1800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b2_10) == 'E103020100'O)and(enc_CER_PDU10(b2_10) == 'E1800201000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b3_10) == 'E10302017F'O)and(enc_CER_PDU10(b3_10) == 'E18002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b4_10) == 'E103020180'O)and(enc_CER_PDU10(b4_10) == 'E1800201800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b5_10) == 'E1030201FB'O)and(enc_CER_PDU10(b5_10) == 'E1800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b6_10) == 'E10402020080'O)and(enc_CER_PDU10(b6_10) == 'E180020200800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU10(b7_10) == 'E1040202FF7F'O)and(enc_CER_PDU10(b7_10) == 'E1800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E103020105'O) == b8_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E10402810105'O) == b8_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18103020105'O) == b8_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1810402810105'O) == b8_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1800201050000'O) == b8_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E103020100'O) == b9_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E10402810100'O) == b9_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18103020100'O) == b9_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1810402810100'O) == b9_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1800201000000'O) == b9_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E10302017F'O) == b10_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1040281017F'O) == b10_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1810302017F'O) == b10_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E181040281017F'O) == b10_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18002017F0000'O) == b10_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E103020180'O) == b11_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E10402810180'O) == b11_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18103020180'O) == b11_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1810402810180'O) == b11_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1800201800000'O) == b11_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1030201FB'O) == b12_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E104028101FB'O) == b12_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E181030201FB'O) == b12_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18104028101FB'O) == b12_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1800201FB0000'O) == b12_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E10402020080'O) == b13_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1050281020080'O) == b13_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1810402020080'O) == b13_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E181050281020080'O) == b13_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E180020200800000'O) == b13_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1040202FF7F'O) == b14_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E105028102FF7F'O) == b14_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E181040202FF7F'O) == b14_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E18105028102FF7F'O) == b14_10){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU10('E1800202FF7F0000'O) == b14_10){setverdict(pass);} else {setverdict(fail);}

}
//===========================================
//  DER + CER coding of integer with APPLICATION TAG, EXPLICIT (unified)  
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ApplicationTag_Explicit() runs on Test_CT {
  const BERPDU11 b1_11 := 5
  const BERPDU11 b2_11 := 0
  const BERPDU11 b3_11 := 127
  const BERPDU11 b4_11 := -128
  const BERPDU11 b5_11 := -5
  const BERPDU11 b6_11 := 128
  const BERPDU11 b7_11 := -129
  if ((enc_DER_PDU11(b1_11) == '6203020105'O)and(enc_CER_PDU11(b1_11) == '62800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b2_11) == '6203020100'O)and(enc_CER_PDU11(b2_11) == '62800201000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b3_11) == '620302017F'O)and(enc_CER_PDU11(b3_11) == '628002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b4_11) == '6203020180'O)and(enc_CER_PDU11(b4_11) == '62800201800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b5_11) == '62030201FB'O)and(enc_CER_PDU11(b5_11) == '62800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b6_11) == '620402020080'O)and(enc_CER_PDU11(b6_11) == '6280020200800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU11(b7_11) == '62040202FF7F'O)and(enc_CER_PDU11(b7_11) == '62800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6203020105'O) == b8_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('620402810105'O) == b8_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628103020105'O) == b8_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62810402810105'O) == b8_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62800201050000'O) == b8_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6203020100'O) == b9_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('620402810100'O) == b9_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628103020100'O) == b9_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62810402810100'O) == b9_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62800201000000'O) == b9_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('620302017F'O) == b10_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62040281017F'O) == b10_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62810302017F'O) == b10_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6281040281017F'O) == b10_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628002017F0000'O) == b10_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6203020180'O) == b11_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('620402810180'O) == b11_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628103020180'O) == b11_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62810402810180'O) == b11_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62800201800000'O) == b11_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62030201FB'O) == b12_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6204028101FB'O) == b12_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6281030201FB'O) == b12_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628104028101FB'O) == b12_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62800201FB0000'O) == b12_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('620402020080'O) == b13_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62050281020080'O) == b13_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62810402020080'O) == b13_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6281050281020080'O) == b13_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6280020200800000'O) == b13_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62040202FF7F'O) == b14_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6205028102FF7F'O) == b14_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('6281040202FF7F'O) == b14_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('628105028102FF7F'O) == b14_11){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU11('62800202FF7F0000'O) == b14_11){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  DER + CER coding of integer with Context Specific TAG, IMPLICIT (unified)
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag_Implicit() runs on Test_CT {
  const BERPDU11 b1_12 := 5
  const BERPDU11 b2_12 := 0
  const BERPDU11 b3_12 := 127
  const BERPDU11 b4_12 := -128
  const BERPDU11 b5_12 := -5
  const BERPDU11 b6_12 := 128
  const BERPDU11 b7_12 := -129
  if ((enc_DER_PDU12(b1_12) == '800105'O)and(enc_CER_PDU12(b1_12) == '800105'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b2_12) == '800100'O)and(enc_CER_PDU12(b2_12) == '800100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b3_12) == '80017F'O)and(enc_CER_PDU12(b3_12) == '80017F'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b4_12) == '800180'O)and(enc_CER_PDU12(b4_12) == '800180'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b5_12) == '8001FB'O)and(enc_CER_PDU12(b5_12) == '8001FB'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b6_12) == '80020080'O)and(enc_CER_PDU12(b6_12) == '80020080'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU12(b7_12) == '8002FF7F'O)and(enc_CER_PDU12(b7_12) == '8002FF7F'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('800105'O) == b8_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('80810105'O) == b8_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('800100'O) == b9_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('80810100'O) == b9_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('8081017F'O) == b10_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('800180'O) == b11_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('80810180'O) == b11_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('8001FB'O) == b12_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('808101FB'O) == b12_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('80020080'O) == b13_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('8081020080'O) == b13_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('8002FF7F'O) == b14_12){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU12('808102FF7F'O) == b14_12){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  DER + CER coding of integer with PRIVATE TAG, IMPLICIT (unified)
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_PrivateTag_Implicit () runs on Test_CT {
  const BERPDU13 b1_13 := 5
  const BERPDU13 b2_13 := 0
  const BERPDU13 b3_13 := 127
  const BERPDU13 b4_13 := -128
  const BERPDU13 b5_13 := -5
  const BERPDU13 b6_13 := 128
  const BERPDU13 b7_13 := -129
  if ((enc_DER_PDU13(b1_13) == 'C10105'O)and(enc_CER_PDU13(b1_13) == 'C10105'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b2_13) == 'C10100'O)and(enc_CER_PDU13(b2_13) == 'C10100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b3_13) == 'C1017F'O)and(enc_CER_PDU13(b3_13) == 'C1017F'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b4_13) == 'C10180'O)and(enc_CER_PDU13(b4_13) == 'C10180'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b5_13) == 'C101FB'O)and(enc_CER_PDU13(b5_13) == 'C101FB'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b6_13) == 'C1020080'O)and(enc_CER_PDU13(b6_13) == 'C1020080'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU13(b7_13) == 'C102FF7F'O)and(enc_CER_PDU13(b7_13) == 'C102FF7F'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C10105'O) == b8_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C1810105'O) == b8_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C10100'O) == b9_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C1810100'O) == b9_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C1017F'O) == b10_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C181017F'O) == b10_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C10180'O) == b11_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C1810180'O) == b11_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C101FB'O) == b12_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C18101FB'O) == b12_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C1020080'O) == b13_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C181020080'O) == b13_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C102FF7F'O) == b14_13){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU13('C18102FF7F'O) == b14_13){setverdict(pass);} else {setverdict(fail);} 
}

//===========================================
//  DER + CER coding of integer with APPLICATION TAG, IMPLICIT (unified) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ApplicationTag_Implicit() runs on Test_CT {
  const BERPDU14 b1_14 := 5
  const BERPDU14 b2_14 := 0
  const BERPDU14 b3_14 := 127
  const BERPDU14 b4_14 := -128
  const BERPDU14 b5_14 := -5
  const BERPDU14 b6_14 := 128
  const BERPDU14 b7_14 := -129
  if ((enc_DER_PDU14(b1_14) == '420105'O)and(enc_CER_PDU14(b1_14) == '420105'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b2_14) == '420100'O)and(enc_CER_PDU14(b2_14) == '420100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b3_14) == '42017F'O)and(enc_CER_PDU14(b3_14) == '42017F'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b4_14) == '420180'O)and(enc_CER_PDU14(b4_14) == '420180'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b5_14) == '4201FB'O)and(enc_CER_PDU14(b5_14) == '4201FB'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b6_14) == '42020080'O)and(enc_CER_PDU14(b6_14) == '42020080'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU14(b7_14) == '4202FF7F'O)and(enc_CER_PDU14(b7_14) == '4202FF7F'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('420105'O) == b8_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('42810105'O) == b8_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('420100'O) == b9_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('42810100'O) == b9_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('42017F'O) == b10_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('4281017F'O) == b10_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('420180'O) == b11_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('42810180'O) == b11_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('4201FB'O) == b12_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('428101FB'O) == b12_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('42020080'O) == b13_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('4281020080'O) == b13_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('4202FF7F'O) == b14_14){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU14('428102FF7F'O) == b14_14){setverdict(pass);} else {setverdict(fail);}   
}
//===========================================
//  DER + CER coding of integer (5) with Context Specific TAG = 30, EXPLICIT (unified)) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag30_Explicit() runs on Test_CT {
  const BERPDU15 b1_15 := 5
  if ((enc_DER_PDU15(b1_15) == 'BE03020105'O)and(enc_CER_PDU15(b1_15) == 'BE800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU15('BE03020105'O) == b2_15){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU15('BE800201050000'O) == b2_15){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer (5) with Context Specific TAG = 31, EXPLICIT (unified)) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag31_Explicit() runs on Test_CT {
  const BERPDU16 b := 5
  if ((enc_DER_PDU16(b) == 'BF1F03020105'O)and(enc_CER_PDU16(b) == 'BF1F800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU16('BF1F03020105'O) == b) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU16('BF1F800201050000'O) == b) {setverdict(pass);} else {setverdict(fail);} 
}

//===========================================
//  DER + CER coding of integer (5) with Context Specific TAG = 127, EXPLICIT (unified)) 
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag127_Explicit() runs on Test_CT {
  const BERPDU17 b := 5
  if ((enc_DER_PDU17(b) == 'BF7F03020105'O)and(enc_CER_PDU17(b) == 'BF7F800201050000'O)) {setverdict(pass);} else {setverdict(fail);} 
  if (dec_BER_PDU17('BF7F03020105'O) == b) {setverdict(pass);} else {setverdict(fail);} //DER
  if (dec_BER_PDU17('BF7F800201050000'O) == b){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer with Context Specific TAG = 128, EXPLICIT  
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag128_Explicit() runs on Test_CT {
  const BERPDU18 b := 5
  if ((enc_DER_PDU18(b) == 'BF810003020105'O)and(enc_CER_PDU18(b) == 'BF8100800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU18('BF8100800201050000'O) == b) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU18('BF810003020105'O) == b) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer with Context Specific TAG = 16383, EXPLICIT (unified)  
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag16383_Explicit() runs on Test_CT {
  const BERPDU19 b := 5
  if ((enc_DER_PDU19(b) == 'BFFF7F03020105'O)and(enc_CER_PDU19(b) == 'BFFF7F800201050000'O)) {setverdict(pass);} else {setverdict(fail);} 
  if (dec_BER_PDU19('BFFF7F03020105'O) == b){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU19('BFFF7F800201050000'O) == b) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of integer with Context Specific TAG = 16384, EXPLICIT (unified)  
//===========================================
testcase  tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag16384_Explicit() runs on Test_CT {
  const BERPDU20 b := 5
  if ((enc_DER_PDU20(b) == 'BF81800003020105'O)and(enc_CER_PDU20(b) == 'BF818000800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU20('BF81800003020105'O) == b){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU20('BF818000800201050000'O) == b) {setverdict(pass);} else {setverdict(fail);}  
}
//===========================================
// DER + CER coding of ENUMERATED  hardcoded positive (unified) 
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_hardcoded_positive() runs on Test_CT {
  const BERPDU21 b1 := third
  const BERPDU21 b2 := first
  const BERPDU21 b3 := second
  if ((enc_DER_PDU21(b1) == '0A0109'O)and(enc_CER_PDU21(b1) == '0A0109'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU21(b2) == '0A01FB'O)and(enc_CER_PDU21(b2) == '0A01FB'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU21(b3) == '0A0100'O)and(enc_CER_PDU21(b3) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of ENUMERATED third, no hardcoding (unified)
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_third_no_hardcoding() runs on Test_CT {
  const BERPDU22 b1 := third
  const BERPDU22 b2 := first
  if ((enc_DER_PDU22(b1) == '0A0102'O)and(enc_CER_PDU22(b1) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU22(b2) == '0A0100'O)and(enc_CER_PDU22(b2) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}
  
}

//===========================================
//  DER + CER coding of ENUMERATED  first (unified)
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_first1() runs on Test_CT {
  const BERPDU23 b1 := first
  const BERPDU23 b2 := second
  const BERPDU23 b3 := third
  if ((enc_DER_PDU23(b1) == '0A0101'O)and(enc_CER_PDU23(b1) == '0A0101'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU23(b2) == '0A0100'O)and(enc_CER_PDU23(b2) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU23(b3) == '0A0102'O)and(enc_CER_PDU23(b3) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}
  
}

//===========================================
//  DER + CER coding of ENUMERATED  first (unified)
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_first2() runs on Test_CT {
  const BERPDU24 b1 := first
  const BERPDU24 b2 := second
  const BERPDU24 b3 := third
  const BERPDU24 b4 := fourth
  const BERPDU24 b5 := fifth
  const BERPDU24 b6 := sixth

  if ((enc_DER_PDU24(b1) == '0A0101'O)and(enc_CER_PDU24(b1) == '0A0101'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU24(b2) == '0A0100'O)and(enc_CER_PDU24(b2) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU24(b3) == '0A0102'O)and(enc_CER_PDU24(b3) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU24(b4) == '0A0103'O)and(enc_CER_PDU24(b4) == '0A0103'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU24(b5) == '0A0105'O)and(enc_CER_PDU24(b5) == '0A0105'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU24(b6) == '0A0106'O)and(enc_CER_PDU24(b6) == '0A0106'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0101'O) ==  b7_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810101'O) ==  b7_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0102'O) ==  b8_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810102'O) ==  b8_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0103'O) ==  b9_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810103'O) ==  b9_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0105'O) ==  b10_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810105'O) ==  b10_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0106'O) ==  b11_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810106'O) ==  b11_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A0100'O) ==  b12_24){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU24('0A810100'O) ==  b12_24){setverdict(pass);} else {setverdict(fail);} 

}
//===========================================
//  DER + CER coding of ENUMERATED , tagged, EXPLICIT 
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_tagged_explicit_6() runs on Test_CT {
  const BERPDU25 b := sixth
  if ((enc_DER_PDU25(b) == 'B5030A0106'O)and(enc_CER_PDU25(b) == 'B5800A01060000'O)) {setverdict(pass);} else {setverdict(fail);}
} 

//===========================================
//  DER + CER coding of ENUMERATED , tagged, IMPLICIT (unified)
//===========================================
testcase  tc_DER_CER_coding_of_enumerated_tagged_implicit() runs on Test_CT {
  const BERPDU26 b1 := sixth
  
  if ((enc_DER_PDU26(b1) == '9F580106'O)and(enc_CER_PDU26(b1) == '9F580106'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580101'O) ==  b2_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810101'O) ==  b2_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580100'O) ==  b3_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810100'O) ==  b3_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580102'O) ==  b4_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810102'O) ==  b4_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580103'O) ==  b5_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810103'O) ==  b5_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580105'O) ==  b6_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810105'O) ==  b6_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F580106'O) ==  b7_26){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU26('9F58810106'O) ==  b7_26){setverdict(pass);} else {setverdict(fail);}
} 

//===========================================
//   DECODING OF EXPLICIT TAGGED ENUMERATED, (unified)
//===========================================
testcase  tc_decoding_of_explicit_tagged_enumerated() runs on Test_CT {
   
   if (dec_BER_PDU27('A0030A0101'O) ==  b1_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01010000'O) ==  b1_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810101'O) ==  b1_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810101'O) ==  b1_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0030A0100'O) ==  b2_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01000000'O) ==  b2_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810100'O) ==  b2_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810100'O) ==  b2_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0030A0102'O) ==  b3_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01020000'O) ==  b3_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810102'O) ==  b3_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810102'O) ==  b3_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0030A0103'O) ==  b4_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01030000'O) ==  b4_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810103'O) ==  b4_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810103'O) ==  b4_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0030A0105'O) ==  b5_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01050000'O) ==  b5_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810105'O) ==  b5_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810105'O) ==  b5_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0030A0106'O) ==  b6_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0800A01060000'O) ==  b6_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A0040A810106'O) ==  b6_27){setverdict(pass);} else {setverdict(fail);}
   if (dec_BER_PDU27('A081040A810106'O) ==  b6_27){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER coding of REAL, (unified)
//===========================================
testcase  tc_CER_DER_coding_of_real() runs on Test_CT {
  if ((enc_DER_PDU28(b1_28) == '0900'O)and(enc_CER_PDU28(b1_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b2_28) == '0900'O)and(enc_CER_PDU28(b2_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b3_28) == '0900'O)and(enc_CER_PDU28(b3_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b4_28) == '0900'O)and(enc_CER_PDU28(b4_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b5_28) == '0900'O)and(enc_CER_PDU28(b5_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b6_28) == '0900'O)and(enc_CER_PDU28(b6_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b7_28) == '0900'O)and(enc_CER_PDU28(b7_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b8_28) == '0900'O)and(enc_CER_PDU28(b8_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b9_28) == '0900'O)and(enc_CER_PDU28(b9_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b10_28) == '0900'O)and(enc_CER_PDU28(b10_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b11_28) == '0900'O)and(enc_CER_PDU28(b11_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b12_28) == '0900'O)and(enc_CER_PDU28(b12_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b13_28) == '0900'O)and(enc_CER_PDU28(b13_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b14_28) == '0900'O)and(enc_CER_PDU28(b14_28) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b15_28) == '090603312E452B30'O)and(enc_CER_PDU28(b15_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b16_28) == '090603312E452B30'O)and(enc_CER_PDU28(b16_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b17_28) == '090603312E452B30'O)and(enc_CER_PDU28(b17_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b18_28) == '090603312E452B30'O)and(enc_CER_PDU28(b18_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b19_28) == '090603312E452B30'O)and(enc_CER_PDU28(b19_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b20_28) == '090603312E452B30'O)and(enc_CER_PDU28(b20_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b21_28) == '090603312E452B30'O)and(enc_CER_PDU28(b21_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b22_28) == '090603312E452B30'O)and(enc_CER_PDU28(b22_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b23_28) == '090603312E452B30'O)and(enc_CER_PDU28(b23_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b24_28) == '090603312E452B30'O)and(enc_CER_PDU28(b24_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b25_28) == '090603312E452B30'O)and(enc_CER_PDU28(b25_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b26_28) == '090603312E452B30'O)and(enc_CER_PDU28(b26_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b27_28) == '090603312E452B30'O)and(enc_CER_PDU28(b27_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b28_28) == '090603322E452B30'O)and(enc_CER_PDU28(b28_28) == '090603322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b29_28) == '090603322E452B30'O)and(enc_CER_PDU28(b29_28) == '090603322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b30_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b30_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b31_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b31_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b32_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b32_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b33_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b33_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b34_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b34_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b35_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b35_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b36_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b36_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b37_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b37_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b38_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b38_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b39_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b39_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b40_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b40_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b41_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b41_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b42_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b42_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b43_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b43_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b44_28) == '090603312E452B30'O)and(enc_CER_PDU28(b44_28) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b45_28) == '0907032D312E452B30'O)and(enc_CER_PDU28(b45_28) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b46_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b46_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b47_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b47_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b48_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b48_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b49_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b49_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b50_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b50_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b51_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b51_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b52_28) == '09070331322E452B30'O)and(enc_CER_PDU28(b52_28) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b53_28) == '09070333342E452D32'O)and(enc_CER_PDU28(b53_28) == '09070333342E452D32'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b54_28) == '0908033334342E452D33'O)and(enc_CER_PDU28(b54_28) == '0908033334342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b55_28) == '0908033334352E452D33'O)and(enc_CER_PDU28(b55_28) == '0908033334352E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b56_28) == '09070333342E452D33'O)and(enc_CER_PDU28(b56_28) == '09070333342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b57_28) == '09070333342E452D34'O)and(enc_CER_PDU28(b57_28) == '09070333342E452D34'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b58_28) == '0908033330342E452D33'O)and(enc_CER_PDU28(b58_28) == '0908033330342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b59_28) == '090E033132333435363738392E452D39'O)and(enc_CER_PDU28(b59_28) == '090E033132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b60_28) == '090E033132333435363738392E452D39'O)and(enc_CER_PDU28(b60_28) == '090E033132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b61_28) == '090F033132333435363738392E452D3130'O)and(enc_CER_PDU28(b61_28) == '090F033132333435363738392E452D3130'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b62_28) == '090E033132333435363738392E452B30'O)and(enc_CER_PDU28(b62_28) == '090E033132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b63_28) == '090E033132333435363738392E452B30'O)and(enc_CER_PDU28(b63_28) == '090E033132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b64_28) == '090D033132333435363738392E4531'O)and(enc_CER_PDU28(b64_28) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b65_28) == '090D033132333435363738392E4531'O)and(enc_CER_PDU28(b65_28) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b66_28) == '090D033132333435363738392E4531'O)and(enc_CER_PDU28(b66_28) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b67_28) == '090D033132333435363738392E4532'O)and(enc_CER_PDU28(b67_28) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b68_28) == '090D033132333435363738392E4532'O)and(enc_CER_PDU28(b68_28) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b69_28) == '090D033132333435363738392E4532'O)and(enc_CER_PDU28(b69_28) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b70_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b70_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b71_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b71_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b72_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b72_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b73_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b73_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b74_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b74_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b75_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b75_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b76_28) == '0908032D31322E452B30'O)and(enc_CER_PDU28(b76_28) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b77_28) == '0908032D33342E452D32'O)and(enc_CER_PDU28(b77_28) == '0908032D33342E452D32'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b78_28) == '0909032D3334342E452D33'O)and(enc_CER_PDU28(b78_28) == '0909032D3334342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b79_28) == '0909032D3334352E452D33'O)and(enc_CER_PDU28(b79_28) == '0909032D3334352E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b80_28) == '0908032D33342E452D33'O)and(enc_CER_PDU28(b80_28) == '0908032D33342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b81_28) == '0908032D33342E452D34'O)and(enc_CER_PDU28(b81_28) == '0908032D33342E452D34'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b82_28) == '0909032D3330342E452D33'O)and(enc_CER_PDU28(b82_28) == '0909032D3330342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b83_28) == '090F032D3132333435363738392E452D39'O)and(enc_CER_PDU28(b83_28) == '090F032D3132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b84_28) == '090F032D3132333435363738392E452D39'O)and(enc_CER_PDU28(b84_28) == '090F032D3132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b85_28) == '0910032D3132333435363738392E452D3130'O)and(enc_CER_PDU28(b85_28) == '0910032D3132333435363738392E452D3130'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b86_28) == '090F032D3132333435363738392E452B30'O)and(enc_CER_PDU28(b86_28) == '090F032D3132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b87_28) == '090F032D3132333435363738392E452B30'O)and(enc_CER_PDU28(b87_28) == '090F032D3132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b88_28) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU28(b88_28) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b89_28) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU28(b89_28) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b90_28) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU28(b90_28) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b91_28) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU28(b91_28) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b92_28) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU28(b92_28) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b93_28) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU28(b93_28) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b94_28) == '090140'O)and(enc_CER_PDU28(b94_28) == '090140'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU28(b95_28) == '090141'O)and(enc_CER_PDU28(b95_28) == '090141'O)) {setverdict(pass);} else {setverdict(fail);} 
}

//===========================================
//  CER + DER encoding of REAL, 1 , IMPLICIT TAG
//===========================================
testcase  tc_CER_DER_coding_of_real_1_implicit() runs on Test_CT {
  if ((enc_DER_PDU29(b_29) == '800603312E452B30'O)and(enc_CER_PDU29(b_29) == '800603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of REAL, 1 , EXPLICIT TAG
//===========================================
testcase  tc_CER_DER_coding_of_real_1_explicit() runs on Test_CT {
  if ((enc_DER_PDU30(b_30) == 'A008090603312E452B30'O)and(enc_CER_PDU30(b_30) == 'A080090603312E452B300000'O)) {setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//   CER + DER coding of BIT STRING, (unified)
//===========================================
testcase  tc_CER_DER_coding_of_bitstring() runs on Test_CT {
 const BERPDU31 b1 := ''B
 const BERPDU31 b2 := '1'B
 const BERPDU31 b3 := '1010101'B
 const BERPDU31 b4 := '10101010'B
 const BERPDU31 b5 := '111100001'B 
   if ((enc_DER_PDU31(b1) == '030100'O)and(enc_CER_PDU31(b1) == '030100'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b2) == '03020780'O)and(enc_CER_PDU31(b2) == '03020780'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b3) == '030201AA'O)and(enc_CER_PDU31(b3) == '030201AA'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b4) == '030200AA'O)and(enc_CER_PDU31(b4) == '030200AA'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b5) == '030307F080'O)and(enc_CER_PDU31(b5) == '030307F080'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b6_31) == '038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)
    and(enc_CER_PDU31(b6_31) == '038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU31(b7_31) == '038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)
    and(enc_CER_PDU31(b7_31) == '2380038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF030200FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('030100'O) == b8_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2303030100'O) == b8_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2306030100030100'O) == b8_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23800301000000'O) == b8_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('03020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('0381020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('230403020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23050381020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2381050381020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238003810207800000'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23080302078003020780'O) == b10_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2306230403020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('030201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('03810201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2304030201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('230503810201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23810503810201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238003810201AA0000'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2308030201AA030201AA'O) == b12_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23062304030201AA'O) == b11_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('030200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('03810200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2304030200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('230503810200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23810503810200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238003810200AA0000'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2308030200AA030200AA'O) == b14_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23062304030200AA'O) == b13_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31( '030307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('03810307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2305030307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('230603810307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23810603810307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238003810307F0800000'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('230A030307F080030307F080'O) == b16_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('23072305030307F080'O) == b15_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b17_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('03830003E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b17_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238203EC038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b17_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('2380038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000'O) == b17_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238207D8038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b18_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b19_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238203F0038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF030200FF'O) == b19_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU31('238203ED038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b19_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU33('A080030207800000'O) == b9_31){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU33('A00403020780'O) == b9_31){setverdict(pass);} else {setverdict(fail);}

}
//===========================================
//  CER + DER coding of BIT STRING, length = 1, IMPLICIT TAG (primitive)
//===========================================
testcase  tc_CER_DER_coding_of_bitstring_length1_implicit() runs on Test_CT {
  const BERPDU32 b := '1'B
  if ((enc_DER_PDU32(b) == '80020780'O)and(enc_CER_PDU32(b) == '80020780'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU32('80020780'O) == b_32){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of BIT STRING, length = 1, EXPLICIT TAG (constructed)
//===========================================
testcase  tc_CER_DER_coding_of_bitstring_length1_explicit() runs on Test_CT {
  const BERPDU33 b := '1'B
  if ((enc_DER_PDU33(b) == 'A00403020780'O)and(enc_CER_PDU33(b) == 'A080030207800000'O)) {setverdict(pass);} else {setverdict(fail);}
  
}

//===========================================
//   CER + DER coding of OCTETSTRING, (unified)
//===========================================
testcase  tc_CER_DER_coding_of_OCTETSTRING() runs on Test_CT {
  const BERPDU34 b1_34 := ''O
  const BERPDU34 b2_34 := 'FFFF'O
  const BERPDU34 b3_34 := 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O
  const BERPDU34 b4_34 := 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O
  if ((enc_DER_PDU34(b1_34) == '0400'O)and(enc_CER_PDU34(b1_34) == '0400'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU34(b2_34) == '0402FFFF'O)and(enc_CER_PDU34(b2_34) == '0402FFFF'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU34(b3_34) == '048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)
  and(enc_CER_PDU34(b3_34) == '048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU34(b4_34) == '048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)
  and(enc_CER_PDU34(b4_34) == '2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

if (dec_BER_PDU34('0400'O) == b5_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('24020400'O) == b5_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('240404000400'O) == b5_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('248004000000'O) == b5_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('0402FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('048102FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('24040402FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('2405048102FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('248105048102FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('24800402FFFF0000'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('24080402FFFF0402FFFF'O) == b7_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('240624040402FFFF'O) == b6_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b8_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('04830003E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b8_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('248203EC048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b8_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000'O) == b8_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('248207D8048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b9_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0401FF0000'O) == b10_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b10_34){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU34('248203ED048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == b10_34){setverdict(pass);} else {setverdict(fail);}

if (dec_BER_PDU36('A0040402FFFF'O) == myIntegerValue_36) {setverdict(pass);} else {setverdict(fail);}

}//tc_

//===========================================
//  CER + DER encoding of OCTETSTRING, IMPLICIT TAG length = 2 (primitive)
//===========================================
testcase  tc_CER_DER_coding_of_OCTETSTRING_implicit_length_2() runs on Test_CT {
  const BERPDU35 b := 'FFFF'O
  if ((enc_DER_PDU35(b) == '8002FFFF'O)and(enc_CER_PDU35(b) == '8002FFFF'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU35('8002FFFF'O) == myIntegerValue_35) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of OCTETSTRING, EXPLICIT TAG length = 2 (primitive)
//===========================================
testcase  tc_CER_DER_coding_of_OCTETSTRING_explicit_length_2() runs on Test_CT {
  const BERPDU36 b := 'FFFF'O
  if ((enc_DER_PDU36(b) == 'A0040402FFFF'O)and(enc_CER_PDU36(b) == 'A0800402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU36('A0800402FFFF0000'O) == myIntegerValue_36) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   DER + CER coding of NULL (unified)
//===========================================
testcase  tc_CER_DER_coding_of_NULL() runs on Test_CT {
  const BERPDU37 b := NULL;
  if ((enc_DER_PDU37(b) == '0500'O)and(enc_CER_PDU37(b) == '0500'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU37('0500'O) == myNullValue_37){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU37('058100'O) == myNullValue_37){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU37('05820000'O) == myNullValue_37){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  DER + CER coding of NULL with Context Specific TAG, EXPLICIT (unified)
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_ContextSpecificTag_Explicit() runs on Test_CT {
  const BERPDU38 b := NULL;
  if ((enc_DER_PDU38(b) == 'A0020500'O)and(enc_CER_PDU38(b) == 'A08005000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU38('A0020500'O) == myNullValue_38){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU38('A08005000000'O) == myNullValue_38){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU38('A0020500'O) == myNullValue_38){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU38('A081020500'O) == myNullValue_38){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU38('A08103058100'O) == myNullValue_38){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER coding of NULL with PRIVATE  TAG, EXPLICIT (unified) 
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_PrivateTag_Explicit() runs on Test_CT {
  const BERPDU39 b := NULL;
  if ((enc_DER_PDU39(b) == 'E1020500'O)and(enc_CER_PDU39(b) == 'E18005000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU39('E1020500'O) == myNullValue_39){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU39('E18005000000'O) == myNullValue_39){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU39('E1020500'O) == myNullValue_39){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU39('E181020500'O) == myNullValue_39){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU39('E18103058100'O) == myNullValue_39){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  DER + CER coding of NULL with APPLICATION TAG, EXPLICIT (unified) 
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_ApplicationTag_Explicit() runs on Test_CT {
  const BERPDU40 b := NULL;
  if ((enc_DER_PDU40(b) == '62020500'O)and(enc_CER_PDU40(b) == '628005000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU40('62020500'O) == myNullValue_40){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU40('628005000000'O) == myNullValue_40){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU40('62020500'O) == myNullValue_40){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU40('6281020500'O) == myNullValue_40){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU40('628103058100'O) == myNullValue_40){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER encoding of NULL with Context Specific TAG, IMPLICIT (unified)
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_ContextSpecificTag_Implicit() runs on Test_CT {
  const BERPDU40 b := NULL;
  if ((enc_DER_PDU41(b) == '8000'O)and(enc_CER_PDU41(b) == '8000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU41('8000'O) == myNullValue_41){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU41('808100'O) == myNullValue_41){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
// DER + CER encoding of NULL with PRIVATE TAG, IMPLICIT (unified)
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_PrivateTag_Implicit() runs on Test_CT {
  const BERPDU42 b := NULL;
  if ((enc_DER_PDU42(b) == 'C100'O)and(enc_CER_PDU42(b) == 'C100'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU42('C100'O) == myNullValue_42){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU42('C18100'O) == myNullValue_42){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  DER + CER encoding of NULL with APPLICATION TAG, IMPLICIT (unified)
//===========================================
testcase tc_CER_DER_coding_of_NULL_with_ApplicationTag_Implicit() runs on Test_CT {
  const BERPDU43 b := NULL;
  if ((enc_DER_PDU43(b) == '4200'O)and(enc_CER_PDU43(b) == '4200'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU43('4200'O) == myNullValue_43){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU43('428100'O) == myNullValue_43){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  CER + DER encoding of SEQUENCE (unified) 
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE() runs on Test_CT {
  const BERPDU44 myValue1 := {b :=  omit,
			 c := omit  }
  const BERPDU44 myValue2 := {b :=  true,
			 c := omit  }
  const BERPDU44 myValue3 := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU44(myValue1) == '3000'O)and(enc_CER_PDU44(myValue1) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU44(myValue2) == '30030101FF'O)and(enc_CER_PDU44(myValue2) == '30800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU44(myValue3) == '30060101FF020105'O)and(enc_CER_PDU44(myValue3) == '30800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('3000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('30800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('30030101FF'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('30800101FF0000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('30060101FF020105'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU44('30800101FF0201050000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   CER + DER encoding of SEQUENCE (one element is equal to Default) (unified)
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneElementIsEqualToDefault() runs on Test_CT {
  const BERPDU45 myValue1 := { b :=  true, c := 5  }
  const BERPDU45 myValue2 := { b :=  false, c := 5  }

  if ((enc_DER_PDU45(myValue1) == '3003020105'O)and(enc_CER_PDU45(myValue1) == '30800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU45(myValue2) == '3006010100020105'O)and(enc_CER_PDU45(myValue2) == '30800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU45('3003020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU45('30800201050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU45('3006010100020105'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU45('30800101000201050000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_bothElementsAreUsed_implicitTagsForElements() runs on Test_CT {
  const BERPDU48 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU48(myValue) == '30079E01FF9F1F0105'O)and(enc_CER_PDU48(myValue) == '30809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU48('30079E01FF9F1F0105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU48('30809E01FF9F1F01050000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_bothElementsAreUsed_explicitTagsForElements() runs on Test_CT {
  const BERPDU49 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU49(myValue) == '300BBE030101FFBF1F03020105'O)and(enc_CER_PDU49(myValue) == '3080BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU49('300BBE030101FFBF1F03020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU49('3080BE800101FF0000BF1F8002010500000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of TAGGED SEQUENCE (both elements are used)
//===========================================
testcase tc_CER_DER_coding_of_taggedSEQUENCE_bothElementsAreUsed() runs on Test_CT {
  const BERPDU50 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU50(myValue) == 'A00830060101FF020105'O)and(enc_CER_PDU50(myValue) == 'A08030800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU50('A00830060101FF020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU50('A08030800101FF02010500000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU50('A00830060101FF020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU50('A08030800101FF02010500000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used)
//===========================================
testcase tc_CER_DER_coding_of_taggedSEQUENCE_bothElementsAreTaggedAndUsed() runs on Test_CT {
  const BERPDU54 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU54(myValue) == 'A00C300AA0030101FFA103020105'O)and(enc_CER_PDU54(myValue) == 'A0803080A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU54('A00C300AA0030101FFA103020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU54('A0803080A0800101FF0000A180020105000000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SEQUENCE with CHOICE element
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCE_withCHOICEelement() runs on Test_CT {
  const BERPDU65 myValue := {b := {x := true},
			 c := 4 
			   }
  if ((enc_DER_PDU65(myValue) == '30060101FF020104'O)and(enc_CER_PDU65(myValue) == '30800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU65('30060101FF020104'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU65('30800101FF0201040000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of SEQUENCE with fields of different types
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_withFieldsOfDifferentTypes() runs on Test_CT {
  const BERPDU67 myValue_67 := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID_67,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  , 
			 m := 
                             { 1 ,2 }   ,  
			 n := 
                             { true, true }  
			 }         
			 
  if ((enc_DER_PDU67(myValue_67) == '305305000101FF0201020A0100090603312E452B30030207800402FFFF06030002031603414243A1030101FF300505000101FF310C03020780090603312E452B30A3083006020101020102A40831060101FF0101FF'O) and(enc_CER_PDU67(myValue_67) == '308005000101FF0201020A0100090603312E452B30030207800402FFFF06030002031603414243A1800101FF0000308005000101FF0000318003020780090603312E452B300000A380308002010102010200000000A48031800101FF0101FF000000000000'O)) 
{setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  DECODING , DER,  SEQUENCE with fields of different types , (unified)
//===========================================
testcase tc_DER_decoding_of_SEQUENCE_withFieldsOfDifferentTypes() runs on Test_CT {
  const BERPDU69 myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID_69,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  , 
			 m := 
                             { 1 ,2 }   ,  
			 n := 
                             { true, true }  
			 }
  if (dec_BER_PDU69('304505000101FF0201020A0100030207800402FFFF06030002031603414243A1030101FF300505000101FF3106030207800500A3083006020101020102A40831060101FF0101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU69('308005000101FF0201020A0100030207800402FFFF06030002031603414243A1800101FF0000308005000101FF000031800302078005000000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of SEQUENCE OF INTEGER (empty) (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFinteger_empty() runs on Test_CT {
  const BERPDU71 myValue := { }
  if ((enc_DER_PDU71(myValue) == '3000'O)and(enc_CER_PDU71(myValue) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU71('3000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU71('30800000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of SEQUENCE OF BOOLEAN (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFBOOLEAN() runs on Test_CT {
  const BERPDU72 myValue := {true, false }
  if ((enc_DER_PDU72(myValue) == '30060101FF010100'O)and(enc_CER_PDU72(myValue) == '30800101FF0101000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU72('30060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU72('30800101FF0101000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   CER + DER encoding of SEQUENCE OF OCTET STRING (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFOCTETSTRING() runs on Test_CT {
  const BERPDU73 myValue := {'FFFF'O, 'AB'O };
  if ((enc_DER_PDU73(myValue) == '30070402FFFF0401AB'O)and(enc_CER_PDU73(myValue) == '30800402FFFF0401AB0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU73('30070402FFFF0401AB'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU73('30800402FFFF0401AB0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SEQUENCE OF SEQUENCE (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFSEQUENCE() runs on Test_CT {
  const BERPDU74 myValue := {
				{
				  a := 5,
				  b := true
				},
				{
				  a := 3,
				  b := false
				}
                       };

  if ((enc_DER_PDU74(myValue) == '301030060201050101FF3006020103010100'O)and(enc_CER_PDU74(myValue) == '308030800201050101FF0000308002010301010000000000'O)) 
  {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU74('301030060201050101FF3006020103010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU74('308030800201050101FF0000308002010301010000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of SEQUENCE OF SET (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFSET() runs on Test_CT {
  const BERPDU75 myValue := {
				{
				  a := 5,
				  b := true
				},
				{
				  a := 3,
				  b := false
				}
                        };
  if ((enc_DER_PDU75(myValue) == '301031060101FF0201053106010100020103'O)and(enc_CER_PDU75(myValue) == '308031800101FF0201050000318001010002010300000000'O)) 
  {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU75('301031060101FF0201053106010100020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU75('308031800101FF0201050000318001010002010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of SEQUENCE OF SEQUENCE OF (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFSEQUENCEOF() runs on Test_CT {
  const BERPDU76 myValue := {
				{
				5,
				6,
				7
				},
				{
				 1,
				 2,
				 3
				}
                        };

  if ((enc_DER_PDU76(myValue) == '301630090201050201060201073009020101020102020103'O)and(enc_CER_PDU76(myValue) == '308030800201050201060201070000308002010102010202010300000000'O)) 
  {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU76('301630090201050201060201073009020101020102020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU76('308030800201050201060201070000308002010102010202010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}


}

//===========================================
//   CER + DER encoding of SEQUENCE OF CHOICE (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFCHOICE() runs on Test_CT {
  const BERPDU77 myValue := {
				{
				  a := 5
				},
				{
				  b := false
				}
                        };
  if ((enc_DER_PDU77(myValue) == '3006020105010100'O)and(enc_CER_PDU77(myValue) == '30800201050101000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU77('3006020105010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU77('30800201050101000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}


//===========================================
//   CER + DER encoding of SEQUENCE OF SETOF (unified)
//===========================================
testcase tc_CER_DER_coding_of_SEQUENCEOFSETOF() runs on Test_CT {
  const BERPDU78 myValue := {
				{
				5,
				6,
				7
				},
				{
				 1,
				 2,
				 3
				}
                        };
   if ((enc_DER_PDU78(myValue) == '301631090201050201060201073109020101020102020103'O)and(enc_CER_PDU78(myValue) == '308031800201050201060201070000318002010102010202010300000000'O)) 
  {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU78('301631090201050201060201073109020101020102020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU78('308031800201050201060201070000318002010102010202010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}


}

//===========================================
//   CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN (unified) 
//===========================================
testcase tc_CER_DER_coding_of_TAGGEDSEQUENCEOFBOOLEAN() runs on Test_CT {
  const BERPDU79 myValue := {true, false }
  if ((enc_DER_PDU79(myValue) == 'A00830060101FF010100'O)and(enc_CER_PDU79(myValue) == 'A08030800101FF01010000000000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU79('A00830060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU79('A08030800101FF01010000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of SET (EMPTY) (unified)
//===========================================
testcase tc_CER_DER_coding_of_SET_empty() runs on Test_CT {
  const BERPDU82 myValue1 := {b :=  omit,
			 c := omit  }
  const BERPDU82 myValue2 := {b :=  true,
			 c := omit  }
  const BERPDU82 myValue3 := {b :=  true,
			 c := 5  }
  const BERPDU82 myValue4 := { c := 5,
			  b := true  }
  if ((enc_DER_PDU82(myValue1) == '3100'O)and(enc_CER_PDU82(myValue1) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU82(myValue2) == '31030101FF'O)and(enc_CER_PDU82(myValue2) == '31800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU82(myValue3) == '31060101FF020105'O)and(enc_CER_PDU82(myValue3) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU82(myValue4) == '31060101FF020105'O)and(enc_CER_PDU82(myValue4) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU82(myValue3) == '31060101FF020105'O)and(enc_CER_PDU82(myValue3) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('3100'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31030101FF'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31800101FF0000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31060101FF020105'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31800101FF0201050000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU82('31060201050101FF'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//  CER + DER encoding of SET (one element is equal to Default) (unified)
//===========================================
testcase tc_CER_DER_coding_of_SET_one_element_is_equal_to_Default() runs on Test_CT {
  const BERPDU83 myValue1 := {b :=  true, c := 5  }
  const BERPDU83 myValue2 := {c := 5, b :=  true }
  const BERPDU83 myValue3 := {b :=  false, c := 5  }
  const BERPDU83 myValue4 := {c := 5, b :=  false  }
  if ((enc_DER_PDU83(myValue1) == '3103020105'O)and(enc_CER_PDU83(myValue1) == '31800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU83(myValue2) == '3103020105'O)and(enc_CER_PDU83(myValue2) == '31800201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU83(myValue3) == '3106010100020105'O)and(enc_CER_PDU83(myValue3) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU83(myValue4) == '3106010100020105'O)and(enc_CER_PDU83(myValue4) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('3103020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('31800201050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('31060201050101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('31800101FF0201050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('3106010100020105'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('31800101000201050000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('3106020105010100'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU83('31800201050101000000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
}
//===========================================
//   encoding of SET (different order2) (one element is not equal to Default)
//===========================================
testcase tc_CER_DER_coding_of_SET_diffOrder_one_element_is_equal_to_Default() runs on Test_CT {
  const BERPDU84 myValue:= {c := 5, b :=  false  }
  if ((enc_DER_PDU84(myValue) == '3106010100020105'O)and(enc_CER_PDU84(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail)};
}

//*********************************************
// CONTROL PART
//*********************************************

control {
  execute(tc_DER_CER_encoding_of_BOOLEAN());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_ContextSpecTag_Explicit());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_PrivateTag_Explicit());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_ApplicationTag_Explicit());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_ContextSpecTag_Implicit());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_PrivateTag_Implicit());
  execute(tc_DER_CER_encoding_of_BOOLEAN_with_ApplicationTag_Implicit());
  execute(tc_BER_decoding_of_BOOLEAN());
  execute(tc_DER_decoding_of_BOOLEAN_Explicit());
  execute(tc_BER_decoding_of_BOOLEAN_with_PrivateTag_Explicit());  
  execute(tc_DER_CER_decoding_of_BOOLEAN_with_ApplicationTag_Explicit());
  execute(tc_DER_CER_decoding_of_BOOLEAN_with_ContextSpecTag_Implicit());
  execute(tc_DER_CER_decoding_of_BOOLEAN_with_PrivateTag_Implicit());
  execute(tc_DER_CER_decoding_of_BOOLEAN_with_ApplicationTag_Implicit());
  execute(tc_DER_CER_coding_of_INTEGER());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_PrivateTag_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ApplicationTag_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag_Implicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_PrivateTag_Implicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ApplicationTag_Implicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag30_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag31_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag127_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag128_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag16383_Explicit());
  execute(tc_DER_CER_coding_of_INTEGER_with_ContextSpecTag16384_Explicit());
  execute(tc_DER_CER_coding_of_enumerated_hardcoded_positive());
  execute(tc_DER_CER_coding_of_enumerated_third_no_hardcoding());
  execute(tc_DER_CER_coding_of_enumerated_first1());
  execute(tc_DER_CER_coding_of_enumerated_first2());
  execute(tc_DER_CER_coding_of_enumerated_tagged_explicit_6());
  execute(tc_DER_CER_coding_of_enumerated_tagged_implicit());
  execute(tc_decoding_of_explicit_tagged_enumerated());
  execute(tc_CER_DER_coding_of_real());
  execute(tc_CER_DER_coding_of_real_1_implicit());
  execute(tc_CER_DER_coding_of_real_1_explicit());
  execute(tc_CER_DER_coding_of_bitstring());
  execute(tc_CER_DER_coding_of_bitstring_length1_implicit());
  execute(tc_CER_DER_coding_of_bitstring_length1_explicit());
  execute(tc_CER_DER_coding_of_OCTETSTRING());
  execute(tc_CER_DER_coding_of_OCTETSTRING_implicit_length_2());
  execute(tc_CER_DER_coding_of_OCTETSTRING_explicit_length_2());
  execute(tc_CER_DER_coding_of_NULL());
  execute(tc_CER_DER_coding_of_NULL_with_ContextSpecificTag_Explicit());
  execute(tc_CER_DER_coding_of_NULL_with_PrivateTag_Explicit());
  execute(tc_CER_DER_coding_of_NULL_with_ApplicationTag_Explicit());
  execute(tc_CER_DER_coding_of_NULL_with_ContextSpecificTag_Implicit());
  execute(tc_CER_DER_coding_of_NULL_with_PrivateTag_Implicit());
  execute(tc_CER_DER_coding_of_NULL_with_ApplicationTag_Implicit());
  execute(tc_CER_DER_encoding_of_SEQUENCE());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneElementIsEqualToDefault());
  execute(tc_CER_DER_encoding_of_SEQUENCE_bothElementsAreUsed_implicitTagsForElements());
  execute(tc_CER_DER_encoding_of_SEQUENCE_bothElementsAreUsed_explicitTagsForElements());
  execute(tc_CER_DER_coding_of_taggedSEQUENCE_bothElementsAreUsed());
  execute(tc_CER_DER_coding_of_taggedSEQUENCE_bothElementsAreTaggedAndUsed());
  execute(tc_CER_DER_coding_of_SEQUENCE_withCHOICEelement());
  execute(tc_CER_DER_encoding_of_SEQUENCE_withFieldsOfDifferentTypes());
  execute(tc_DER_decoding_of_SEQUENCE_withFieldsOfDifferentTypes());
  execute(tc_CER_DER_coding_of_SEQUENCEOFinteger_empty())
  execute(tc_CER_DER_coding_of_SEQUENCEOFBOOLEAN());
  execute(tc_CER_DER_coding_of_SEQUENCEOFOCTETSTRING());
  execute(tc_CER_DER_coding_of_SEQUENCEOFSEQUENCE());
  execute(tc_CER_DER_coding_of_SEQUENCEOFSET());
  execute(tc_CER_DER_coding_of_SEQUENCEOFSEQUENCEOF());
  execute(tc_CER_DER_coding_of_SEQUENCEOFCHOICE());
  execute(tc_CER_DER_coding_of_SEQUENCEOFSETOF());
  execute(tc_CER_DER_coding_of_TAGGEDSEQUENCEOFBOOLEAN());
  execute(tc_CER_DER_coding_of_SET_empty());
  execute(tc_CER_DER_coding_of_SET_one_element_is_equal_to_Default());
  execute(tc_CER_DER_coding_of_SET_diffOrder_one_element_is_equal_to_Default());

}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER coding, AUTOMATIC TAGGING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER coding, AUTOMATIC TAGGING (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS;

BERPDU46 ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

BERPDU47 ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

BERPDU51 ::= [0] SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

BERPDU58 ::= [0] SEQUENCE
      {   
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }

BERPDU59 ::= SEQUENCE
      {   
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

MySeq60 ::= SEQUENCE
      {x INTEGER OPTIONAL,
       y OCTET STRING}

BERPDU60 ::= SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq60
      }

MySeq61 ::= SEQUENCE
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}

BERPDU61 ::= SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq61
      }

MySeq62 ::= SEQUENCE
      {x  INTEGER OPTIONAL,
       y OCTET STRING}
BERPDU62 ::= SEQUENCE
      {   
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq62
      }

MySeq63 ::= SEQUENCE
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}

BERPDU63 ::= SEQUENCE
      {   
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq63
      }

BERPDU64 ::= SEQUENCE
      {   
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,
	c   INTEGER OPTIONAL
	
      }

BERPDU66 ::= SEQUENCE
      {
	a   OCTET STRING,
	b   BOOLEAN, 
	...,
	d   BIT STRING,
	..., 
	c   INTEGER OPTIONAL
      }

BERPDU68 ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},
	
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	
	l   SET { x3 BIT STRING,
		  y3 REAL},
		  
	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }


myOBJID-68 OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}

BERPDU70 ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	l   SET { x3 BIT STRING,
		  y3 NULL},
	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN	  
       }

BERPDU85 ::= SET
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

BERPDU86 ::= SET
      {
	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }

BERPDU87 ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

BERPDU88 ::= SET
      {
	c   INTEGER OPTIONAL,
	b   BOOLEAN DEFAULT TRUE
      }

myOBJID-70 OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}



END

<STATIC>

type component Test_CT {} 

import from TempA all;
external function enc_DER_PDU46(in BERPDU46 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU46(in BERPDU46 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU46(in octetstring stream) return BERPDU46 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU47(in BERPDU47 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU47(in BERPDU47 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU47(in octetstring stream) return BERPDU47 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU51(in BERPDU51 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU51(in BERPDU51 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU51(in octetstring stream) return BERPDU51 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU58(in BERPDU58 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU58(in BERPDU58 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU58(in octetstring stream) return BERPDU58 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU59(in BERPDU59 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU59(in BERPDU59 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU59(in octetstring stream) return BERPDU59 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU60(in BERPDU60 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU60(in BERPDU60 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU60(in octetstring stream) return BERPDU60 with { extension "prototype(convert) decode(BER)" }


external function enc_DER_PDU61(in BERPDU61 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU61(in BERPDU61 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU61(in octetstring stream) return BERPDU61 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU62(in BERPDU62 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU62(in BERPDU62 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU62(in octetstring stream) return BERPDU62 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU63(in BERPDU63 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU63(in BERPDU63 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU63(in octetstring stream) return BERPDU63 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU64(in BERPDU64 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU64(in BERPDU64 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU64(in octetstring stream) return BERPDU64 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU66(in BERPDU66 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU66(in BERPDU66 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU66(in octetstring stream) return BERPDU66 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU68(in BERPDU68 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU68(in BERPDU68 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU68(in octetstring stream) return BERPDU68 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU70(in BERPDU70 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU70(in BERPDU70 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU70(in octetstring stream) return BERPDU70 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU85(in BERPDU85 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU85(in BERPDU85 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU85(in octetstring stream) return BERPDU85 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU86(in BERPDU86 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU86(in BERPDU86 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU86(in octetstring stream) return BERPDU86 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU87(in BERPDU87 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU87(in BERPDU87 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU87(in octetstring stream) return BERPDU87 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU88(in BERPDU88 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU88(in BERPDU88 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU88(in octetstring stream) return BERPDU88 with { extension "prototype(convert) decode(BER)" }

<TTCN_TC:PURE_EXEC>

//*********************************************
// TESTCASES
//*********************************************

//===========================================
//  CER + DER encoding of  SEQUENCE (EMPTY), AUTOMATIC TAGGING (unified) 
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_empty_automaticTagging() runs on Test_CT {
  const BERPDU46 myValue1 := {b :=  omit,
			   c :=  omit  }
  const BERPDU46 myValue2 := {b :=  true,
			   c := omit  }
  const BERPDU46 myValue3 := {b :=  true,
			   c := 5  }

  if ((enc_DER_PDU46(myValue1) == '3000'O)and(enc_CER_PDU46(myValue1) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU46(myValue2) == '30038001FF'O)and(enc_CER_PDU46(myValue2) == '30808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU46(myValue3) == '30068001FF810105'O)and(enc_CER_PDU46(myValue3) == '30808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('3000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('30800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('30038001FF'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('30808001FF0000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('30068001FF810105'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU46('30808001FF8101050000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING (unified)
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneElementIsEqualToDefault_automaticTagging() runs on Test_CT {

  const BERPDU47 myValue1 := {b :=  true,
			   c := 5  }
  const BERPDU47 myValue2 := {b :=  false,
			   c := 5  }
  if ((enc_DER_PDU47(myValue1) == '3003810105'O)and(enc_CER_PDU47(myValue1) == '30808101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU47(myValue2) == '3006800100810105'O)and(enc_CER_PDU47(myValue2) == '30808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU47('3003810105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU47('30808101050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU47('3006800100810105'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU47('30808001008101050000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of TAGGED SEQUENCE (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
//===========================================
testcase tc_CER_DER_encoding_of_taggedSEQUENCE_bothElementsAreUsed_automaticTagging() runs on Test_CT {
  const BERPDU51 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU51(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU51(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
//===========================================
testcase tc_CER_DER_encoding_of_taggedSEQUENCE_bothElementsAreTaggedAndUsed_automaticTagging() runs on Test_CT {
  const BERPDU58 myValue := {b :=  true,
			 c := 5  }
  if ((enc_DER_PDU58(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU58(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU58('A0068001FF810105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU58('A0808001FF8101050000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//    CER + DER encoding of SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneElementisTaggedManually_automaticTagging() runs on Test_CT {
  const BERPDU59 myValue := {b :=  true,
			   c := 5  }
  if ((enc_DER_PDU59(myValue) == '30068501FF020105'O)and(enc_CER_PDU59(myValue) == '30808501FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU59('30068501FF020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU59('30808501FF0201050000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//   CER + DER encoding of SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_COMPONENTSOFused_noManualTags_automaticTagging() runs on Test_CT {
  const BERPDU60 myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }
  if ((enc_DER_PDU60(myValue) == '300C8001FF8101058201068301FF'O)and(enc_CER_PDU60(myValue) == '30808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU60('300C8001FF8101058201068301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU60('30808001FF8101058201068301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SEQUENCE , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneComponentIsManuallyTagged_COMPONENTSOFused_noManualTags_automaticTagging() runs on Test_CT {
  const BERPDU61 myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }
  if ((enc_DER_PDU61(myValue) == '300C8001FF8101058201068301FF'O)and(enc_CER_PDU61(myValue) == '30808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU61('300C8001FF8101058201068301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU61('30808001FF8101058201068301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneBaseElementIsManuallyTagged_COMPONENTSOFused_automaticTagging() runs on Test_CT {
  const BERPDU62 myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

  if ((enc_DER_PDU62(myValue) == '300D8001FF030207800201060401FF'O)and(enc_CER_PDU62(myValue) == '30808001FF030207800201060401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU62('300D8001FF030207800201060401FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU62('30808001FF030207800201060401FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}


}

//===========================================
//   CER + DER encoding of SEQUENCE , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS 
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_oneBaseElementAndOneComponentIsManuallyTagged_COMPONENTSOFused_automaticTagging() runs on Test_CT {
  const BERPDU63 myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }
  if ((enc_DER_PDU63(myValue) == '300D8001FF030207808101060401FF'O)and(enc_CER_PDU63(myValue) == '30808001FF030207808101060401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU63('300D8001FF030207808101060401FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU63('30808001FF030207808101060401FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}


//===========================================
//  CER + DER encoding of SEQUENCE with CHOICE element, AUTOMATIC TAGS 
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_withCHOICEelement_automaticTagging() runs on Test_CT {
  const BERPDU64 myValue := {b := {x := true},
			 c := 4 
			   }
  if ((enc_DER_PDU64(myValue) == '3008A0038001FF810104'O)and(enc_CER_PDU64(myValue) == '3080A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU64('3008A0038001FF810104'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU64('3080A0808001FF00008101040000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//  CER + DER encoding of SEQUENCE with EXTENSION , AUTOMATIC TAGS
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_withExtension_automaticTagging() runs on Test_CT {
  const BERPDU66 myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4 
			}
  if ((enc_DER_PDU66(myValue) == '300D8001FF8101FF83020780820104'O)and(enc_CER_PDU66(myValue) == '30808001FF8101FF830207808201040000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU66('300D8001FF8101FF83020780820104'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU66('30808001FF8101FF830207808201040000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU66('308300000D8001FF8101FF83020780820104'O) == myValue){setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of SEQUENCE with fields of different types, AUTOMATIC TAGS
//===========================================
testcase tc_CER_DER_encoding_of_SEQUENCE_withfieldsOfDifferentTypes_automaticTagging() runs on Test_CT {
const BERPDU68 myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID_68,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  , 
			 m := 
                             { 1 ,2 }   ,  
			 n := 
                             { true, true }  
			 }
  if ((enc_DER_PDU68(myValue) == '304F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)
and(enc_CER_PDU68(myValue) == '308080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) 
{setverdict(pass);} else {setverdict(fail);}


}

//===========================================
//  DECODING , DER,  SEQUENCE with fields of different types , AUTOMATIC TAGS (unified)
//===========================================
testcase tc_DER_encoding_of_SEQUENCE_withFieldsOfDifferentTypes_automaticTagging() runs on Test_CT {
  const BERPDU70 myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID_70,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,
			      y2  := true  }   ,
			 l := {y3 := NULL ,
			       x3 := '1'B   }  , 
			 m := 
                             { 1 ,2 }   ,  
			 n := 
                             { true, true }  
			 }         

 

  if (dec_BER_PDU70('304380008101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF'O) == myValue)
  {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU70('308080008101FF8201028301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue)
  {setverdict(pass);} else {setverdict(fail);}

}

//===========================================
//   CER + DER encoding of  SET (EMPTY), AUTOMATIC TAGGING (unified) 
//===========================================
testcase tc_CER_DER_encoding_of_SET_empty_automaticTagging() runs on Test_CT {
  const BERPDU85 myValue1 := {b :=  omit,
			   c :=  omit  }
  const BERPDU85 myValue2 := {b :=  true,
			   c := omit  }
  const BERPDU85 myValue3 := {
			   c := omit,
			   b :=  true  }
  const BERPDU85 myValue4 := {b :=  true,
			   c := 5  }
  const BERPDU85 myValue5 := {
			   c := 5,
			   b :=  true  }

  if ((enc_DER_PDU85(myValue1) == '3100'O)and(enc_CER_PDU85(myValue1) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU85(myValue2) == '31038001FF'O)and(enc_CER_PDU85(myValue2) == '31808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU85(myValue3) == '31038001FF'O)and(enc_CER_PDU85(myValue3) == '31808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU85(myValue4) == '31068001FF810105'O)and(enc_CER_PDU85(myValue4) == '31808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if ((enc_DER_PDU85(myValue5) == '31068001FF810105'O)and(enc_CER_PDU85(myValue5) == '31808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('3100'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31038001FF'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31808001FF0000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31068001FF810105'O) == myValue4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31808001FF8101050000'O) == myValue4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31068101058001FF'O) == myValue4){setverdict(pass);} else {setverdict(fail);}
  if (dec_BER_PDU85('31808101058001FF0000'O) == myValue4){setverdict(pass);} else {setverdict(fail);}  

}
//===========================================
//   CER + DER encoding of SET (both elements are used)(different order2)  AUTOMATIC TAGGING  
//===========================================
testcase tc_CER_DER_encoding_of_SET_bothElementsUsed_diffOrder_automaticTagging() runs on Test_CT {
  const BERPDU86 myValue := {b :=  true, c := 5  }
  if ((enc_DER_PDU86(myValue) == '31068001058101FF'O)and(enc_CER_PDU86(myValue) == '31808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
}

//===========================================
//  CER + DER encoding of SET (one element is equal to Default) AUTOMATIC TAGGING (unified)  
//===========================================
testcase tc_CER_DER_encoding_of_SET_oneElementIsEqualToDefault_automaticTagging() runs on Test_CT {
 const BERPDU87 myValue1 := {b :=  true,c := 5  }
 const BERPDU87 myValue2 := {b :=  false,c := 5  }
 const BERPDU87 myValue3 := {c := 5,b :=  false  }
 const BERPDU87 myValue4 := {c := 5 , b :=  true }

 if ((enc_DER_PDU87(myValue1) == '3103810105'O)and(enc_CER_PDU87(myValue1) == '31808101050000'O)) {setverdict(pass);} else {setverdict(fail);}
 if ((enc_DER_PDU87(myValue2) == '3106800100810105'O)and(enc_CER_PDU87(myValue2) == '31808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}
 if ((enc_DER_PDU87(myValue3) == '3106800100810105'O)and(enc_CER_PDU87(myValue3) == '31808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}
 if ((enc_DER_PDU87(myValue4) == '3103810105'O)and(enc_CER_PDU87(myValue4) == '31808101050000'O)) {setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('3103810105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('31808101050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('31068001FF810105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('31808101058001FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('3106800100810105'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('31808001008101050000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('3106810105800100'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
 if (dec_BER_PDU87('31808101058001000000'O) == myValue2){setverdict(pass);} else {setverdict(fail);}

}
//===========================================
//  CER + DER encoding of SET (different order2)(one element is not equal to Default) AUTOMATIC TAGGING 
//===========================================
testcase tc_CER_DER_encoding_of_SET_differentOrder_oneElementIsNotEqualToDefault_automaticTagging() runs on Test_CT {
  const BERPDU88 myValue := {b :=  false, c := 5  }
  if ((enc_DER_PDU88(myValue) == '3106800105810100'O)and(enc_CER_PDU88(myValue) == '31808001058101000000'O)) {setverdict(pass);} else {setverdict(fail);}
}

//*********************************************
// CONTROL PART
//*********************************************

control {
  execute(tc_CER_DER_encoding_of_SEQUENCE_empty_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneElementIsEqualToDefault_automaticTagging());
  execute(tc_CER_DER_encoding_of_taggedSEQUENCE_bothElementsAreUsed_automaticTagging());
  execute(tc_CER_DER_encoding_of_taggedSEQUENCE_bothElementsAreTaggedAndUsed_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneElementisTaggedManually_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_COMPONENTSOFused_noManualTags_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneComponentIsManuallyTagged_COMPONENTSOFused_noManualTags_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneBaseElementIsManuallyTagged_COMPONENTSOFused_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_oneBaseElementAndOneComponentIsManuallyTagged_COMPONENTSOFused_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_withCHOICEelement_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_withExtension_automaticTagging());
  execute(tc_CER_DER_encoding_of_SEQUENCE_withfieldsOfDifferentTypes_automaticTagging());
  execute(tc_DER_encoding_of_SEQUENCE_withFieldsOfDifferentTypes_automaticTagging())
  execute(tc_CER_DER_encoding_of_SET_empty_automaticTagging());
  execute(tc_CER_DER_encoding_of_SET_bothElementsUsed_diffOrder_automaticTagging());
  execute(tc_CER_DER_encoding_of_SET_oneElementIsEqualToDefault_automaticTagging());
  execute(tc_CER_DER_encoding_of_SET_differentOrder_oneElementIsNotEqualToDefault_automaticTagging());
}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN

IMPORTS;

BERPDU55 ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }

BERPDU56 ::= [0] SEQUENCE
      {   
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }

BERPDU80 ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;
external function enc_DER_PDU55(in BERPDU55 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU55(in BERPDU55 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU55(in octetstring stream) return BERPDU55 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU56(in BERPDU56 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU56(in BERPDU56 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU56(in octetstring stream) return BERPDU56 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU80(in BERPDU80 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU80(in BERPDU80 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU80(in octetstring stream) return BERPDU80 with { extension "prototype(convert) decode(BER)" }


const BERPDU55 myValue_55 := {b :=  true,
			 c := 5  }
const BERPDU56 myValue_56 := {b :=  true,
			 c := 5  }

const BERPDU80 myValue_80 := {true, false }

<TTCN_TC:EXEC>
//===================================================
//CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
//===================================================
if ((enc_DER_PDU55(myValue_55) == '30079E01FF9F1F0105'O)and(enc_CER_PDU55(myValue_55) == '30809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU55('30079E01FF9F1F0105'O) == myValue_55){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU55('30809E01FF9F1F01050000'O) == myValue_55){setverdict(pass);} else {setverdict(fail);}

//===================================================
// CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
//===================================================
if ((enc_DER_PDU56(myValue_56) == 'A00C300AA0030101FFA103020105'O)and(enc_CER_PDU56(myValue_56) == 'A0803080A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU56('A00C300AA0030101FFA103020105'O) == myValue_56){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU56('A0803080A0800101FF0000A180020105000000000000'O) == myValue_56){setverdict(pass);} else {setverdict(fail);}


//===================================================
// CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING (unified)
//===================================================
if ((enc_DER_PDU80(myValue_80) == 'A00830060101FF010100'O)and(enc_CER_PDU80(myValue_80) == 'A08030800101FF01010000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU80('A00830060101FF010100'O) == myValue_80){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU80('A08030800101FF01010000000000'O) == myValue_80){setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN

IMPORTS;

BERPDU52 ::= SEQUENCE
      {   
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }

BERPDU53 ::= [0] SEQUENCE
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

BERPDU57 ::= [0] SEQUENCE
      {   
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }

BERPDU81 ::= [0] SEQUENCE OF BOOLEAN

BERPDU88 ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }

BERPDU89 ::= SET
      {   	
	c [31] IMPLICIT INTEGER OPTIONAL,
	b [30] IMPLICIT BOOLEAN OPTIONAL
      }

BERPDU90 ::= SET
      { 
        c [31] EXPLICIT INTEGER OPTIONAL,
	b [30] EXPLICIT BOOLEAN OPTIONAL
	
      }

END

<STATIC>

import from TempA all;
external function enc_DER_PDU52(in BERPDU52 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU52(in BERPDU52 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU52(in octetstring stream) return BERPDU52 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU53(in BERPDU53 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU53(in BERPDU53 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU53(in octetstring stream) return BERPDU53 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU57(in BERPDU57 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU57(in BERPDU57 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU57(in octetstring stream) return BERPDU57 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU81(in BERPDU81 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU81(in BERPDU81 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU81(in octetstring stream) return BERPDU81 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU88(in BERPDU88 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU88(in BERPDU88 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU88(in octetstring stream) return BERPDU88 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU89(in BERPDU89 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU89(in BERPDU89 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
//external function dec_BER_PDU89(in octetstring stream) return BERPDU89 with { extension "prototype(convert) decode(BER)" }

external function enc_DER_PDU90(in BERPDU90 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU90(in BERPDU90 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
//external function dec_BER_PDU90(in octetstring stream) return BERPDU90 with { extension "prototype(convert) decode(BER)" }

const BERPDU52 myValue_52 := {b :=  true,c := 5  }
const BERPDU53 myValue_53 := {b :=  true,c := 5  }
const BERPDU57 myValue_57 := {b :=  true,c := 5  }
const BERPDU81 myValue_81 := {true, false }
const BERPDU88 myValue1_88 := {b :=  true, c := 5  }
const BERPDU88 myValue2_88 := { c := 5, b :=  true  }
const BERPDU89 myValue_89 := {b :=  true,c := 5  }
const BERPDU90 myValue_90 := {b :=  true,c := 5  }

<TTCN_TC:EXEC>
//===========================================
//CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
//===========================================
if ((enc_DER_PDU52(myValue_52) == '300BBE030101FFBF1F03020105'O)and(enc_CER_PDU52(myValue_52) == '3080BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU52('300BBE030101FFBF1F03020105'O) == myValue_52){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU52('3080BE800101FF0000BF1F8002010500000000'O) == myValue_52){setverdict(pass);} else {setverdict(fail);}
//===========================================
//CER + DER encoding of TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT
//===========================================
if ((enc_DER_PDU53(myValue_53) == 'A0060101FF020105'O)and(enc_CER_PDU53(myValue_53) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU53('A0060101FF020105'O) == myValue_53){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU53('A0800101FF0201050000'O) == myValue_53){setverdict(pass);} else {setverdict(fail);}

//===========================================
// CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
//===========================================
if ((enc_DER_PDU57(myValue_57) == 'A0068001FF810105'O)and(enc_CER_PDU57(myValue_57) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU57('A0068001FF810105'O) == myValue_57){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU57('A0808001FF8101050000'O) == myValue_57){setverdict(pass);} else {setverdict(fail);}
//===========================================
//  CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING (unified)
//===========================================
if ((enc_DER_PDU81(myValue_81) == 'A0060101FF010100'O)and(enc_CER_PDU81(myValue_81) == 'A0800101FF0101000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU81('A0060101FF010100'O) == myValue_81){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU81('A0800101FF0101000000'O) == myValue_81){setverdict(pass);} else {setverdict(fail);}
//===========================================
//  CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements (unified) 
//===========================================
if ((enc_DER_PDU88(myValue1_88) == '31079E01FF9F1F0105'O)and(enc_CER_PDU88(myValue1_88) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU88(myValue2_88) == '31079E01FF9F1F0105'O)and(enc_CER_PDU88(myValue2_88) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU88('31079E01FF9F1F0105'O) == myValue1_88){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU88('31809E01FF9F1F01050000'O) == myValue1_88){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU88('31079F1F01059E01FF'O) == myValue1_88){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU88('31809F1F01059E01FF0000'O) == myValue1_88){setverdict(pass);} else {setverdict(fail);}
//===========================================
//  CER + DER encoding of SET (different order2) (both elements are used) IMPLICIT TAGS for elements 
//===========================================
if ((enc_DER_PDU89(myValue_89) == '31079E01FF9F1F0105'O)and(enc_CER_PDU89(myValue_89) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
//===========================================
//   CER + DER encoding of SET (different order2)(both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT 
//===========================================
if ((enc_DER_PDU90(myValue_90) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU90(myValue_90) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5 ,
			 b :=  true }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue1) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue2) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31079E01FF9F1F0105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31809E01FF9F1F01050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31079F1F01059E01FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31809F1F01059E01FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2)(both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2)(both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      { 
        c [31] IMPLICIT INTEGER OPTIONAL,  
	b [30] IMPLICIT BOOLEAN OPTIONAL
	
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue1) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue2) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310BBE030101FFBF1F03020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180BE800101FF0000BF1F8002010500000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310BBF1F03020105BE030101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180BF1F800201050000BE800101FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2) (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2) (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {   
	
	c [31] EXPLICIT INTEGER OPTIONAL,
	b [30] EXPLICIT BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5 ,
			 b :=  true }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue1) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue2) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310BBE030101FFBF1F03020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180BE800101FF0000BF1F8002010500000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310BBF1F03020105BE030101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180BF1F800201050000BE800101FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used) (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used) (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue1) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue2) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101FF020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060201050101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101FF020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {   	
	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), AUTOMATIC TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), AUTOMATIC TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue1) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue2) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001058101FF'O)and(enc_CER_PDU(myValue) == 'A0808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue1) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue2) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0060101FF020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0800101FF0201050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0060201050101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0800201050101FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2)(both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2)(both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   
	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue1) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue2) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101FF020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060201050101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used) (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used) (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue1) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue2) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00C310AA0030101FFA103020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0803180A0800101FF0000A180020105000000000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00C310AA103020105A0030101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0803180A1800201050000A0800101FF000000000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order) (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order) (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {   
	b  [1]  BOOLEAN OPTIONAL,
	c  [0]  INTEGER OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA003020105A1030101FF'O)and(enc_CER_PDU(myValue) == 'A0803180A0800201050000A1800101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue1) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue2) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00C310AA0030101FFA103020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0803180A0800101FF0000A180020105000000000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00C310AA103020105A0030101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0803180A1800201050000A0800101FF000000000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   
	b  [1]  BOOLEAN OPTIONAL,
	c  [0]  INTEGER OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA003020105A1030101FF'O)and(enc_CER_PDU(myValue) == 'A0803180A0800201050000A1800101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true  }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue1) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue2) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0068001FF810105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0808001FF8101050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0068101058001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0808101058001FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2)(both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2)(both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   
	
	c  [1]  INTEGER OPTIONAL,
	b  [0]  BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := {
			 c := 5,
			 b :=  true}
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue1) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue2) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0068001FF810105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0808001FF8101050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0068101058001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0808101058001FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {   
	
	c  [0]  INTEGER OPTIONAL,
	b  [1]  BOOLEAN OPTIONAL
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001058101FF'O)and(enc_CER_PDU(myValue) == 'A0808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := 5  }
const BERPDU myValue2 := { c := 5 ,
			  b :=  true }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '31060201058501FF'O)and(enc_CER_PDU(myValue1) == '31800201058501FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '31060201058501FF'O)and(enc_CER_PDU(myValue2) == '31800201058501FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060201058501FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800201058501FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31068501FF020105'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808501FF0201050000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}
BERPDU ::= SET
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '310C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310C8001FF8101058201068301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF8101058201068301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310C8001FF8201068101058301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF8201068101058301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order) ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order) ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {y OCTET STRING,
      
       x INTEGER OPTIONAL
       }



BERPDU ::= SET
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201FF830106'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201FF8301060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}
BERPDU ::= SET
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '310C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310C8001FF8101058201068301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF8101058201068301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310C8301FF8001FF820106810105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808301FF8101058201068001FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , (different order) one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , (different order) one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      {y OCTET STRING,
      x [0] INTEGER OPTIONAL
       }



BERPDU ::= SET
      {   
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201FF830106'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201FF8301060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}
BERPDU ::= SET
      {
        b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310D020106030207800401FF8001FF'O)and(enc_CER_PDU(myValue1) == '3180020106030207800401FF8001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D020106030207800401FF8001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180020106030207800401FF8001FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D030207800201060401FF8001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180030207800201060401FF8001FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , (different order)one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , (different order)one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN


MySeq ::= SET
      {y OCTET STRING,
       x  INTEGER OPTIONAL
       }



BERPDU ::= SET
      {   
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D020106030207800401FF8001FF'O)and(enc_CER_PDU(myValue) == '3180020106030207800401FF8001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}
BERPDU ::= SET
      {   
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310D030207800401FF8001FF810106'O)and(enc_CER_PDU(myValue1) == '3180030207800401FF8001FF8101060000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D030207800401FF8001FF810106'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180030207800401FF8001FF8101060000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D8101060401FF8001FF03020780'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF0401FF030207808101060000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET ,(different order) one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET ,(different order) one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      { y OCTET STRING,
        x  [1] INTEGER OPTIONAL
       }



BERPDU ::= SET
      {   
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D030207800401FF8001FF810106'O)and(enc_CER_PDU(myValue) == '3180030207800401FF8001FF8101060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with CHOICE element, AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with CHOICE element, AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b := {x := true},
			 c := 4}
const BERPDU myValue2 := { c := 4,
			 b := {x := true} }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '3108A0038001FF810104'O)and(enc_CER_PDU(myValue1) == '3180A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '3108A0038001FF810104'O)and(enc_CER_PDU(myValue2) == '3180A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3108A0038001FF810104'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180A0808001FF00008101040000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3108810104A0038001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180810104A0808001FF00000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET with CHOICE element (different order2), AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET with CHOICE element (different order2), AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {   
	
		
	c   INTEGER OPTIONAL,
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL
	
      }

	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 4,
			 b := {x := true} }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3108800104A1038001FF'O)and(enc_CER_PDU(myValue) == '3180800104A1808001FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with CHOICE element, (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with CHOICE element, (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
::=
BEGIN
BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,
	c   INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b := {x := true},
			 c := 4}
const BERPDU myValue2 := {c := 4 ,
			 b := {x := true}}
const BERPDU myValue3 := {b := {y := 'FF'O},
			 c := 4}
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '31060101FF020104'O)and(enc_CER_PDU(myValue1) == '31800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '31060101FF020104'O)and(enc_CER_PDU(myValue2) == '31800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue3) == '31060201040401FF'O)and(enc_CER_PDU(myValue3) == '31800401FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060101FF020104'O) == myValue1) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101FF0201040000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060201040101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800201040101FF0000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060201040401FF'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800401FF0201040000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060401FF020104'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800201040401FF0000'O) == myValue3){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with EXTENSION , AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with EXTENSION , AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SET
      {
	a   OCTET STRING,
	b   BOOLEAN,
	c   INTEGER OPTIONAL,
	...,
	d   BIT STRING
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4 
			   }
const BERPDU myValue2 := {
			  a := 'FF'O,  
			  d := '1'B,
			  b := true,
			  c := 4 
			   }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310D8001FF8101FF82010483020780'O)and(enc_CER_PDU(myValue1) == '31808001FF8101FF820104830207800000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '310D8001FF8101FF82010483020780'O)and(enc_CER_PDU(myValue2) == '31808001FF8101FF820104830207800000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D8001FF8101FF82010483020780'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF8101FF820104830207800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310D8001FF830207808101FF820104'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31808001FF830207808101FF8201040000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318300000D8001FF8101FF82010483020780'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318300000D8101FF820104830207808001FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	
	l   SET { x3 BIT STRING,
		  y3 REAL},
		  
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }

myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  , 
			 m := 
                             { 1 ,2 }   ,  
			 n := 
                             { true, true }  
			 }         
			 


<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31530101FF020102030207800402FFFF05000603000203090603312E452B300A0100300505000101FF310C03020780090603312E452B301603414243A1030101FFA3083006020101020102A40831060101FF0101FF'O)and(enc_CER_PDU(myValue) == '31800101FF020102030207800402FFFF05000603000203090603312E452B300A0100308005000101FF0000318003020780090603312E452B3000001603414243A1800101FF0000A380308002010102010200000000A48031800101FF0101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with fields of different types, AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with fields of different types, AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	l   SET { x3 BIT STRING,
		  y3 REAL},
	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue1 := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,
			      y2  := true  }   ,
			 l := {y3 := 1.0 ,
			       x3 := '1'B   }  ,
			 m := 
                             { 1 ,2 }   ,
			 n := 
                             { true, true }
			 }
const BERPDU myValue2 := {a :=  NULL,
			 c := 2,
			 d := first,
			 e := 1.0,
			  b := true,
			 f := '1'B,
			 g := 'FFFF'O,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,
			      y2  := true  }   ,
			 l := {y3 := 1.0 ,
			       x3 := '1'B   }  ,
			 h := myOBJID,
			 m := 
                             { 1 ,2 }   ,
			 n := 
                             { true, true }
			 }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '314F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)
  and(enc_CER_PDU(myValue1) == '318080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '314F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)
  and(enc_CER_PDU(myValue2) == '318080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGGING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGGING (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '310C020101400102800103C00104'O)and(enc_CER_PDU(myValue1) == '3180020101400102800103C001040000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310C020101400102800103C00104'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180020101400102800103C001040000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
::=
BEGIN
BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>
if ((enc_DER_PDU(myValue1) == '31120201016003020102A003020103E003020104'O)and(enc_CER_PDU(myValue1) == '318002010160800201020000A0800201030000E08002010400000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31120201016003020102A003020103E003020104'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318002010160800201020000A0800201030000E08002010400000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>
if ((enc_DER_PDU(myValue1) == '31120201016003020102A003020103E003020104'O)and(enc_CER_PDU(myValue1) == '318002010160800201020000A0800201030000E08002010400000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31120201016003020102A003020103E003020104'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318002010160800201020000A0800201030000E08002010400000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET including untagged CHOICE (spec example) IMPLICIT TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET including untagged CHOICE (spec example) IMPLICIT TAGS (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {
	      j  [0] INTEGER
	    }
	  }
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3 } }
			 }

<TTCN_TC:EXEC>
if ((enc_DER_PDU(myValue1) == '310BA103820102830101850103'O)and(enc_CER_PDU(myValue1) == '3180850103A18082010200008301010000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('310BA103820102830101850103'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180850103A18082010200008301010000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET including untagged CHOICE (spec example) EXPLICIT TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET including untagged CHOICE (spec example) EXPLICIT TAGS (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {
	      j  [0] INTEGER
	    }
	  }
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := { g := 3 } }
			 }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '3111A105A203020102A303020101A503020103'O)and(enc_CER_PDU(myValue1) == '3180A5800201030000A180A28002010200000000A38002010100000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3111A105A203020102A303020101A503020103'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3180A5800201030000A180A28002010200000000A38002010100000000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , different order, SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , different order, SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {   
	
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }
	
	
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 c := 5, 
			 b :=  true }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201050101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SET with fields of different types , (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SET with fields of different types ,(unified)>

<STATIC:ASN>

TempA
DEFINITIONS
::=
BEGIN
BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	--e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	l   SET { x3 BIT STRING,
		  y3 NULL},
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,
			      y2  := true  }   ,
			 l := {y3 := NULL ,
			       x3 := '1'B   }  ,
			 m := 
                             { 1 ,2 }   ,
			 n := 
                             { true, true }
			 }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31450101FF020102030207800402FFFF050006030002030A01001603414243300505000101FF3106030207800500A1030101FFA3083006020101020102A40831060101FF0101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101FF020102030207800402FFFF050006030002030A01001603414243308005000101FF000031800302078005000000A1800101FF0000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31450101FF0201020A0100030207800402FFFF06030002031603414243A1030101FF300505000101FF3106030207800500A3083006020101020102A40831060101FF0101FF0500'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101FF0201020A0100030207800402FFFF050006030002031603414243A1800101FF0000308005000101FF000031800302078005000000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SET with fields of different types , AUTOMATIC TAGS (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SET with fields of different types , AUTOMATIC TAGS (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	l   SET { x3 BIT STRING,
		  y3 NULL},
	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,
			      y2  := true  }   ,
			 l := {y3 := NULL ,
			       x3 := '1'B   }  ,
			 m := 
                             { 1 ,2 }   ,
			 n := 
                             { true, true }
			 }

<TTCN_TC:EXEC>

if (dec_BER_PDU('314380008101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318080008101FF8201028301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31438101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF8000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318080008201028101FF8301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF INTEGER (empty) (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF INTEGER (empty) (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := { }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '3100'O)and(enc_CER_PDU(myValue1) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3100'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800000'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF BOOLEAN (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF BOOLEAN (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '31060101000101FF'O)and(enc_CER_PDU(myValue) == '31800101000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060101000101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101000101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101FF0101000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF OCTET STRING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF OCTET STRING (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '31070401AB0402FFFF'O)and(enc_CER_PDU(myValue) == '31800401AB0402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31070401AB0402FFFF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800401AB0402FFFF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31070402FFFF0401AB'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800402FFFF0401AB0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SEQUENCE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SEQUENCE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},
				
				{
				  a := 3,
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3110300602010301010030060201050101FF'O)and(enc_CER_PDU(myValue) == '31803080020103010100000030800201050101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3110300602010301010030060201050101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31803080020103010100000030800201050101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311030060201050101FF3006020103010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318030800201050101FF0000308002010301010000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SET (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SET (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},
				
				{
				  a := 3,
				  b := false
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3110310601010002010331060101FF020105'O)and(enc_CER_PDU(myValue) == '31803180010100020103000031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3110310601010002010331060101FF020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31803180010100020103000031800101FF02010500000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311031060101FF0201053106010100020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318031800101FF0201050000318001010002010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},
				{
				  b := false
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3106010100020105'O)and(enc_CER_PDU(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3106010100020105'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800101000201050000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('3106020105010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('31800201050101000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SEQUENCE OF (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SEQUENCE OF (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF SEQUENCE OF INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},
				{
				 1,
				 2,
				 3
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '311630090201010201020201033009020105020106020107'O)and(enc_CER_PDU(myValue) == '318030800201010201020201030000308002010502010602010700000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311630090201010201020201033009020105020106020107'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318030800201010201020201030000308002010502010602010700000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311630090201050201060201073009020101020102020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318030800201050201060201070000308002010102010202010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SET OF (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SET OF (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET OF SET OF INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{5,6,7},
				{1,2,3}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '311631090201010201020201033109020105020106020107'O)and(enc_CER_PDU(myValue) == '318031800201010201020201030000318002010502010602010700000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311631090201010201020201033109020105020106020107'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318031800201010201020201030000318002010502010602010700000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('311631090201050201060201073109020101020102020103'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('318031800201050201060201070000318002010102010202010300000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] SET OF BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A00831060101000101FF'O)and(enc_CER_PDU(myValue) == 'A08031800101000101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101000101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101000101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101FF01010000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET OF BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A00831060101000101FF'O)and(enc_CER_PDU(myValue) == 'A08031800101000101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101000101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101000101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A00831060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A08031800101FF01010000000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] SET OF BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A0060101000101FF'O)and(enc_CER_PDU(myValue) == 'A0800101000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0060101000101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0800101000101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0060101FF010100'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0800101FF0101000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF OCTET STRING 
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING 

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {'FFFF'O, ''O };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '310604000402FFFF'O)and(enc_CER_PDU(myValue) == '318004000402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - NULL (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - NULL (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	
	l   SET { x3 BIT STRING,
		  y3 REAL},
		  
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }

myValue8 BERPDU  ::=  h :   {itu-t(0) recommendation(0) a(2) b(3)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {a :=  NULL}
const BERPDU myValue2 := {b :=  true}
const BERPDU myValue3 := {c :=  2}
const BERPDU myValue4 := {d :=  first}
const BERPDU myValue5 := {e :=  1.0}
const BERPDU myValue6 := {f :=  '1'B}
const BERPDU myValue7 := {g :=   'FFFF'O}

const BERPDU myValue9 := {i :=   "ABC"}
const BERPDU myValue10 := {j := {x1 := true   }  }
const BERPDU myValue11 := {k := {x2 := NULL,
                               y2  := true }    }
const BERPDU myValue12 := {l := {y3 := 1.0 ,
                               x3 := '1'B   }    }
const BERPDU myValue13 := {m := 
                             { 1 ,2 }    }
const BERPDU myValue14 := {n := 
                             { true, true }    }
<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '0500'O)and(enc_CER_PDU(myValue1) == '0500'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue2) == '0101FF'O)and(enc_CER_PDU(myValue2) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue3) == '020102'O)and(enc_CER_PDU(myValue3) == '020102'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue4) == '0A0100'O)and(enc_CER_PDU(myValue4) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue5) == '090603312E452B30'O)and(enc_CER_PDU(myValue5) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue6) == '03020780'O)and(enc_CER_PDU(myValue6) == '03020780'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue7) == '0402FFFF'O)and(enc_CER_PDU(myValue7) == '0402FFFF'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue8) == '0603000203'O)and(enc_CER_PDU(myValue8) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue9) == '1603414243'O)and(enc_CER_PDU(myValue9) == '1603414243'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue10) == 'A1030101FF'O)and(enc_CER_PDU(myValue10) == 'A1800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue11) == '300505000101FF'O)and(enc_CER_PDU(myValue11) == '308005000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue12) == '310C03020780090603312E452B30'O)and(enc_CER_PDU(myValue12) == '318003020780090603312E452B300000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue13) == 'A3083006020101020102'O)and(enc_CER_PDU(myValue13) == 'A380308002010102010200000000'O)) {setverdict(pass);} else {setverdict(fail);}
if ((enc_DER_PDU(myValue14) == 'A40831060101FF0101FF'O)and(enc_CER_PDU(myValue14) == 'A48031800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0500'O) == myValue1){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0101FF'O) == myValue2){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('020102'O) == myValue3){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0A0100'O) == myValue4){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('03020780'O) == myValue6){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0402FFFF'O) == myValue7){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0603000203'O) == myValue8){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('1603414243'O) == myValue9){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A1030101FF'O) == myValue10){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A1800101FF0000'O) == myValue10){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('300505000101FF'O) == myValue11){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('308005000101FF0000'O) == myValue11){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3083006020101020102'O) == myValue13){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A380308002010102010200000000'O) == myValue13){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A40831060101FF0101FF'O) == myValue14){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A48031800101FF0101FF00000000'O) == myValue14){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue1 := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue1) == '0101FF'O)and(enc_CER_PDU(myValue1) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0101FF'O) == myValue1){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - No Default TAGS, CHOICE untagged(unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - No Default TAGS, CHOICE untagged(unified)>

<STATIC:ASN>

TempA
DEFINITIONS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b   BOOLEAN,
	c   INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('0101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b   BOOLEAN,
	c   INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8001FF'O)and(enc_CER_PDU(myValue) == '8001FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8001FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('8301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA
DEFINITIONS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= CHOICE
      {     
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A3800101FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE, (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE, (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
IMPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A0038301FF'O)and(enc_CER_PDU(myValue) == 'A0808301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0038301FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A0808301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE, (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE, (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
EXPLICIT TAGS
::=
BEGIN
BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A005A3030101FF'O)and(enc_CER_PDU(myValue) == 'A080A3800101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A005A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A080A3800101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE, NO DEFAULT,  TAGGED CHOICE, (unified)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE, NO DEFAULT,  TAGGED CHOICE, (unified)>

<STATIC:ASN>

TempA

DEFINITIONS
::=
BEGIN
BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == 'A005A3030101FF'O)and(enc_CER_PDU(myValue) == 'A080A3800101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A005A3030101FF'O) == myValue){setverdict(pass);} else {setverdict(fail);}
if (dec_BER_PDU('A080A3800101FF00000000'O) == myValue){setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
	

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0038301FF'O)and(enc_CER_PDU(myValue) == 'A0808301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER, CHOICE - SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER, CHOICE - SET>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	
	l   SET { x3 BIT STRING,
		  y3 OCTET STRING},
		  
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }
       
       
        
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {l := {y3 := 'FFFF'O ,

			       x3 := '1'B   }    }




<TTCN_TC:EXEC>

if (dec_BER_PDU('3108030207800402FFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - SET>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,
	
	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},
	
	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},
	
	l   SET { x3 BIT STRING,
		  y3 OCTET STRING},
		  
	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN	  
       }
       
       
        
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {l := {y3 := 'FFFF'O ,

			       x3 := '1'B   }    }




<TTCN_TC:EXEC>

if (dec_BER_PDU('3180030207800402FFFF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS



::=

BEGIN

   

BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
	


        
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0038301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  CER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   CER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS



::=

BEGIN

   

BERPDU ::= [0] CHOICE
      {     
	b  [3] BOOLEAN,
	c  [6] INTEGER	
      }
	


        
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808301FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , itu-t(0) recommendation(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , itu-t(0) recommendation(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , itu-t recommendation (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , itu-t recommendation (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t recommendation a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 0 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 0 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) question(1),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) question(1),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) question(1) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t question,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t question,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t question a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 1,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 1,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 1 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) administration(2),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) administration(2),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) administration(2) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t administration,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t administration,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t administration a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 2,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 2,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 2 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) network-operator(3),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) network-operator(3),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) network-operator(3) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t network-operator,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t network-operator,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t network-operator a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 3,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 3,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 3 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) identified-organization(4),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) identified-organization(4),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) identified-organization(4) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t identified-organization,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t identified-organization,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 4,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 4,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 4 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , iso(1) standard(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , iso(1) standard(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) standard(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso standard  (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso standard  (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso standard a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso(1) member-body(2)(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso(1) member-body(2)(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) member-body(2) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso member-body(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso member-body(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso member-body a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 2 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso(1) identified-organization(3) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso(1) identified-organization(3) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) identified-organization(3) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso identified-organization(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso identified-organization(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 3 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 3 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 3 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(0)(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(0)(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t something(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t something(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 2 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 2 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {2 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(100) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(100) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(100) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,joint-iso-itu-t 100 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,joint-iso-itu-t 100 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t 100 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 2 100 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 2 100 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {2 100 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , multiple octets needed for values (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , multiple octets needed for values (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::=  OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3) 2000 4000 }

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>
		     
if ((enc_DER_PDU(b) == '06075002038F509F20'O)and(enc_CER_PDU(b) == '06075002038F509F20'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , [0] IMPLICIT,  primitive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , [0] IMPLICIT,  primitive>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8003000203'O)and(enc_CER_PDU(b) == '8003000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , [0] EXPLICIT  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , [0] EXPLICIT  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0050603000203'O)and(enc_CER_PDU(b) == 'A08006030002030000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t(0) recommendation(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t(0) recommendation(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= { itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t recommendation ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t recommendation ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t recommendation a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER 0 0 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER 0 0 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {0 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) question(1) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) question(1) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t(0) question(1) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t question ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t question ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t question a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER 0 1 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER 0 1 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {0 1 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER , itu-t(0) administration(2) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER , itu-t(0) administration(2) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t(0) administration(2) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER , itu-t administration ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER , itu-t administration ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t administration a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 2 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 2 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {0 2 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) network-operator(3) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) network-operator(3) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t(0) network-operator(3) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t network-operator ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t network-operator ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t network-operator a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 3 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 3 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {0 3 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) identified-organization(4) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) identified-organization(4) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t(0) identified-organization(4) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t identified-organization ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t identified-organization ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 4  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 4  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {0 4 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) standard(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) standard(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso(1) standard(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso standard ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso standard ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso standard a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 0  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 0  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {1 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) member-body(2) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) member-body(2) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso(1) member-body(2) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso member-body ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso member-body ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso member-body a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 2 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 2 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {1 2 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) identified-organization(3) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) identified-organization(3) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso(1) identified-organization(3) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso identified-organization ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso identified-organization ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {iso identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 3  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 3  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {1 3 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t something(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t something(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {joint-iso-itu-t something(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,2 0  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,2 0  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {2 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {joint-iso-itu-t(2) something(100) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {joint-iso-itu-t 100 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,2 100 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,2 100 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {2 100 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,multiple octets needed for values ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,multiple octets needed for values ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER 

myValue BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3) 2000 4000 }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06075002038F509F20'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 0, IMPLICIT,  primitive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 0, IMPLICIT,  primitive>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OBJECT IDENTIFIER 

myValue BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8003000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER ,0 0, EXPLICIT,  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER ,0 0, EXPLICIT,  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER 

myValue BERPDU ::=  {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0050603000203'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER ,0 0, EXPLICIT,  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER ,0 0, EXPLICIT,  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER 

myValue BERPDU ::=  {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08006030002030000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER encoding of OPEN TYPE from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER encoding of OPEN TYPE from Information Object Class>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),  
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}

	
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}},field2  :=  999 };


<TTCN_TC:EXEC>
			      
if ((enc_DER_PDU(myValue) == '30093003020108020203E7'O)and(enc_CER_PDU(myValue) == '308030800201080000020203E70000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER encoding of  TYPE from Information Object 
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER encoding of  TYPE from Information Object >

<STATIC:ASN>

TempA

DEFINITIONS 


::= 

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object   
field2 MY-CLASS-1.&fixedTypeValueField       
}

END


<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {  field1 :=  {f1 := 8},field2  :=  999 };


<TTCN_TC:EXEC>
			      
if ((enc_DER_PDU(myValue) == '30093003020108020203E7'O)and(enc_CER_PDU(myValue) == '308030800201080000020203E70000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,OPEN TYPE, DER, from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,OPEN TYPE, DER, from Information Object Class>

<STATIC:ASN>


TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),  
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}

	
END
<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('30093003020108020203E7'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,OPEN TYPE, CER, from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,OPEN TYPE, CER, from Information Object Class>

<STATIC:ASN>


TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),  
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}

	
END
<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201080000020203E70000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , TYPE from Information Object Class, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , TYPE from Information Object Class, DER>

<STATIC:ASN>


TempA

DEFINITIONS 


::= 

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object   
field2 MY-CLASS-1.&fixedTypeValueField       
}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {f1 := 8}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('30093003020108020203E7'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , TYPE from Information Object Class, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , TYPE from Information Object Class, CER>

<STATIC:ASN>


TempA

DEFINITIONS 


::= 

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]		
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER                      

ASN1-Type2 ::= BOOLEAN                    

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}                   

ASN1-Type4 ::= OCTET STRING                


--****************************************************************************************************
-- OBJECTS using the class defined above 
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::= 
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999 
}

              
myObject-2 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type2  
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::= 
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555	
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::= 
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::= 
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object   
field2 MY-CLASS-1.&fixedTypeValueField       
}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {f1 := 8}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201080000020203E70000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Encoding/decoding of big integers
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Encoding/decoding of big integers
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Encoding/decoding of big integers>

<STATIC:ASN>

TempA DEFINITIONS AUTOMATIC TAGS ::=
BEGIN

BERPDU ::= INTEGER
bi1 BERPDU ::= 5
bi2 BERPDU ::= 0
bi3 BERPDU ::= 127
bi4 BERPDU ::= -128
bi5 BERPDU ::= -5
bi-6 BERPDU ::= 128
bi7 BERPDU ::= -129

BERPDU2 ::= REAL
--b BERPDU2 ::= 12345678900

Rec-ber ::= SEQUENCE {
  int1 Number,
  int2 Number
}
Rec-ber-literal ::= SEQUENCE {
  int1 NumberLit,
  int2 NumberLit
}
Number ::= INTEGER
NumberLit ::= NumericString (SIZE (100))
myNumber Number ::= 12345678910111213141516

END

<STATIC>

import from TempA language "ASN.1:1997" all

external function enc_ber1(in Rec_ber r) return octetstring
  with { extension "encode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_ber1(in octetstring r) return Rec_ber
  with { extension "decode(BER:BER_ACCEPT_ALL) prototype(convert) errorbehavior(ALL:WARNING)" }
external function enc_ber2(in integer r) return octetstring
  with { extension "encode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
// Attributes are not checked in the compiler.
external function dec_ber2(in octetstring r) return integer
  with { extension "decode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_ber3(inout octetstring r, out Rec_ber s) return integer
  with { extension "decode(BER:BER_ACCEPT_ALL) prototype(sliding) errorbehavior(ALL:WARNING)" }

type component comp_ber { }

<TTCN_TC:EXEC>

  const integer a := 2147483647
  const integer b := 2147483648
  const integer c := 2147483649
  const integer d := 128
  const integer e := myNumber
  const integer f := 12147483648
  var Rec_ber myrec1 := {int1 := a, int2 := b}
  var Rec_ber myrec2 := {int1 := c, int2 := d}
  var Rec_ber myrec3 := {int1 := 1048576, int2 := 321768}
  var Rec_ber myrec4 := {65536, 131072}
  var Rec_ber myrec5 := {4294967296, 8388608}
  var Rec_ber myrec6 := {12345678910111213141516, 11111111111111111111}
  var Rec_ber myrec7 := {8589934592, 1099511627776}
  var Rec_ber myrec8 := {int1 := a, int2 := b}
  var Rec_ber myrec9 := {int1 := 12345678910111213141516, int2 := -1234}
  var Rec_ber myrec10 := {int1 := -12345678910111213141516, int2 := -1234}
  var Rec_ber myrec11 := {2147483648, -2147483648}
  var Rec_ber myrec12 := {-2147483647, 2147483647}
  var Rec_ber myrec13 := {2147483649, -2147483649}
  var Rec_ber myrec14 := {-4294967296, 4294967296}
  var Rec_ber myrec15 := {4294967295, -4294967295}
  var Rec_ber myrec16 := {-4294967297, 4294967297}
  var Rec_ber pdu1 := {12345678910111213141516, -2147483648}
  var Rec_ber pdu2 := {123, 456}
  var octetstring encoded_pdu
  var Rec_ber decoded_pdu
  var integer ret_val  
  encoded_pdu := enc_ber1(pdu2)
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 0 and decoded_pdu == pdu2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := '800100'O
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := substr(enc_ber1(pdu1), 0, 4)
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber2(-2147483648)
  if (encoded_pdu == '020480000000'O) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec1)
  if (myrec1 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := a, int2 := b} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec2)
  if (myrec2 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := c, int2 := d} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec3)
  if (myrec3 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := 1048576, int2 := 321768} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec4)
  if (myrec4 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({65536, 131072} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec5)
  if (myrec5 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({4294967296, 8388608} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec6)
  if (myrec6 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({12345678910111213141516, 11111111111111111111} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec7)
  if (myrec7 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({8589934592, 1099511627776} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec8)
  if (myrec8 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := a, int2 := b} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec9)
  if (myrec9 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := 12345678910111213141516, int2 := -1234} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec10)
  if (myrec10 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := -12345678910111213141516, int2 := -1234} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec11)
  if (myrec11 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({2147483648, -2147483648} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec12)
  if (myrec12 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-2147483647, 2147483647} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec13)
  if (myrec13 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({2147483649, -2147483649} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec14)
  if (myrec14 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-4294967296, 4294967296} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec15)
  if (myrec15 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({4294967295, -4294967295} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec16)
  if (myrec16 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-4294967297, 4294967297} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
Negative tests for the BER decoder.
.*---------------------------------------------------------------------*
:h2.Test cases
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form NR3 pretending to be NR1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form NR3 pretending to be NR1>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0133313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This decimal encoding does not conform to NR1 form.

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form NR3 pretending to be NR2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form NR3 pretending to be NR2>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0233313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This decimal encoding does not conform to NR2 form.

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. BER decoding REAL, reserved decimal form 0x20
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, reserved decimal form 0x20>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D2033313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x20 (See X.690 8.5.7).

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form 0
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form 0>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0033313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x0 (See X.690 8.5.7).

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form 4
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form 4>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0433313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x4 (See X.690 8.5.7).

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Memory leak while BER decoding, test for HO73756
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Memory leak while BER decoding, test for HO73756>

<STATIC:ASN>
TempA DEFINITIONS ::=
BEGIN

MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField ASN1-Type1 UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	&TypeField]
[FIXED VALUE TYPE FIELD &fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING

myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type3
FIXED VALUE TYPE FIELD 999
}

myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type2
FIXED VALUE TYPE FIELD 888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type4
FIXED VALUE TYPE FIELD 555
}

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|myObject-3,
...
}

BERPDU ::= SEQUENCE
{
field1 MY-CLASS-1.&TypeField ({MyInformationObjectSet1} {@.field2} ),
field2 MY-CLASS-1.&fixedTypeValueField ({MyInformationObjectSet1})
}

END
<STATIC>
// Test for memory leak problem in BER decoder: HO73756.
import from TempA all;

external function dec_backtrack(in octetstring stream, out BERPDU outpdu) return integer with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

type component empty {
  var BERPDU mypdu
}

<TTCN_TC:PURE_EXEC>

testcase mytc() runs on empty {
  dec_backtrack('30093003020108020203E7'O, mypdu)
  dec_backtrack('30093003020108020203E7'O, mypdu)
  setverdict(pass)
}

control {
  execute(mytc())
}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h1.REFERENCES
.*---------------------------------------------------------------------*
:nl. Requirement specification(s):
:nl.-------------------------------
:list.
:li. 8/ETH/RUS-2003:0087 Uen - Requirement Specification for TITAN's encoder/decoder functions
:elist.

:etext.
