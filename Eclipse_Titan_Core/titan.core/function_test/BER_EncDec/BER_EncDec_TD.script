.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Bartha, Norbert
.*   Beres, Szabolcs
.*   Delic, Adam
.*   Hanko, Matyas
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*   Szalai, Gabor
.*
.******************************************************************************/
:text.
:lang eng.
.*
:docname.Test Description
:docno.8/152 91-CRL 113 200/3 Uen
:rev.A
:date.2013-01-17
.*
:prep.ETH/XZR Krisztian Pandi
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY
.*
:title.Test Description - BER coder
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.

This file is obsolate, don't modify, improve it anymore!

This TD contains test cases related to TTCN3 Executor's BER coder function.
DON'T YOU DARE TO WRITE AN INSPECTION RECORD ABOUT THIS FILE.

:exmp.

:p.:us.Revision Information:eus.

:xmp nokeep.
:us.History:eus.

REV   DATE         PREPARED   CHANGE
===   ==========   ========   ======
A     2003-10-31   ETHEKR     New document
B     2007-03-06   EDMDELI    Implicit message encoding
C     2007-03-21   EJNOSZA    Bugfix in a testcase for implicit msg. enc.
D     2008-10-01   EFERKOV    Big integers
E     2010-01-18   EKRISZA    Updated for TITAN R8C
F     2011-06-18   EKRISZA    Added tests for errors
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester

:exmp.
:np.
.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Testing FIELDLENGTH Attribute
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN TRUE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN TRUE >

<STATIC:ASN>

TempA

DEFINITIONS ::=


BEGIN
BERPDU ::= BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := true

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0101FF'O)and(enc_CER_PDU(b) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN FALSE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN FALSE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := false

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '010100'O)and(enc_CER_PDU(b) == '010100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := true

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0030101FF'O)and(enc_CER_PDU(b) == 'A0800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := true

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E1030101FF'O)and(enc_CER_PDU(b) == 'E1800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := true

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '62030101FF'O)and(enc_CER_PDU(b) == '62800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := false

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '800100'O)and(enc_CER_PDU(b) == '800100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := false

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C10100'O)and(enc_CER_PDU(b) == 'C10100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of BOOLEAN with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of BOOLEAN with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT BOOLEAN
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := true

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '4201FF'O)and(enc_CER_PDU(b) == '4201FF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BOOLEAN, CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BOOLEAN, CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BOOLEAN, CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BOOLEAN, CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BOOLEAN

myBooleanValue BERPDU ::= FALSE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('010100'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BOOLEAN, (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BOOLEAN, (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('05810101'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BOOELAN, (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BOOELAN, (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BOOLEAN

myBooleanValue BERPDU ::= FALSE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0582000100'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT BOOLEAN , DER, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT BOOLEAN , DER, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT BOOLEAN, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT BOOLEAN, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101FF0000'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT BOOLEAN, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT BOOLEAN, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT BOOLEAN, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT BOOLEAN, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810401810199'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT BOOLEAN , DER, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT BOOLEAN , DER, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT BOOLEAN, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT BOOLEAN, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800101FF0000'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT BOOLEAN, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT BOOLEAN, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT BOOLEAN, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT BOOLEAN, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810401810199'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT BOOLEAN , DER, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT BOOLEAN , DER, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT BOOLEAN, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT BOOLEAN, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800101FF0000'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT BOOLEAN, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT BOOLEAN, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281030101FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT BOOLEAN, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT BOOLEAN, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810401810199'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT BOOLEAN ,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT BOOLEAN ,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8001FF'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT BOOLEAN,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT BOOLEAN,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80810133'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT BOOLEAN,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT BOOLEAN,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= FALSE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C10100'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT BOOLEAN,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT BOOLEAN,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1810105'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT BOOLEAN,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT BOOLEAN,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= FALSE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('420100'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT BOOLEAN,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT BOOLEAN,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT BOOLEAN

myBooleanValue BERPDU ::= TRUE

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42810188'O) == myBooleanValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5)>
START OF INTEGER SECTION

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '020105'O)and(enc_CER_PDU(b) == '020105'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A003020105'O)and(enc_CER_PDU(b) == 'A0800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E103020105'O)and(enc_CER_PDU(b) == 'E1800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '6203020105'O)and(enc_CER_PDU(b) == '62800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '800105'O)and(enc_CER_PDU(b) == '800105'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C10105'O)and(enc_CER_PDU(b) == 'C10105'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '420105'O)and(enc_CER_PDU(b) == '420105'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '020100'O)and(enc_CER_PDU(b) == '020100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A003020100'O)and(enc_CER_PDU(b) == 'A0800201000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E103020100'O)and(enc_CER_PDU(b) == 'E1800201000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '6203020100'O)and(enc_CER_PDU(b) == '62800201000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '800100'O)and(enc_CER_PDU(b) == '800100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C10100'O)and(enc_CER_PDU(b) == 'C10100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (0) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (0) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 0

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '420100'O)and(enc_CER_PDU(b) == '420100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '02017F'O)and(enc_CER_PDU(b) == '02017F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A00302017F'O)and(enc_CER_PDU(b) == 'A08002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E10302017F'O)and(enc_CER_PDU(b) == 'E18002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '620302017F'O)and(enc_CER_PDU(b) == '628002017F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '80017F'O)and(enc_CER_PDU(b) == '80017F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C1017F'O)and(enc_CER_PDU(b) == 'C1017F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (127) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (127) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 127

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '42017F'O)and(enc_CER_PDU(b) == '42017F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '020180'O)and(enc_CER_PDU(b) == '020180'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A003020180'O)and(enc_CER_PDU(b) == 'A0800201800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E103020180'O)and(enc_CER_PDU(b) == 'E1800201800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '6203020180'O)and(enc_CER_PDU(b) == '62800201800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '800180'O)and(enc_CER_PDU(b) == '800180'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C10180'O)and(enc_CER_PDU(b) == 'C10180'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-128) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-128) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '420180'O)and(enc_CER_PDU(b) == '420180'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0201FB'O)and(enc_CER_PDU(b) == '0201FB'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0030201FB'O)and(enc_CER_PDU(b) == 'A0800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E1030201FB'O)and(enc_CER_PDU(b) == 'E1800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '62030201FB'O)and(enc_CER_PDU(b) == '62800201FB0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8001FB'O)and(enc_CER_PDU(b) == '8001FB'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C101FB'O)and(enc_CER_PDU(b) == 'C101FB'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-5) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-5) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '4201FB'O)and(enc_CER_PDU(b) == '4201FB'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '02020080'O)and(enc_CER_PDU(b) == '02020080'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A00402020080'O)and(enc_CER_PDU(b) == 'A080020200800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E10402020080'O)and(enc_CER_PDU(b) == 'E180020200800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '620402020080'O)and(enc_CER_PDU(b) == '6280020200800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '80020080'O)and(enc_CER_PDU(b) == '80020080'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C1020080'O)and(enc_CER_PDU(b) == 'C1020080'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (128) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (128) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 128

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '42020080'O)and(enc_CER_PDU(b) == '42020080'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0202FF7F'O)and(enc_CER_PDU(b) == '0202FF7F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0040202FF7F'O)and(enc_CER_PDU(b) == 'A0800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E1040202FF7F'O)and(enc_CER_PDU(b) == 'E1800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '62040202FF7F'O)and(enc_CER_PDU(b) == '62800202FF7F0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8002FF7F'O)and(enc_CER_PDU(b) == '8002FF7F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C102FF7F'O)and(enc_CER_PDU(b) == 'C102FF7F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (-129) with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (-129) with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := -129

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '4202FF7F'O)and(enc_CER_PDU(b) == '4202FF7F'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=30

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [30] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BE03020105'O)and(enc_CER_PDU(b) == 'BE800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=31

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [31] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BF1F03020105'O)and(enc_CER_PDU(b) == 'BF1F800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=127

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [127] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BF7F03020105'O)and(enc_CER_PDU(b) == 'BF7F800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=128

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [128] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BF810003020105'O)and(enc_CER_PDU(b) == 'BF8100800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=16383

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16383] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BFFF7F03020105'O)and(enc_CER_PDU(b) == 'BFFF7F800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of integer (5) with Context Specific TAG, EXPLICIT>

 TAG=16384

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16384] EXPLICIT INTEGER
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 5

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'BF81800003020105'O)and(enc_CER_PDU(b) == 'BF818000800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (5), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (5), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (5), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (5), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (5), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (5), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0282000105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (5), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (5), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (5), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (5), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08103020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810402810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E103020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E10402810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18103020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810402810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (5),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (5),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6203020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('620402810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628103020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810402810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (5),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (5),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('800105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C10105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('420105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42810105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (0), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (0), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (0), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (0), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (0), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (0), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0282000100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (0), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (0), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (0), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (0), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800201000000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (0), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (0), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (0), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (0), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08103020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (0), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (0), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810402810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E103020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E10402810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18103020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (0), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810402810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (0),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (0),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800201000000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6203020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('620402810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628103020100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (0), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810402810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (0),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (0),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800201000000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (0),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (0),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('800100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (0),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (0),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (0),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (0),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C10100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (0),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (0),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (0),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (0),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('420100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (0),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (0),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 0

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42810100'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (127), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (127), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (127), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (127), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (127), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (127), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('028200017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (127), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (127), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (127), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (127), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08002017F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (127), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (127), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (127), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (127), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (127), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (127), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E10302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1040281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (127), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181040281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (127),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (127),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18002017F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('620302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62040281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810302017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (127), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281040281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (127),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (127),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628002017F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (127),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (127),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (127),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (127),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8081017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (127),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (127),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (127),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (127),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C181017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (127),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (127),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (127),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (127),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 127

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('4281017F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-128), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-128), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-128), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-128), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-128), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-128), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0282000180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-128), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-128), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-128), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-128), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800201800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A003020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08103020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810402810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E103020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E10402810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18103020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810402810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-128),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-128),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800201800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6203020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('620402810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628103020180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810402810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-128),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-128),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800201800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('800180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C10180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('420180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42810180'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-5), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-5), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-5), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-5), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-5), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-5), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02820001FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-5), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-5), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-5), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-5), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800201FB0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08104028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E104028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18104028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-5),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-5),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800201FB0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6204028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281030201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-5), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628104028101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-5),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-5),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800201FB0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8001FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('808101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C18101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-5),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-5),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('4201FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-5),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-5),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('428101FB'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (128), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (128), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (128), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (128), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (128), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (128), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('028200020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (128), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (128), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (128), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (128), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A080020200800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0810402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081050281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E10402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1050281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1810402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181050281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (128),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (128),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E180020200800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('620402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62050281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62810402020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (128), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281050281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (128),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (128),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6280020200800000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8081020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C1020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C181020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (128),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (128),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('42020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (128),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (128),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= 128

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('4281020080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-129), CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-129), CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-129), (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-129), (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING INTEGER (-129), (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING INTEGER (-129), (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('02820002FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-129), DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-129), DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-129), CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-129), CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800202FF7F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-129), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-129), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-129), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-129), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT INTEGER (-129), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT INTEGER (-129), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08105028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E105028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-129), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18105028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT INTEGER (-129),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT INTEGER (-129),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1800202FF7F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Short form - Short form, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Short form - Short form, DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6205028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281040202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-129), Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628105028102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT INTEGER (-129),Indefinite form,CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT INTEGER (-129),Indefinite form,CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62800202FF7F0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-129),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-129),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8002FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT INTEGER (-129),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT INTEGER (-129),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('808102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-129),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-129),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT INTEGER (-129),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT INTEGER (-129),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C18102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-129),Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-129),Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('4202FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT INTEGER (-129),Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT INTEGER (-129),Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT INTEGER

myIntegerValue BERPDU ::= -129

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('428102FF7F'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 30
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 30>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [30] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BE03020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 30
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 30>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [30] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BE800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 31
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 31>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [31] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF1F03020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 31
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 31>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [31] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF1F800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 127
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 127>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [127] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF7F03020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 127
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 127>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [127] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF7F800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 128
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 128>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [128] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF810003020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 128
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 128>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [128] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF8100800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 16383
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 16383>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16383] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BFFF7F03020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 16383
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 16383>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16383] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BFFF7F800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER  integer (5) with Context Specific TAG = 16384
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER  integer (5) with Context Specific TAG = 16384>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16384] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF81800003020105'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER  integer (5) with Context Specific TAG = 16384
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER  integer (5) with Context Specific TAG = 16384>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [16384] EXPLICIT INTEGER

myIntegerValue BERPDU ::= 5

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('BF818000800201050000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED third(-9) hardcoded positive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED third(-9) hardcoded positive >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first(-5), second(0), third(9)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := third

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0109'O)and(enc_CER_PDU(b) == '0A0109'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED first(0) hardcoded negative
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED first(0) hardcoded negative>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first(-5), second(0), third(9)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := first

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A01FB'O)and(enc_CER_PDU(b) == '0A01FB'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED second(0) hardcoded zero
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED second(0) hardcoded zero>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first(-5), second(0), third(9)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := second

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0100'O)and(enc_CER_PDU(b) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED third, no hardcoding
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED third, no hardcoding>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second, third}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := third

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0102'O)and(enc_CER_PDU(b) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED first, no hardcoding
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED first, no hardcoding>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second, third}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := first

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0100'O)and(enc_CER_PDU(b) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED second, no hardcoding
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED second, no hardcoding>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first(-5), second(0), third(9)}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := second

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0100'O)and(enc_CER_PDU(b) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED first
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED first>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := first

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0101'O)and(enc_CER_PDU(b) == '0A0101'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED second(0)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED second(0)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := second

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0100'O)and(enc_CER_PDU(b) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED third
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED third>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := third

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0102'O)and(enc_CER_PDU(b) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED first
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED first>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := first

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0101'O)and(enc_CER_PDU(b) == '0A0101'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED second(0)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED second(0)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := second

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0100'O)and(enc_CER_PDU(b) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED third
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED third>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := third

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0102'O)and(enc_CER_PDU(b) == '0A0102'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED fourth (after extension ...)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED fourth (after extension ...)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := fourth

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0103'O)and(enc_CER_PDU(b) == '0A0103'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED fifth(5) (after extension ...)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED fifth(5) (after extension ...)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := fifth

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0105'O)and(enc_CER_PDU(b) == '0A0105'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED sixth (after extension ...)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED sixth (after extension ...)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := sixth

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0A0106'O)and(enc_CER_PDU(b) == '0A0106'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED , tagged, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED , tagged, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [21] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := sixth

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'B5030A0106'O)and(enc_CER_PDU(b) == 'B5800A01060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of ENUMERATED , tagged, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of ENUMERATED , tagged, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := sixth

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '9F580106'O)and(enc_CER_PDU(b) == '9F580106'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01010000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (first)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (first)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= first



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810101'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01000000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (second(0))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (second(0))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= second



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810100'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01020000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (third)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (third)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= third



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810102'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01030000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (fourth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (fourth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fourth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810103'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01050000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (fifth(5))
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (fifth(5))>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= fifth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810105'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, CER+DER (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, CER+DER (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF UNTAGGED ENUMERATED, Length of length = 1, (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0A810106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, DER (short form - short form) (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0030A0106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED OF ENUMERATED, CER (INDEFINITE FORM) (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800A01060000'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, short form - long form (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040A810106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF EXPLICIT TAGGED ENUMERATED, long form - long form (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081040A810106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, CER+DER (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F580106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OF IMPLICIT TAGGED ENUMERATED, long form (sixth)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OF IMPLICIT TAGGED ENUMERATED, long form (sixth)>
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [88] IMPLICIT ENUMERATED {first, second(0),third,...,fourth, fifth(5),sixth}


myValue BERPDU ::= sixth



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('9F58810106'O) ==  myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=  0e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=  0e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=  0.0e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0900'O)and(enc_CER_PDU(b) == '0900'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.0e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.0e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.0e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL,  1.0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL,  1.0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=  1.0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.0e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.0e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.0e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL,  1.0E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL,  1.0E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=   1.0E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.0e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.0e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.0e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL,  1.0E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL,  1.0E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=  1.0E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 2

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603322E452B30'O)and(enc_CER_PDU(b) == '090603322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 2.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 2.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 2.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603322E452B30'O)and(enc_CER_PDU(b) == '090603322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0e0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0e0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0e0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0e+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0e+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0e+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0E+0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0E+0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0E+0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0e-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0e-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0e-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0E-0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0E-0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0E-0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.000 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.000 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.000

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090603312E452B30'O)and(enc_CER_PDU(b) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.000 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.000 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.000

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0907032D312E452B30'O)and(enc_CER_PDU(b) == '0907032D312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 12

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 12.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12.0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12.0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 12.0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.2E1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.2E1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.2E1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.12E2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.12E2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.12E2

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1.2E+1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1.2E+1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1.2E1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.12E+2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.12E+2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.12E2

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070331322E452B30'O)and(enc_CER_PDU(b) == '09070331322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.34 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.34 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.34

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070333342E452D32'O)and(enc_CER_PDU(b) == '09070333342E452D32'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.344 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.344 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.344

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908033334342E452D33'O)and(enc_CER_PDU(b) == '0908033334342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.345 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.345 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.345

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908033334352E452D33'O)and(enc_CER_PDU(b) == '0908033334352E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.034 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.034 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.034

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070333342E452D33'O)and(enc_CER_PDU(b) == '09070333342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0034 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0034 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0034

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '09070333342E452D34'O)and(enc_CER_PDU(b) == '09070333342E452D34'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.304 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.304 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.304

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908033330342E452D33'O)and(enc_CER_PDU(b) == '0908033330342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.1234567890 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.1234567890 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.1234567890

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E033132333435363738392E452D39'O)and(enc_CER_PDU(b) == '090E033132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E033132333435363738392E452D39'O)and(enc_CER_PDU(b) == '090E033132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 0.0123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 0.0123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 0.0123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090F033132333435363738392E452D3130'O)and(enc_CER_PDU(b) == '090F033132333435363738392E452D3130'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 123456789.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 123456789.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 123456789.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E033132333435363738392E452B30'O)and(enc_CER_PDU(b) == '090E033132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E033132333435363738392E452B30'O)and(enc_CER_PDU(b) == '090E033132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1234567890 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1234567890 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1234567890

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4531'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1234567890.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1234567890.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1234567890.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4531'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1234567890.00 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1234567890.00 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 1234567890.00

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4531'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12345678900.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12345678900.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 12345678900.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4532'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12345678900.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12345678900.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::=12345678900.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4532'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 12345678900.00 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 12345678900.00 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= 12345678900.00

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090D033132333435363738392E4532'O)and(enc_CER_PDU(b) == '090D033132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12.0E0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12.0E0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12.0E0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.2E1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.2E1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.2E1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.12E2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.12E2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.12E2

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1.2E+1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1.2E+1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1.2E1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.12E+2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.12E+2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.12E2

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D31322E452B30'O)and(enc_CER_PDU(b) == '0908032D31322E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.34 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.34 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.34

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D33342E452D32'O)and(enc_CER_PDU(b) == '0908032D33342E452D32'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.344 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.344 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.344

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0909032D3334342E452D33'O)and(enc_CER_PDU(b) == '0909032D3334342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.345 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.345 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.345

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0909032D3334352E452D33'O)and(enc_CER_PDU(b) == '0909032D3334352E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.034 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.034 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.034

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D33342E452D33'O)and(enc_CER_PDU(b) == '0908032D33342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.0034 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.0034 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.0034

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0908032D33342E452D34'O)and(enc_CER_PDU(b) == '0908032D33342E452D34'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.304 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.304 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.304

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0909032D3330342E452D33'O)and(enc_CER_PDU(b) == '0909032D3330342E452D33'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.1234567890 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.1234567890 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.1234567890

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090F032D3132333435363738392E452D39'O)and(enc_CER_PDU(b) == '090F032D3132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090F032D3132333435363738392E452D39'O)and(enc_CER_PDU(b) == '090F032D3132333435363738392E452D39'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -0.0123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -0.0123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -0.0123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0910032D3132333435363738392E452D3130'O)and(enc_CER_PDU(b) == '0910032D3132333435363738392E452D3130'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -123456789.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -123456789.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -123456789.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090F032D3132333435363738392E452B30'O)and(enc_CER_PDU(b) == '090F032D3132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -123456789 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -123456789 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -123456789

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090F032D3132333435363738392E452B30'O)and(enc_CER_PDU(b) == '090F032D3132333435363738392E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1234567890 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1234567890 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1234567890

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1234567890.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1234567890.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1234567890.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -1234567890.00 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -1234567890.00 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -1234567890.00

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4531'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4531'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12345678900.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12345678900.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12345678900.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12345678900.0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12345678900.0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12345678900.0

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, -12345678900.00 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, -12345678900.00 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= -12345678900.00

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090E032D3132333435363738392E4532'O)and(enc_CER_PDU(b) == '090E032D3132333435363738392E4532'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, PLUS-INFINITY (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, PLUS-INFINITY (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= PLUS-INFINITY

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090140'O)and(enc_CER_PDU(b) == '090140'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, MINUS-INFINITY (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, MINUS-INFINITY (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= REAL
b BERPDU ::= MINUS-INFINITY

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '090141'O)and(enc_CER_PDU(b) == '090141'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1 , IMPICIT TAG
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1 , IMPICIT TAG>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT REAL
b BERPDU ::= 1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '800603312E452B30'O)and(enc_CER_PDU(b) == '800603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of REAL, 1 , EXPICIT TAG
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of REAL, 1 , EXPICIT TAG>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT REAL
b BERPDU ::= 1

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A008090603312E452B30'O)and(enc_CER_PDU(b) == 'A080090603312E452B300000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := ''B

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '030100'O)and(enc_CER_PDU(b) == '030100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 1 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 1 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '1'B

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '03020780'O)and(enc_CER_PDU(b) == '03020780'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 7 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 7 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '1010101'B
<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '030201AA'O)and(enc_CER_PDU(b) == '030201AA'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 8 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 8 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '10101010'B
<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '030200AA'O)and(enc_CER_PDU(b) == '030200AA'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 9 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 9 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '111100001'B

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '030307F080'O)and(enc_CER_PDU(b) == '030307F080'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER(primitive) + DER(primitive) encoding of BIT STRING, contents length = 1000 octets  (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER(primitive) + DER(primitive) encoding of BIT STRING, contents length = 1000 octets  (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

b BERPDU ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)and(enc_CER_PDU(b) == '038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER(constructed) + DER(primitive) encoding of BIT STRING, contents length = 1001 octets  (1000 octets of data and one (ENC_02_014 and ENC_02_015)  ENC_02_012 and ENC_02_012
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER(constructed) + DER(primitive) encoding of BIT STRING, contents length = 1001 octets  (1000 octets of data and one (ENC_02_014 and ENC_02_015)  ENC_02_012 and ENC_02_012>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

b BERPDU ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }


<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)and(enc_CER_PDU(b)
== '2380038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF030200FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 1, IMPLICIT TAG (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 1, IMPLICIT TAG (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '1'B

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '80020780'O)and(enc_CER_PDU(b) == '80020780'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of BIT STRING, length = 1, EXPLICIT TAG (constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of BIT STRING, length = 1, EXPLICIT TAG (constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT BIT STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := '1'B

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A00403020780'O)and(enc_CER_PDU(b) == 'A080030207800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING  ,length = 0 ,CER +DER (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING  ,length = 0 ,CER +DER (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::=''B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('030100'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 0 ,constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 0 ,constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::=''B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2303030100'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 0 ,constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 0 ,constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::=''B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2306030100030100'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 0 ,constructed, indefinite
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 0 ,constructed, indefinite>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myIntegerValue BERPDU ::=''B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23800301000000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('03020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 , (primitive, long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 , (primitive, long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myIntegerValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0381020780'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('230403020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 , (constructed, short form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 , (constructed, short form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23050381020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 , (constructed, long form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 , (constructed, long form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2381050381020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1 , (constructed, indefinite form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1 , (constructed, indefinite form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238003810207800000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 1 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 1 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='11'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER:BER_ACCEPT_ALL)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23080302078003020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 1 , (constructed inside constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 1 , (constructed inside constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2306230403020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('030201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 , (primitive, long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 , (primitive, long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myIntegerValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('03810201AA'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2304030201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 , (constructed, short form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 , (constructed, short form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('230503810201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 , (constructed, long form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 , (constructed, long form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23810503810201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 7 , (constructed, indefinite form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 7 , (constructed, indefinite form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238003810201AA0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 7 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 7 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101011010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2308030201AA030201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 7 , (constructed inside constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 7 , (constructed inside constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23062304030201AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('030200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 , (primitive, long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 , (primitive, long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myIntegerValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('03810200AA'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2304030200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 , (constructed, short form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 , (constructed, short form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('230503810200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 , (constructed, long form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 , (constructed, long form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23810503810200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 8 , (constructed, indefinite form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 8 , (constructed, indefinite form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238003810200AA0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 8 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 8 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1010101010101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2308030200AA030200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 8 , (constructed inside constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 8 , (constructed inside constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='10101010'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23062304030200AA'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU( '030307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (primitive, long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (primitive, long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myIntegerValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('03810307F080'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2305030307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (constructed, short form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (constructed, short form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('230603810307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (constructed, long form - long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (constructed, long form - long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23810603810307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (constructed, indefinite form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (constructed, indefinite form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238003810307F0800000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 9 , (constructed, short form - short form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 9 , (constructed, short form - short form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('230A030307F080030307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 9 , (constructed inside constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 9 , (constructed inside constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='111100001'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('23072305030307F080'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1000 CER + DER, primitive (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1000 CER + DER, primitive (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1000 , primitive longer form (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1000 , primitive longer form (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('03830003E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1000 , constructed long form -long form (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1000 , constructed long form -long form (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238203EC038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1000 , constructed indefinite form (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1000 , constructed indefinite form (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2380038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,2xlength = 1000 , constructed  (999 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,2xlength = 1000 , constructed  (999 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238207D8038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1001 DER , primitive (1000 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1001 DER , primitive (1000 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1001 CER , constructed (1000 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1001 CER , constructed (1000 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238203F0038203E800FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF030200FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING ,length = 1001 , constructed (1000 octets of data and one unused bits octet)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING ,length = 1001 , constructed (1000 octets of data and one unused bits octet)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('238203ED038203E900FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING CER +DER  ,length = 1 , IMPLICIT TAG primitive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING CER +DER  ,length = 1 , IMPLICIT TAG primitive >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('80020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING CER ,length = 1 , EXPLICIT TAG (constructed )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING CER ,length = 1 , EXPLICIT TAG (constructed )>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A080030207800000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING BIT STRING DER ,length = 1 EXPLICIT TAG , (constructed )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING BIT STRING DER ,length = 1 EXPLICIT TAG , (constructed )>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= BIT STRING

myValue BERPDU ::='1'B

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00403020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OCTETSTRING, length = 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OCTETSTRING, length = 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := ''O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0400'O)and(enc_CER_PDU(b) == '0400'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OCTETSTRING, length = 2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OCTETSTRING, length = 2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 'FFFF'O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0402FFFF'O)and(enc_CER_PDU(b) == '0402FFFF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OCTETSTRING, length = 1000 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OCTETSTRING, length = 1000 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)and(enc_CER_PDU(b) == '048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER(constructed) + DER(primitive) encoding of OCTETSTRING, length = 1001 (ENC_02_014 and ENC_02_015)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER(constructed) + DER(primitive) encoding of OCTETSTRING, length = 1001 (ENC_02_014 and ENC_02_015)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b :=
'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O)and(enc_CER_PDU(b)
== '2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OCTETSTRING, IMPLICIT TAG length = 2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OCTETSTRING, IMPLICIT TAG length = 2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 'FFFF'O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8002FFFF'O)and(enc_CER_PDU(b) == '8002FFFF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OCTETSTRING,EXPICIT TAG , length = 2 (constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OCTETSTRING,EXPICIT TAG , length = 2 (constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OCTET STRING
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := 'FFFF'O

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0040402FFFF'O)and(enc_CER_PDU(b) == 'A0800402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 0 ,CER +DER (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 0 ,CER +DER (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::=''H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0400'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 0 ,constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 0 ,constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::=''H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('24020400'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,2xlength = 0 ,constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,2xlength = 0 ,constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::=''H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('240404000400'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 0 ,constructed, indefinite
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 0 ,constructed, indefinite>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::=''H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('248004000000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0402FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 , (primitive, long form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 , (primitive, long form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('048102FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,constructed, short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,constructed, short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('24040402FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,constructed, short form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,constructed, short form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2405048102FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,constructed, long form - long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,constructed, long form - long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('248105048102FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,constructed, indefinite form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,constructed, indefinite form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('24800402FFFF0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,2xlength = 2 ,constructed, short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,2xlength = 2 ,constructed, short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('24080402FFFF0402FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,constructed form inside constructed form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,constructed form inside constructed form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('240624040402FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1000 ,CER + DER, (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1000 ,CER + DER, (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU
::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1000 , (primitive, longer form)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1000 , (primitive, longer form)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('04830003E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1000 ,constructed, long form -long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1000 ,constructed, long form -long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('248203EC048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1000 ,constructed, indefinite form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1000 ,constructed, indefinite form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,2xlength = 1000 ,constructed, short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,2xlength = 1000 ,constructed, short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('248207D8048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1001 ,CER (constructed, indefinite form. segmented)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1001 ,CER (constructed, indefinite form. segmented)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
myIntegerValue BERPDU ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('2480048203E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0401FF0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1001 ,DER (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1001 ,DER (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
myIntegerValue BERPDU ::='FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 1001 ,constructed, definite form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 1001 ,constructed, definite form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING
myIntegerValue BERPDU ::= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'H


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('248203ED048203E9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,CER + DER,IMPLICIT TAG (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,CER + DER,IMPLICIT TAG (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8002FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,CER ,EXPLICIT TAG (constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,CER ,EXPLICIT TAG (constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800402FFFF0000'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OCTETSTRING ,length = 2 ,DER,EXPLICIT TAG (constructed)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OCTETSTRING ,length = 2 ,DER,EXPLICIT TAG (constructed)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OCTET STRING

myIntegerValue BERPDU ::='FFFF'H

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0040402FFFF'O) == myIntegerValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL >
START OF NULL SECTION

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0500'O)and(enc_CER_PDU(b) == '0500'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with Context Specific TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with Context Specific TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0020500'O)and(enc_CER_PDU(b) == 'A08005000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with PRIVATE  TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with PRIVATE  TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'E1020500'O)and(enc_CER_PDU(b) == 'E18005000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with APPLICATION TAG, EXPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with APPLICATION TAG, EXPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '62020500'O)and(enc_CER_PDU(b) == '628005000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with Context Specific TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with Context Specific TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8000'O)and(enc_CER_PDU(b) == '8000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with PRIVATE TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with PRIVATE TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'C100'O)and(enc_CER_PDU(b) == 'C100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER + CER encoding of NULL with APPLICATION TAG, IMPLICIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER + CER encoding of NULL with APPLICATION TAG, IMPLICIT>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT NULL
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU b := NULL

<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '4200'O)and(enc_CER_PDU(b) == '4200'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING NULL, CER+DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING NULL, CER+DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING NULL, (LENGTH OF LENGTH = 1)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING NULL, (LENGTH OF LENGTH = 1)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('058100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING NULL, (LENGTH OF LENGTH = 2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING NULL, (LENGTH OF LENGTH = 2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('05820000'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT NULL , DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT NULL , DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT NULL, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT NULL, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08005000000'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT NULL, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT NULL, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT NULL, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT NULL, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A081020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] EXPLICIT NULL, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] EXPLICIT NULL, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08103058100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT NULL , DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT NULL , DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT NULL, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT NULL, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18005000000'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT NULL, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT NULL, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E1020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT NULL, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT NULL, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E181020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] EXPLICIT NULL, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] EXPLICIT NULL, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('E18103058100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT NULL , DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT NULL , DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT NULL, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT NULL, CER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628005000000'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT NULL, Short form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT NULL, Short form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('62020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT NULL, Long form - short form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT NULL, Long form - short form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('6281020500'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] EXPLICIT NULL, Long form Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] EXPLICIT NULL, Long form Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] EXPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('628103058100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT NULL  ,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT NULL  ,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8000'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [0] IMPLICIT NULL ,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [0] IMPLICIT NULL ,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('808100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT NULL ,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT NULL ,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [PRIVATE 1] IMPLICIT NULL ,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [PRIVATE 1] IMPLICIT NULL ,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [PRIVATE 1] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('C18100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT NULL ,Short form CER,DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT NULL ,Short form CER,DER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('4200'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING [APPLICATION 2] IMPLICIT NULL,Long form
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING [APPLICATION 2] IMPLICIT NULL,Long form>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [APPLICATION 2] IMPLICIT NULL

myNullValue BERPDU ::= NULL

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('428100'O) == myNullValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3000'O)and(enc_CER_PDU(myValue) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30030101FF'O)and(enc_CER_PDU(myValue) == '30800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30060101FF020105'O)and(enc_CER_PDU(myValue) == '30800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3003020105'O)and(enc_CER_PDU(myValue) == '30800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3006010100020105'O)and(enc_CER_PDU(myValue) == '30800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of  SEQUENCE (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of  SEQUENCE (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3000'O)and(enc_CER_PDU(myValue) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30038001FF'O)and(enc_CER_PDU(myValue) == '30808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30068001FF810105'O)and(enc_CER_PDU(myValue) == '30808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3003810105'O)and(enc_CER_PDU(myValue) == '30808101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3006800100810105'O)and(enc_CER_PDU(myValue) == '30808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '30809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '30809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3080BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3080BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00830060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08030800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00830060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08030800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C300AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803080A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C300AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803080A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30068501FF020105'O)and(enc_CER_PDU(myValue) == '30808501FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SEQUENCE
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '30808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SEQUENCE
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '30808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN


MySeq ::= SEQUENCE
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300D8001FF030207800201060401FF'O)and(enc_CER_PDU(myValue) == '30808001FF030207800201060401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SEQUENCE
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300D8001FF030207808101060401FF'O)and(enc_CER_PDU(myValue) == '30808001FF030207808101060401FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3008A0038001FF810104'O)and(enc_CER_PDU(myValue) == '3080A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN




BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30060101FF020104'O)and(enc_CER_PDU(myValue) == '30800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SEQUENCE
      {

	a   OCTET STRING,

	b   BOOLEAN,

	...,

	d   BIT STRING,
	...,

	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300D8001FF8101FF83020780820104'O)and(enc_CER_PDU(myValue) == '30808001FF8101FF830207808201040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE with fields of different types
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE with fields of different types>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }











<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '305305000101FF0201020A0100090603312E452B30030207800402FFFF06030002031603414243A1030101FF300505000101FF310C03020780090603312E452B30A3083006020101020102A40831060101FF0101FF'O)and(enc_CER_PDU(myValue) == '308005000101FF0201020A0100090603312E452B30030207800402FFFF06030002031603414243A1800101FF0000308005000101FF0000318003020780090603312E452B300000A380308002010102010200000000A48031800101FF0101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE with fields of different types, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE with fields of different types, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }











<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '304F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)and(enc_CER_PDU(myValue) == '308080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  DER , SEQUENCE (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  DER , SEQUENCE (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  CER , SEQUENCE (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  CER , SEQUENCE (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30800000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.DECODING DER , SEQUENCE (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - DECODING DER , SEQUENCE (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.DECODING CER , SEQUENCE (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - DECODING CER , SEQUENCE (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30800101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  DER , SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  DER , SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  DER , SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  DER , SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800101FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER , SEQUENCE (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER , SEQUENCE (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('3003020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER,  SEQUENCE (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER,  SEQUENCE (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('30800201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SEQUENCE (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SEQUENCE (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('3006010100020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SEQUENCE (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SEQUENCE (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('30800101000201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER ,  SEQUENCE (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER ,  SEQUENCE (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER ,  SEQUENCE (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER ,  SEQUENCE (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30800000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER , SEQUENCE (only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER , SEQUENCE (only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30038001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER , SEQUENCE (only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER , SEQUENCE (only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   DER , SEQUENCE (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   DER , SEQUENCE (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   CER , SEQUENCE (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   CER , SEQUENCE (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   DER , SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   DER , SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3003810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   CER , SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   CER , SEQUENCE (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30808101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER ,SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER ,SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3006800100810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER ,SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER ,SEQUENCE (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001008101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30079E01FF9F1F0105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30809E01FF9F1F01050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30079E01FF9F1F0105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SEQUENCE (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30809E01FF9F1F01050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER, SEQUENCE (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER, SEQUENCE (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('300BBE030101FFBF1F03020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER, SEQUENCE (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER, SEQUENCE (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3080BE800101FF0000BF1F8002010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER , SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER , SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('300BBE030101FFBF1F03020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER , SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER , SEQUENCE (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3080BE800101FF0000BF1F8002010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00830060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08030800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00830060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08030800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SEQUENCE (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00830060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SEQUENCE (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08030800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER, TAGGED SEQUENCE (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER, TAGGED SEQUENCE (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C300AA0030101FFA103020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER, TAGGED SEQUENCE (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER, TAGGED SEQUENCE (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803080A0800101FF0000A180020105000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C300AA0030101FFA103020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER encoding of TAGGED SEQUENCE (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803080A0800101FF0000A180020105000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SEQUENCE (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SEQUENCE (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30068501FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30808501FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SEQUENCE
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('300C8001FF8101058201068301FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }




<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF8101058201068301FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SEQUENCE
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('300C8001FF8101058201068301FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF8101058201068301FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('300D8001FF030207800201060401FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF030207800201060401FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('300D8001FF030207808101060401FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SEQUENCE
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SEQUENCE
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF030207808101060401FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3008A0038001FF810104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3080A0808001FF00008101040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SEQUENCE with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SEQUENCE with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('30060101FF020104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SEQUENCE
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800101FF0201040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER,SEQUENCE with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER,SEQUENCE with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SEQUENCE
      {

	a   OCTET STRING,

	b   BOOLEAN,

	...,

	d   BIT STRING,
	...,

	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('300D8001FF8101FF83020780820104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SEQUENCE with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SEQUENCE with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SEQUENCE
      {

	a   OCTET STRING,

	b   BOOLEAN,

	...,

	d   BIT STRING,
	...,

	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('30808001FF8101FF830207808201040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  SEQUENCE with Long Form , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  SEQUENCE with Long Form , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SEQUENCE
      {

	a   OCTET STRING,

	b   BOOLEAN,

	...,

	d   BIT STRING,
	...,

	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('308300000D8001FF8101FF83020780820104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SEQUENCE with fields of different types ,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SEQUENCE with fields of different types ,>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	--e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('304505000101FF0201020A0100030207800402FFFF06030002031603414243A1030101FF300505000101FF3106030207800500A3083006020101020102A40831060101FF0101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SEQUENCE with fields of different types ,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SEQUENCE with fields of different types ,>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	-- e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0, 090603312E452B30
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('308005000101FF0201020A0100030207800402FFFF06030002031603414243A1800101FF0000308005000101FF000031800302078005000000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SEQUENCE with fields of different types , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SEQUENCE with fields of different types , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('304380008101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SEQUENCE with fields of different types ,AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SEQUENCE with fields of different types ,AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS
::=

BEGIN


BERPDU ::= SEQUENCE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('308080008101FF8201028301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF INTEGER



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := { }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3000'O)and(enc_CER_PDU(myValue) == '30800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '30060101FF010100'O)and(enc_CER_PDU(myValue) == '30800101FF0101000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF OCTET STRING

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '30070402FFFF0401AB'O)and(enc_CER_PDU(myValue) == '30800402FFFF0401AB0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '301030060201050101FF3006020103010100'O)and(enc_CER_PDU(myValue) == '308030800201050101FF0000308002010301010000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF SET >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '301031060101FF0201053106010100020103'O)and(enc_CER_PDU(myValue) == '308031800101FF0201050000318001010002010300000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3006020105010100'O)and(enc_CER_PDU(myValue) == '30800201050101000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '301630090201050201060201073009020101020102020103'O)and(enc_CER_PDU(myValue) == '308030800201050201060201070000308002010102010202010300000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SEQUENCE OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SEQUENCE OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET OF INTEGER

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '301631090201050201060201073109020101020102020103'O)and(enc_CER_PDU(myValue) == '308031800201050201060201070000318002010102010202010300000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00830060101FF010100'O)and(enc_CER_PDU(myValue) == 'A08030800101FF01010000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00830060101FF010100'O)and(enc_CER_PDU(myValue) == 'A08030800101FF01010000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF010100'O)and(enc_CER_PDU(myValue) == 'A0800101FF0101000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER, SEQUENCE OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER, SEQUENCE OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := { }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER, SEQUENCE OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER, SEQUENCE OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := { }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER, SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER, SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER, SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER, SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800101FF0101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('30070402FFFF0401AB'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800402FFFF0401AB0000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('301030060201050101FF3006020103010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201050101FF0000308002010301010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF SET  >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('301031060101FF0201053106010100020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF SET  >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('308031800101FF0201050000318001010002010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('3006020105010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('30800201050101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('301630090201050201060201073009020101020102020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201050201060201070000308002010102010202010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SEQUENCE OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SEQUENCE OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('301631090201050201060201073109020101020102020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SEQUENCE OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SEQUENCE OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SEQUENCE OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('308031800201050201060201070000318002010102010202010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00830060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SEQUENCE OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SEQUENCE OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08030800101FF01010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00830060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SEQUENCE OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08030800101FF01010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SEQUENCE OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SEQUENCE OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101FF0101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3100'O)and(enc_CER_PDU(myValue) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31030101FF'O)and(enc_CER_PDU(myValue) == '31800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101FF020105'O)and(enc_CER_PDU(myValue) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET(different order) (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET(different order) (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := { c := 5,
			  b := true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101FF020105'O)and(enc_CER_PDU(myValue) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2)(both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2)(both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101FF020105'O)and(enc_CER_PDU(myValue) == '31800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3103020105'O)and(enc_CER_PDU(myValue) == '31800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order)(one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order)(one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5 ,
			 b :=  true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3103020105'O)and(enc_CER_PDU(myValue) == '31800201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106010100020105'O)and(enc_CER_PDU(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order) (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order) (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  false  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106010100020105'O)and(enc_CER_PDU(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order2) (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order2) (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN DEFAULT TRUE
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  false  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106010100020105'O)and(enc_CER_PDU(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of  SET (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of  SET (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3100'O)and(enc_CER_PDU(myValue) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET(only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET(only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31038001FF'O)and(enc_CER_PDU(myValue) == '31808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order)(only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order)(only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := omit,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31038001FF'O)and(enc_CER_PDU(myValue) == '31808001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31068001FF810105'O)and(enc_CER_PDU(myValue) == '31808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.encoding of SET (both elements are used)(different order) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - encoding of SET (both elements are used)(different order) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31068001FF810105'O)and(enc_CER_PDU(myValue) == '31808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used)(different order2)  AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used)(different order2)  AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31068001058101FF'O)and(enc_CER_PDU(myValue) == '31808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (one element is equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3103810105'O)and(enc_CER_PDU(myValue) == '31808101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order)  (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order)  (one element is equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5 ,
			 b :=  true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3103810105'O)and(enc_CER_PDU(myValue) == '31808101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106800100810105'O)and(enc_CER_PDU(myValue) == '31808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order)(one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order)(one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  false  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106800100810105'O)and(enc_CER_PDU(myValue) == '31808001008101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2)(one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2)(one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN DEFAULT TRUE
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3106800105810100'O)and(enc_CER_PDU(myValue) == '31808001058101000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order) (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order) (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2) (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2) (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	c [31] IMPLICIT INTEGER OPTIONAL,
	b [30] IMPLICIT BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.encoding of SET (different order) (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - encoding of SET (different order) (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5 ,
			 b :=  true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2)(both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2)(both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
        c [31] IMPLICIT INTEGER OPTIONAL,
	b [30] IMPLICIT BOOLEAN OPTIONAL

      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31079E01FF9F1F0105'O)and(enc_CER_PDU(myValue) == '31809E01FF9F1F01050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order)(both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order)(both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2) (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2) (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {

	c [31] EXPLICIT INTEGER OPTIONAL,
	b [30] EXPLICIT BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order) (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order) (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5 ,
			 b :=  true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (different order2)(both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (different order2)(both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
        c [31] EXPLICIT INTEGER OPTIONAL,
	b [30] EXPLICIT BOOLEAN OPTIONAL

      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BBE030101FFBF1F03020105'O)and(enc_CER_PDU(myValue) == '3180BE800101FF0000BF1F8002010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order) (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order) (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001058101FF'O)and(enc_CER_PDU(myValue) == 'A0808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order)(both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order)(both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2)(both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2)(both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101FF020105'O)and(enc_CER_PDU(myValue) == 'A0800101FF0201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order) (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order) (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101FF020105'O)and(enc_CER_PDU(myValue) == 'A08031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order) (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order) (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET
      {
	b  [1]  BOOLEAN OPTIONAL,
	c  [0]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA003020105A1030101FF'O)and(enc_CER_PDU(myValue) == 'A0803180A0800201050000A1800101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order)(both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order)(both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA0030101FFA103020105'O)and(enc_CER_PDU(myValue) == 'A0803180A0800101FF0000A180020105000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [1]  BOOLEAN OPTIONAL,
	c  [0]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00C310AA003020105A1030101FF'O)and(enc_CER_PDU(myValue) == 'A0803180A0800201050000A1800101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of TAGGED SET (different order) (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of TAGGED SET (different order) (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2)(both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2)(both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {

	c  [1]  INTEGER OPTIONAL,
	b  [0]  BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.encoding of TAGGED SET (different order) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - encoding of TAGGED SET (different order) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 5,
			 b :=  true  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001FF810105'O)and(enc_CER_PDU(myValue) == 'A0808001FF8101050000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET (different order2) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET (different order2) (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] SET
      {

	c  [0]  INTEGER OPTIONAL,
	b  [1]  BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0068001058101FF'O)and(enc_CER_PDU(myValue) == 'A0808001058101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060201058501FF'O)and(enc_CER_PDU(myValue) == '31800201058501FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET , (different order) one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET , (different order) one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := { c := 5 ,
			  b :=  true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060201058501FF'O)and(enc_CER_PDU(myValue) == '31800201058501FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET (different order) ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET (different order) ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {y OCTET STRING,

       x INTEGER OPTIONAL
       }



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201FF830106'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201FF8301060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201068301FF'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201068301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , (different order) one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , (different order) one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      {y OCTET STRING,

      x [0] INTEGER OPTIONAL
       }



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C8001FF8101058201FF830106'O)and(enc_CER_PDU(myValue) == '31808001FF8101058201FF8301060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN


MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D020106030207800401FF8001FF'O)and(enc_CER_PDU(myValue) == '3180020106030207800401FF8001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , (different order)one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , (different order)one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN


MySeq ::= SET
      {y OCTET STRING,
       x  INTEGER OPTIONAL
       }



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D020106030207800401FF8001FF'O)and(enc_CER_PDU(myValue) == '3180020106030207800401FF8001FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>
030



if ((enc_DER_PDU(myValue) == '310D030207800401FF8001FF810106'O)and(enc_CER_PDU(myValue) == '3180030207800401FF8001FF8101060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET ,(different order) one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET ,(different order) one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

MySeq ::= SET
      { y OCTET STRING,
        x  [1] INTEGER OPTIONAL
       }



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D030207800401FF8001FF810106'O)and(enc_CER_PDU(myValue) == '3180030207800401FF8001FF8101060000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3108A0038001FF810104'O)and(enc_CER_PDU(myValue) == '3180A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET with CHOICE element (different order), AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET with CHOICE element (different order), AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 4,
			 b := {x := true} }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3108A0038001FF810104'O)and(enc_CER_PDU(myValue) == '3180A0808001FF00008101040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET with CHOICE element (different order2), AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET with CHOICE element (different order2), AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {


	c   INTEGER OPTIONAL,
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 4,
			 b := {x := true} }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3108800104A1038001FF'O)and(enc_CER_PDU(myValue) == '3180800104A1808001FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN




BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101FF020104'O)and(enc_CER_PDU(myValue) == '31800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET with CHOICE element,(different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET with CHOICE element,(different order) >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN




BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 c := 4 ,
			 b := {x := true}
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101FF020104'O)and(enc_CER_PDU(myValue) == '31800101FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN




BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := {y := 'FF'O},
			 c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060201040401FF'O)and(enc_CER_PDU(myValue) == '31800401FF0201040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D8001FF8101FF82010483020780'O)and(enc_CER_PDU(myValue) == '31808001FF8101FF820104830207800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. encoding of SET with EXTENSION , (different order) AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  encoding of SET with EXTENSION , (different order) AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN




BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			  a := 'FF'O,
			  d := '1'B,
			  b := true,
			  c := 4
			   }
<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310D8001FF8101FF82010483020780'O)and(enc_CER_PDU(myValue) == '31808001FF8101FF820104830207800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }

myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }



<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31530101FF020102030207800402FFFF05000603000203090603312E452B300A0100300505000101FF310C03020780090603312E452B301603414243A1030101FFA3083006020101020102A40831060101FF0101FF'O)and(enc_CER_PDU(myValue) == '31800101FF020102030207800402FFFF05000603000203090603312E452B300A0100308005000101FF0000318003020780090603312E452B3000001603414243A1800101FF0000A380308002010102010200000000A48031800101FF0101FF000000000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with fields of different types, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with fields of different types, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '314F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)and(enc_CER_PDU(myValue) == '318080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET with fields of different types (different order), AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET with fields of different types (different order), AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL,
			 c := 2,
			 d := first,
			 e := 1.0,
			  b := true,
			 f := '1'B,
			 g := 'FFFF'O,

			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := 1.0 ,

			       x3 := '1'B   }  ,
			 h := myOBJID,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '314F80008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB0C80020780810603312E452B30AC06020101020102AD060101FF0101FF'O)and(enc_CER_PDU(myValue) == '318080008101FF820102830100840603312E452B30850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB8080020780810603312E452B300000AC800201010201020000AD800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN

BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C020101400102800103C00104'O)and(enc_CER_PDU(myValue) == '3180020101400102800103C001040000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN

BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31120201016003020102A003020103E003020104'O)and(enc_CER_PDU(myValue) == '318002010160800201020000A0800201030000E08002010400000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31120201016003020102A003020103E003020104'O)and(enc_CER_PDU(myValue) == '318002010160800201020000A0800201030000E08002010400000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET including untagged CHOICE (spec example) IMPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET including untagged CHOICE (spec example) IMPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3 } }
			 }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310BA103820102830101850103'O)and(enc_CER_PDU(myValue) == '3180850103A18082010200008301010000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET including untagged CHOICE (spec example) EXPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET including untagged CHOICE (spec example) EXPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := { g := 3 } }
			 }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3111A105A203020102A303020101A503020103'O)and(enc_CER_PDU(myValue) == '3180A5800201030000A180A28002010200000000A38002010100000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  DER , SET (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  DER , SET (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3100'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  CER , SET (EMPTY)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  CER , SET (EMPTY)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31800000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.DECODING DER , SET (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - DECODING DER , SET (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.DECODING CER , SET (only one element is used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - DECODING CER , SET (only one element is used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  DER , SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  DER , SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING  CER , SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING  CER , SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,different order , SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,different order , SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060201050101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , different order, SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , different order, SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {

	c   INTEGER OPTIONAL,
	b   BOOLEAN OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 c := 5,
			 b :=  true }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201050101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER , SET (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER , SET (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('3103020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER,  SET (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER,  SET (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING, default included , SET (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING, default included , SET (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('31060201050101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , default included,  SET (one element is equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , default included,  SET (one element is equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SET (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SET (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('3106010100020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SET (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SET (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101000201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order , SET (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order , SET (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('3106020105010100'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order , SET (one element is not equal to Default)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order , SET (one element is not equal to Default)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }
<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201050101000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER ,  SET (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER ,  SET (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3100'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER ,  SET (EMPTY), AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER ,  SET (EMPTY), AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  omit,
			 c :=  omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31800000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER , SET (only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER , SET (only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31038001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER , SET (only one element is used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER , SET (only one element is used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := omit  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   DER , SET (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   DER , SET (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   CER , SET (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   CER , SET (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order , SET (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order , SET (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31068101058001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order , SET (both elements are used) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order , SET (both elements are used) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808101058001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   DER , SET (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   DER , SET (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3103810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING   CER , SET (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING   CER , SET (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , default included  , SET (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , default included  , SET (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , default included, SET (one element is equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , default included, SET (one element is equal to Default) AUTOMATIC TAGGING >

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808101058001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER ,SET (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER ,SET (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3106800100810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER ,SET (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER ,SET (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001008101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING,reverse order,SET (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING,reverse order,SET (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('3106810105800100'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER ,SET (one element is not equal to Default) AUTOMATIC TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER ,SET (one element is not equal to Default) AUTOMATIC TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   BOOLEAN DEFAULT TRUE,
	c   INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  false,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808101058001000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SET (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SET (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31079E01FF9F1F0105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SET (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SET (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31809E01FF9F1F01050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31079F1F01059E01FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31809F1F01059E01FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31079E01FF9F1F0105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31809E01FF9F1F01050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31079F1F01059E01FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , SET (both elements are used) IMPLICIT TAGS for elements, EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] IMPLICIT BOOLEAN OPTIONAL,
	c [31] IMPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31809F1F01059E01FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER, SET (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER, SET (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('310BBE030101FFBF1F03020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER, SET (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER, SET (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180BE800101FF0000BF1F8002010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order, SET (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order, SET (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('310BBF1F03020105BE030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order, SET (both elements are used) EXPLICIT TAGS for elements
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order, SET (both elements are used) EXPLICIT TAGS for elements>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180BF1F800201050000BE800101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  DER , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  DER , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310BBE030101FFBF1F03020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  CER , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  CER , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180BE800101FF0000BF1F8002010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  , reverse order , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  , reverse order , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310BBF1F03020105BE030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  , reverse order , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  , reverse order , SET (both elements are used) EXPLICIT TAGS for elements, IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b [30] EXPLICIT BOOLEAN OPTIONAL,
	c [31] EXPLICIT INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180BF1F800201050000BE800101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060201050101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SEQUENCE (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SEQUENCE (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SEQUENCE
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SET (both elements are used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SET (both elements are used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060201050101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order , TAGGED SET (both elements are used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800201050101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101FF02010500000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060201050101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order , TAGGED SET (both elements are used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800201050101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER, TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER, TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C310AA0030101FFA103020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER, TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER, TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803180A0800101FF0000A180020105000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING reverse order, TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING reverse order, TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C310AA103020105A0030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING reverse order, TAGGED SET (both elements are TAGGED and used)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING reverse order, TAGGED SET (both elements are TAGGED and used)>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803180A1800201050000A0800101FF000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C310AA0030101FFA103020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER encoding of TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803180A0800101FF0000A180020105000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A00C310AA103020105A0030101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, reverse order, TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, reverse order, TAGGED SET (both elements are TAGGED and used), EXPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0803180A1800201050000A0800101FF000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order, TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order, TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068101058001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SET (both elements are TAGGED and used), IMPLICIT TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808101058001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068001FF810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808001FF8101050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order , TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0068101058001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , reverse order, TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , reverse order, TAGGED SET (both elements are TAGGED and used), AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= [0] SET
      {
	b  [0]  BOOLEAN OPTIONAL,
	c  [1]  INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808101058001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060201058501FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201058501FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31068501FF020105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET , one element is manually tagged, AUTOMATIC TAGGING ENVIRONMENT>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b  [5] BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31808501FF0201050000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310C8001FF8101058201068301FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }




<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF8101058201068301FF0000'O) == myValue){setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310C8001FF8201068101058301FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }




<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF8201068101058301FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310C8001FF8101058201068301FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF8101058201068301FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET ,one component element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310C8301FF8001FF820106810105'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET ,COMPONENTS OF used, AUTOMATIC TAGS, no manual tags>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x [0] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   BOOLEAN OPTIONAL,
	c   INTEGER OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := 5 ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31808301FF8101058201068001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('310D020106030207800401FF8001FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180020106030207800401FF8001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('310D030207800201060401FF8001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET , one base element is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180030207800201060401FF8001FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310D030207800401FF8001FF810106'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180030207800401FF8001FF8101060000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET , one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }



const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310D8101060401FF8001FF03020780'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET, one base element and one component is manually tagged,COMPONENTS OF used, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


MySeq ::= SET
      {x  [1] INTEGER OPTIONAL,
       y OCTET STRING}



BERPDU ::= SET
      {
	b   [0]  BOOLEAN OPTIONAL,
	c   BIT STRING OPTIONAL,
	COMPONENTS OF MySeq
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b :=  true,
			 c := '1'B ,
			 x := 6,
			 y := 'FF'O   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF0401FF030207808101060000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3108A0038001FF810104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180A0808001FF00008101040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3108810104A0038001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET with CHOICE element, AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET with CHOICE element, AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN

BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3180810104A0808001FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31060101FF020104'O) == myValue) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0201040000'O) == myValue){setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := {x := true},
			 c := 4
			   }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31060201040101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,reverse order, SET with CHOICE element,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,reverse order, SET with CHOICE element, >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {x := true},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201040101FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING DER, SET with CHOICE element, different choice
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING DER, SET with CHOICE element, different choice >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {y := 'FF'O},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060201040401FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING CER, SET with CHOICE element, different choice
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING CER, SET with CHOICE element, different choice >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {y := 'FF'O},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800401FF0201040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , SET with CHOICE element, different choice
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , SET with CHOICE element, different choice >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {y := 'FF'O},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060401FF020104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , SET with CHOICE element, different choice
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , SET with CHOICE element, different choice >

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN


BERPDU ::= SET
      {
	b   CHOICE {
			x BOOLEAN,
			y OCTET STRING
			}
		    OPTIONAL,


	c   INTEGER OPTIONAL

      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {b := {y := 'FF'O},
			 c := 4
			   }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201040401FF0000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,DER, SET with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,DER, SET with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('310D8001FF8101FF82010483020780'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,CER, SET with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,CER, SET with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING


      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF8101FF820104830207800000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('310D8001FF830207808101FF820104'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING ,different order, SET with EXTENSION , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING ,different order, SET with EXTENSION , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING


      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('31808001FF830207808101FF8201040000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING  SET with Long Form , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING  SET with Long Form , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('318300000D8001FF8101FF82010483020780'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING, different order,  SET with Long Form , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING, different order,  SET with Long Form , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {

	a   OCTET STRING,

	b   BOOLEAN,

	c   INTEGER OPTIONAL,

	...,

	d   BIT STRING




      }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }

<TTCN_TC:EXEC>

if (dec_BER_PDU('318300000D8101FF820104830207808001FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SET with fields of different types ,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SET with fields of different types ,>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	--e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('31450101FF020102030207800402FFFF050006030002030A01001603414243300505000101FF3106030207800500A1030101FFA3083006020101020102A40831060101FF0101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , CER,  SET with fields of different types ,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , CER,  SET with fields of different types ,>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	-- e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0, 090603312E452B30
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF020102030207800402FFFF050006030002030A01001603414243308005000101FF000031800302078005000000A1800101FF0000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , different order,  SET with fields of different types , different order
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , different order,  SET with fields of different types , different order >

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	--e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('31450101FF0201020A0100030207800402FFFF06030002031603414243A1030101FF300505000101FF3106030207800500A3083006020101020102A40831060101FF0101FF0500'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , different order,  SET with fields of different types , different order2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , different order,  SET with fields of different types , different order2>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	-- e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			// e := 1.0, 090603312E452B30
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }





<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0201020A0100030207800402FFFF050006030002031603414243A1800101FF0000308005000101FF000031800302078005000000A380308002010102010200000000A48031800101FF0101FF000000000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SET with fields of different types , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SET with fields of different types , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('314380008101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , DER,  SET with fields of different types ,AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , DER,  SET with fields of different types ,AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS
::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('318080008101FF8201028301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , different order,  SET with fields of different types , AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , different order,  SET with fields of different types , AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS
AUTOMATIC TAGS

::=

BEGIN



BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('31438101FF8201028301008400850207808602FFFF87030002038803414243A9038001FFAA0580008101FFAB06800207808100AC06020101020102AD060101FF0101FF8000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING , different order,  SET with fields of different types ,AUTOMATIC TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING , different order,  SET with fields of different types ,AUTOMATIC TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS
::=

BEGIN


BERPDU ::= SET
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   NULL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1  BOOLEAN,
		    y1  OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 NULL},

	m    SEQUENCE OF INTEGER,
	n    SET OF BOOLEAN
       }
myOBJID OBJECT IDENTIFIER  ::=   {itu-t(0) recommendation(0) a(2) b(3)}



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {a :=  NULL,
			 b := true,
			 c := 2,
			 d := first,
			 e := NULL,
			 f := '1'B,
			 g := 'FFFF'O,
			 h := myOBJID,
			 i :=   "ABC",
			 j := {x1 := true   } ,
			 k := {x2 := NULL,

			      y2  := true  }   ,
			 l := {y3 := NULL ,

			       x3 := '1'B   }  ,
			 m :=
                             { 1 ,2 }   ,
			 n :=
                             { true, true }
			 }






<TTCN_TC:EXEC>

if (dec_BER_PDU('318080008201028101FF8301008400850207808602FFFF87030002038803414243A9808001FF0000AA8080008101FF0000AB808002078081000000AC800201010201020000AD800101FF0101FF00000000'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310C020101400102800103C00104'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) IMPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180020101400102800103C001040000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31120201016003020102A003020103E003020104'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE )>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('318002010160800201020000A0800201030000E08002010400000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER, (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('31120201016003020102A003020103E003020104'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER,  (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER,  (include UNIVERSAL, APPLICATION, CONTEXT SPECIFIC, PRIVATE ) EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN



BERPDU ::= SET
      {
        d  [PRIVATE 0]  INTEGER OPTIONAL,
	a  INTEGER OPTIONAL,
	b  [APPLICATION 0] INTEGER OPTIONAL,
	c  [0] INTEGER OPTIONAL

      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


const BERPDU myValue := {
			 a :=  1,
			 c :=  3,
			 d :=  4,
			 b :=  2 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('318002010160800201020000A0800201030000E08002010400000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER,  untagged CHOICE in SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER,  untagged CHOICE in SET>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN




BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }




const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3  }}
			 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('310BA103820102830101850103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, CER,  untagged CHOICE in SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, CER,  untagged CHOICE in SET>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN




BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }




const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3  }}
			 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180850103A18082010200008301010000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, DER,  untagged CHOICE in SET, EXPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, DER,  untagged CHOICE in SET, EXPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN




BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }




const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3  }}
			 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3111A105A203020102A303020101A503020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DECODING SET, CER,  untagged CHOICE in SET, EXPLICIT TAGS
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DECODING SET, CER,  untagged CHOICE in SET, EXPLICIT TAGS>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN




BERPDU ::= SET
      {
       a [3] INTEGER,
       b [1] CHOICE
          {
	   c [2] INTEGER,
	   d [4] INTEGER
	  },
       e CHOICE
       	  {
	   f CHOICE
	   {
	      g [5] INTEGER,
	      h [6] INTEGER
	   },
           i CHOICE
            {


	      j  [0] INTEGER

	    }
	  }
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }




const BERPDU myValue := {
			 a :=  1,
			 b := {c:= 2},
			 e := { f := {g := 3  }}
			 }



<TTCN_TC:EXEC>

if (dec_BER_PDU('3180A5800201030000A180A28002010200000000A38002010100000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF INTEGER



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := { }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '3100'O)and(enc_CER_PDU(myValue) == '31800000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '31060101000101FF'O)and(enc_CER_PDU(myValue) == '31800101000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '31070401AB0402FFFF'O)and(enc_CER_PDU(myValue) == '31800401AB0402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3110300602010301010030060201050101FF'O)and(enc_CER_PDU(myValue) == '31803080020103010100000030800201050101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SET >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3110310601010002010331060101FF020105'O)and(enc_CER_PDU(myValue) == '31803180010100020103000031800101FF02010500000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '3106010100020105'O)and(enc_CER_PDU(myValue) == '31800101000201050000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '311630090201010201020201033009020105020106020107'O)and(enc_CER_PDU(myValue) == '318030800201010201020201030000308002010502010602010700000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET OF INTEGER

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '311631090201010201020201033109020105020106020107'O)and(enc_CER_PDU(myValue) == '318031800201010201020201030000318002010502010602010700000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101000101FF'O)and(enc_CER_PDU(myValue) == 'A08031800101000101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A00831060101000101FF'O)and(enc_CER_PDU(myValue) == 'A08031800101000101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of TAGGED SET OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of TAGGED SET OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {true, false }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0060101000101FF'O)and(enc_CER_PDU(myValue) == 'A0800101000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of SET OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of SET OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {'FFFF'O, ''O };

<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '310604000402FFFF'O)and(enc_CER_PDU(myValue) == '318004000402FFFF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER, SET OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER, SET OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := { }


<TTCN_TC:EXEC>

if (dec_BER_PDU('3100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER, SET OF INTEGER (empty)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER, SET OF INTEGER (empty)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := { }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER, SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER, SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060101000101FF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER, SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER, SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101000101FF0000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , SET OF BOOLEAN (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , SET OF BOOLEAN (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , SET OF BOOLEAN (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , SET OF BOOLEAN (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101FF0101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31070401AB0402FFFF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF OCTET STRING >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800401AB0402FFFF0000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF OCTET STRING (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF OCTET STRING (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31070402FFFF0401AB'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF OCTET STRING (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF OCTET STRING (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF OCTET STRING

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {'FFFF'O, 'AB'O };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800402FFFF0401AB0000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('3110300602010301010030060201050101FF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF SEQUENCE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31803080020103010100000030800201050101FF00000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SEQUENCE (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SEQUENCE (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311030060201050101FF3006020103010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SEQUENCE (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SEQUENCE (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318030800201050101FF0000308002010301010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF SET  >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('3110310601010002010331060101FF020105'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF SET  >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31803180010100020103000031800101FF02010500000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SET  (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SET  (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311031060101FF0201053106010100020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SET  (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SET  (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET {a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5,
				  b := true
				},

				{
				  a := 3,
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318031800101FF0201050000318001010002010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('3106010100020105'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF CHOICE >

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800101000201050000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF CHOICE (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF CHOICE (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('3106020105010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF CHOICE (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF CHOICE (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF CHOICE{a INTEGER, b BOOLEAN}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				  a := 5
				},

				{
				  b := false
				}

                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('31800201050101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311630090201010201020201033009020105020106020107'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318030800201010201020201030000308002010502010602010700000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SEQUENCE OF, (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SEQUENCE OF, (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311630090201050201060201073009020101020102020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SEQUENCE OF, (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SEQUENCE OF, (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SEQUENCE OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318030800201050201060201070000308002010102010202010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,SET OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,SET OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311631090201010201020201033109020105020106020107'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,SET OF SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,SET OF SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318031800201010201020201030000318002010502010602010700000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SET OF (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SET OF (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('311631090201050201060201073109020101020102020103'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,SET OF SET OF (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,SET OF SET OF (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= SET OF SET OF INTEGER

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {
				{
				5,
				6,
				7
				},

				{
				 1,
				 2,
				 3
				}
                        };


<TTCN_TC:EXEC>

if (dec_BER_PDU('318031800201050201060201070000318002010102010202010300000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101000101FF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SET OF BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SET OF BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101000101FF00000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN (different order)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101FF01010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101000101FF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101000101FF00000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (different order)>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A00831060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN, EXPLICIT TAGGING (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08031800101FF01010000000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING DER,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING DER,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060101000101FF'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING CER,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING CER,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101000101FF0000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (different order)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (different order)>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0060101FF010100'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (different order2)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,TAGGED SET OF BOOLEAN, IMPLICIT TAGGING (different order2)>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS
::=

BEGIN

BERPDU ::= [0] SET OF BOOLEAN

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {true, false }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0800101FF0101000000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - NULL
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - NULL>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {a :=  NULL}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0500'O)and(enc_CER_PDU(myValue) == '0500'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b :=  true}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - INTEGER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - INTEGER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {c :=  2}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '020102'O)and(enc_CER_PDU(myValue) == '020102'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - ENUMERATED
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - ENUMERATED>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {d :=  first}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0A0100'O)and(enc_CER_PDU(myValue) == '0A0100'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - REAL
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - REAL>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {e :=  1.0}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '090603312E452B30'O)and(enc_CER_PDU(myValue) == '090603312E452B30'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - BIT STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - BIT STRING>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {f :=  '1'B}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '03020780'O)and(enc_CER_PDU(myValue) == '03020780'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - OCTET STRING>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {g :=   'FFFF'O}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0402FFFF'O)and(enc_CER_PDU(myValue) == '0402FFFF'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - OBJECT IDENTIFIER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - OBJECT IDENTIFIER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



 myValue BERPDU  ::=  h :   {itu-t(0) recommendation(0) a(2) b(3)}



END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }


<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0603000203'O)and(enc_CER_PDU(myValue) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - IA5String
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - IA5String>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {i :=   "ABC"}

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '1603414243'O)and(enc_CER_PDU(myValue) == '1603414243'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {j := {x1 := true   }  }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A1030101FF'O)and(enc_CER_PDU(myValue) == 'A1800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - SEQUENCE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {k := {x2 := NULL,

			      y2  := true	 }    }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '300505000101FF'O)and(enc_CER_PDU(myValue) == '308005000101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - SET>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {l := {y3 := 1.0 ,

			       x3 := '1'B   }    }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '310C03020780090603312E452B30'O)and(enc_CER_PDU(myValue) == '318003020780090603312E452B300000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {m :=
                             { 1 ,2 }    }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3083006020101020102'O)and(enc_CER_PDU(myValue) == 'A380308002010102010200000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {n :=
                             { true, true }    }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A40831060101FF0101FF'O)and(enc_CER_PDU(myValue) == 'A48031800101FF0101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - No Default TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - No Default TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN

BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '0101FF'O)and(enc_CER_PDU(myValue) == '0101FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8001FF'O)and(enc_CER_PDU(myValue) == '8001FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN

BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == '8301FF'O)and(enc_CER_PDU(myValue) == '8301FF'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A3030101FF'O)and(enc_CER_PDU(myValue) == 'A3800101FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0038301FF'O)and(enc_CER_PDU(myValue) == 'A0808301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS

::=

BEGIN

BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A005A3030101FF'O)and(enc_CER_PDU(myValue) == 'A080A3800101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN

BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A005A3030101FF'O)and(enc_CER_PDU(myValue) == 'A080A3800101FF00000000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS

::=

BEGIN

BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {b := true }

<TTCN_TC:EXEC>




if ((enc_DER_PDU(myValue) == 'A0038301FF'O)and(enc_CER_PDU(myValue) == 'A0808301FF0000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - NULL
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - NULL>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {a :=  NULL}

<TTCN_TC:EXEC>

if (dec_BER_PDU('0500'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - BOOLEAN
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - BOOLEAN>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {b :=  true}

<TTCN_TC:EXEC>

if (dec_BER_PDU('0101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - INTEGER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - INTEGER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {c :=  2}

<TTCN_TC:EXEC>

if (dec_BER_PDU('020102'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - ENUMERATED
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - ENUMERATED>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {d :=  first}

<TTCN_TC:EXEC>

if (dec_BER_PDU('0A0100'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - BIT STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - BIT STRING>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {f :=  '1'B}

<TTCN_TC:EXEC>

if (dec_BER_PDU('03020780'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - OCTET STRING
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - OCTET STRING>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }
END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }
const BERPDU myValue := {g :=   'FFFF'O}

<TTCN_TC:EXEC>

if (dec_BER_PDU('0402FFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - OBJECT IDENTIFIER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - OBJECT IDENTIFIER>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }

myValue BERPDU  ::=  h :   {itu-t(0) recommendation(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - IA5String
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, CHOICE - IA5String>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {i :=   "ABC"}


<TTCN_TC:EXEC>

if (dec_BER_PDU('1603414243'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER ,DER, CHOICE - CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER ,DER, CHOICE - CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {j := {x1 := true   }  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A1030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {j := {x1 := true   }  }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A1800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER, CHOICE - SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER, CHOICE - SEQUENCE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {k := {x2 := NULL,

			      y2  := true	 }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('300505000101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - SEQUENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - SEQUENCE>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {k := {x2 := NULL,

			      y2  := true	 }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('308005000101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER, CHOICE - SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER, CHOICE - SET>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 OCTET STRING},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {l := {y3 := 'FFFF'O ,

			       x3 := '1'B   }    }




<TTCN_TC:EXEC>

if (dec_BER_PDU('3108030207800402FFFF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - SET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - SET>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 OCTET STRING},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {l := {y3 := 'FFFF'O ,

			       x3 := '1'B   }    }




<TTCN_TC:EXEC>

if (dec_BER_PDU('3180030207800402FFFF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER, CHOICE - SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER, CHOICE - SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {m :=
                             { 1 ,2 }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3083006020101020102'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - SEQUENCE OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - SEQUENCE OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {m :=
                             { 1 ,2 }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A380308002010102010200000000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER, CHOICE - SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER, CHOICE - SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {n :=
                             { true, true }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A40831060101FF0101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER, CHOICE - SET OF
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER, CHOICE - SET OF>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= CHOICE
      {
        a   NULL,
	b   BOOLEAN,
	c   INTEGER,
	d   ENUMERATED {first ,second ,third},
	e   REAL,
	f   BIT STRING,
	g   OCTET STRING,

	h   OBJECT IDENTIFIER,
	i   IA5String,
	j   CHOICE {x1 [1] BOOLEAN,
		    y1 [2] OCTET STRING},

	k   SEQUENCE{x2 NULL,
		     y2 BOOLEAN},

	l   SET { x3 BIT STRING,
		  y3 REAL},

	m   [3] SEQUENCE OF INTEGER,
	n   [4] SET OF BOOLEAN
       }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {n :=
                             { true, true }    }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A48031800101FF0101FF00000000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER decoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER decoding of CHOICE - Default IMPLICIT TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS

::=

BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('0101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER decoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER decoding of CHOICE - Default EXPLICIT TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('0101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER decoding of CHOICE - No Default TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER decoding of CHOICE - No Default TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('0101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS, CHOICE untagged>

<STATIC:ASN>

TempA

DEFINITIONS


AUTOMATIC TAGS

::=

BEGIN
BERPDU ::= CHOICE
      {
	b   BOOLEAN,
	c   INTEGER
      }



END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8001FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER decoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER decoding of CHOICE -  Default IMPLICIT TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS




::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS




::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE -  Default EXPLICIT TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS


::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END


<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE - No  Default  TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS


AUTOMATIC TAGS

::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }



END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS


IMPLICIT TAGS

::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS


EXPLICIT TAGS

::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER decoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER decoding of CHOICE -  No Default TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS



::=

BEGIN
BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }


END



<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER decoding of CHOICE -  Default AUTOMATIC TAGS,  number-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS


::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] IMPLICIT BOOLEAN,
	c  [6] INTEGER
      }





END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('8301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER  decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER  decoding of CHOICE -  Default IMPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE -  No Default  TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  CER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   CER decoding of CHOICE -  Default EXPLICIT TAGS,  fully-tagged CHOICE>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN


BERPDU ::= CHOICE
      {
	b  [3] EXPLICIT BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A3800101FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0038301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE - DEFAULT IMPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

IMPLICIT TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808301FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DER decoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DER decoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A005A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER decoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER decoding of CHOICE ,DEFAULT EXPLICIT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

EXPLICIT TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A080A3800101FF00000000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DER decoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DER decoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A005A3030101FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  CER decoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   CER decoding of CHOICE, NO DEFAULT,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS




::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A080A3800101FF00000000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  DER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   DER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0038301FF'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  CER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -   CER decoding of CHOICE ,DEFAULT AUTOMATIC,  TAGGED CHOICE,>

<STATIC:ASN>

TempA

DEFINITIONS

AUTOMATIC TAGS



::=

BEGIN



BERPDU ::= [0] CHOICE
      {
	b  [3] BOOLEAN,
	c  [6] INTEGER
      }




END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {b := true }



<TTCN_TC:EXEC>

if (dec_BER_PDU('A0808301FF0000'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , itu-t(0) recommendation(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , itu-t(0) recommendation(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , itu-t recommendation (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , itu-t recommendation (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t recommendation a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 0 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 0 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603000203'O)and(enc_CER_PDU(b) == '0603000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) question(1),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) question(1),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) question(1) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t question,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t question,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t question a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 1,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 1,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 1 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603010203'O)and(enc_CER_PDU(b) == '0603010203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) administration(2),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) administration(2),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) administration(2) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t administration,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t administration,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t administration a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 2,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 2,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 2 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603020203'O)and(enc_CER_PDU(b) == '0603020203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) network-operator(3),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) network-operator(3),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) network-operator(3) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t network-operator,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t network-operator,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t network-operator a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 3,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 3,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 3 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603030203'O)and(enc_CER_PDU(b) == '0603030203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) identified-organization(4),(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t(0) identified-organization(4),(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) identified-organization(4) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,itu-t identified-organization,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,itu-t identified-organization,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {itu-t identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,0 4,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,0 4,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {0 4 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603040203'O)and(enc_CER_PDU(b) == '0603040203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , iso(1) standard(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , iso(1) standard(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) standard(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso standard  (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso standard  (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso standard a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603280203'O)and(enc_CER_PDU(b) == '0603280203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso(1) member-body(2)(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso(1) member-body(2)(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) member-body(2) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso member-body(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso member-body(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso member-body a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 2 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 2 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 2 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032A0203'O)and(enc_CER_PDU(b) == '06032A0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso(1) identified-organization(3) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso(1) identified-organization(3) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso(1) identified-organization(3) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,iso identified-organization(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,iso identified-organization(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {iso identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 1 3 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 1 3 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {1 3 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06032B0203'O)and(enc_CER_PDU(b) == '06032B0203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(0)(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(0)(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t something(0) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t something(0) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 2 0 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 2 0 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {2 0 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '0603500203'O)and(enc_CER_PDU(b) == '0603500203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(100) (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , joint-iso-itu-t(2) something(100) (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(100) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER ,joint-iso-itu-t 100 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER ,joint-iso-itu-t 100 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t 100 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , 2 100 (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , 2 100 (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER
b BERPDU ::= {2 100 a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '060481340203'O)and(enc_CER_PDU(b) == '060481340203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , multiple octets needed for values (primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , multiple octets needed for values (primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::=  OBJECT IDENTIFIER
b BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3) 2000 4000 }

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '06075002038F509F20'O)and(enc_CER_PDU(b) == '06075002038F509F20'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , [0] IMPLICIT,  primitive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , [0] IMPLICIT,  primitive>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == '8003000203'O)and(enc_CER_PDU(b) == '8003000203'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.CER + DER encoding of OBJECT IDENTIFIER , [0] EXPLICIT  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - CER + DER encoding of OBJECT IDENTIFIER , [0] EXPLICIT  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER
b BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }



<TTCN_TC:EXEC>

if ((enc_DER_PDU(b) == 'A0050603000203'O)and(enc_CER_PDU(b) == 'A08006030002030000'O)) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t(0) recommendation(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t(0) recommendation(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= { itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t recommendation ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t recommendation ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t recommendation a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER 0 0 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER 0 0 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {0 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) question(1) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) question(1) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t(0) question(1) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER, itu-t question ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER, itu-t question ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t question a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER 0 1 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER 0 1 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {0 1 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603010203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER , itu-t(0) administration(2) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER , itu-t(0) administration(2) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t(0) administration(2) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER , itu-t administration ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER , itu-t administration ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t administration a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 2 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 2 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {0 2 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603020203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) network-operator(3) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) network-operator(3) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t(0) network-operator(3) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t network-operator ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t network-operator ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t network-operator a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 3 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 3 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {0 3 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603030203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) identified-organization(4) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t(0) identified-organization(4) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t(0) identified-organization(4) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,itu-t identified-organization ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,itu-t identified-organization ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 4  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 4  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {0 4 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603040203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) standard(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) standard(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso(1) standard(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso standard ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso standard ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso standard a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 0  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 0  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {1 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603280203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) member-body(2) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) member-body(2) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso(1) member-body(2) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso member-body ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso member-body ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso member-body a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 2 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 2 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {1 2 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032A0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) identified-organization(3) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso(1) identified-organization(3) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso(1) identified-organization(3) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,iso identified-organization ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,iso identified-organization ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {iso identified-organization a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,1 3  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,1 3  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {1 3 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06032B0203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t something(0) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t something(0) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {joint-iso-itu-t something(0) a(2) b(3)}


END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,2 0  ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,2 0  ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {2 0 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('0603500203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {joint-iso-itu-t(2) something(100) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,joint-iso-itu-t(2) something(100) ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {joint-iso-itu-t 100 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,2 100 ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,2 100 ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {2 100 a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('060481340203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,multiple octets needed for values ,(primitive)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,multiple octets needed for values ,(primitive)>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= OBJECT IDENTIFIER

myValue BERPDU ::= {joint-iso-itu-t(2) something(0) a(2) b(3) 2000 4000 }

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('06075002038F509F20'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER+DER ,0 0, IMPLICIT,  primitive
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER+DER ,0 0, IMPLICIT,  primitive>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] IMPLICIT OBJECT IDENTIFIER

myValue BERPDU ::= {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('8003000203'O) == myValue)


{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , DER ,0 0, EXPLICIT,  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , DER ,0 0, EXPLICIT,  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER

myValue BERPDU ::=  {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A0050603000203'O) == myValue)



{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING OBJECT IDENTIFIER , CER ,0 0, EXPLICIT,  constructed
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING OBJECT IDENTIFIER , CER ,0 0, EXPLICIT,  constructed>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN
BERPDU ::= [0] EXPLICIT OBJECT IDENTIFIER

myValue BERPDU ::=  {itu-t(0) recommendation(0) a(2) b(3)}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }


<TTCN_TC:EXEC>

if (dec_BER_PDU('A08006030002030000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER encoding of OPEN TYPE from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER encoding of OPEN TYPE from Information Object Class>

<STATIC:ASN>

TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}


END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}},field2  :=  999 };


<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '30093003020108020203E7'O)and(enc_CER_PDU(myValue) == '308030800201080000020203E70000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. CER + DER encoding of  TYPE from Information Object
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  CER + DER encoding of  TYPE from Information Object >

<STATIC:ASN>

TempA

DEFINITIONS


::=

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object
field2 MY-CLASS-1.&fixedTypeValueField
}

END


<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_CER)" }

const BERPDU myValue := {  field1 :=  {f1 := 8},field2  :=  999 };


<TTCN_TC:EXEC>

if ((enc_DER_PDU(myValue) == '30093003020108020203E7'O)and(enc_CER_PDU(myValue) == '308030800201080000020203E70000'O)) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,OPEN TYPE, DER, from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,OPEN TYPE, DER, from Information Object Class>

<STATIC:ASN>


TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}


END
<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('30093003020108020203E7'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING ,OPEN TYPE, CER, from Information Object Class
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING ,OPEN TYPE, CER, from Information Object Class>

<STATIC:ASN>


TempA

DEFINITIONS ::=
BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}

BERPDU ::= SEQUENCE

{
field1 MY-CLASS-1.&TypeField                 ({MyInformationObjectSet1} {@.field2} ),
field2 MY-CLASS-1.&fixedTypeValueField      ({MyInformationObjectSet1})
}


END
<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {aSN1_Type3 := {f1 := 8}}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201080000020203E70000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , TYPE from Information Object Class, DER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , TYPE from Information Object Class, DER>

<STATIC:ASN>


TempA

DEFINITIONS


::=

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object
field2 MY-CLASS-1.&fixedTypeValueField
}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {f1 := 8}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('30093003020108020203E7'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. DECODING , TYPE from Information Object Class, CER
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  DECODING , TYPE from Information Object Class, CER>

<STATIC:ASN>


TempA

DEFINITIONS


::=

BEGIN


--***************************************************************************************************
--modified class taken from Gyuri ASN1
--***************************************************************************************************
MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField            ASN1-Type1   UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	                &TypeField]
[FIXED VALUE TYPE FIELD		&fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING


--****************************************************************************************************
-- OBJECTS using the class defined above
--****************************************************************************************************


myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD               ASN1-Type3
FIXED VALUE TYPE FIELD	 999
}


myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type2
FIXED VALUE TYPE FIELD		888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD			ASN1-Type4
FIXED VALUE TYPE FIELD		555
}

--****************************************************************************************************
-- Defining Information Object sets
--****************************************************************************************************

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|
myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|
myObject-3,
...
}



BERPDU ::= SEQUENCE

{
field1 myObject-1.&TypeField ,               -- type from object
field2 MY-CLASS-1.&fixedTypeValueField
}

END

<STATIC>

import from TempA all;

external function dec_BER_PDU(in octetstring stream) return BERPDU with { extension "prototype(convert) decode(BER)" }

const BERPDU myValue := {  field1 := {f1 := 8}, field2  :=   999};


<TTCN_TC:EXEC>

if (dec_BER_PDU('308030800201080000020203E70000'O) == myValue)

{setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing Enc/Dec functions of implicit message encoding
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.  Fast enc/dec function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype fast>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
BERPDU ::= SEQUENCE
{
	a   OCTET STRING,
	b   BOOLEAN,
	...,
	d   BIT STRING,
	...,
	c   INTEGER OPTIONAL
}
END

<STATIC>

import from TempA all;
external function enc_DER_PDU(in BERPDU pdu, out octetstring os) with { extension "prototype(fast) encode(BER:BER_ENCODE_DER)" }
external function enc_CER_PDU(in BERPDU pdu, out octetstring os) with { extension "prototype(fast) encode(BER:BER_ENCODE_CER)" }
external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

const BERPDU myValue := {
			  a := 'FF'O,
			  b := true,
			  d := '1'B,
			  c := 4
			   }
<TTCN_TC:EXEC>

var octetstring der_encoded, cer_encoded;
var BERPDU der_decoded, cer_decoded;

enc_DER_PDU(myValue, der_encoded);
enc_CER_PDU(myValue, cer_encoded);

if ((der_encoded == '300D8001FF8101FF83020780820104'O) and
    (cer_encoded == '30808001FF8101FF830207808201040000'O))
  {setverdict(pass);} else {setverdict(fail);}

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}
dec_BER_PDU(cer_encoded, cer_decoded);
if (cer_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Backtrack decode function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype backtrack>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
STRPDU ::= PrintableString
USTRPDU ::= GeneralString
SEQPDU ::= SEQUENCE {
  f1 INTEGER,
  f2 OCTET STRING,
  f3 BOOLEAN
}
END

<STATIC>

import from TempA all;

external function encode_str(in STRPDU pdu) return octetstring
  with { extension "prototype(convert) encode(BER)" }
external function encode_ustr(in USTRPDU updu) return octetstring
  with { extension "prototype(convert) encode(BER)" }
external function encode_seq(in SEQPDU pdu) return octetstring
  with { extension "prototype(convert) encode(BER)" }
external function decode_str(in octetstring os, out STRPDU pdu) return integer
  with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }
external function decode_ustr(in octetstring os, out USTRPDU pdu) return integer
  with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }
external function decode_seq(in octetstring os, out SEQPDU pdu) return integer
  with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

<TTCN_TC:EXEC>

var STRPDU str := "haha";
var USTRPDU ustr := "uu";
var SEQPDU seq := { 123, 'ABCDEF'O, true }
var STRPDU decoded_str;
var USTRPDU decoded_ustr;
var SEQPDU decoded_seq;
var integer ret_val;

ret_val := decode_str(encode_str(str), decoded_str);
if (ret_val==0 and decoded_str==str) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_ustr(encode_ustr(ustr), decoded_ustr);
if (ret_val==0 and decoded_ustr==ustr) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_seq(encode_seq(seq), decoded_seq);
if (ret_val==0 and decoded_seq==seq) {setverdict(pass);} else {setverdict(fail);}

ret_val := decode_str(''O, decoded_str);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_ustr(''O, decoded_ustr);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_seq(''O, decoded_seq);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}

ret_val := decode_str('12'O, decoded_str);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_ustr('12'O, decoded_ustr);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_seq('12'O, decoded_seq);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}

ret_val := decode_str('1234'O, decoded_str);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_ustr('1234'O, decoded_ustr);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
ret_val := decode_seq('1234'O, decoded_seq);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Sliding decode function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype sliding>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
PDU ::= SEQUENCE {
  f1 INTEGER,
  f2 OCTET STRING,
  f3 BOOLEAN
}
END

<STATIC>

import from TempA all;

external function encode_PDU(in PDU pdu) return octetstring
  with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU(inout octetstring os, out PDU pdu) return integer
  with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

<TTCN_TC:EXEC>

var PDU pdu := { 123, 'ABCDEF'O, true }
var octetstring encoded_pdu;
var PDU decoded_pdu;
var integer ret_val;

encoded_pdu := encode_PDU(pdu);
ret_val := decode_PDU(encoded_pdu, decoded_pdu);
if (ret_val==0 and decoded_pdu==pdu) {setverdict(pass);} else {setverdict(fail);}

encoded_pdu := '800100'O;
ret_val := decode_PDU(encoded_pdu, decoded_pdu);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

encoded_pdu := substr(encode_PDU(pdu), 0, 4);
ret_val := decode_PDU(encoded_pdu, decoded_pdu);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Sliding decoding, octetstring length 0,1,2 -> incomplete TLV
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: incomplete TLV>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN
PDU0 ::= NULL
PDU1 ::= BOOLEAN
PDU2 ::= INTEGER
PDU3 ::= ENUMERATED { e0 (0), e1 (1) }
PDU4 ::= REAL
PDU5 ::= BIT STRING
PDU6 ::= OCTET STRING
PDU7 ::= PrintableString
PDU8 ::= GeneralString
PDU9 ::= CHOICE { i INTEGER, b BOOLEAN }
PDU10 ::= SEQUENCE { i INTEGER, b BOOLEAN }
PDU11 ::= SEQUENCE OF INTEGER
PDU12 ::= OBJECT IDENTIFIER
END

<STATIC>

import from TempA all;

external function encode_PDU0(in PDU0 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU0(inout octetstring os, out PDU0 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU1(in PDU1 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU1(inout octetstring os, out PDU1 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU2(in PDU2 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU2(inout octetstring os, out PDU2 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU3(in PDU3 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU3(inout octetstring os, out PDU3 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU4(in PDU4 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU4(inout octetstring os, out PDU4 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU5(in PDU5 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU5(inout octetstring os, out PDU5 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU6(in PDU6 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU6(inout octetstring os, out PDU6 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU7(in PDU7 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU7(inout octetstring os, out PDU7 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU8(in PDU8 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU8(inout octetstring os, out PDU8 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU9(in PDU9 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU9(inout octetstring os, out PDU9 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU10(in PDU10 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU10(inout octetstring os, out PDU10 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU11(in PDU11 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU11(inout octetstring os, out PDU11 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

external function encode_PDU12(in PDU12 pdu) return octetstring with { extension "prototype(convert) encode(BER:BER_ENCODE_DER)" }
external function decode_PDU12(inout octetstring os, out PDU12 pdu) return integer with { extension "prototype(sliding) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

<TTCN_TC:EXEC>

var octetstring encoded_pdu;
var integer ret_val;

var PDU0 pdu0 := NULL;
var PDU0 decoded_pdu0;
encoded_pdu := substr(encode_PDU0(pdu0), 0, 0);
ret_val := decode_PDU0(encoded_pdu, decoded_pdu0);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU0(pdu0), 0, 1);
ret_val := decode_PDU0(encoded_pdu, decoded_pdu0);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU1 pdu1 := true;
var PDU1 decoded_pdu1;
encoded_pdu := substr(encode_PDU1(pdu1), 0, 0);
ret_val := decode_PDU1(encoded_pdu, decoded_pdu1);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU1(pdu1), 0, 1);
ret_val := decode_PDU1(encoded_pdu, decoded_pdu1);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU1(pdu1), 0, 2);
ret_val := decode_PDU1(encoded_pdu, decoded_pdu1);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU2 pdu2 := 123;
var PDU2 decoded_pdu2;
encoded_pdu := substr(encode_PDU2(pdu2), 0, 0);
ret_val := decode_PDU2(encoded_pdu, decoded_pdu2);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU2(pdu2), 0, 1);
ret_val := decode_PDU2(encoded_pdu, decoded_pdu2);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU2(pdu2), 0, 2);
ret_val := decode_PDU2(encoded_pdu, decoded_pdu2);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU3 pdu3 := e1;
var PDU3 decoded_pdu3;
encoded_pdu := substr(encode_PDU3(pdu3), 0, 0);
ret_val := decode_PDU3(encoded_pdu, decoded_pdu3);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU3(pdu3), 0, 1);
ret_val := decode_PDU3(encoded_pdu, decoded_pdu3);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU3(pdu3), 0, 2);
ret_val := decode_PDU3(encoded_pdu, decoded_pdu3);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU4 pdu4 := 1.23;
var PDU4 decoded_pdu4;
encoded_pdu := substr(encode_PDU4(pdu4), 0, 0);
ret_val := decode_PDU4(encoded_pdu, decoded_pdu4);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU4(pdu4), 0, 1);
ret_val := decode_PDU4(encoded_pdu, decoded_pdu4);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU4(pdu4), 0, 2);
ret_val := decode_PDU4(encoded_pdu, decoded_pdu4);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU5 pdu5 := '101010'B;
var PDU5 decoded_pdu5;
encoded_pdu := substr(encode_PDU5(pdu5), 0, 0);
ret_val := decode_PDU5(encoded_pdu, decoded_pdu5);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU5(pdu5), 0, 1);
ret_val := decode_PDU5(encoded_pdu, decoded_pdu5);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU5(pdu5), 0, 2);
ret_val := decode_PDU5(encoded_pdu, decoded_pdu5);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU6 pdu6 := 'ABCDEF12'O;
var PDU6 decoded_pdu6;
encoded_pdu := substr(encode_PDU6(pdu6), 0, 0);
ret_val := decode_PDU6(encoded_pdu, decoded_pdu6);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU6(pdu6), 0, 1);
ret_val := decode_PDU6(encoded_pdu, decoded_pdu6);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU6(pdu6), 0, 2);
ret_val := decode_PDU6(encoded_pdu, decoded_pdu6);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU7 pdu7 := "haha";
var PDU7 decoded_pdu7;
encoded_pdu := substr(encode_PDU7(pdu7), 0, 0);
ret_val := decode_PDU7(encoded_pdu, decoded_pdu7);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU7(pdu7), 0, 1);
ret_val := decode_PDU7(encoded_pdu, decoded_pdu7);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU7(pdu7), 0, 2);
ret_val := decode_PDU7(encoded_pdu, decoded_pdu7);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU8 pdu8 := "huhu";
var PDU8 decoded_pdu8;
encoded_pdu := substr(encode_PDU8(pdu8), 0, 0);
ret_val := decode_PDU8(encoded_pdu, decoded_pdu8);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU8(pdu8), 0, 1);
ret_val := decode_PDU8(encoded_pdu, decoded_pdu8);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU8(pdu8), 0, 2);
ret_val := decode_PDU8(encoded_pdu, decoded_pdu8);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU9 pdu9 := { b := true }
var PDU9 decoded_pdu9;
encoded_pdu := substr(encode_PDU9(pdu9), 0, 0);
ret_val := decode_PDU9(encoded_pdu, decoded_pdu9);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU9(pdu9), 0, 1);
ret_val := decode_PDU9(encoded_pdu, decoded_pdu9);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU9(pdu9), 0, 2);
ret_val := decode_PDU9(encoded_pdu, decoded_pdu9);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU10 pdu10 := { 123 , true }
var PDU10 decoded_pdu10;
encoded_pdu := substr(encode_PDU10(pdu10), 0, 0);
ret_val := decode_PDU10(encoded_pdu, decoded_pdu10);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU10(pdu10), 0, 1);
ret_val := decode_PDU10(encoded_pdu, decoded_pdu10);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU10(pdu10), 0, 2);
ret_val := decode_PDU10(encoded_pdu, decoded_pdu10);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU11 pdu11 := { 1, 2, 3 }
var PDU11 decoded_pdu11;
encoded_pdu := substr(encode_PDU11(pdu11), 0, 0);
ret_val := decode_PDU11(encoded_pdu, decoded_pdu11);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU11(pdu11), 0, 1);
ret_val := decode_PDU11(encoded_pdu, decoded_pdu11);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU11(pdu11), 0, 2);
ret_val := decode_PDU11(encoded_pdu, decoded_pdu11);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

var PDU12 pdu12 := objid { itu_t(0) 4 }
var PDU12 decoded_pdu12;
encoded_pdu := substr(encode_PDU12(pdu12), 0, 0);
ret_val := decode_PDU12(encoded_pdu, decoded_pdu12);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU12(pdu12), 0, 1);
ret_val := decode_PDU12(encoded_pdu, decoded_pdu12);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}
encoded_pdu := substr(encode_PDU12(pdu12), 0, 2);
ret_val := decode_PDU12(encoded_pdu, decoded_pdu12);
if (ret_val==2) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Encoding/decoding of big integers
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Encoding/decoding of big integers
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Encoding/decoding of big integers>

<STATIC:ASN>

TempA DEFINITIONS AUTOMATIC TAGS ::=
BEGIN

BERPDU ::= INTEGER
bi1 BERPDU ::= 5
bi2 BERPDU ::= 0
bi3 BERPDU ::= 127
bi4 BERPDU ::= -128
bi5 BERPDU ::= -5
bi-6 BERPDU ::= 128
bi7 BERPDU ::= -129

BERPDU2 ::= REAL
--b BERPDU2 ::= 12345678900

Rec-ber ::= SEQUENCE {
  int1 Number,
  int2 Number
}
Rec-ber-literal ::= SEQUENCE {
  int1 NumberLit,
  int2 NumberLit
}
Number ::= INTEGER
NumberLit ::= NumericString (SIZE (100))
myNumber Number ::= 12345678910111213141516

END

<STATIC>

import from TempA language "ASN.1:1997" all

external function enc_ber1(in Rec_ber r) return octetstring
  with { extension "encode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_ber1(in octetstring r) return Rec_ber
  with { extension "decode(BER:BER_ACCEPT_ALL) prototype(convert) errorbehavior(ALL:WARNING)" }
external function enc_ber2(in integer r) return octetstring
  with { extension "encode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
// Attributes are not checked in the compiler.
external function dec_ber2(in octetstring r) return integer
  with { extension "decode(BER:BER_ENCODE_DER) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_ber3(inout octetstring r, out Rec_ber s) return integer
  with { extension "decode(BER:BER_ACCEPT_ALL) prototype(sliding) errorbehavior(ALL:WARNING)" }

type component comp_ber { }

<TTCN_TC:EXEC>

  const integer a := 2147483647
  const integer b := 2147483648
  const integer c := 2147483649
  const integer d := 128
  const integer e := myNumber
  const integer f := 12147483648
  var Rec_ber myrec1 := {int1 := a, int2 := b}
  var Rec_ber myrec2 := {int1 := c, int2 := d}
  var Rec_ber myrec3 := {int1 := 1048576, int2 := 321768}
  var Rec_ber myrec4 := {65536, 131072}
  var Rec_ber myrec5 := {4294967296, 8388608}
  var Rec_ber myrec6 := {12345678910111213141516, 11111111111111111111}
  var Rec_ber myrec7 := {8589934592, 1099511627776}
  var Rec_ber myrec8 := {int1 := a, int2 := b}
  var Rec_ber myrec9 := {int1 := 12345678910111213141516, int2 := -1234}
  var Rec_ber myrec10 := {int1 := -12345678910111213141516, int2 := -1234}
  var Rec_ber myrec11 := {2147483648, -2147483648}
  var Rec_ber myrec12 := {-2147483647, 2147483647}
  var Rec_ber myrec13 := {2147483649, -2147483649}
  var Rec_ber myrec14 := {-4294967296, 4294967296}
  var Rec_ber myrec15 := {4294967295, -4294967295}
  var Rec_ber myrec16 := {-4294967297, 4294967297}
  var Rec_ber pdu1 := {12345678910111213141516, -2147483648}
  var Rec_ber pdu2 := {123, 456}
  var octetstring encoded_pdu
  var Rec_ber decoded_pdu
  var integer ret_val  
  encoded_pdu := enc_ber1(pdu2)
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 0 and decoded_pdu == pdu2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := '800100'O
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := substr(enc_ber1(pdu1), 0, 4)
  ret_val := dec_ber3(encoded_pdu, decoded_pdu)
  if (ret_val == 2) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber2(-2147483648)
  if (encoded_pdu == '020480000000'O) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec1)
  if (myrec1 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := a, int2 := b} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec2)
  if (myrec2 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := c, int2 := d} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec3)
  if (myrec3 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := 1048576, int2 := 321768} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec4)
  if (myrec4 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({65536, 131072} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec5)
  if (myrec5 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({4294967296, 8388608} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec6)
  if (myrec6 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({12345678910111213141516, 11111111111111111111} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec7)
  if (myrec7 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({8589934592, 1099511627776} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec8)
  if (myrec8 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := a, int2 := b} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec9)
  if (myrec9 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := 12345678910111213141516, int2 := -1234} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec10)
  if (myrec10 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({int1 := -12345678910111213141516, int2 := -1234} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec11)
  if (myrec11 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({2147483648, -2147483648} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec12)
  if (myrec12 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-2147483647, 2147483647} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec13)
  if (myrec13 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({2147483649, -2147483649} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec14)
  if (myrec14 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-4294967296, 4294967296} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec15)
  if (myrec15 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({4294967295, -4294967295} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  encoded_pdu := enc_ber1(myrec16)
  if (myrec16 == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}
  if ({-4294967297, 4294967297} == dec_ber1(encoded_pdu)) {setverdict(pass)} else {setverdict(fail)}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
Negative tests for the BER decoder.
.*---------------------------------------------------------------------*
:h2.Test cases
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form NR3 pretending to be NR1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form NR3 pretending to be NR1>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0133313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This decimal encoding does not conform to NR1 form.

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form NR3 pretending to be NR2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form NR3 pretending to be NR2>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0233313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This decimal encoding does not conform to NR2 form.

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. BER decoding REAL, reserved decimal form 0x20
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, reserved decimal form 0x20>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D2033313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x20 (See X.690 8.5.7).

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form 0
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form 0>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0033313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x0 (See X.690 8.5.7).

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. BER decoding REAL, decimal form 4
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- BER decoding REAL, decimal form 4>

<STATIC:ASN>

TempA
DEFINITIONS
AUTOMATIC TAGS
::=
BEGIN

IMPORTS; -- nothing

BERPDU ::= REAL

END

<STATIC>

type float BERPDU;

external function dec_BER_PDU(in octetstring os, out BERPDU pdu)
  with { extension "prototype(fast) decode(BER:BER_ACCEPT_ALL) " }

// pi: 31415926.E-7
const octetstring der_encoded := '090D0433313431353932362E452D37'O;
const BERPDU myValue := 3.1415926;

<TTCN_TC:EXEC>

var BERPDU der_decoded, cer_decoded;

dec_BER_PDU(der_encoded, der_decoded);
if (der_decoded==myValue) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Dynamic test case error: While BER-decoding type '@Temp.BERPDU': While decoding REAL type: This is a reserved value: 0x4 (See X.690 8.5.7).

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Memory leak while BER decoding, test for HO73756
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Memory leak while BER decoding, test for HO73756>

<STATIC:ASN>
TempA DEFINITIONS ::=
BEGIN

MY-CLASS-1 ::= CLASS
{
&TypeField OPTIONAL,
&fixedTypeValueField ASN1-Type1 UNIQUE OPTIONAL

}
WITH SYNTAX
{
[TYPE FIELD	&TypeField]
[FIXED VALUE TYPE FIELD &fixedTypeValueField]
}

ASN1-Type1 ::= INTEGER

ASN1-Type2 ::= BOOLEAN

ASN1-Type3 ::= SEQUENCE {f1 INTEGER}

ASN1-Type4 ::= OCTET STRING

myObject-1 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type3
FIXED VALUE TYPE FIELD 999
}

myObject-2 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type2
FIXED VALUE TYPE FIELD 888
}

myObject-3 MY-CLASS-1 ::=
{
TYPE FIELD ASN1-Type4
FIXED VALUE TYPE FIELD 555
}

MyInformationObjectSet1 MY-CLASS-1 ::=
{
myObject-1|myObject-2,
...
}

MyInformationObjectSet2 MY-CLASS-1 ::=
{
MyInformationObjectSet1|myObject-3,
...
}

BERPDU ::= SEQUENCE
{
field1 MY-CLASS-1.&TypeField ({MyInformationObjectSet1} {@.field2} ),
field2 MY-CLASS-1.&fixedTypeValueField ({MyInformationObjectSet1})
}

END
<STATIC>
// Test for memory leak problem in BER decoder: HO73756.
import from TempA all;

external function dec_backtrack(in octetstring stream, out BERPDU outpdu) return integer with { extension "prototype(backtrack) decode(BER:BER_ACCEPT_ALL) errorbehavior(ALL:WARNING)" }

type component empty {
  var BERPDU mypdu
}

<TTCN_TC:PURE_EXEC>

testcase mytc() runs on empty {
  dec_backtrack('30093003020108020203E7'O, mypdu)
  dec_backtrack('30093003020108020203E7'O, mypdu)
  setverdict(pass)
}

control {
  execute(mytc())
}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h1.REFERENCES
.*---------------------------------------------------------------------*
:nl. Requirement specification(s):
:nl.-------------------------------
:list.
:li. 8/ETH/RUS-2003:0087 Uen - Requirement Specification for TITAN's encoder/decoder functions
:elist.

:etext.
