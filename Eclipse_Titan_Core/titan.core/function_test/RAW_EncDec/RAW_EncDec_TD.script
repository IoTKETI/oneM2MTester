.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Delic, Adam
.*   Hanko, Matyas
.*   Kovacs, Ferenc
.*   Pandi, Krisztian
.*   Raduly, Csaba
.*   Szabados, Kristof
.*   Szabo, Janos Zoltan â€“ initial implementation
.*
.******************************************************************************/
:text.
:lang eng.
.*
:docname.Test Description
:docno.7/152 91-CRL 113 200/3 Uen
:rev.A
:date.2013-01-27
.*
:prep.ETH/XZR Krisztian	Pandi
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY
.*
:title.Test description - RAW coder
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.

This file is obsolate, don't modify, improve it anymore!

This TD contains test cases related to TTCN3 Executor's RAW coder function.
DON'T YOU DARE TO WRITE AN INSPECTION RECORD ABOUT THIS FILE.

:exmp.

:p.:us.Revision Information:eus.

:xmp nokeep.
:us.History:eus.

REV   DATE         PREPARED   CHANGE
===   ==========   ========   ======
A     2003-10-31   ETHCSIR    New document
B     2005-11-09   EKRISZA    New tests and updates of the original tests.
C     2007-03-06   EDMDELI    Implicit message encoding
D     2007-06-20   EDMDELI    New testcase for implicit message encoding
E     2008-10-01   EFERKOV    Big integers
F     2010-01-18   EKRISZA     Updated for TITAN R8C
H     2010-08-13   EKRISZA     Updated for TITAN R8E
J      2011-05-26   EKRISZA    Added new test
K     2010-01-18   EKRISZA     Updated for TITAN R8H
A     2011-12-12   EKRISZA     Updated for release
A     2012-06-27   EFERKOV     Updated for release
A     2013-01-17   EKRIPND     Updated for release
:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester

:exmp.
:np.
.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Testing FIELDLENGTH Attribute
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(16)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(16)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(16)"};

const RAW_PDU 		i := 255
const octetstring 	o := 'FF00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(8)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(8)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(8)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(4)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(4)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(4)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(1)  for longer integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(1)  for longer integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(1)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(16)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(16)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(16)"};

const RAW_PDU 		i := 4660
const octetstring 	o := '3412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(32)  for integer 1 bit long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(32)  for integer 1 bit long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(32)"};

const RAW_PDU 		i := 1
const octetstring 	o := '01000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Default FIELDLENGTH  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Default FIELDLENGTH  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant ""};

const RAW_PDU 		i := 255
const octetstring 	o := 'FF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(8)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(8)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(8)"};

const RAW_PDU 		i := '11110000'B
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(8)  for bitstring 4 bits long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(8)  for bitstring 4 bits long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(8)"};

const RAW_PDU 		i := '1111'B
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == '0000'B & i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(4)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(4)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(4)"};

const RAW_PDU 		i := '1111'B
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(4)  for longer bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(4)  for longer bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(4)"};

const RAW_PDU 		i := '11111111'B
const octetstring 	o := 'FF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(16)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(16)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(16)"};

const RAW_PDU 		i := '1111000001110000'B
const octetstring 	o := '70F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(24)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(24)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(24)"};

const RAW_PDU 		i := '1111000001110000'B
const octetstring 	o := '70F000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) =='00000000'B & i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(0)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(0)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(0)"};

const RAW_PDU 		i := '1111000001110000'B
const octetstring 	o := '70F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Default FIELDLENGTH  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Default FIELDLENGTH  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant ""};

const RAW_PDU 		i := '1111000001110000'B
const octetstring 	o := '70F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(32)  for bitstring 4 bits long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(32)  for bitstring 4 bits long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(32)"};

const RAW_PDU 		i := '1111'B
const octetstring 	o := '0F000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == '0000000000000000000000000000'B & i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(1)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(1)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(1)"};

const RAW_PDU 		i := '0F'O
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(2)"};

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2) and BYTEORDER (first)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2) and BYTEORDER (first)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { variant "FIELDLENGTH(2)";
       variant "BYTEORDER (first)";
       encode "RAW"
     };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2) and BYTEORDER (last)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2) and BYTEORDER (last)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(2)";
       variant "BYTEORDER (last)"
     };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '3412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(4) and  BYTEORDER (first) for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(4) and  BYTEORDER (first) for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "BYTEORDER (first)"
     };

const RAW_PDU 		i := '12345678'O
const octetstring 	o := '12345678'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(4)  for octetstring 3 octets long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(4)  for octetstring 3 octets long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "BYTEORDER (first)"
     };

const RAW_PDU 		i := '123456'O
const octetstring 	o := '12345600'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) == i & '00'O))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(5)  for octetstring 2 octets long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(5)  for octetstring 2 octets long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(5)"
       };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i & '000000'O )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(4) and BYTEORDER (last)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(4) and BYTEORDER (last)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "BYTEORDER (last)"
     };

const RAW_PDU 		i := '12345678'O
const octetstring 	o := '78563412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(4) and BYTEORDER (last) for octetstring 3 octets long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(4) and BYTEORDER (last) for octetstring 3 octets long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "BYTEORDER (last)"
     };

const RAW_PDU 		i := '123456'O
const octetstring 	o := '00563412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) == i & '00'O))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Default  FIELDLENGTH  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Default  FIELDLENGTH  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant ""};

const RAW_PDU 		i := '123456'O
const octetstring 	o := '123456'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(0)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(0)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with {encode "RAW";
      variant "FIELDLENGTH(0)"
      };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(2)"};

const RAW_PDU 		i := '0F'H
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(4)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(4)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with {encode "RAW";
      variant "FIELDLENGTH(4)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '2143'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(8)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(8)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '21430000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i)  == o)and((dec_RAW_PDU(o) == i & '0000'H ))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2)  for hexstring longer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2)  for hexstring longer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with {encode "RAW";
      variant "FIELDLENGTH(2)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i)  == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Default FIELDLENGTH  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Default FIELDLENGTH  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW";
       variant ""};

const RAW_PDU 		i := '12345670'H
const octetstring 	o := '21436507'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(0)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(0)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(0)"};

const RAW_PDU 		i := '123456'H
const octetstring 	o := '214365'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(12)  for hexstring 2 hex long
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(12)  for hexstring 2 hex long>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(12)"};

const RAW_PDU 		i := '12'H
const octetstring 	o := '210000000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i)  == o)and((dec_RAW_PDU(o) == i & '0000000000'H ))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH (4) for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH (4) for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant "FIELDLENGTH(4)" ;
       encode "RAW"};

const RAW_PDU 		i := first
const octetstring 	o := '01'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(32)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(32)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant "FIELDLENGTH(32)"
       encode "RAW";};

const RAW_PDU 		i := first
const octetstring 	o := '01000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Default FIELDLENGTH  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Default FIELDLENGTH  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant ""
       encode "RAW";};

const RAW_PDU 		i := tenth
const octetstring 	o := '0A'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type bitstring RAW_PDU length (4);

const octetstring 	o := '0F'O
const RAW_PDU 	i := '1111'B


<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type hexstring RAW_PDU length (0);

const octetstring 	o := ''O
const RAW_PDU 	i := ''H


<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type octetstring RAW_PDU length (2 .. 2);

const octetstring 	o := '1122'O
const RAW_PDU 	i := '1122'O


<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }



type bitstring btype length (4)
type hexstring htype length (5)
type octetstring otype length (2 .. 2)

type record RAW_PDU {btype b, htype h, otype o}
with {encode "RAW"; variant  ""};

const octetstring 	o := '1932541122'O
const RAW_PDU 	i := {'1001'B,'12345'H, '1122'O}

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction record of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type bitstring btype length (12 .. 12)

type record length (2 .. 2) of btype  RAW_PDU
with {encode "RAW"; variant  ""};

const RAW_PDU 	i := {'000011111111'B, '111100001111'B}
const octetstring 	o := 'FFF0F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction set>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }



type bitstring btype length (1)
type hexstring htype length (4)
type octetstring otype length (2 .. 2)

type set RAW_PDU {htype h, otype o, btype b}
with {encode "RAW"; variant  ""};

const octetstring 	o := '2143112201'O
const RAW_PDU 	i := {h := '1234'H, o := '1122'O, b := '1'B}

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction - set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction set of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type bitstring btype length (12 .. 12)

type set length (2 .. 2) of btype  RAW_PDU
with {encode "RAW"; variant  ""};

const RAW_PDU 	i := {'000011111111'B, '111100001111'B}
const octetstring 	o := 'FFF0F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction and ALIGN - bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction and ALIGN - bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type bitstring RAW_PDU length (9 .. 9)
with {encode "RAW"; variant "ALIGN(left)"}


const RAW_PDU 	i := '111100001'B
const octetstring 	o := 'E101'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((dec_RAW_PDU(o) == i )) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction and ALIGN - hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction and ALIGN - hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type hexstring RAW_PDU length (10 .. 10)
with {encode "RAW"; variant "ALIGN(right), BITORDERINOCTET(lsb)"}


const RAW_PDU 	i := '0000012345'H
const octetstring 	o := '0000103254000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((dec_RAW_PDU(o) == i )) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH with length restriction and ALIGN - octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH with length restriction and ALIGN - octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type octetstring RAW_PDU length (8 .. 8)
with {encode "RAW"; variant "ALIGN(left)"}


const RAW_PDU 	i := '0102030400000000'O
const octetstring 	o := '010203040000000000000000000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((dec_RAW_PDU(o) == i )) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing BYTEORDER Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for integer 0
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for integer 0>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (first)"  };

const RAW_PDU 		i := 0
const octetstring 	o := '00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (first)"  };

const RAW_PDU 		i := 1
const octetstring 	o := '01'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (first)"  };

const RAW_PDU 		i := 18
const octetstring 	o := '12'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first) and FIELDLENGTH (8)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first) and FIELDLENGTH (8)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW" ;
       variant "FIELDLENGTH (8)" ;
       variant "BYTEORDER (first)" };

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first) and  FIELDLENGTH(16)for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first) and  FIELDLENGTH(16)for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW" ;
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (first)" };

const RAW_PDU 		i := 15
const octetstring 	o := '0F00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for integer 0
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for integer 0>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (last)"  };

const RAW_PDU 		i := 0
const octetstring 	o := '00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (last)"  };

const RAW_PDU 		i := 1
const octetstring 	o := '01'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER (last) for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER (last) for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "BYTEORDER (last)"  };

const RAW_PDU 		i := 18
const octetstring 	o := '12'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last) and FIELDLENGTH (8) for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last) and FIELDLENGTH (8) for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH (8)" ;
       variant "BYTEORDER (last)" };

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last) and FIELDLENGTH(16) for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last) and FIELDLENGTH(16) for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (last)" };

const RAW_PDU 		i := 15
const octetstring 	o := '000F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (first)" };

const RAW_PDU 		i := '0000000100000010'B
const octetstring 	o := '0201'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (last)" };

const RAW_PDU 		i := '0000000100000010'B
const octetstring 	o := '0102'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "BYTEORDER (first)"};

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "BYTEORDER (last)"};

const RAW_PDU 		i := '1234'O
const octetstring 	o := '3412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (first) "};

const RAW_PDU 		i := first
const octetstring 	o := '0100'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (last) "};

const RAW_PDU 		i := first
const octetstring 	o := '0001'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(first)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(first)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BYTEORDER(first)"};

const RAW_PDU 		i := '1234567890'H
const octetstring 	o := '2143658709'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BYTEORDER(last)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BYTEORDER(last)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BYTEORDER(last)"};

const RAW_PDU 		i := '1234567890'H
const octetstring 	o := '0987654321'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing BITORDERINFIELD Attribute
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := 15
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := 4660
const octetstring 	o := '3412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := 4660
const octetstring 	o := '482C'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := '0F'O
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := '0F'O
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := '1234'O
const octetstring 	o := '2C48'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := '00000011'B
const octetstring 	o := '03'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := '00000011'B
const octetstring 	o := 'C0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := '0001111100110001'B
const octetstring 	o := '311F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := '0001111100110001'B
const octetstring 	o := 'F88C'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(4)" ;
       variant "BITORDERINFIELD (lsb) "};

const RAW_PDU 		i := first
const octetstring 	o := '01'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)   for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)   for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD (msb) "};

const RAW_PDU 		i := first
const octetstring 	o := '80'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(lsb)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(lsb)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BITORDERINFIELD(lsb)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '2143'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINFIELD(msb)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINFIELD(msb)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BITORDERINFIELD(msb)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := 'C284'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing BITORDERINOCTET Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(lsb)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET (msb) for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET (msb) for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(msb)"};

const RAW_PDU 		i := 15
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(lsb)"};

const RAW_PDU 		i := 4660
const octetstring 	o := '3412'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(msb)"
     };

const RAW_PDU 		i := 4660
const octetstring 	o := '2C48'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINOCTET(lsb)"
     };

const RAW_PDU 		i := '0F'O
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINOCTET(msb)"
     };

const RAW_PDU 		i := '0F'O
const octetstring 	o := 'F0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb) for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb) for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with {encode "RAW";
      variant "FIELDLENGTH(2)" ;
      variant "BITORDERINOCTET(lsb)"
     };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINOCTET(msb)"
     };

const RAW_PDU 		i := '1234'O
const octetstring 	o := '482C'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(lsb)"
     };

const RAW_PDU 		i := '00000011'B
const octetstring 	o := '03'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(msb)"
     };

const RAW_PDU 		i := '00000011'B
const octetstring 	o := 'C0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(lsb)"
     };

const RAW_PDU 		i := '0001111100110001'B
const octetstring 	o := '311F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(msb)"
     };

const RAW_PDU 		i := '0001111100110001'B
const octetstring 	o := '8CF8'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(4)" ;
       variant "BITORDERINOCTET (lsb) "
     };

const RAW_PDU 		i := first
const octetstring 	o := '01'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type enumerated RAW_PDU
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET (msb) "
     };

const RAW_PDU 		i := first
const octetstring 	o := '80'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(lsb)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(lsb)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BITORDERINOCTET(lsb)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '2143'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   BITORDERINOCTET(msb)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    BITORDERINOCTET(msb)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "BITORDERINOCTET(msb)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '84C2'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing COMP Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   COMP( nosign )  for positive integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP( nosign )  for positive integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( nosign ) "
     };

const RAW_PDU 		i := 2
const octetstring 	o := '02'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   COMP ( nosign ) for negative integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP ( nosign ) for negative integer >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( nosign ) "
     };

const RAW_PDU 		i := -2
const octetstring 	o := '02'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   COMP( signbit )  for positive integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP( signbit )  for positive integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( signbit ) "
     };

const RAW_PDU 		i := 2
const octetstring 	o := '02'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   COMP( signbit )   for negative integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP( signbit )   for negative integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( signbit ) "
     };

const RAW_PDU 		i := -2
const octetstring 	o := '82'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   COMP( 2scompl )  for positive integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP( 2scompl )  for positive integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( 2scompl ) "
     };

const RAW_PDU 		i := 2
const octetstring 	o := '02'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   COMP( 2scompl )  for negative integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP( 2scompl )  for negative integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( 2scompl ) "
     };

const RAW_PDU 		i := -2
const octetstring 	o := 'FE'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing PADDING Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   PADDING  for integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING  for integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{ integer   int1 ,
  integer   int2 ,
  integer   int3 ,
  integer   int4   }
 with { variant (int3) "FIELDLENGTH (4)" ;
        variant (int1) "PADDING( yes ) " ;
        variant (int2) "FIELDLENGTH (4)" ;
        variant (int2) "PADDING( yes ) " ;
        variant (int3) "FIELDLENGTH (4)" ;
        variant (int3) "PADDING( no ) " ;
        variant (int4) "FIELDLENGTH (4)" ;
        variant (int4) "PADDING( no ) " ; }
} with {encode "RAW" };


const RAW_PDU
	i := {  int1 :=    1  ,
	        int2 :=    2  ,
		int3 :=    3  ,
		int4 :=    4       }



const octetstring 	o := '010243'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   PADDING  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{ bitstring   bit1 ,
  bitstring   bit2 ,
  bitstring   bit3 ,
  bitstring   bit4   }
 with { variant (bit1) "FIELDLENGTH(4)" ;
        variant (bit1) "PADDING( yes ) " ;
	variant (bit2) "FIELDLENGTH(4)" ;
        variant (bit2) "PADDING( yes ) " ;
	variant (bit3) "FIELDLENGTH(4)" ;
        variant (bit3) "PADDING( no ) " ;
	variant (bit4) "FIELDLENGTH(4)" ;
        variant (bit4) "PADDING( no ) " ;
      };
} with {encode "RAW"}


const RAW_PDU
	i := {  bit1 :=  '0001'B  ,
	        bit2 :=  '0010'B  ,
		bit3 :=  '0011'B  ,
		bit4 :=  '0100'B       }



const octetstring 	o := '010243'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   PADDING  for enumerated
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING  for enumerated>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type enumerated enumerated1
{ zero, first, second, third, fourth, fifth }

type enumerated enumerated2
{ tenth, eleventh, twelfth, thirteenth, fourthteenth, fifteenth }

type enumerated enumerated3
{ twenty, twentyfirst, twentysecond, twentythird, twentyfourth, twentyfifth }

type enumerated enumerated4
{ thirty, thirtyfirst, thirtysecond, thirtythird, thirtyfourth, thirtyfifth }


type record RAW_PDU
{ enumerated1   enum1 ,
  enumerated2   enum2 ,
  enumerated3   enum3 ,
  enumerated4   enum4   }
 with { variant (enum1) "FIELDLENGTH(4)" ;
        variant (enum1) "PADDING( yes ) " ;
	variant (enum2) "FIELDLENGTH(4)" ;
        variant (enum2) "PADDING( yes ) " ;
	variant (enum3) "FIELDLENGTH(4)" ;
        variant (enum3) "PADDING( no ) " ;
	variant (enum4) "FIELDLENGTH(4)" ;
        variant (enum4) "PADDING( no ) " ;
      };
} with {encode "RAW" };


const RAW_PDU
	i := {  enum1 :=  first  ,
	        enum2 :=  twelfth  ,
		enum3 :=  twentythird  ,
		enum4 :=  thirtyfourth       }






const octetstring 	o := '010243'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   PADDING  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{ hexstring   hex1 ,
  hexstring   hex2 ,
  hexstring   hex3 ,
  hexstring   hex4   }
 with { encode "RAW";
        variant (hex1) "FIELDLENGTH(1)" ;
        variant (hex1) "PADDING( yes ) " ;
	variant (hex2) "FIELDLENGTH(1)" ;
        variant (hex2) "PADDING( yes ) " ;
	variant (hex3) "FIELDLENGTH(1)" ;
        variant (hex3) "PADDING( no ) " ;
	variant (hex4) "FIELDLENGTH(1)" ;
        variant (hex4) "PADDING( no ) " ;
      };
} with {encode "RAW" }


const RAW_PDU
	i := {  hex1 :=  '1'H  ,
	        hex2 :=  '2'H  ,
		hex3 :=  '3'H  ,
		hex4 :=  '4'H       }



const octetstring 	o := '010243'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing PREPADDING Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.  PREPADDING(yes)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(yes)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU length (3)
with {encode "RAW"; variant "PREPADDING(yes)"}

const RAW_PDU 		i := '101'B
const octetstring 	o := '05'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.  PREPADDING(yes)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(yes)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU length (1)
with {encode "RAW"; variant "PREPADDING(yes)"}

const RAW_PDU 		i := 'F'H
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(word16)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(word16)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring otype
with {encode "RAW"; variant "PREPADDING(word16)"}
type hexstring   htype length (3)

type record RAW_PDU { htype h, otype o}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {'AAA'H,'FF'O}
const octetstring 	o := 'AA0AFF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(word16)  for record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(word16)  for record of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer itype
with {encode "RAW"; variant "FIELDLENGTH(3)"}
type record length (1) of itype rtype
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU {itype r1, rtype r2}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {4,{7}}
const octetstring 	o := '040007'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(dword32)  for set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(dword32)  for set of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)
type record length (2) of BIT3 rtype
with {encode "RAW"; variant "PREPADDING(dword32)"}

type record RAW_PDU {BIT3 r1, rtype r2}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {'100'B,{'111'B, '101'B}}
const octetstring 	o := '040000002F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(dword32)  for record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(dword32)  for record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)

type record stype {BIT3 s1, BIT3 s2}
with {encode "RAW"; variant "PREPADDING(dword32)"}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{'111'B,'111'B},{'110'B,'000'B},{'111'B,'111'B}}
const octetstring 	o := '3F000000060000003F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(word16)  for set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(word16)  for set>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)

type set stype {BIT3 s1}
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{s1:='111'B},{s1:='110'B},{s1:='111'B}}
const octetstring 	o := '0700060007'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PREPADDING(word16)  for union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PREPADDING(word16)  for union>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)
type hexstring HEX1 length (1)

type union utype {BIT3 u1, HEX1 u2}
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU {utype r1, utype r2, utype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{u1:='111'B},{u1:='010'B},{u1:='111'B}}
const octetstring 	o := '0700020007'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing PADDING_PATTERN Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.  PADDING_PATTERN  for record of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-     PADDING_PATTERN  for record of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer itype
with {encode "RAW"; variant "FIELDLENGTH(3)"}
type record length (1) of itype rtype
with {encode "RAW"; variant "PREPADDING(yes), PADDING_PATTERN('1'B)"}

type record RAW_PDU {itype r1, rtype r2}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {4,{7}}
const octetstring 	o := 'FC07'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDING_PATTERN  for set of
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-     PADDING_PATTERN  for set of>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)

type set length (2) of BIT3 rtype
with {encode "RAW"; variant "PREPADDING(yes), PADDING_PATTERN('10000'B)"}

type record RAW_PDU {BIT3 r1, rtype r2}
with {encode "RAW"; variant ""}


const RAW_PDU 		i := {'100'B,{'111'B, '101'B}}
const octetstring 	o := '842F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDING_PATTERN  for record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING_PATTERN  for record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT9 length (9)

type record stype {BIT9 s1, BIT9 s2}
with {encode "RAW"; variant "PREPADDING(40), PADDING_PATTERN('100000'B)"}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant ""}


const RAW_PDU 		i := {{'111000111'B,'111000111'B},{'111111111'B,'111111111'B},{'111000111'B,'111000111'B}}
const octetstring 	o := 'C78F832008FFFF832008C78F03'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDING_PATTERN  for set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING_PATTERN  for set>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring HEX3 length (3)

type set stype {HEX3 s1}
with {encode "RAW"; variant "PREPADDING(15), PADDING_PATTERN('10001'B)"}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{s1:='FFF'H},{s1:='FFF'H},{s1:='FFF'H}}
const octetstring 	o := 'FF9FFFCFFF03'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDING_PATTERN  for union
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDING_PATTERN  for union>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring OCT2 length (2)

type union utype {OCT2 u1, hexstring u2}
with {encode "RAW"; variant "PREPADDING(256),PADDING_PATTERN('11001'B)"}

type record RAW_PDU {utype r1, utype r2, utype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{u1:='AABB'O},{u1:='CCDD'O},{u1:='EEFF'O}}
const octetstring 	o := 'AABB39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CECCDD39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CEEEFF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing PADDALL Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.  PADDALL with PADDING Attribute - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDALL with PADDING Attribute - record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT1 length (1)

type record stype {BIT1 s1, BIT1 s2}
with {encode "RAW"; variant "PADDING(yes), PADDALL"}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant ""}

const RAW_PDU 		i := {{'1'B,'1'B},{'1'B,'1'B},{'1'B,'1'B}}
const octetstring 	o := '010101010101'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDALL with PADDING Attribute - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDALL with PADDING Attribute - set>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)

type set stype {BIT3 s1, BIT3 s2}
with {encode "RAW"; variant "PADDING(4), PADDALL"}

type set RAW_PDU {stype r1, stype r2}
with {encode "RAW"; variant "PADDING(dword32), PADDALL"}

const RAW_PDU 		i := {r1:={s1:='111'B,s2:='101'B},r2:={s1:='111'B,s2:='101'B}}

const octetstring 	o := '57570000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDALL with PREPADDING Attribute - record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDALL with PADDING Attribute - record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring HEX1 length (1)

type record stype {HEX1 s1, HEX1 s2}

type record RAW_PDU {stype r1, stype r2, stype r3}
with {encode "RAW"; variant "PREPADDING(12), PADDALL"}

const RAW_PDU 		i := {{'A'H,'B'H},{'A'H,'B'H},{'A'H,'B'H}}
const octetstring 	o := 'BAA00BBA'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PADDALL with PREPADDING Attribute - set
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PADDALL with PADDING Attribute - set>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring HEX1 length (1)

type set stype {HEX1 s1, HEX1 s2, HEX1 s3}
with {encode "RAW"; variant "PREPADDING(12), PADDALL"}

type set RAW_PDU {stype r1, stype r2}
with {encode "RAW"; variant "PREPADDING(36), PADDALL, PADDING_PATTERN('1111'B)"}

const RAW_PDU 		i := {	r1:={s1:='A'H,s2:='B'H,s3:='C'H},
				r2:={s1:='A'H,s2:='B'H,s3:='C'H}}

const octetstring 	o := '0AB000FCAF000BC0'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing PTROFFSET Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.  PTROFFSET is set to default base
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PTROFFSET is set to default base>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT4 length (4)
type hexstring HEX1 length (1)
type octetstring OCT3 length (3)

group RAW_group{

type integer INT1
with {variant "FIELDLENGTH(8)" };

type record RAW_PDU {
			INT1 ptr1,
			INT1 ptr2,
			BIT4 field1,
			BIT4 field2 }

with { variant (ptr1) "POINTERTO(field1)";
       variant (ptr1) "UNIT(1)";
       variant (ptr1) "PTROFFSET(ptr1)";
       variant (ptr2) "POINTERTO(field2)";
       variant (ptr2) "UNIT(1)"
       variant (ptr2) "PTROFFSET(ptr2)"}

} with {encode "RAW" };

const	RAW_PDU i := {16,12,'0110'B,'1001'B}

const octetstring 	o := '100C96'O


<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  PTROFFSET is set to the beginning of record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PTROFFSET is set to the beginning of record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)
type hexstring HEX1 length (1)
type octetstring OCT3 length (3)

group RAW_group{

type integer INT1
with { encode "RAW"; variant "FIELDLENGTH(8)" };


type record RAW_PDU {
			INT1 ptr1,
			INT1 ptr2,
			INT1 ptr3,

			BIT3 field1,
			HEX1 field2,
			OCT3 field3 }

with { variant (ptr1) "POINTERTO(field1)";
       variant (ptr1) "UNIT(1)";
       variant (ptr1) "PTROFFSET(ptr1)";
       variant (ptr2) "POINTERTO(field2)";
       variant (ptr2) "UNIT(1)";
       variant (ptr2) "PTROFFSET(ptr1)";
       variant (ptr3) "POINTERTO(field3)";
       variant (ptr3) "UNIT(1)";
       variant (ptr3) "PTROFFSET(ptr1)"}

} with {encode "RAW" };

const	RAW_PDU i := {24,27,31,'111'B,'A'H,'010203'O}

const octetstring 	o := '181B1FD7008101'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.  PTROFFSET is set to data field
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    PTROFFSET is set to data field>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3 length (3)
type hexstring HEX1 length (1)
type octetstring OCT3 length (3)

group RAW_group{

type integer INT1
with { variant "FIELDLENGTH(8)" };


type record RAW_PDU {
			INT1 ptr1,
			INT1 ptr2,
			INT1 ptr3,

			BIT3 field1,
			HEX1 field2,
			OCT3 field3 }

with {  variant (ptr1) "POINTERTO(field1)";
        variant (ptr1) "UNIT(1)";
        variant (ptr1) "PTROFFSET(field1)";
        variant (ptr2) "POINTERTO(field2)";
        variant (ptr2) "UNIT(1)";
        variant (ptr2) "PTROFFSET(field1)";
        variant (ptr3) "POINTERTO(field3)";
        variant (ptr3) "UNIT(1)";
        variant (ptr3) "PTROFFSET(field1)"}

} with {encode "RAW" };

const	RAW_PDU i := {0,3,7,'111'B,'A'H,'010203'O}

const octetstring 	o := '000307D7008101'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing HEXORDER Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   HEXORDER(low)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    HEXORDER(low)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "HEXORDER(low)"};

const RAW_PDU 		i := '1234567890'H
const octetstring 	o := '2143658709'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   HEXORDER(high)  for hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    HEXORDER(high)  for hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with { encode "RAW"; variant "HEXORDER(high)"};

const RAW_PDU 		i := '1234567890'H
const octetstring 	o := '1234567890'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing EXTENSION BIT Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(no)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(no)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(no)"};

const RAW_PDU 		i := '1234567890'O
const octetstring 	o := '1234567890'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(yes)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(yes)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

const RAW_PDU 		i := '010203040500'O
const octetstring 	o := '010203040580'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == '010203040580'O)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(reverse)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(reverse)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

const RAW_PDU 		i := '010203040500'O
const octetstring 	o := '818283848500'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == '818283848500'O)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(yes)  for record of octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(yes)  for record of octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring OCT1
with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

const RAW_PDU 		i := {'84'O, '00'O}
const octetstring 	o := '0480'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(reverse)  for record of octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(reverse)  for record of octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring OCT1
with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

const RAW_PDU 		i := {'80'O}
const octetstring 	o := '00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(no)  for record of octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(no)  for record of octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring OCT1
with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(no)"};

const RAW_PDU 		i := {'84'O, '05'O}
const octetstring 	o := '8405'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(yes)  for record of bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(yes)  for record of bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


type bitstring BIT3
with { encode "RAW"; variant "FIELDLENGTH(3)"};

type record of BIT3 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

const RAW_PDU 		i := {'111'B, '000'B, '111'B}
const octetstring 	o := 'C301'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(reverse)  for record of bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(reverse)  for record of bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3
with { encode "RAW"; variant "FIELDLENGTH(3)"};

type record of BIT3 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

const RAW_PDU 		i := {'111'B, '000'B, '111'B}
const octetstring 	o := 'E700'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(yes)  for set of bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(yes)  for set of bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3
with { encode "RAW"; variant "FIELDLENGTH(3)"};

type set of BIT3 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

const RAW_PDU 		i := {'111'B, '000'B, '111'B}
const octetstring 	o := 'C301'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(reverse)  for set of bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(reverse)  for set of bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring BIT3
with { encode "RAW"; variant "FIELDLENGTH(3)"};

type set of BIT3 RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

const RAW_PDU 		i := {'111'B, '000'B, '111'B}
const octetstring 	o := 'E700'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(yes)  for set of hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(yes)  for set of hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type set of hexstring RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

const RAW_PDU 		i := {'F'H, '0'H, 'F'H}
const octetstring 	o := '070F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT(reverse)  for set of hexstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT(reverse)  for set of hexstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type set of hexstring RAW_PDU
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

const RAW_PDU 		i := {'F'H, '00'H, 'FFF'H}
const octetstring 	o := '0FF87F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}



const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      15 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } 	 }



const octetstring   o :='1234560F010100008002020000800303000080'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      12 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } 	 }



const octetstring   o :='1234560C010100008002820303000080'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      9 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } 	 }



const octetstring   o :='12345609010100008002820383'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      6 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } 	 }



const octetstring   o :='12345606018102820383'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      4 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=  omit     	 }



const octetstring   o :='1234560401810282'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}



const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      2 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=  omit ,
	   oct3 :=  omit     	 }



const octetstring   o :='123456020181'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      15 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } 	 }



const octetstring   o :='1234560F010100008002020000800303000080'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

}with{encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      5 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=  omit ,
	   oct3 :=  omit      }



const octetstring   o :='123456050101000080'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with EXTENSION_BIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with EXTENSION_BIT >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec2
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};


type record Rec3
{ BIT7          data ,
  BIT1          extensionbit   }
 with { variant ""};




type record Octet1
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)" ;};



type record Octet2
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};



type record Octet3
{ BIT7          data ,
  BIT1          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)"};




type record RAW_PDU
{ OCT3                octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

}with{encode "RAW"}




const RAW_PDU
    i := { octstr :=  '123456'O ,
           length1 :=      10 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct3 :=  omit      }



const octetstring   o :='1234560A01010000800202000080'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing EXTENSION_BIT_GROUP Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT_GROUP(no)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT_GROUP(no)>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1 length(1);
type bitstring BIT7 length(7);

type record RAW_PDU {
	BIT7 	field1,
	BIT1	ext1,
	BIT7	field2,
	BIT1	ext2,
	BIT7	field3,
	BIT1	ext3
}with { variant "EXTENSION_BIT_GROUP(no, field1, ext3)"};

}with {encode "RAW"}

const RAW_PDU 	i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B}
const octetstring o := '7F700F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT_GROUP(yes)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT_GROUP(yes)>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1 length(1);
type bitstring BIT7 length(7);

type record RAW_PDU {
	BIT7 	field1,
	BIT1	ext1,
	BIT7	field2,
	BIT1	ext2,
	BIT7	field3,
	BIT1	ext3
}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"};

}with{encode "RAW"}

const RAW_PDU 	i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B}
const octetstring o := '7FF00F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT_GROUP(yes) - two groups
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT_GROUP(yes) - two groups>

<STATIC>
external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1 length(1);
type bitstring BIT7 length(7);

type record RAW_PDU {
	BIT7 	field1,
	BIT1	ext1,
	BIT7	field2,
	BIT1	ext2,
	BIT7	field3,
	BIT1	ext3,
	BIT7	field4,
	BIT1	ext4

}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"
        variant "EXTENSION_BIT_GROUP(yes, field3, ext4)"};

}with{encode "RAW"}

const RAW_PDU 	i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B, '1111111'B, '0'B}
const octetstring o := '7FF00FFF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.   EXTENSION_BIT_GROUP(yes, reverse) - two groups
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    EXTENSION_BIT_GROUP(yes, reverse) - two groups>

<STATIC>
external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT1 length(1);
type bitstring BIT7 length(7);

type record RAW_PDU {
	BIT7 	field1,
	BIT1	ext1,
	BIT7	field2,
	BIT1	ext2,
	BIT7	field3,
	BIT1	ext3,
	BIT7	field4,
	BIT1	ext4

}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"
        variant "EXTENSION_BIT_GROUP(reverse, field3, ext4)"};

}with{encode "RAW"}

const RAW_PDU 	i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B, '1111111'B, '0'B}
const octetstring o := '7FF08F7F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if (enc_RAW_PDU(i) == o) {setverdict(pass);} else {setverdict(fail);}


<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2.Testing ALIGN Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   ALIGN(right) for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    ALIGN(right) for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "ALIGN (right)"
     };

const RAW_PDU 		i := '123456'O
const octetstring 	o := '12345600'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) == i & '00'O))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   ALIGN(left)  for octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    ALIGN(left)  for octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type octetstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "ALIGN (left)"
     };

const RAW_PDU 		i := '123456'O
const octetstring 	o := '00123456'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) =='00'O & i ))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   ALIGN(right) for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    ALIGN(right) for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)";
       variant "ALIGN (right)"
     };

const RAW_PDU 		i := '11111111'B
const octetstring 	o := 'FF00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) == '00000000'B & i))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.   ALIGN(left)  for bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    ALIGN(left)  for bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(16)";
       variant "ALIGN (left)"
     };

const RAW_PDU 		i := '11111111'B
const octetstring 	o := '00FF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and((dec_RAW_PDU(o) ==i & '00000000'B ))) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing Compound types
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3. Test of  record with integer and octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with integer and octetstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{  integer       int ,
   octetstring   octstr }
with { variant (int) "FIELDLENGTH(8)" ;
       variant (octstr) "FIELDLENGTH(2)" } ;

}with{encode "RAW"}

const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O   }



const octetstring 	o := '141234'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with default values in field
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with default values in field>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{  integer       int ,
   octetstring   octstr }
with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" } ;

const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O   }

}with{encode "RAW"}

const octetstring 	o := '141234'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{  integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)"
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B
         }



const octetstring 	o := '1412343F'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with enumerated and fieldlength calculation
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with enumerated and fieldlength calculation>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""};




type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN    }

with {variant (int) "" ;
      variant (octstr) "FIELDLENGTH(2)" ;
      variant (bit6) "FIELDLENGTH(6)" ;
      variant (bit2) "FIELDLENGTH(2)" ;
      variant (enum1) "FIELDLENGTH(8)" ;
      variant (length1) "LENGTHTO(octN)" ;
      variant (octN) ""
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O

         }



const octetstring 	o := '1412343F0A03123456'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of record called from record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of record called from record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_encode{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""
     }




type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1    }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) ""
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O  ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     }

         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union called from record with CROSSTAG
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union called from record with CROSSTAG>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


group RAW_group{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""
     }



type union optionalpart
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant (one) "" ;
       variant (two) "" ;
       variant (three) "" ;
       variant (four) "" ;
       variant (five) "" ;
     }





type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart  opt_part ,
   octetstring   eop        }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) "" ;
       variant (id) "" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5       ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union called from record with CROSSTAG, OTHERWISE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union called from record with CROSSTAG, OTHERWISE>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


group RAW_group{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""
     }



type union optionalpart
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant (one) "" ;
       variant (two) "" ;
       variant (three) "" ;
       variant (four) "" ;
       variant (five) "" ;
     }





type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart  opt_part ,
   octetstring   eop        }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) "" ;
       variant (id) "" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   OTHERWISE      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.



.*---------------------------------------------------------------------*
:h3. Test of record without specifying the default attributes for fields
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of record without specifying the default attributes for fields>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


group RAW_group{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)"
     }



type union optionalpart
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant "" }





type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart  opt_part ,
   octetstring   eop        }

with { variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of record of called from record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of record of called from record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }



group RAW_group{

type record record2
 { octetstring       oct1 ,
   integer         length2 ,
   octetstring       octN  }
with { variant (oct1) "FIELDLENGTH(1)";
       variant (length2) "LENGTHTO(octN)"

     }



type record of record2 Rec2list
with { variant "" };




type record RAW_PDU
 { integer       length1 ,
   Rec2list      rec2list   }

with { variant (length1) "LENGTHTO(rec2list)"   } ;

}with{encode "RAW"}


const RAW_PDU
    i := { length1:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     }    }
         }



const octetstring 	o := '081202345612027890'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of set with TAG
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of set with TAG >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type set RAW_PDU
 { intrec       int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3     )"
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := {  octstr :=  { tag := 2 ,
	                octfield := '1234'O } ,
	    int :=   {  tag := 1 ,
                       intfield :=  15  } ,
	    bit8 :=   {  tag := 3 ,
	                bit8field :=   '11111111'B }
         }



const octetstring 	o := '010F02123403FF'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union with TAG , first element called
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union with TAG , first element called>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type union RAW_PDU
 { intrec      int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3     )"
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=   {  tag := 1 ,
                       intfield :=  15  }
         }



const octetstring 	o := '010F'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union with TAG , second element called
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union with TAG , second element called>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type union RAW_PDU
 { intrec      int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3)"
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := {  octstr :=  { tag := 2 ,
	                octfield := '1234'O }
         }



const octetstring 	o := '021234'O




<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union with TAG , third element called
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union with TAG , third element called>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type union RAW_PDU
 { intrec      int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3     )"
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { bit8 :=   {  tag := 3 ,
	                bit8field :=   '11111111'B }
         }



const octetstring 	o := '03FF'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of union with TAG , third element called with OTHERWISE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of union with TAG , third element called with OTHERWISE>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type union RAW_PDU
 { intrec      field1 ,
   octrec      field2 ,
   bitrec      field3}

with { variant "TAG (
                      field1,      tag=1 ;
                      field2,      tag=2 ;
		      field3,      OTHERWISE)"};

}with{encode "RAW"}


const RAW_PDU
    i := { field3 :=   {  tag := 3,
	                bit8field :=   '11111111'B }
         }



const octetstring 	o := '03FF'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. Test of set of called from record
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of set of called from record>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }



group RAW_group{

type record record2
 { octetstring       oct1 ,
   integer         length2 ,
   octetstring       octN  }
with { variant (oct1) "FIELDLENGTH(1)";
       variant (length2) "LENGTHTO(octN)"

     }

type set of record2 Rec2list
with { variant "" };

type record RAW_PDU
 { integer       length1 ,
   Rec2list      rec2list   }

with { variant (length1) "LENGTHTO(rec2list)"   } ;

}with{encode "RAW"}


const RAW_PDU
    i := { length1:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     }    }
         }



const octetstring 	o := '081202345612027890'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of record with optional field with PRESENCE
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of record with optional field with PRESENCE>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }


group RAW_group{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)"
     }


type union optionalpart
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant "" }


type record record2
 { octetstring       oct1 ,
   integer         length2 ,
   octetstring       octN  }
with { variant (oct1) "FIELDLENGTH(1)";
       variant (length2) "LENGTHTO(octN)"

     }


type record of record2 Rec2list
with { variant "" };

type record RAW_PDU
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       length3 ,
   Rec2list      rec2list ,
   integer       id ,
   integer       opt_part_ptr ,
   integer       presenceid ,
   optionalpart  opt_part optional ,
   octetstring   eop   optional     }

with { variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (length3) "LENGTHTO(rec2list)"
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "PRESENCE (presenceid= 1)" ;
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}


const RAW_PDU
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   length3:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     } }  ,
	   id :=                5 ,
           opt_part_ptr:=            2 ,
           presenceid := 1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF0812023456120278900502010500'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with UNIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with UNIT>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer INT1
with { variant "" } ;



type record RAW_PDU
{ INT1      length1 ,
  octetstring   octstr }
with { variant (length1) "LENGTHTO(octstr)" ;
       variant (length1) "UNIT(8)" } ;

}with{encode "RAW"}

const RAW_PDU
    i := { length1 :=           4   ,
           octstr :=      '12345678'O   }



const octetstring 	o := '0412345678'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with PTRUNIT
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with PTRUNIT>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{ integer      pointer1 ,
  integer      pointer2 ,
  integer      pointer3 ,
  octetstring   octstr1 ,
  octetstring   octstr2 ,
  octetstring   octstr3 }
with { variant (pointer1) "POINTERTO(octstr1)" ;
       variant (pointer1) "PTRUNIT(1)" ;
       variant (pointer2) "POINTERTO(octstr2)" ;
       variant (pointer3) "POINTERTO(octstr3)" ;
       variant (octstr1) "FIELDLENGTH(3)" ;
       variant (octstr2) "FIELDLENGTH(3)" ;
       variant (octstr3) "FIELDLENGTH(3)" ;
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { pointer1 :=         24 ,
           pointer2 :=         5 ,
           pointer3 :=         7 ,
           octstr1 :=      '010203'O  ,
           octstr2 :=      '040506'O  ,
           octstr3 :=      '070809'O   }



const octetstring 	o := '180507010203040506070809'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  record with PTROFFSET
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  record with PTROFFSET>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record RAW_PDU
{ integer      pointer1 ,
  integer      pointer2 ,
  integer      pointer3 ,
  octetstring   octstr1 ,
  octetstring   octstr2 ,
  octetstring   octstr3 }
with { variant (pointer1) "POINTERTO(octstr1)" ;
       variant (pointer1) "PTROFFSET(0)" ;
       variant (pointer2) "POINTERTO(octstr2)" ;
       variant (pointer3) "POINTERTO(octstr3)" ;
       variant (octstr1) "FIELDLENGTH(3)" ;
       variant (octstr2) "FIELDLENGTH(3)" ;
       variant (octstr3) "FIELDLENGTH(3)" ;
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { pointer1 :=         3 ,
           pointer2 :=         5 ,
           pointer3 :=         7 ,
           octstr1 :=      '010203'O  ,
           octstr2 :=      '040506'O  ,
           octstr3 :=      '070809'O   }



const octetstring 	o := '030507010203040506070809'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Complicated structured types
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 1 >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type record Rec1field
{ bitstring  bit7 ,
  bitstring  bit1 ,
  octetstring oct1 }
with { variant (bit7) "FIELDLENGTH (7)" ;
       variant (bit1) "FIELDLENGTH (1)" ;
       variant (oct1) "FIELDLENGTH (1)" ;
     };

type enumerated Enum1
{zero, first, second, third, fourth, fifth }
with { variant "FIELDLENGTH (8)" };


type record Rec3
{ integer  int ,
  octetstring octstr ,
  bitstring  bitstr   }
with { variant (octstr) "FIELDLENGTH (1)" ;
       variant (bitstr) "FIELDLENGTH (8)" ;
     };


type record of Rec3  Recof
with { variant "" };

type record Rec5
{ integer length1 ,
  octetstring octN  }
with { variant (length1) "LENGTHTO (octN)" };



type union Rec2content
{ Enum1   enum1 ,
  Recof   recof ,
  Rec5   rec5    }
with { variant "" };



type record Rec2data
{  octetstring     id ,
   integer       length1 ,
   octetstring    octN ,
   integer       length2 ,
   Rec2content   content  }
with { variant (id) "FIELDLENGTH (1)" ;
       variant (length1) "LENGTHTO (octN)" ;
       variant (length2) "LENGTHTO (content)" ;
       variant (content) "CROSSTAG (
                                    enum1 ,    id='01'O ;
                                    recof ,    id='02'O ;
                                    rec5 ,     id='03'O   ) "
      };







type set of Rec2data Rec2datas
      with { variant "" };



type record RAW_PDU
{ integer      length1 ,
  Rec1field    rec1field1 ,
  integer      length2 ,
  Rec1field    rec1field2 ,
  Rec2datas      datas  }
with { variant (length1) "LENGTHTO(rec1field1)" ;
       variant (length2) "LENGTHTO(rec1field2)"
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  length1 :=    2 ,
	    rec1field1 :=   { bit7 := '0000001'B ,
	                      bit1 := '1'B ,
	                      oct1:=  'FF'O } ,
	    length2 :=    2 ,
	    rec1field2 :=   { bit7 := '0000010'B ,
	                      bit1 := '1'B ,
	                      oct1:=  'FF'O } ,
            datas :={  { id := '01'O ,
	                 length1 :=   2 ,
			 octN :=  '1234'O ,
			 length2 :=   1 ,
			 content := { enum1 := fifth }    },
                       { id := '02'O ,
	                 length1 :=   2 ,
			 octN :=  '5678'O,
			 length2 :=   6 ,
			 content := { recof := { { int :=  1 ,
			                           octstr := 'FF'O ,
						   bitstr := '00000000'B  } ,
                                                 { int :=  2 ,
			                           octstr := 'FF'O ,
						   bitstr := '00000000'B    } } } } ,
                       { id := '03'O ,
	                 length1 :=   2 ,
			 octN :=  '9012'O,
			 length2 :=   6 ,
			 content := { rec5 := { length1 :=  5 ,
			                         octN := '1234567890'O  } } } } }



const octetstring 	o := '0281FF0282FF010212340105020256780601FF0002FF000302901206051234567890'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 2 >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };



type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};




type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=   omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  }   } ,
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0202000102FFFF00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 3
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 3>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };



type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};




type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      7 ,
	       length1 :=        5 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 3 ,
			    octN :=  '123456'O   } , // octN := omit
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  }   } ,
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0207051F031234560102FFFF00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 4
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 4>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };



type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};




type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      7 ,
	       length1 :=        5 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 3 ,
			    octN :=  '123456'O   } , // octN := omit
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0207051F031234560102FFFF02070005123456789003048F0F123404060F123456789000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 5
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 5>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)" };


type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;




type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}

const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      4 ,
	       length1 :=        2 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 0 ,
			    octN :=  omit   } ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0204021F000102FFFF02070005123456789003048F0F123404060F123456789000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 6
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 6>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };

type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};

type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0202000102FFFF02070005123456789003048F0F123404060F123456789000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 7
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 7 >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};


type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   2 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   0 ,
					              octN := omit } } } ,
			         { id :=   3 ,
	                           length1 :=   2 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := omit } } } ,
			         { id :=   4 ,
	                           length1 :=   1 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := omit } } } } ,
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0202000102FFFF0202000003028F0F04010F00'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 8
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 8>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };


type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};


type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      0 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   omit ,
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '02000000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  Test of  structured types - 9
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   Test of  structured types - 9>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

type integer INT1
with { variant "" };

type record Rec1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec2
{  bitstring   bit8 ,
   INT1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};


type union opt_par_union
{ octetstring  octstr ,
  Rec2         rec2 ,
  Rec3         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1 length1,
   Rec1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}


const RAW_PDU
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      0 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   omit ,
	       EndOP := omit     }



const octetstring 	o := '020000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 10
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 10>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int  )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }



type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 :=
		           { paramName :=         name2 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }     },
	        eop :=               '00'O            } }



const octetstring 	o := '0112345680FF010207051234567890010612345680FF01020612345680FF01030612345680FF01040612345680FF0100'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 11
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 11>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 := omit ,
		       param4 := omit ,
		       param3 := omit ,
		       param2 := omit       },
	        eop :=   omit         } }



const octetstring 	o := '0112345680FF010207051234567890'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 12
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 12 >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=               '00'O            } }



const octetstring 	o := '0112345680FF010207051234567890010612345680FF01030612345680FF01040612345680FF0100'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 13
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 13 >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 := omit ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=    omit          } }



const octetstring 	o := '0212345680FF010207051234567890010612345680FF01030612345680FF01'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 14
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 14>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }


type record Field1
{ BIT1    field2indic ,
  BIT7    field2par   }
with { variant "" }



type union Field2
{ OCT3       present_ ,
  OCT3       absent   }
with { variant "" }



type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  Field1                field1 ,
  Field2                field2 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant (field2) "CROSSTAG(
                                      present_ ,       field1.field2indic = '1'B ;
				      absent ,        field1.field2indic = '0'B ; )" ;
          variant  (paramLength) "LENGTHTO(field1 , field2 , hexstr , int   )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

} with{encode "RAW"}

const RAW_PDU
    i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     field1 :=
			          { field2indic :=  '1'B ,
				    field2par :=  '0000000'B  } ,
			     field2 :=
			          { present_ :=  'FFFFFF'O   } ,
			     hexstr :=            '12'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=   '00'O        } }



const octetstring    o :='0212345680FF010207051234567890010612345680FF01030612345680FF01040601FFFFFF210100'O


<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 15
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 15>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

type integer INT1
with { variant "" } ;

type bitstring BIT1
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3                octstr ,
  BIT7                bit7 ,
  BIT1                bit1 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant  (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int   )" }


type record Field1
{ BIT1    field2indic ,
  BIT7    field2par   }
with { variant "" }


type union Field2
{ OCT3       present_ ,
  OCT3       absent   }
with { variant "" }


type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  Field1                field1 ,
  Field2                field2 ,
  HEX2                hexstr ,
  INT1                int }
   with { variant (field2) "CROSSTAG(
                                      present_ ,       field1.field2indic = '1'B ;
				      absent ,        field1.field2indic = '0'B ; )" ;
          variant  (paramLength) "LENGTHTO(field1 , field2 , hexstr , int   )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3               octstr ,
  BIT7               bit7 ,
  BIT1               bit1 ,
  HEX2               hexstr ,
  INT1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}

const RAW_PDU
    i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     field1 :=
			          { field2indic :=  '0'B ,
				    field2par :=  '0000000'B  } ,
			     field2 :=
			          { absent :=  '000000'O   } ,
			     hexstr :=            '12'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=   '00'O        } }



const octetstring   o :='0212345680FF010207051234567890010612345680FF01030612345680FF01040600000000210100'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 16
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 16>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;

type union Union2
{ OCT3          field1 ,
  OCT2          field2 ,
  OCT3          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ BIT4                id ,
  Union1             union1 ,
  Union2             union2  }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}




const RAW_PDU
    i := { id :=   '0001'B ,
           union1 := { field1 := '0000'B } ,
	   union2 := { field1 := '123456'O } 	 }



const octetstring   o :='01123456'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Test of  structured types - 17
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Test of  structured types - 17>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;

type octetstring OCT3
with { variant "FIELDLENGTH(3)" } ;


type union Union2
{ OCT3          field1 ,
  OCT2          field2 ,
  OCT3          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ BIT4                id ,
  Union1             union1 ,
  Union2             union2  }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := { id :=   '0111'B ,
           union1 := { field2 := '1111'B } ,
	   union2 := { field4 := '1234'O } 	 }



const octetstring   o :='F71234'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Testing RAW update
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Raw update test 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 1>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;

type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2 union2 ,
  Union1 union1,
  BIT4 id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field4 := '1234'O } ,
            union1 := { field2 := '1111'B },
            id := '0111'B }



const octetstring   o :='12347F'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 2>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2 union2 ,
  Union1 union1,
  BIT4 id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            id := '0001'B }



const octetstring   o :='12341F'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 3
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 3>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type bitstring BIT8
with { variant "FIELDLENGTH(8)"};

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2             union2 ,
  Union1 union1,
  BIT8 outfiller,
  BIT4 id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            outfiller := '00001000'B,
            id := '0001'B }



const octetstring   o :='12348F10'O



<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 4
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 4>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type bitstring BIT8
with { variant "FIELDLENGTH(8)"};

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2  union2 ,
  BIT8    outfiller,
  Union1  union1,
  BIT4 id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field1 := '1234'O } ,
            outfiller := '00001000'B,
            union1 := { field1 := '1111'B },
            id := '0001'B }


const octetstring   o :='1234081F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 5
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 5>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type bitstring BIT8
with { variant "FIELDLENGTH(8)"};

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ BIT8    outfiller,
  Union2  union2 ,
  Union1  union1,
  BIT4 id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  outfiller := '00001000'B,
            union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            id := '0001'B }


const octetstring   o :='0812341F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 6
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 6>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2  union2 ,
  BIT4    id,
  Union1  union1}
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field1 := '1234'O },
            id := '0001'B,
            union1 := { field1 := '1111'B }
             }


const octetstring   o :='1234F1'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 7
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 7>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2  union2 ,
  BIT4    id,
  Union1  union1}
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := { field4 := '1234'O },
            id := '0101'B,
            union1 := { field2 := '1111'B }
             }


const octetstring   o :='1234F5'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 8
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 8>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union2
{ OCT2          field1 ,
  OCT2          field2 ,
  OCT2          field3 ,
  OCT2          field4  }
 with { variant ""};


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};


type record RAW_PDU
{ Union2  union2_1,
  Union2  union2_2,
  Union1  union1_1,
  BIT4    id,
  Union1  union1_2,
  BIT4    id2}
   with { variant  (union2_1) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1_1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   })" ;
          variant (union2_2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)";
          variant (union1_2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2_1 := {field1 := '1234'O },
            union2_2 := { field1 := '1234'O},
            union1_1 := { field1 := '1111'B },
            id := '0001'B,
            union1_2 := { field1 := '1111'B},
            id2 := '0001'B
             }


const octetstring   o :='123412341F1F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 9
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 9>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;


type union Union1
{ BIT4          field1 ,
  BIT4          field2  }
 with { variant ""};

type union Union3
{ BIT4 field1,
  OCT2 field2
} with { variant ""};


type record RAW_PDU
{ BIT4    id,
  Union3  union3,
  Union1  union1,
  BIT4    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)"
          } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  id := '0001'B,
            union3 := {field1 := '1110'B},
            union1 := { field1 := '1111'B},
            id2 := '0001'B
             }


const octetstring   o :='E11F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 10
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 10>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;

group shortening{

type union Union1
{ BIT4          field1 ,
  BIT4          field2  };

type union Union2
{ OCT2          field1 ,
  OCT2          field2 };

type union Union3
{ BIT4 field1,
  OCT2 field2 };

} with {variant ""}

type record RAW_PDU
{ Union2  union2,
  BIT4    id,
  Union3  union3,
  Union1  union1,
  BIT4    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)";
          variant (union2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)"} ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := {field1 := '1234'O},
            id := '0001'B,
            union3 := {field1 := '1110'B},
            union1 := { field1 := '1111'B},
            id2 := '0001'B
             }


const octetstring   o :='1234E11F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 11
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 11>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type bitstring BIT4
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2
with { variant "FIELDLENGTH(2)" } ;

group shortening{

type union Union1
{ BIT4          field1 ,
  BIT4          field2  };

type union Union3
{ BIT4 field1,
  OCT2 field2 };

} with {variant ""}

type record RAW_PDU
{ union {
   octetstring field1,
   octetstring field2
  }       union2,
  BIT4    id,
  Union3  union3,
  Union1  union1,
  BIT4    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)";
          variant (union2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)";
          variant (union2.field1, union2.field2) "FIELDLENGTH(2)"
          } ;

}with{encode "RAW"}

const RAW_PDU
    i := {  union2 := {field1 := '1234'O},
            id := '0001'B,
            union3 := {field1 := '1110'B},
            union1 := { field1 := '1111'B},
            id2 := '0001'B
             }


const octetstring   o :='1234E11F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 12
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 12>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type union Code {
  integer field1,
  integer field2,
  integer field3
} with { variant "FIELDLENGTH(8)"};

type record RAW_PDU{
  Code code,
  bitstring ABCxxxxx,
  integer PDU_length,
  octetstring id optional
  } with { variant (PDU_length) "FIELDLENGTH(16)";
           variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             field1, id = omit;
             field2, id = '02'O;
             field3, id = '03'O; )"};

}with{encode "RAW"}

const RAW_PDU
    i := {  code := { field1 := 16},
            ABCxxxxx := '00000000'B,
            PDU_length := 16,
            id := omit }


const octetstring   o :='10001000'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 13
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 13>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type union Code {
  integer field1,
  integer field2,
  integer field3
} with { variant "FIELDLENGTH(8)"};

type record RAW_PDU{
  Code code,
  bitstring ABCxxxxx,
  integer PDU_length,
  octetstring id optional
  } with { variant (PDU_length) "FIELDLENGTH(16)";
           variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             field1, id = omit;
             field2, id = '02'O;
             field3, id = '03'O; )"};

}with{encode "RAW"}

const RAW_PDU
    i := {  code := { field2 := 16},
            ABCxxxxx := '10000000'B,
            PDU_length := 16,
            id := '02'O }


const octetstring   o :='1080100002'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 14
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 14>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type union Code {
  enumerated {e1a (0), e1b (1), e1c (2)} E1,
  enumerated {e2a (1), e2b (2), e2c (3)} E2,
  enumerated {e3a (2), e3b (3), e3c (4), e3d (5)} E3
} with { variant (E1,E2,E3) "FIELDLENGTH(32)";
         variant (E1,E2,E3) "BYTEORDER(last)";
         variant (E1,E2,E3) "COMP(2scompl)"};

type integer UINT24 (0..16777215)
with {variant "FIELDLENGTH(24)";
      variant "BYTEORDER(last)"};

type enumerated Identifier {
  id_E1 (0),
  id_E2 (1),
  id_E3 (2)
} with {variant "FIELDLENGTH(32)";
        variant "BYTEORDER(last)";
        variant "COMP(2scompl)"};

type record RAW_PDU{
  Code code,
  bitstring ABCxxxxx,
  UINT24 PDU_length,
  Identifier id optional,
  octetstring payload optional
  } with { variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             E1, id = omit;
             E2, id = id_E2;
             E3, id = id_E3; )";
            variant (PDU_length) "LENGTHTO(code,ABCxxxxx,PDU_length,id,payload)"};

}with{encode "RAW"}

const RAW_PDU
    i := {  code := {E1 := e1c},
            ABCxxxxx := '00000000'B,
            PDU_length := 8,
            id := omit,
            payload := omit}


const octetstring   o :='0000000200000008'O ;

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 15
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 15>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type union Code {
  enumerated {e1a (0), e1b (1), e1c (2)} E1,
  enumerated {e2a (1), e2b (2), e2c (3)} E2,
  enumerated {e3a (2), e3b (3), e3c (4), e3d (5)} E3
} with { variant (E1,E2,E3) "FIELDLENGTH(32)";
         variant (E1,E2,E3) "BYTEORDER(last)";
         variant (E1,E2,E3) "COMP(2scompl)"};

type integer UINT24 (0..16777215)
with {variant "FIELDLENGTH(24)";
      variant "BYTEORDER(last)"};

type enumerated Identifier {
  id_E1 (0),
  id_E2 (1),
  id_E3 (2)
} with {variant "FIELDLENGTH(32)";
        variant "BYTEORDER(last)";
        variant "COMP(2scompl)"};

type record RAW_PDU{
  Code code,
  bitstring ABCxxxxx,
  UINT24 PDU_length,
  Identifier id optional,
  octetstring payload optional
  } with { variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             E1, id = omit;
             E2, id = id_E2;
             E3, id = id_E3; )";
            variant (PDU_length) "LENGTHTO(code,ABCxxxxx,PDU_length,id,payload)"};

}with{encode "RAW"}

const RAW_PDU
    i := {  code := {E2 := e2b},
            ABCxxxxx := '10000000'B,
            PDU_length := 14,
            id := id_E2,
            payload := 'ABCD'O}


const octetstring   o :='000000028000000E00000001ABCD'O ;

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Raw update test 16
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-  Raw update test 16>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{

type union Code {
  enumerated {e1a (0), e1b (1), e1c (2)} E1,
  enumerated {e2a (1), e2b (2), e2c (3)} E2,
  enumerated {e3a (2), e3b (3), e3c (4), e3d (5)} E3
} with { variant (E1,E2,E3) "FIELDLENGTH(32)";
         variant (E1,E2,E3) "BYTEORDER(last)";
         variant (E1,E2,E3) "COMP(2scompl)"};

type integer UINT24 (0..16777215)
with {variant "FIELDLENGTH(24)";
      variant "BYTEORDER(last)"};

type enumerated Identifier {
  id_E1 (0),
  id_E2 (1),
  id_E3 (2)
} with {variant "FIELDLENGTH(32)";
        variant "BYTEORDER(last)";
        variant "COMP(2scompl)"};

type record RAW_PDU{
  Code code,
  bitstring ABCxxxxx,
  UINT24 PDU_length,
  Identifier id optional,
  octetstring payload optional
  } with { variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             E1, id = omit;
             E2, id = id_E2;
             E3, id = id_E3; )";
            variant (PDU_length) "LENGTHTO(code,ABCxxxxx,PDU_length,id,payload)"};

}with{encode "RAW"}

const RAW_PDU
    i := {  code := {E3 := e3b},
            ABCxxxxx := '10100000'B,
            PDU_length := 14,
            id := id_E3,
            payload := 'ABCD'O}


const octetstring   o :='00000003A000000E00000002ABCD'O ;

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o )and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3. group raw attribute test 1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 1>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group {
  type integer RAW_PDU
} with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( 2scompl ) "
     };

const RAW_PDU 		i := -2
const octetstring 	o := 'FE'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. group raw attribute test 2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 2>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with {  encode "RAW";
        variant  "BITORDERINOCTET(msb)";
        variant  "BYTEORDER(last)";
        variant  "ALIGN(left)";
        variant  "BITORDERINFIELD(msb)";
        variant  "COMP(signbit)";
        variant  "FIELDLENGTH(20)" };

const RAW_PDU 		i := -234
const octetstring 	o := 'EA0008'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.



.*---------------------------------------------------------------------*
:h3. group raw attribute test 3
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 3>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        group grp_v4 {
          group grp_v5 {
            group grp_v6 {
              type integer RAW_PDU
            } with { variant "BITORDERINOCTET(msb)" }
          } with { variant "BYTEORDER(last)" }
        } with { variant "ALIGN(left)" }
      } with { variant "BITORDERINFIELD(msb)" }
    } with { variant "COMP(signbit)" }
  } with { variant "FIELDLENGTH(20)" }
} with { encode "RAW" }

const RAW_PDU 		i := -234
const octetstring 	o := 'EA0008'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. group raw attribute test 4
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 4>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        group grp_v4 {
          group grp_v5 {
            group grp_v6 {
              type integer RAW_PDU
              with { variant "" }
            } with { variant "FIELDLENGTH(20)"; variant "COMP(signbit)" }
          } with { variant "BITORDERINFIELD(msb)"; variant "ALIGN(left)" }
        } with { variant "BITORDERINOCTET(msb)"; variant "BYTEORDER(last)" }
      } with { variant "BITORDERINOCTET(lsb)"; variant "BYTEORDER(first)" }
    } with { variant "FIELDLENGTH(10)"; variant "COMP(2scompl)" }
  } with { variant "BITORDERINFIELD(lsb)"; variant "ALIGN(right)" }

} with { encode "RAW" }

const RAW_PDU 		i := -234
const octetstring 	o := 'EA0008'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>


.*---------------------------------------------------------------------*
:h3. group raw attribute test 5
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 5>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        type integer RAW_PDU
        with { encode "RAW"; variant "" }
      } with { encode "RAW"; variant "FIELDLENGTH(20)"; variant "COMP(signbit)" }
    } with { encode "RAW"; variant "BITORDERINFIELD(msb)"; variant "ALIGN(left)" }
  } with { encode "RAW"; variant "BITORDERINOCTET(msb)"; variant "BYTEORDER(last)" }
} with { encode "RAW" }

const RAW_PDU 		i := -234
const octetstring 	o := 'EA0008'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. group raw attribute test 6
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 6>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        type integer RAW_PDU
        with { variant "" }
      } with { variant override "FIELDLENGTH(32)"  }
    } with { variant "FIELDLENGTH(10)" }
  } with { variant override "FIELDLENGTH(8)"; variant "FIELDLENGTH(2)" }
} with { encode "RAW" }

const RAW_PDU 		i := 255
const octetstring 	o := 'FF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. group raw attribute test 7
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- group raw attribute test 7>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

group RAW_group{
  group grp1 {
    type record RAW_PDU
    { integer   int1 ,
      integer   int2 ,
      integer   int3 ,
      integer   int4   }
     with { variant (int1,int2,int3,int4) "FIELDLENGTH(4)";
            variant (int1,int2) "PADDING(yes)";
            variant (int3,int4) "PADDING(no)"; }
  } with { variant "FIELDLENGTH(3)" }
} with {encode "RAW" };


const RAW_PDU
	i := {  int1 :=    1  ,
	        int2 :=    2  ,
		int3 :=    3  ,
		int4 :=    4       }

const octetstring 	o := '010243'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing Enc/Dec functions of implicit message encoding
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.  Fast enc/dec function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype fast>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu, out octetstring stream) with { extension "prototype(fast) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream, out RAW_PDU pdu) with { extension "prototype(fast) decode(RAW)" }
type integer RAW_PDU with { encode "RAW"; variant "FIELDLENGTH(16)" };

const RAW_PDU 		i := 255
const octetstring 	o := 'FF00'O

<TTCN_TC:EXEC>

var octetstring encoded_pdu;
var RAW_PDU decoded_pdu;

enc_RAW_PDU(i, encoded_pdu);
dec_RAW_PDU(o, decoded_pdu);

if ( encoded_pdu == o and decoded_pdu == i ) {setverdict(pass);}
else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Backtrack decode function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype backtrack>

<STATIC>

external function dec_RAW_PDU(in octetstring stream, out RAW_PDU pdu) return integer
  with { extension "prototype(backtrack) decode(RAW) errorbehavior(ALL:WARNING)" }

type integer RAW_PDU with { encode "RAW"; variant "FIELDLENGTH(16)" };

const RAW_PDU 		i := 255
const octetstring o1 := 'FF00'O
const octetstring o2 := '12'O

<TTCN_TC:EXEC>

var RAW_PDU decoded_pdu;
var integer ret_val;

ret_val := dec_RAW_PDU(o1, decoded_pdu);
if (ret_val==0 and decoded_pdu==i) {setverdict(pass);}
else {setverdict(fail);}

ret_val := dec_RAW_PDU(o2, decoded_pdu);
if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Sliding decode function
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Implicit message encoding: prototype sliding>

<STATIC>

external function dec_RAW_PDU(inout octetstring stream, out RAW_PDU pdu) return integer
  with { extension "prototype(sliding) decode(RAW) errorbehavior(ALL:WARNING)" }

type integer RAW_PDU with { encode "RAW"; variant "FIELDLENGTH(16)" };

const RAW_PDU 		i := 255

<TTCN_TC:EXEC>

var octetstring o1 := 'FF00'O;
var octetstring o2 := '12'O;
var RAW_PDU decoded_pdu;
var integer ret_val;

ret_val := dec_RAW_PDU(o1, decoded_pdu);
if (ret_val==0 and decoded_pdu==i) {setverdict(pass);}
else {setverdict(fail);}

ret_val := dec_RAW_PDU(o2, decoded_pdu);
if (ret_val>0) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h2. Testing limits of codec
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Decoding empty octetstring to PDU
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Decoding empty octetstring to PDU>

<STATIC>

type record PDU {
  integer f1,
  octetstring f2,
  boolean f3
} with { encode "RAW" variant "" }

external function decodePDU(inout octetstring os, out PDU pdu) return integer
with { extension "prototype(sliding) decode(RAW) errorbehavior(ALL:WARNING)" }

<TTCN_TC:EXEC>

var octetstring os := ''O;
var PDU pdu;
var integer ret_val := decodePDU(os, pdu);
if (ret_val>0) {setverdict(pass);} else {setverdict(fail);}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2. Testing encoding/decoding of big integers
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3. Encoding/decoding big integer variables
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Big integers: Encoding/decoding big integer variables>

<STATIC>

external function enc_raw3(in myint3 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw3(in octetstring r) return myint3
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function enc_raw2(in myint2 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw2(in octetstring r) return myint2
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }

type integer myint2
with {
  variant "FIELDLENGTH(128)"
  variant "COMP(nosign)"
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" }

type integer myint3
with {
  variant "FIELDLENGTH(96)"
  variant "COMP(signbit)"
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" }

<TTCN_TC:EXEC>

  var myint3 v1 := -4294967296
  var myint3 v2 := -2147483647
  var myint3 v3 := 34359738368
  var myint3 v4 := 4398046511104
  var myint3 v5 := -140737488355328
  var myint3 v6 := 4294967296
  var myint3 v7 := 4294967295
  var myint3 v8 := -4294967295
  var myint3 v9 := 4294967297
  var myint3 v10 := -4294967297
  var myint3 v11 := 2147483647
  var myint3 v12 := -2147483648
  var myint3 v13 := 2147483648
  var myint3 v14 := -2147483649
  var myint3 v15 := 2147483649
  var myint2 v16 := -4294967296
  var myint2 v17 := 2147483647
  var myint2 v18 := 34359738368
  var myint2 v19 := 4398046511104
  var octetstring o
  o := enc_raw3(v1);if (v1 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v2);if (v2 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v3);if (v3 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v4);if (v4 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(-140737488355328);if (v5 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v6);if (v6 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v7);if (v7 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v8);if (v8 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v9);if (v9 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v10);if (v10 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v11);if (v11 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v12);if (v12 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v13);if (v13 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v14);if (v14 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  
<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Encoding/decoding records with big integer fields
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Big integers: Encoding/decoding records with big integer fields>

<STATIC>

external function enc_raw(in rec_raw1 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw(in octetstring r) return rec_raw1
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
  
type integer myint1
with {
  variant "FIELDLENGTH(256)"
  variant "COMP(2scompl)" 
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" } // The script eats the trailing '}' in a new line.

type record rec_raw1 {
  myint1 int1,
  myint1 int2
} with { variant "" encode "RAW" }

<TTCN_TC:EXEC>

  var rec_raw1 myrec1 := {int1 := -12345678910111213141516, int2 := -3}
  var rec_raw1 myrec2 := {int1 := -11111111111111111111111, int2 := -11111111111111111111111}
  var rec_raw1 myrec3 := {int1 := -2147483648, int2 := -4294967296}
  var rec_raw1 myrec4 := {int1 := 2147483648, int2 := -4294967296}
  var rec_raw1 myrec5 := {int1 := -2147483649, int2 := 2147483649}
  var rec_raw1 myrec6 := {int1 := -1234, int2 := -4321}
  var octetstring o
  o := enc_raw(myrec1);if (myrec1 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec2);if (myrec2 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec3);if (myrec3 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec4);if (myrec4 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec5);if (myrec5 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec6);if (myrec6 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Multiple optional fields (R8G FOA bug)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- Multiple optional fields (R8G FOA bug)>

<STATIC>

external function enc_PDU_GTPCv2(in PDU_GTPCv2 pdu) return octetstring
with { extension "prototype(convert)" extension "encode(RAW)" }

external function dec_PDU_GTPCv2(in octetstring stream) return PDU_GTPCv2
with { extension "prototype(convert)" extension "decode(RAW)" }

type bitstring BIT3 length(3) with { encode "RAW"  variant "FIELDLENGTH(3)" };
type bitstring BIT4 length(4) with { encode "RAW"  variant "FIELDLENGTH(4)" };
type bitstring BIT5 length(5) with { encode "RAW"  variant "FIELDLENGTH(5)" };
type bitstring BIT1 length(1) with { encode "RAW"  variant "FIELDLENGTH(1)" };
type octetstring OCT1 length(1) with { encode "RAW"  variant "FIELDLENGTH(1)" };
type octetstring OCT2 length(2) with { encode "RAW"  variant "FIELDLENGTH(2)" };
type octetstring OCT3 length(3) with { encode "RAW"  variant "FIELDLENGTH(3)" };
type octetstring OCT4 length(4) with { encode "RAW"  variant "FIELDLENGTH(4)" };
type integer LIN1 (0..255) with { encode "RAW"  variant "FIELDLENGTH(8)" };

type integer LIN2_BO_LAST (0..65535) with { encode "RAW"  variant "FIELDLENGTH(16), COMP(nosign), BYTEORDER(last)" };

type record Cause {
    OCT1              elementIdentifier, //dec 2, '02'O  
    LIN2_BO_LAST      lengthIndicator,
    BIT4              instance,
    BIT4              spare,
    OCT1              causeValue,
    BIT1              cS,
    BIT1              bCE,
    BIT1              pCE,
    BIT5              spare2,
    OCT1              typeOfOffendingIE optional,
    LIN2_BO_LAST      lengthIndicator2 optional,
    BIT4              instanceOfOffendingIE optional,
    BIT4              spare3 optional
} with { encode "RAW" 
    variant "PRESENCE (elementIdentifier = '02'O; )" 
    variant (lengthIndicator) "LENGTHTO(causeValue,cS,bCE,pCE,spare2,typeOfOffendingIE,
    lengthIndicator2,instanceOfOffendingIE,spare3 )" };

type record Recovery {
    OCT1              elementIdentifier,  // dec 3, '03'O 
    LIN2_BO_LAST      lengthIndicator,
    BIT4              instance,
    BIT4              spare,
    integer           recoveryValue
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(recoveryValue)"
    variant "PRESENCE (elementIdentifier = '03'O; )" }; 

type set of  ProtocolID_or_ContainerID   ProtocolIDs_and_ContainerIDs;

type record ProtocolID_or_ContainerID {
    OCT2               protocolID_or_ContainerID,
    LIN1               lengthIndicator,
    octetstring        protID_orContID_Contents
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO (protID_orContID_Contents)"};

type record ProtocolConfigOptions {
    OCT1                         elementIdentifier, // dec 78 '4E'O;
    LIN2_BO_LAST                 lengthIndicator,
    BIT4                         instance,
    BIT4                         spare,
    BIT3                         configProtocol,
    BIT4                         spare2,  //'0000'B
    BIT1                         extensionField,   //'1'B
    ProtocolIDs_and_ContainerIDs protocolIDs_and_ContainerIDs optional
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(configProtocol,spare2,extensionField,protocolIDs_and_ContainerIDs)"
    variant "PRESENCE (elementIdentifier = '4E'O; )" };

type record PrivateExtension {
    OCT1                         elementIdentifier, // dec 255, 'FF'O
    LIN2_BO_LAST                 lengthIndicator,
    BIT4                         instance,
    BIT4                         spare,
    integer                      enterpriseID,
    octetstring                  proprietartyValue 
}  with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(enterpriseID,proprietartyValue)"; 
    variant "PRESENCE (elementIdentifier = 'FF'O;)"; };

type set DeleteSessionResponse {
    Cause                                   cause,
    Recovery                                recovery optional,
    ProtocolConfigOptions                   protocolConfigOptions optional, 
    PrivateExtension                        privateExtension optional };

type union GTPCv2_PDUs {
    DeleteSessionResponse                        deleteSessionResponse };

type record PDU_GTPCv2 {
    BIT3                           spare,   //0 
    BIT1                           t_Bit,
    BIT1                           p_Bit,
    BIT3                           version,  //'010'B
    OCT1                           messageType,
    LIN2_BO_LAST                   lengthf, 
    OCT4                           tEID optional,
    OCT3                           sequenceNumber,
    OCT1                           spare3, // 0
    GTPCv2_PDUs                    gtpcv2_pdu,
    PDU_GTPCv2                     piggybackPDU_GTPCv2 optional
}  with { encode "RAW" 
    variant (tEID) "PRESENCE(t_Bit = '1'B)";
    variant (piggybackPDU_GTPCv2) "PRESENCE(p_Bit = '1'B)";   
    variant (lengthf) "LENGTHTO(tEID,sequenceNumber,spare3,gtpcv2_pdu)";
    variant (gtpcv2_pdu) "CROSSTAG(
    deleteSessionResponse,                             messageType = '25'O;  //37
    )"; };

<TTCN_TC:EXEC>

  var PDU_GTPCv2 vl_temp := dec_PDU_GTPCv2( '48250013800000000249BF000200020010000300010011'O );
  setverdict(pass);

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. HO79315: Segfault on unbound octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- HO79315: Segfault on unbound octetstring>

<STATIC>

type octetstring raw_pdu_octetstring with { encode "RAW"; variant "FIELDLENGTH(1)"};
external function enc_raw_pdu_octetstring(in raw_pdu_octetstring pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_raw_pdu_octetstring(in octetstring stream) return raw_pdu_octetstring with { extension "prototype(convert) decode(RAW)" }

<TTCN_TC:EXEC>

  var raw_pdu_octetstring i
  const octetstring o := '0F'O
  if ((enc_raw_pdu_octetstring(i) == o)and(dec_raw_pdu_octetstring(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_raw_pdu_octetstring(i)= ", enc_raw_pdu_octetstring(i), "; dec_raw_pdu_octetstring(o)= ", dec_raw_pdu_octetstring(o));}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h1.REFERENCES
.*---------------------------------------------------------------------*
:nl. Requirement specification(s):
:nl.-------------------------------
:list.
:li. 8/ETH/RUS-2003:0087 Uen - Requirement Specification for TITAN's encoder/decoder functions
:elist.

:etext.
