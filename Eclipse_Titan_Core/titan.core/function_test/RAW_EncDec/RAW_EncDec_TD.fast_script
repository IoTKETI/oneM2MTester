.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Kovacs, Ferenc
.*   Szabados, Kristof
.*
.******************************************************************************/
:text.
:lang eng.
.*
:docname.Test Description
:docno.7/152 91-CRL 113 200/5 Uen
:rev.A
:date.2015-04-27
.*
:prep.ETH/XZR Jeno Balasko (+36 1 437 7760)
:appr.ETH/XZ (Gyula Koos)
:checked.ETHGRY
.*
:title.Test description - RAW coder
:contents level=3.
.*---------------------------------------------------------------------*
:h1.PREREQUISITES AND PREPARATIONS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Scope of the Test Object
.*---------------------------------------------------------------------*
:xmp tab=1 nokeep.
This TD contains unified test cases related to TTCN3 Executor's RAW coder function.
The original test cases can be found in the RAW_EncDec_TD.script file.
The reason for the unification was to get a really fast version of the tests.

:exmp.

:p.:us.Revision Information:eus.

:xmp nokeep.
:us.History:eus.

REV   DATE         PREPARED   CHANGE
===   ==========   ========   ======
A     2003-10-31   ETHCSIR    New document
B     2005-11-09   EKRISZA    New tests and updates of the original tests.
C     2007-03-06   EDMDELI    Implicit message encoding
D     2007-06-20   EDMDELI    New testcase for implicit message encoding
E     2008-10-01   EFERKOV    Big integers
F     2010-01-18   EKRISZA    Updated for TITAN R8C
H     2010-08-13   EKRISZA    Updated for TITAN R8E
J     2011-05-26   EKRISZA    Added new test
K     2010-01-18   EKRISZA    Updated for TITAN R8H
A     2011-12-12   EKRISZA    Updated for release
PB1   2012-01-31   ETHBAAT    Based on Test Description RAW coder, 7/152 91-CRL 113 200 Uen, file: RAW_EncDec_TD.script Testcases expecting "passed" have been merged
B     2013-01-17   EKRIPND     Updated for release
PC1   2013-02-01   ETHBAAT    Testcase for TR HQ49956 fixing added

:exmp.

.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
:p.:us.Software Tools:eus.
:xmp tab=2 nokeep.

	SAtester

:exmp.
:np.
.*---------------------------------------------------------------------*
:h1.REQUIREMENT-BASED TESTS
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Testing FIELDLENGTH Attribute
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.  passing tests
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   passing tests>

<STATIC>

type component TempComp {}

<TTCN_TC:PURE_EXEC>

type integer RAW_PDU_1
with { encode "RAW"; variant "FIELDLENGTH(16)"};
external function enc_RAW_PDU_1(in RAW_PDU_1 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_1(in octetstring stream) return RAW_PDU_1 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_16_for_integer() runs on TempComp {
  const RAW_PDU_1 	i := 255
  const octetstring 	o := 'FF00'O

  if ((enc_RAW_PDU_1(i) == o)and(dec_RAW_PDU_1(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_1(i)= ", enc_RAW_PDU_1(i), "; dec_RAW_PDU_1(o)= ", dec_RAW_PDU_1(o));}
}

type integer RAW_PDU_2
with { encode "RAW"; variant "FIELDLENGTH(8)"};
external function enc_RAW_PDU_2(in RAW_PDU_2 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_2(in octetstring stream) return RAW_PDU_2 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_8_for_integer() runs on TempComp {
  const RAW_PDU_2 	i := 15
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_2(i) == o)and(dec_RAW_PDU_2(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_2(i)= ", enc_RAW_PDU_2(i), "; dec_RAW_PDU_2(o)= ", dec_RAW_PDU_2(o));}
}



type integer RAW_PDU_3
with { encode "RAW"; variant "FIELDLENGTH(4)"};
external function enc_RAW_PDU_3(in RAW_PDU_3 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_3(in octetstring stream) return RAW_PDU_3 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_for_integer() runs on TempComp {
  const RAW_PDU_3 	i := 15
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_3(i) == o)and(dec_RAW_PDU_3(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_3(i)= ", enc_RAW_PDU_3(i), "; dec_RAW_PDU_3(o)= ", dec_RAW_PDU_3(o));}
}



testcase TC_FIELDLENGTH_16_for_integer_2() runs on TempComp {
  const RAW_PDU_1 	i := 4660
  const octetstring 	o := '3412'O

  if ((enc_RAW_PDU_1(i) == o)and(dec_RAW_PDU_1(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_1(i)= ", enc_RAW_PDU_1(i), "; dec_RAW_PDU_1(o)= ", dec_RAW_PDU_1(o));}
}



type integer RAW_PDU_4
with { encode "RAW"; variant "FIELDLENGTH(32)"};
external function enc_RAW_PDU_4(in RAW_PDU_4 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_4(in octetstring stream) return RAW_PDU_4 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_32_for_integer_1_bit_long() runs on TempComp {
  const RAW_PDU_4 	i := 1
  const octetstring 	o := '01000000'O

  if ((enc_RAW_PDU_4(i) == o)and(dec_RAW_PDU_4(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_4(i)= ", enc_RAW_PDU_4(i), "; dec_RAW_PDU_4(o)= ", dec_RAW_PDU_4(o));}
}



type integer RAW_PDU_5
with { encode "RAW"; variant ""};
external function enc_RAW_PDU_5(in RAW_PDU_5 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_5(in octetstring stream) return RAW_PDU_5 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Default_FIELDLENGTH_for_integer() runs on TempComp {
  const RAW_PDU_5 	i := 255
  const octetstring 	o := 'FF'O

  if ((enc_RAW_PDU_5(i) == o)and(dec_RAW_PDU_5(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_5(i)= ", enc_RAW_PDU_5(i), "; dec_RAW_PDU_5(o)= ", dec_RAW_PDU_5(o));}
}



type bitstring RAW_PDU_6
with { encode "RAW"; variant "FIELDLENGTH(8)"};
external function enc_RAW_PDU_6(in RAW_PDU_6 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_6(in octetstring stream) return RAW_PDU_6 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_8_for_bitstring() runs on TempComp {
  const RAW_PDU_6 	i := '11110000'B
  const octetstring 	o := 'F0'O

  if ((enc_RAW_PDU_6(i) == o)and(dec_RAW_PDU_6(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_6(i)= ", enc_RAW_PDU_6(i), "; dec_RAW_PDU_6(o)= ", dec_RAW_PDU_6(o));}
}



type bitstring RAW_PDU_7
with { encode "RAW"; variant "FIELDLENGTH(8)"};
external function enc_RAW_PDU_7(in RAW_PDU_7 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_7(in octetstring stream) return RAW_PDU_7 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_8_for_bitstring_4_bits_long() runs on TempComp {
  const RAW_PDU_7 	i := '1111'B
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_7(i) == o)and(dec_RAW_PDU_7(o) == '0000'B & i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_7(i)= ", enc_RAW_PDU_7(i), "; dec_RAW_PDU_7(o)= ", dec_RAW_PDU_7(o));}
}



type bitstring RAW_PDU_8
with { encode "RAW"; variant "FIELDLENGTH(4)"};
external function enc_RAW_PDU_8(in RAW_PDU_8 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_8(in octetstring stream) return RAW_PDU_8 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_for_bitstring() runs on TempComp {
  const RAW_PDU_8 	i := '1111'B
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_8(i) == o)and(dec_RAW_PDU_8(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_8(i)= ", enc_RAW_PDU_8(i), "; dec_RAW_PDU_8(o)= ", dec_RAW_PDU_8(o));}
}



type bitstring RAW_PDU_9
with { encode "RAW"; variant "FIELDLENGTH(16)"};
external function enc_RAW_PDU_9(in RAW_PDU_9 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_9(in octetstring stream) return RAW_PDU_9 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_16_for_bitstring() runs on TempComp {
  const RAW_PDU_9 	i := '1111000001110000'B
  const octetstring 	o := '70F0'O

  if ((enc_RAW_PDU_9(i) == o)and(dec_RAW_PDU_9(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_9(i)= ", enc_RAW_PDU_9(i), "; dec_RAW_PDU_9(o)= ", dec_RAW_PDU_9(o));}
}



type bitstring RAW_PDU_10
with { encode "RAW"; variant "FIELDLENGTH(24)"};
external function enc_RAW_PDU_10(in RAW_PDU_10 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_10(in octetstring stream) return RAW_PDU_10 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_24_for_bitstring() runs on TempComp {
  const RAW_PDU_10 	i := '1111000001110000'B
  const octetstring 	o := '70F000'O

  if ((enc_RAW_PDU_10(i) == o)and(dec_RAW_PDU_10(o) =='00000000'B & i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_10(i)= ", enc_RAW_PDU_10(i), "; dec_RAW_PDU_10(o)= ", dec_RAW_PDU_10(o));}
}



type bitstring RAW_PDU_11
with { encode "RAW"; variant "FIELDLENGTH(0)"};
external function enc_RAW_PDU_11(in RAW_PDU_11 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_11(in octetstring stream) return RAW_PDU_11 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_0_for_bitstring() runs on TempComp {
  const RAW_PDU_11 	i := '1111000001110000'B
  const octetstring 	o := '70F0'O

  if ((enc_RAW_PDU_11(i) == o)and(dec_RAW_PDU_11(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_11(i)= ", enc_RAW_PDU_11(i), "; dec_RAW_PDU_11(o)= ", dec_RAW_PDU_11(o));}
}



type bitstring RAW_PDU_12
with { encode "RAW"; variant ""};
external function enc_RAW_PDU_12(in RAW_PDU_12 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_12(in octetstring stream) return RAW_PDU_12 with { extension "prototype(convert) decode(RAW)" }

testcase TC_DEFAULT_FIELDLENGTH_for_bitstring() runs on TempComp {
  const RAW_PDU_12 	i := '1111000001110000'B
  const octetstring 	o := '70F0'O

  if ((enc_RAW_PDU_12(i) == o)and(dec_RAW_PDU_12(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_12(i)= ", enc_RAW_PDU_12(i), "; dec_RAW_PDU_12(o)= ", dec_RAW_PDU_12(o));}
}



type bitstring RAW_PDU_13
with { encode "RAW"; variant "FIELDLENGTH(32)"};
external function enc_RAW_PDU_13(in RAW_PDU_13 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_13(in octetstring stream) return RAW_PDU_13 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_32_for_bitstring_4_bits_long() runs on TempComp {
  const RAW_PDU_13 	i := '1111'B
  const octetstring 	o := '0F000000'O

  if ((enc_RAW_PDU_13(i) == o)and(dec_RAW_PDU_13(o) == '0000000000000000000000000000'B & i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_13(i)= ", enc_RAW_PDU_13(i), "; dec_RAW_PDU_13(o)= ", dec_RAW_PDU_13(o));}
}



type octetstring RAW_PDU_14
with { encode "RAW"; variant "FIELDLENGTH(1)"};
external function enc_RAW_PDU_14(in RAW_PDU_14 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_14(in octetstring stream) return RAW_PDU_14 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_1_for_octetstring() runs on TempComp {
  const RAW_PDU_14 	i := '0F'O
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_14(i) == o)and(dec_RAW_PDU_14(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_14(i)= ", enc_RAW_PDU_14(i), "; dec_RAW_PDU_14(o)= ", dec_RAW_PDU_14(o));}
}



type octetstring RAW_PDU_15
with { encode "RAW"; variant "FIELDLENGTH(2)"};
external function enc_RAW_PDU_15(in RAW_PDU_15 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_15(in octetstring stream) return RAW_PDU_15 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_2_for_octetstring() runs on TempComp {
  const RAW_PDU_15 	i := '1234'O
  const octetstring 	o := '1234'O

  if ((enc_RAW_PDU_15(i) == o)and(dec_RAW_PDU_15(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_15(i)= ", enc_RAW_PDU_15(i), "; dec_RAW_PDU_15(o)= ", dec_RAW_PDU_15(o));}
}



type octetstring RAW_PDU_16
with { variant "FIELDLENGTH(2)";
       variant "BYTEORDER (first)";
       encode "RAW"
     };
external function enc_RAW_PDU_16(in RAW_PDU_16 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_16(in octetstring stream) return RAW_PDU_16 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_2_and_BYTEORDER_first_for_octetstring() runs on TempComp {
  const RAW_PDU_16 	i := '1234'O
  const octetstring 	o := '1234'O

  if ((enc_RAW_PDU_16(i) == o)and(dec_RAW_PDU_16(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_16(i)= ", enc_RAW_PDU_16(i), "; dec_RAW_PDU_16(o)= ", dec_RAW_PDU_16(o));}
}



type octetstring RAW_PDU_17
with { variant "FIELDLENGTH(2)";
       variant "BYTEORDER (last)";
       encode "RAW"
     };
external function enc_RAW_PDU_17(in RAW_PDU_17 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_17(in octetstring stream) return RAW_PDU_17 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_2_and_BYTEORDER_last_for_octetstring() runs on TempComp {
  const RAW_PDU_17 	i := '1234'O
  const octetstring 	o := '3412'O

  if ((enc_RAW_PDU_17(i) == o)and(dec_RAW_PDU_17(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_17(i)= ", enc_RAW_PDU_17(i), "; dec_RAW_PDU_17(o)= ", dec_RAW_PDU_17(o));}
}



type octetstring RAW_PDU_18
with { variant "FIELDLENGTH(4)";
       variant "BYTEORDER (first)";
       encode "RAW"
     };
external function enc_RAW_PDU_18(in RAW_PDU_18 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_18(in octetstring stream) return RAW_PDU_18 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_and_BYTEORDER_first_for_octetstring() runs on TempComp {
  const RAW_PDU_18 	i := '12345678'O
  const octetstring 	o := '12345678'O

  if ((enc_RAW_PDU_18(i) == o)and(dec_RAW_PDU_18(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_18(i)= ", enc_RAW_PDU_18(i), "; dec_RAW_PDU_18(o)= ", dec_RAW_PDU_18(o));}
}



testcase TC_FIELDLENGTH_4_for_octetstring_3_octets_long() runs on TempComp {
  const RAW_PDU_18 	i := '123456'O
  const octetstring 	o := '12345600'O

  if ((enc_RAW_PDU_18(i) == o)and(dec_RAW_PDU_18(o) == i & '00'O)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_18(i)= ", enc_RAW_PDU_18(i), "; dec_RAW_PDU_18(o)= ", dec_RAW_PDU_18(o));}
}



type octetstring RAW_PDU_19
with { variant "FIELDLENGTH(5)";
       encode "RAW"
     };
external function enc_RAW_PDU_19(in RAW_PDU_19 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_19(in octetstring stream) return RAW_PDU_19 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_5_for_octetstring_2_octets_long() runs on TempComp {
  const RAW_PDU_19 	i := '1234'O
  const octetstring 	o := '1234000000'O

  if ((enc_RAW_PDU_19(i) == o)and(dec_RAW_PDU_19(o) == i& '000000'O )) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_19(i)= ", enc_RAW_PDU_19(i), "; dec_RAW_PDU_19(o)= ", dec_RAW_PDU_19(o));}
}



type octetstring RAW_PDU_20
with { variant "FIELDLENGTH(4)";
       variant "BYTEORDER (last)";
       encode "RAW"
     };
external function enc_RAW_PDU_20(in RAW_PDU_20 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_20(in octetstring stream) return RAW_PDU_20 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_and_BYTEORDER_last_for_octetstring() runs on TempComp {
  const RAW_PDU_20 	i := '12345678'O
  const octetstring 	o := '78563412'O

  if ((enc_RAW_PDU_20(i) == o)and(dec_RAW_PDU_20(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_20(i)= ", enc_RAW_PDU_20(i), "; dec_RAW_PDU_20(o)= ", dec_RAW_PDU_20(o));}
}



testcase TC_FIELDLENGTH_4_and_BYTEORDER_last_for_octetstring_3_octets_long() runs on TempComp {
  const RAW_PDU_20 	i := '123456'O
  const octetstring 	o := '00563412'O

  if ((enc_RAW_PDU_20(i) == o)and(dec_RAW_PDU_20(o) == i & '00'O)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_20(i)= ", enc_RAW_PDU_20(i), "; dec_RAW_PDU_20(o)= ", dec_RAW_PDU_20(o));}
}



type octetstring RAW_PDU_21
with { variant "";
       encode "RAW"
     };
external function enc_RAW_PDU_21(in RAW_PDU_21 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_21(in octetstring stream) return RAW_PDU_21 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Default_FIELDLENGTH_for_octetstring() runs on TempComp {
  const RAW_PDU_21 	i := '123456'O
  const octetstring 	o := '123456'O

  if ((enc_RAW_PDU_21(i) == o)and(dec_RAW_PDU_21(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_21(i)= ", enc_RAW_PDU_21(i), "; dec_RAW_PDU_21(o)= ", dec_RAW_PDU_21(o));}
}



type octetstring RAW_PDU_22
with { variant "FIELDLENGTH(0)";
       encode "RAW"
     };
external function enc_RAW_PDU_22(in RAW_PDU_22 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_22(in octetstring stream) return RAW_PDU_22 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_0_for_octetstring() runs on TempComp {
  const RAW_PDU_22 	i := '1234'O
  const octetstring 	o := '1234'O

  if ((enc_RAW_PDU_22(i) == o)and(dec_RAW_PDU_22(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_22(i)= ", enc_RAW_PDU_22(i), "; dec_RAW_PDU_22(o)= ", dec_RAW_PDU_22(o));}
}



type hexstring RAW_PDU_23
with { variant "FIELDLENGTH(4)";
       encode "RAW"
     };
external function enc_RAW_PDU_23(in RAW_PDU_23 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_23(in octetstring stream) return RAW_PDU_23 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_for_hexstring() runs on TempComp {
  const RAW_PDU_23 	i := '1234'H
  const octetstring 	o := '2143'O

  if ((enc_RAW_PDU_23(i) == o)and(dec_RAW_PDU_23(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_23(i)= ", enc_RAW_PDU_23(i), "; dec_RAW_PDU_23(o)= ", dec_RAW_PDU_23(o));}
}



type hexstring RAW_PDU_24
with { variant "FIELDLENGTH(8)";
       encode "RAW"
     };
external function enc_RAW_PDU_24(in RAW_PDU_24 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_24(in octetstring stream) return RAW_PDU_24 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_8_for_hexstring() runs on TempComp {
  const RAW_PDU_24 	i := '1234'H
  const octetstring 	o := '21430000'O

  if ((enc_RAW_PDU_24(i) == o)and(dec_RAW_PDU_24(o) == i & '0000'H)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_24(i)= ", enc_RAW_PDU_24(i), "; dec_RAW_PDU_24(o)= ", dec_RAW_PDU_24(o));}
}




type hexstring RAW_PDU_25
with { variant "";
       encode "RAW"
     };
external function enc_RAW_PDU_25(in RAW_PDU_25 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_25(in octetstring stream) return RAW_PDU_25 with { extension "prototype(convert) decode(RAW)" }

testcase TC_DEFAULT_FIELDLENGTH_for_hexstring() runs on TempComp {
  const RAW_PDU_25 	i := '12345670'H
  const octetstring 	o := '21436507'O

  if ((enc_RAW_PDU_25(i) == o)and(dec_RAW_PDU_25(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_25(i)= ", enc_RAW_PDU_25(i), "; dec_RAW_PDU_25(o)= ", dec_RAW_PDU_25(o));}
}



type hexstring RAW_PDU_26
with { variant "FIELDLENGTH(0)";
       encode "RAW"
     };
external function enc_RAW_PDU_26(in RAW_PDU_26 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_26(in octetstring stream) return RAW_PDU_26 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_0_for_hexstring() runs on TempComp {
  const RAW_PDU_26 	i := '123456'H
  const octetstring 	o := '214365'O

  if ((enc_RAW_PDU_26(i) == o)and(dec_RAW_PDU_26(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_26(i)= ", enc_RAW_PDU_26(i), "; dec_RAW_PDU_26(o)= ", dec_RAW_PDU_26(o));}
}



type hexstring RAW_PDU_27
with { variant "FIELDLENGTH(12)";
       encode "RAW"
     };
external function enc_RAW_PDU_27(in RAW_PDU_27 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_27(in octetstring stream) return RAW_PDU_27 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_12_for_hexstring_2_hex_long() runs on TempComp {
  const RAW_PDU_27 	i := '12'H
  const octetstring 	o := '210000000000'O

  if ((enc_RAW_PDU_27(i) == o)and(dec_RAW_PDU_27(o) == i & '0000000000'H)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_27(i)= ", enc_RAW_PDU_27(i), "; dec_RAW_PDU_27(o)= ", dec_RAW_PDU_27(o));}
}



type enumerated RAW_PDU_28
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant "FIELDLENGTH(4)" ;
       encode "RAW"};
external function enc_RAW_PDU_28(in RAW_PDU_28 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_28(in octetstring stream) return RAW_PDU_28 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_4_for_enumerated() runs on TempComp {
  const RAW_PDU_28 	i := first
  const octetstring 	o := '01'O

  if ((enc_RAW_PDU_28(i) == o)and(dec_RAW_PDU_28(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_28(i)= ", enc_RAW_PDU_28(i), "; dec_RAW_PDU_28(o)= ", dec_RAW_PDU_28(o));}
}



type enumerated RAW_PDU_29
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant "FIELDLENGTH(32)" ;
       encode "RAW"};
external function enc_RAW_PDU_29(in RAW_PDU_29 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_29(in octetstring stream) return RAW_PDU_29 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_32_for_enumerated() runs on TempComp {
  const RAW_PDU_29 	i := first
  const octetstring 	o := '01000000'O

  if ((enc_RAW_PDU_29(i) == o)and(dec_RAW_PDU_29(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_29(i)= ", enc_RAW_PDU_29(i), "; dec_RAW_PDU_29(o)= ", dec_RAW_PDU_29(o));}
}



type enumerated RAW_PDU_30
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { variant "" ;
       encode "RAW"};
external function enc_RAW_PDU_30(in RAW_PDU_30 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_30(in octetstring stream) return RAW_PDU_30 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Default_FIELDLENGTH_for_enumerated() runs on TempComp {
  const RAW_PDU_30 	i := tenth
  const octetstring 	o := '0A'O

  if ((enc_RAW_PDU_30(i) == o)and(dec_RAW_PDU_30(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_30(i)= ", enc_RAW_PDU_30(i), "; dec_RAW_PDU_30(o)= ", dec_RAW_PDU_30(o));}
}



type bitstring RAW_PDU_31 length (4);
external function enc_RAW_PDU_31(in RAW_PDU_31 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_31(in octetstring stream) return RAW_PDU_31 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_bitstring() runs on TempComp {
  const RAW_PDU_31 	i := '1111'B
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_31(i) == o)and(dec_RAW_PDU_31(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_31(i)= ", enc_RAW_PDU_31(i), "; dec_RAW_PDU_31(o)= ", dec_RAW_PDU_31(o));}
}



type hexstring RAW_PDU_32 length (0);
external function enc_RAW_PDU_32(in RAW_PDU_32 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_32(in octetstring stream) return RAW_PDU_32 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_hexstring() runs on TempComp {
  const RAW_PDU_32 	i := ''H
  const octetstring 	o := ''O

  if ((enc_RAW_PDU_32(i) == o)and(dec_RAW_PDU_32(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_32(i)= ", enc_RAW_PDU_32(i), "; dec_RAW_PDU_32(o)= ", dec_RAW_PDU_32(o));}
}



type octetstring RAW_PDU_33 length (2 .. 2);
external function enc_RAW_PDU_33(in RAW_PDU_33 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_33(in octetstring stream) return RAW_PDU_33 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_octetstring() runs on TempComp {
  const RAW_PDU_33 	i := '1122'O
  const octetstring 	o := '1122'O

  if ((enc_RAW_PDU_33(i) == o)and(dec_RAW_PDU_33(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_33(i)= ", enc_RAW_PDU_33(i), "; dec_RAW_PDU_33(o)= ", dec_RAW_PDU_33(o));}
}


type record RAW_PDU_34 {bitstring b length(4), hexstring h length(5), octetstring o length(2 .. 2)}
with {encode "RAW"; variant  ""};
external function enc_RAW_PDU_34(in RAW_PDU_34 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_34(in octetstring stream) return RAW_PDU_34 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_record() runs on TempComp {
  const RAW_PDU_34 	i := {'1001'B,'12345'H, '1122'O}
  const octetstring 	o := '1932541122'O

  if ((enc_RAW_PDU_34(i) == o)and(dec_RAW_PDU_34(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_34(i)= ", enc_RAW_PDU_34(i), "; dec_RAW_PDU_34(o)= ", dec_RAW_PDU_34(o));}
}



type bitstring btype_35 length (12 .. 12);
type record length (2 .. 2) of btype_35 RAW_PDU_35
with {encode "RAW"; variant  ""};
external function enc_RAW_PDU_35(in RAW_PDU_35 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_35(in octetstring stream) return RAW_PDU_35 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_record_of() runs on TempComp {
  const RAW_PDU_35 	i := {'000011111111'B, '111100001111'B}
  const octetstring 	o := 'FFF0F0'O

  if ((enc_RAW_PDU_35(i) == o)and(dec_RAW_PDU_35(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_35(i)= ", enc_RAW_PDU_35(i), "; dec_RAW_PDU_35(o)= ", dec_RAW_PDU_35(o));}
}



type bitstring btype length (1)
type hexstring htype length (4)
type octetstring otype length (2 .. 2)

type set RAW_PDU_36 {hexstring h length(4), octetstring o length (2 .. 2), bitstring b length(1)}
with {encode "RAW"; variant  ""};
external function enc_RAW_PDU_36(in RAW_PDU_36 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_36(in octetstring stream) return RAW_PDU_36 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_set() runs on TempComp {
  const RAW_PDU_36 	i := {h := '1234'H, o := '1122'O, b := '1'B}
  const octetstring 	o := '2143112201'O

  if ((enc_RAW_PDU_36(i) == o)and(dec_RAW_PDU_36(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_36(i)= ", enc_RAW_PDU_36(i), "; dec_RAW_PDU_36(o)= ", dec_RAW_PDU_36(o));}
}



type bitstring btype_37 length (12 .. 12);
type record length (2 .. 2) of btype_37 RAW_PDU_37
with {encode "RAW"; variant  ""};
external function enc_RAW_PDU_37(in RAW_PDU_37 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_37(in octetstring stream) return RAW_PDU_37 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_set_of() runs on TempComp {
  const RAW_PDU_37 	i := {'000011111111'B, '111100001111'B}
  const octetstring 	o := 'FFF0F0'O

  if ((enc_RAW_PDU_37(i) == o)and(dec_RAW_PDU_37(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_37(i)= ", enc_RAW_PDU_37(i), "; dec_RAW_PDU_37(o)= ", dec_RAW_PDU_37(o));}
}



type bitstring RAW_PDU_38 length (9 .. 9)
with {encode "RAW"; variant "ALIGN(left)"};
external function enc_RAW_PDU_38(in RAW_PDU_38 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_38(in octetstring stream) return RAW_PDU_38 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_and_align_bitstring() runs on TempComp {
  const RAW_PDU_38 	i := '111100001'B
  const octetstring 	o := 'E101'O

  if ((enc_RAW_PDU_38(i) == o)and(dec_RAW_PDU_38(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_38(i)= ", enc_RAW_PDU_38(i), "; dec_RAW_PDU_38(o)= ", dec_RAW_PDU_38(o));}
}



type hexstring RAW_PDU_39 length (10 .. 10)
with {encode "RAW"; variant "ALIGN(right), BITORDERINOCTET(lsb)"};
external function enc_RAW_PDU_39(in RAW_PDU_39 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_39(in octetstring stream) return RAW_PDU_39 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_and_align_hexstring() runs on TempComp {
  const RAW_PDU_39 	i := '0000012345'H
  const octetstring 	o := '0000103254000000'O

  if (dec_RAW_PDU_39(o) == i) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_39(i)= ", enc_RAW_PDU_39(i), "; dec_RAW_PDU_39(o)= ", dec_RAW_PDU_39(o));}
}



type octetstring RAW_PDU_40 length (8 .. 8)
with {encode "RAW"; variant "ALIGN(left)"};
external function enc_RAW_PDU_40(in RAW_PDU_40 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_40(in octetstring stream) return RAW_PDU_40 with { extension "prototype(convert) decode(RAW)" }

testcase TC_FIELDLENGTH_with_length_restriction_and_align_octetstring() runs on TempComp {
  const RAW_PDU_40 	i := '0102030400000000'O
  const octetstring 	o := '010203040000000000000000000000'O

  if (dec_RAW_PDU_40(o) == i) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_40(i)= ", enc_RAW_PDU_40(i), "; dec_RAW_PDU_40(o)= ", dec_RAW_PDU_40(o));}
}



type integer RAW_PDU_41
with {encode "RAW"; variant "BYTEORDER (first)"};
external function enc_RAW_PDU_41(in RAW_PDU_41 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_41(in octetstring stream) return RAW_PDU_41 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_for_integer_0() runs on TempComp {
  const RAW_PDU_41 	i := 0
  const octetstring 	o := '00'O

  if ((enc_RAW_PDU_41(i) == o)and(dec_RAW_PDU_41(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_41(i)= ", enc_RAW_PDU_41(i), "; dec_RAW_PDU_41(o)= ", dec_RAW_PDU_41(o));}
}



testcase TC_BYTEORDER_first_for_integer_1() runs on TempComp {
  const RAW_PDU_41 	i := 1
  const octetstring 	o := '01'O

  if ((enc_RAW_PDU_41(i) == o)and(dec_RAW_PDU_41(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_41(i)= ", enc_RAW_PDU_41(i), "; dec_RAW_PDU_41(o)= ", dec_RAW_PDU_41(o));}
}



testcase TC_BYTEORDER_first_for_integer_18() runs on TempComp {
  const RAW_PDU_41 	i := 18
  const octetstring 	o := '12'O

  if ((enc_RAW_PDU_41(i) == o)and(dec_RAW_PDU_41(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_41(i)= ", enc_RAW_PDU_41(i), "; dec_RAW_PDU_41(o)= ", dec_RAW_PDU_41(o));}
}



type integer RAW_PDU_42
with {encode "RAW" ;
       variant "FIELDLENGTH (8)" ;
       variant "BYTEORDER (first)"};
external function enc_RAW_PDU_42(in RAW_PDU_42 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_42(in octetstring stream) return RAW_PDU_42 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_and_fieldlength_8_for_integer() runs on TempComp {
  const RAW_PDU_42 	i := 15
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_42(i) == o)and(dec_RAW_PDU_42(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_42(i)= ", enc_RAW_PDU_42(i), "; dec_RAW_PDU_42(o)= ", dec_RAW_PDU_42(o));}
}



type integer RAW_PDU_43
with {encode "RAW" ;
       variant "FIELDLENGTH (16)" ;
       variant "BYTEORDER (first)"};
external function enc_RAW_PDU_43(in RAW_PDU_43 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_43(in octetstring stream) return RAW_PDU_43 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_and_fieldlength_16_for_integer() runs on TempComp {
  const RAW_PDU_43 	i := 15
  const octetstring 	o := '0F00'O

  if ((enc_RAW_PDU_43(i) == o)and(dec_RAW_PDU_43(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_43(i)= ", enc_RAW_PDU_43(i), "; dec_RAW_PDU_43(o)= ", dec_RAW_PDU_43(o));}
}



type integer RAW_PDU_44
with {encode "RAW" ;
       variant "BYTEORDER (last)"};
external function enc_RAW_PDU_44(in RAW_PDU_44 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_44(in octetstring stream) return RAW_PDU_44 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_for_integer_0() runs on TempComp {
  const RAW_PDU_44 	i := 0
  const octetstring 	o := '00'O

  if ((enc_RAW_PDU_44(i) == o)and(dec_RAW_PDU_44(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_44(i)= ", enc_RAW_PDU_44(i), "; dec_RAW_PDU_44(o)= ", dec_RAW_PDU_44(o));}
}



testcase TC_BYTEORDER_last_for_integer_1() runs on TempComp {
  const RAW_PDU_44 	i := 1
  const octetstring 	o := '01'O

  if ((enc_RAW_PDU_44(i) == o)and(dec_RAW_PDU_44(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_44(i)= ", enc_RAW_PDU_44(i), "; dec_RAW_PDU_44(o)= ", dec_RAW_PDU_44(o));}
}



testcase TC_BYTEORDER_last_for_integer_18() runs on TempComp {
  const RAW_PDU_44 	i := 18
  const octetstring 	o := '12'O

  if ((enc_RAW_PDU_44(i) == o)and(dec_RAW_PDU_44(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_44(i)= ", enc_RAW_PDU_44(i), "; dec_RAW_PDU_44(o)= ", dec_RAW_PDU_44(o));}
}



type integer RAW_PDU_45
with { encode "RAW";
       variant "FIELDLENGTH (8)" ;
       variant "BYTEORDER (last)" };
external function enc_RAW_PDU_45(in RAW_PDU_45 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_45(in octetstring stream) return RAW_PDU_45 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_and_fieldlength_8_for_integer() runs on TempComp {
  const RAW_PDU_45 	i := 15
  const octetstring 	o := '0F'O

  if ((enc_RAW_PDU_45(i) == o)and(dec_RAW_PDU_45(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_45(i)= ", enc_RAW_PDU_45(i), "; dec_RAW_PDU_45(o)= ", dec_RAW_PDU_45(o));}
}



type integer RAW_PDU_46
with { encode "RAW";
       variant "FIELDLENGTH (16)" ;
       variant "BYTEORDER (last)" };
external function enc_RAW_PDU_46(in RAW_PDU_46 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_46(in octetstring stream) return RAW_PDU_46 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_and_fieldlength_16_for_integer() runs on TempComp {
  const RAW_PDU_46 	i := 15
  const octetstring 	o := '000F'O

  if ((enc_RAW_PDU_46(i) == o)and(dec_RAW_PDU_46(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_46(i)= ", enc_RAW_PDU_46(i), "; dec_RAW_PDU_46(o)= ", dec_RAW_PDU_46(o));}
}



type bitstring RAW_PDU_47
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (first)" };
external function enc_RAW_PDU_47(in RAW_PDU_47 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_47(in octetstring stream) return RAW_PDU_47 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_for_bitstring() runs on TempComp {
  const RAW_PDU_47 	i := '0000000100000010'B
  const octetstring 	o := '0201'O

  if ((enc_RAW_PDU_47(i) == o)and(dec_RAW_PDU_47(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_47(i)= ", enc_RAW_PDU_47(i), "; dec_RAW_PDU_47(o)= ", dec_RAW_PDU_47(o));}
}




type bitstring RAW_PDU_48
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (last)" };
external function enc_RAW_PDU_48(in RAW_PDU_48 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_48(in octetstring stream) return RAW_PDU_48 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_for_bitstring() runs on TempComp {
  const RAW_PDU_48 	i := '0000000100000010'B
  const octetstring 	o := '0102'O

  if ((enc_RAW_PDU_48(i) == o)and(dec_RAW_PDU_48(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_48(i)= ", enc_RAW_PDU_48(i), "; dec_RAW_PDU_48(o)= ", dec_RAW_PDU_48(o));}
}



type octetstring RAW_PDU_49
with { encode "RAW";
       variant "BYTEORDER (first)"};
external function enc_RAW_PDU_49(in RAW_PDU_49 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_49(in octetstring stream) return RAW_PDU_49 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_for_octetstring() runs on TempComp {
  const RAW_PDU_49 	i := '1234'O
  const octetstring 	o := '1234'O

  if ((enc_RAW_PDU_49(i) == o)and(dec_RAW_PDU_49(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_49(i)= ", enc_RAW_PDU_49(i), "; dec_RAW_PDU_49(o)= ", dec_RAW_PDU_49(o));}
}



type octetstring RAW_PDU_50
with { encode "RAW";
       variant "BYTEORDER (last)"};
external function enc_RAW_PDU_50(in RAW_PDU_50 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_50(in octetstring stream) return RAW_PDU_50 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_for_octetstring() runs on TempComp {
  const RAW_PDU_50 	i := '1234'O
  const octetstring 	o := '3412'O

  if ((enc_RAW_PDU_50(i) == o)and(dec_RAW_PDU_50(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_50(i)= ", enc_RAW_PDU_50(i), "; dec_RAW_PDU_50(o)= ", dec_RAW_PDU_50(o));}
}



type enumerated RAW_PDU_51
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (first) "};
external function enc_RAW_PDU_51(in RAW_PDU_51 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_51(in octetstring stream) return RAW_PDU_51 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_for_enumerated() runs on TempComp {
  const RAW_PDU_51 	i := first
  const octetstring 	o := '0100'O

  if ((enc_RAW_PDU_51(i) == o)and(dec_RAW_PDU_51(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_51(i)= ", enc_RAW_PDU_51(i), "; dec_RAW_PDU_51(o)= ", dec_RAW_PDU_51(o));}
}



type enumerated RAW_PDU_52
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BYTEORDER (last) "};
external function enc_RAW_PDU_52(in RAW_PDU_52 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_52(in octetstring stream) return RAW_PDU_52 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_for_enumerated() runs on TempComp {
  const RAW_PDU_52 	i := first
  const octetstring 	o := '0001'O

  if ((enc_RAW_PDU_52(i) == o)and(dec_RAW_PDU_52(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_52(i)= ", enc_RAW_PDU_52(i), "; dec_RAW_PDU_52(o)= ", dec_RAW_PDU_52(o));}
}



type hexstring RAW_PDU_53
with { encode "RAW"; variant "BYTEORDER(first)"};
external function enc_RAW_PDU_53(in RAW_PDU_53 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_53(in octetstring stream) return RAW_PDU_53 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_first_for_hexstring() runs on TempComp {
  const RAW_PDU_53 	i := '1234567890'H
  const octetstring 	o := '2143658709'O

  if ((enc_RAW_PDU_53(i) == o)and(dec_RAW_PDU_53(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_53(i)= ", enc_RAW_PDU_53(i), "; dec_RAW_PDU_53(o)= ", dec_RAW_PDU_53(o));}
}



type hexstring RAW_PDU_54
with { encode "RAW"; variant "BYTEORDER(last)"};
external function enc_RAW_PDU_54(in RAW_PDU_54 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_54(in octetstring stream) return RAW_PDU_54 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BYTEORDER_last_for_hexstring() runs on TempComp {
  const RAW_PDU_54 	i := '1234567890'H
  const octetstring 	o := '0987654321'O

  if ((enc_RAW_PDU_54(i) == o)and(dec_RAW_PDU_54(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_RAW_PDU_54(i)= ", enc_RAW_PDU_54(i), "; dec_RAW_PDU_54(o)= ", dec_RAW_PDU_54(o));}
}


type integer RAW_PDU_56
with { encode "RAW"; 
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_56(in RAW_PDU_56 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_56(in octetstring stream) return RAW_PDU_56 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_integer_8() runs on TempComp{
  const RAW_PDU_56      i := 15
  const octetstring 	o := '0F'O
  if ((enc_RAW_PDU_56(i) == o)and(dec_RAW_PDU_56(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_57
with { encode "RAW"; 
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_57(in RAW_PDU_57 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_57(in octetstring stream) return RAW_PDU_57 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_integer_8() runs on TempComp{
  const RAW_PDU_57         i := 15
  const octetstring 	o := 'F0'O
  if ((enc_RAW_PDU_57(i) == o)and(dec_RAW_PDU_57(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_58
with { encode "RAW"; 
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_58(in RAW_PDU_58 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_58(in octetstring stream) return RAW_PDU_58 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_integer_16() runs on TempComp{
  const RAW_PDU_58      i := 4660
  const octetstring 	o := '3412'O 
  if ((enc_RAW_PDU_58(i) == o)and(dec_RAW_PDU_58(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_59
with { encode "RAW"; 
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_59(in RAW_PDU_59 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_59(in octetstring stream) return RAW_PDU_59 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_integer_16() runs on TempComp{
  const RAW_PDU_59         i := 4660
  const octetstring 	o := '482C'O 
  if ((enc_RAW_PDU_59(i) == o)and(dec_RAW_PDU_59(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_60
with { encode "RAW"; 
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_60(in RAW_PDU_60 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_60(in octetstring stream) return RAW_PDU_60 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_octetstring_1() runs on TempComp{
  const RAW_PDU_60      i := '0F'O
  const octetstring 	o := '0F'O
  if ((enc_RAW_PDU_60(i) == o)and(dec_RAW_PDU_60(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_61
with { encode "RAW"; 
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_61(in RAW_PDU_61 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_61(in octetstring stream) return RAW_PDU_61 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_octetstring_1() runs on TempComp{
  const RAW_PDU_61      i := '0F'O
  const octetstring 	o := 'F0'O
  if ((enc_RAW_PDU_61(i) == o)and(dec_RAW_PDU_61(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_62
with { encode "RAW"; 
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_62(in RAW_PDU_62 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_62(in octetstring stream) return RAW_PDU_62 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_octetstring_2() runs on TempComp{
  const RAW_PDU_62      i := '1234'O
  const octetstring 	o := '1234'O
  if ((enc_RAW_PDU_62(i) == o)and(dec_RAW_PDU_62(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_63
with { encode "RAW"; 
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_63(in RAW_PDU_63 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_63(in octetstring stream) return RAW_PDU_63 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_octetstring_2() runs on TempComp{
  const RAW_PDU_63      i := '1234'O
  const octetstring 	o := '2C48'O
  if ((enc_RAW_PDU_63(i) == o)and(dec_RAW_PDU_63(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_64
with { encode "RAW"; 
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_64(in RAW_PDU_64 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_64(in octetstring stream) return RAW_PDU_64 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_bitstring_8() runs on TempComp{
  const RAW_PDU_64      i := '00000011'B
  const octetstring 	o := '03'O
  if ((enc_RAW_PDU_64(i) == o)and(dec_RAW_PDU_64(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_65
with { encode "RAW"; 
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_65(in RAW_PDU_65 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_65(in octetstring stream) return RAW_PDU_65 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_bitstring_8() runs on TempComp{
  const RAW_PDU_65      i := '00000011'B
  const octetstring 	o := 'C0'O
  if ((enc_RAW_PDU_65(i) == o)and(dec_RAW_PDU_65(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_66
with { encode "RAW"; 
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(lsb)"};

external function enc_RAW_PDU_66(in RAW_PDU_66 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_66(in octetstring stream) return RAW_PDU_66 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_bitstring_16() runs on TempComp {
  const RAW_PDU_66      i :=  '0001111100110001'B
  const octetstring 	o :=  '311F'O
  if ((enc_RAW_PDU_66(i) == o)and(dec_RAW_PDU_66(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_67
with { encode "RAW"; 
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINFIELD(msb)"};

external function enc_RAW_PDU_67(in RAW_PDU_67 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_67(in octetstring stream) return RAW_PDU_67 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_bitstring_16() runs on TempComp{
  const RAW_PDU_67      i :=  '0001111100110001'B
  const octetstring 	o :=  'F88C'O
  if ((enc_RAW_PDU_67(i) == o)and(dec_RAW_PDU_67(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}



type enumerated RAW_PDU_68
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(4)" ;
       variant "BITORDERINFIELD (lsb) "};



external function enc_RAW_PDU_68(in RAW_PDU_68 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_68(in octetstring stream) return RAW_PDU_68 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_enumerated_4() runs on TempComp{
  const RAW_PDU_68 	i := first
  const octetstring 	o := '01'O
  if ((enc_RAW_PDU_68(i) == o)and(dec_RAW_PDU_68(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type enumerated RAW_PDU_69
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINFIELD (msb) "};



external function enc_RAW_PDU_69(in RAW_PDU_69 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_69(in octetstring stream) return RAW_PDU_69 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_enumerated_8() runs on TempComp{
  const RAW_PDU_69 	i := first;
  const octetstring 	o := '80'O;
  if ((enc_RAW_PDU_69(i) == o)and(dec_RAW_PDU_69(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}


type hexstring RAW_PDU_70
with { encode "RAW"; variant "BITORDERINFIELD(lsb)"};



external function enc_RAW_PDU_70(in RAW_PDU_70 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_70(in octetstring stream) return RAW_PDU_70 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_lsb_for_hexstring() runs on TempComp{
  const RAW_PDU_70 		i := '1234'H
  const octetstring 	o := '2143'O
  if ((enc_RAW_PDU_70(i) == o)and(dec_RAW_PDU_70(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type hexstring RAW_PDU_71
with { encode "RAW"; variant "BITORDERINFIELD(msb)"};



external function enc_RAW_PDU_71(in RAW_PDU_71 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_71(in octetstring stream) return RAW_PDU_71 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINFIELD_msb_for_hexstring() runs on TempComp {
  const RAW_PDU_71        i := '1234'H
  const octetstring 	o := 'C284'O
  if ((enc_RAW_PDU_71(i) == o)and(dec_RAW_PDU_71(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//Testing BITORDERINOCTET Attribute:

type integer RAW_PDU_72
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(lsb)"};

external function enc_RAW_PDU_72(in RAW_PDU_72 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_72(in octetstring stream) return RAW_PDU_72 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_integer_8() runs on TempComp{
  const RAW_PDU_72	i := 15;
  const octetstring 	o := '0F'O;
  if ((enc_RAW_PDU_72(i) == o)and(dec_RAW_PDU_72(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_73
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(msb)"};

external function enc_RAW_PDU_73(in RAW_PDU_73 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_73(in octetstring stream) return RAW_PDU_73 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_integer_8() runs on TempComp{
  const RAW_PDU_73	i := 15
  const octetstring 	o := 'F0'O
  if ((enc_RAW_PDU_73(i) == o)and(dec_RAW_PDU_73(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_74
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
  variant "BITORDERINOCTET(lsb)"};

external function enc_RAW_PDU_74(in RAW_PDU_74 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_74(in octetstring stream) return RAW_PDU_74 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_integer_16() runs on TempComp{
  const RAW_PDU_74	i := 4660
  const octetstring 	o := '3412'O
  if ((enc_RAW_PDU_74(i) == o)and(dec_RAW_PDU_74(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_75
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
  variant "BITORDERINOCTET(msb)"};

external function enc_RAW_PDU_75(in RAW_PDU_75 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_75(in octetstring stream) return RAW_PDU_75 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_integer_16() runs on TempComp{
  const RAW_PDU_75	i := 4660
  const octetstring 	o := '2C48'O
  if ((enc_RAW_PDU_75(i) == o)and(dec_RAW_PDU_75(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_76
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINOCTET(lsb)"
     }; 

external function enc_RAW_PDU_76(in RAW_PDU_76 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_76(in octetstring stream) return RAW_PDU_76 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_octetstring_1() runs on TempComp{
  const RAW_PDU_76	i := '0F'O
  const octetstring 	o := '0F'O
  if ((enc_RAW_PDU_76(i) == o)and(dec_RAW_PDU_76(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_77
with { encode "RAW";
       variant "FIELDLENGTH(1)" ;
       variant "BITORDERINOCTET(msb)"
     }; 

external function enc_RAW_PDU_77(in RAW_PDU_77 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_77(in octetstring stream) return RAW_PDU_77 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_octetstring_1() runs on TempComp{
  const RAW_PDU_77	i := '0F'O
  const octetstring 	o := 'F0'O
  if ((enc_RAW_PDU_77(i) == o)and(dec_RAW_PDU_77(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_78
with { encode "RAW";
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINOCTET(lsb)"
     }; 

external function enc_RAW_PDU_78(in RAW_PDU_78 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_78(in octetstring stream) return RAW_PDU_78 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_octetstring_2() runs on TempComp{
  const RAW_PDU_78	i := '1234'O
  const octetstring 	o := '1234'O
  if ((enc_RAW_PDU_78(i) == o)and(dec_RAW_PDU_78(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type octetstring RAW_PDU_79
with { encode "RAW";
       variant "FIELDLENGTH(2)" ;
       variant "BITORDERINOCTET(msb)"
     }; 

external function enc_RAW_PDU_79(in RAW_PDU_79 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_79(in octetstring stream) return RAW_PDU_79 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_octetstring_2() runs on TempComp{
  const RAW_PDU_79	i := '1234'O
  const octetstring 	o := '482C'O
  if ((enc_RAW_PDU_79(i) == o)and(dec_RAW_PDU_79(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_80
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(lsb)"
};
external function enc_RAW_PDU_80(in RAW_PDU_80 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_80(in octetstring stream) return RAW_PDU_80 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_bitstring_8() runs on TempComp{
  const RAW_PDU_80	i := '00000011'B
  const octetstring 	o := '03'O
  if ((enc_RAW_PDU_80(i) == o)and(dec_RAW_PDU_80(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_81
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET(msb)"
};
external function enc_RAW_PDU_81(in RAW_PDU_81 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_81(in octetstring stream) return RAW_PDU_81 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_bitstring_8() runs on TempComp{
  const RAW_PDU_81	i := '00000011'B
  const octetstring 	o := 'C0'O
  if ((enc_RAW_PDU_81(i) == o)and(dec_RAW_PDU_81(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_82
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(lsb)"
};
external function enc_RAW_PDU_82(in RAW_PDU_82 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_82(in octetstring stream) return RAW_PDU_82 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_bitstring_16() runs on TempComp{
  const RAW_PDU_82	i := '0001111100110001'B
  const octetstring 	o := '311F'O
  if ((enc_RAW_PDU_82(i) == o)and(dec_RAW_PDU_82(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type bitstring RAW_PDU_83
with { encode "RAW";
       variant "FIELDLENGTH(16)" ;
       variant "BITORDERINOCTET(msb)"
};
external function enc_RAW_PDU_83(in RAW_PDU_83 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_83(in octetstring stream) return RAW_PDU_83 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_bitstring_16() runs on TempComp{
  const RAW_PDU_83	i := '0001111100110001'B
  const octetstring 	o := '8CF8'O
  if ((enc_RAW_PDU_83(i) == o)and(dec_RAW_PDU_83(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type enumerated RAW_PDU_84
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(4)" ;
       variant "BITORDERINOCTET (lsb) "
     };

external function enc_RAW_PDU_84(in RAW_PDU_84 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_84(in octetstring stream) return RAW_PDU_84 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_enumerated() runs on TempComp{
  const RAW_PDU_84	i := first
  const octetstring 	o := '01'O
  if ((enc_RAW_PDU_84(i) == o)and(dec_RAW_PDU_84(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type enumerated RAW_PDU_85
  { zero, first, second, third, fourth, fifth, sixth , seventh, eight, nineth,
  tenth  }
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "BITORDERINOCTET (msb) "
     };

external function enc_RAW_PDU_85(in RAW_PDU_85 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_85(in octetstring stream) return RAW_PDU_85 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_enumerated() runs on TempComp{
  const RAW_PDU_85	i := first
  const octetstring 	o := '80'O
  
  if ((enc_RAW_PDU_85(i) == o)and(dec_RAW_PDU_85(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type hexstring RAW_PDU_86
with { encode "RAW"; variant "BITORDERINOCTET(lsb)"};

external function enc_RAW_PDU_86(in RAW_PDU_86 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_86(in octetstring stream) return RAW_PDU_86 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_lsb_for_hexstring() runs on TempComp{
  const RAW_PDU_86	i := '1234'H
  const octetstring 	o := '2143'O
  if ((enc_RAW_PDU_86(i) == o)and(dec_RAW_PDU_86(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type hexstring RAW_PDU_87
with { encode "RAW"; variant "BITORDERINOCTET(msb)"};

external function enc_RAW_PDU_87(in RAW_PDU_87 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_87(in octetstring stream) return RAW_PDU_87 with { extension "prototype(convert) decode(RAW)" }

testcase TC_BITORDERINOCTET_msb_for_hexstring() runs on TempComp{
  const RAW_PDU_87	i := '1234'H
  const octetstring 	o := '84C2'O
  if ((enc_RAW_PDU_87(i) == o)and(dec_RAW_PDU_87(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_88
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( nosign ) "
     };
external function enc_RAW_PDU_88(in RAW_PDU_88 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_88(in octetstring stream) return RAW_PDU_88 with { extension "prototype(convert) decode(RAW)" }

testcase TC_COMP_nosign_for_positive_integer_8() runs on TempComp{
  const RAW_PDU_88	i := 2
  const octetstring 	o := '02'O
  if ((enc_RAW_PDU_88(i) == o)and(dec_RAW_PDU_88(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_89
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( signbit ) "
     };
external function enc_RAW_PDU_89(in RAW_PDU_89 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_89(in octetstring stream) return RAW_PDU_89 with { extension "prototype(convert) decode(RAW)" }

testcase TC_COMP_signbit_for_positive_integer_8() runs on TempComp{
  const RAW_PDU_89	i := 2
  const octetstring 	o := '02'O
  if ((enc_RAW_PDU_89(i) == o)and(dec_RAW_PDU_89(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

testcase TC_COMP_signbit_for_negative_integer_8() runs on TempComp{
  const RAW_PDU_89	i := -2
  const octetstring 	o := '82'O
  if ((enc_RAW_PDU_89(i) == o)and(dec_RAW_PDU_89(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

type integer RAW_PDU_90
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( 2scompl ) "
};

external function enc_RAW_PDU_90(in RAW_PDU_90 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_90(in octetstring stream) return RAW_PDU_90 with { extension "prototype(convert) decode(RAW)" }

testcase TC_COMP_2scompl_for_positive_integer_8() runs on TempComp{
  const RAW_PDU_90	i := 2
  const octetstring 	o := '02'O
  if ((enc_RAW_PDU_90(i) == o)and(dec_RAW_PDU_90(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

testcase TC_COMP_2scompl_for_negative_integer_8() runs on TempComp{
  const RAW_PDU_90	i := -2
  const octetstring 	o := 'FE'O
  if ((enc_RAW_PDU_90(i) == o)and(dec_RAW_PDU_90(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
} 

//   PADDING  for integer

group RAW_group1{

type record RAW_PDU_91
{ integer   int1 ,
  integer   int2 ,
  integer   int3 ,
  integer   int4   }
 with { variant (int3) "FIELDLENGTH (4)" ;
        variant (int1) "PADDING( yes ) " ;
        variant (int2) "FIELDLENGTH (4)" ;
        variant (int2) "PADDING( yes ) " ;
        variant (int3) "FIELDLENGTH (4)" ;
        variant (int3) "PADDING( no ) " ;
        variant (int4) "FIELDLENGTH (4)" ;
        variant (int4) "PADDING( no ) " ; }
} with {encode "RAW" };

external function enc_RAW_PDU_91(in RAW_PDU_91 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_91(in octetstring stream) return RAW_PDU_91 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_for_integer() runs on TempComp{

  const RAW_PDU_91
  i := {  
    int1 :=    1  ,
    int2 :=    2  ,
    int3 :=    3  ,
    int4 :=    4  }

  const octetstring 	o := '010243'O

  if ((enc_RAW_PDU_91(i) == o)and(dec_RAW_PDU_91(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//   PADDING  for bitstring
group RAW_group2{

type record RAW_PDU_92
{ bitstring   bit1 ,
  bitstring   bit2 ,
  bitstring   bit3 ,
  bitstring   bit4   }
 with { variant (bit1) "FIELDLENGTH(4)" ;
        variant (bit1) "PADDING( yes ) " ;
	variant (bit2) "FIELDLENGTH(4)" ;
        variant (bit2) "PADDING( yes ) " ;
	variant (bit3) "FIELDLENGTH(4)" ;
        variant (bit3) "PADDING( no ) " ;
	variant (bit4) "FIELDLENGTH(4)" ;
        variant (bit4) "PADDING( no ) " ;
      };
} with {encode "RAW"}


external function enc_RAW_PDU_92(in RAW_PDU_92 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_92(in octetstring stream) return RAW_PDU_92 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_for_bitstring() runs on TempComp{

  const RAW_PDU_92
  i := {  bit1 :=  '0001'B  ,
    bit2 :=  '0010'B  ,
    bit3 :=  '0011'B  ,
    bit4 :=  '0100'B       }
  const octetstring 	o := '010243'O;

  if ((enc_RAW_PDU_92(i) == o)and(dec_RAW_PDU_92(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDING  for enumerated

group RAW_group3{

type enumerated enumerated1
{ zero, first, second, third, fourth, fifth }

type enumerated enumerated2
{ tenth, eleventh, twelfth, thirteenth, fourthteenth, fifteenth }

type enumerated enumerated3
{ twenty, twentyfirst, twentysecond, twentythird, twentyfourth, twentyfifth }

type enumerated enumerated4
{ thirty, thirtyfirst, thirtysecond, thirtythird, thirtyfourth, thirtyfifth }


type record RAW_PDU_93
{ enumerated1   enum1 ,
  enumerated2   enum2 ,
  enumerated3   enum3 ,
  enumerated4   enum4   }
 with { variant (enum1) "FIELDLENGTH(4)" ;
        variant (enum1) "PADDING( yes ) " ;
	variant (enum2) "FIELDLENGTH(4)" ;
        variant (enum2) "PADDING( yes ) " ;
	variant (enum3) "FIELDLENGTH(4)" ;
        variant (enum3) "PADDING( no ) " ;
	variant (enum4) "FIELDLENGTH(4)" ;
        variant (enum4) "PADDING( no ) " ;
      };
} with {encode "RAW" };

external function enc_RAW_PDU_93(in RAW_PDU_93 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_93(in octetstring stream) return RAW_PDU_93 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_for_enumerated() runs on TempComp{
  const RAW_PDU_93
	i := {  enum1 :=  first  ,
	        enum2 :=  twelfth  ,
		enum3 :=  twentythird  ,
		enum4 :=  thirtyfourth       }

  const octetstring 	o := '010243'O
 
  if ((enc_RAW_PDU_93(i) == o)and(dec_RAW_PDU_93(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//   PADDING  for hexstring

group RAW_group4{

type record RAW_PDU_94
{ hexstring   hex1 ,
  hexstring   hex2 ,
  hexstring   hex3 ,
  hexstring   hex4   }
 with { encode "RAW";
        variant (hex1) "FIELDLENGTH(1)" ;
        variant (hex1) "PADDING( yes ) " ;
	variant (hex2) "FIELDLENGTH(1)" ;
        variant (hex2) "PADDING( yes ) " ;
	variant (hex3) "FIELDLENGTH(1)" ;
        variant (hex3) "PADDING( no ) " ;
	variant (hex4) "FIELDLENGTH(1)" ;
        variant (hex4) "PADDING( no ) " ;
      };
} with {encode "RAW" }

external function enc_RAW_PDU_94(in RAW_PDU_94 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_94(in octetstring stream) return RAW_PDU_94 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_for_hexstring() runs on TempComp{
  const RAW_PDU_94
	i := {  hex1 :=  '1'H  ,
	        hex2 :=  '2'H  ,
		hex3 :=  '3'H  ,
		hex4 :=  '4'H       }

  const octetstring 	o := '010243'O 
 
  if ((enc_RAW_PDU_94(i) == o)and(dec_RAW_PDU_94(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(yes)  for bitstring

type bitstring RAW_PDU_95 length (3)
with {encode "RAW"; variant "PREPADDING(yes)"}

external function enc_RAW_PDU_95(in RAW_PDU_95 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_95(in octetstring stream) return RAW_PDU_95 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_yes_for_bitstring() runs on TempComp{
  const RAW_PDU_95 i := '101'B
  const octetstring 	o := '05'O
 
  if ((enc_RAW_PDU_95(i) == o)and(dec_RAW_PDU_95(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(yes)  for hexstring

type hexstring RAW_PDU_96 length (1)
with {encode "RAW"; variant "PREPADDING(yes)"}

external function enc_RAW_PDU_96(in RAW_PDU_96 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_96(in octetstring stream) return RAW_PDU_96 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_yes_for_hexstring() runs on TempComp{
  const RAW_PDU_96     i := 'F'H
  const octetstring    o := '0F'O
 
  if ((enc_RAW_PDU_96(i) == o)and(dec_RAW_PDU_96(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(word16)  for octetstring

type octetstring otype1
with {encode "RAW"; variant "PREPADDING(word16)"}
type hexstring   htype1 length (3)
type record RAW_PDU_97 { htype1 h, otype1 o}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_97(in RAW_PDU_97 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_97(in octetstring stream) return RAW_PDU_97 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_word16_for_octetstring() runs on TempComp{
  const RAW_PDU_97     i :=  {'AAA'H,'FF'O}
  const octetstring    o :=  'AA0AFF'O
 
  if ((enc_RAW_PDU_97(i) == o)and(dec_RAW_PDU_97(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(word16)  for record of

type integer itype1
with {encode "RAW"; variant "FIELDLENGTH(3)"}
type record length (1) of itype1 rtype1
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU_98 {itype1 r1, rtype1 r2}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_98(in RAW_PDU_98 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_98(in octetstring stream) return RAW_PDU_98 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_word16_for_record_of() runs on TempComp{
  const RAW_PDU_98     i :=  {4,{7}} 
  const octetstring    o :=  '040007'O 
 
  if ((enc_RAW_PDU_98(i) == o)and(dec_RAW_PDU_98(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(dword32)  for set of
type bitstring BIT3 length (3)
type record length (2) of BIT3 rtype2
with {encode "RAW"; variant "PREPADDING(dword32)"}

type record RAW_PDU_99 {BIT3 r1, rtype2 r2}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_99(in RAW_PDU_99 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_99(in octetstring stream) return RAW_PDU_99 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_dword32_for_set_of() runs on TempComp{
  const RAW_PDU_99     i :=  {'100'B,{'111'B, '101'B}}
  const octetstring    o :=  '040000002F'O 
 
  if ((enc_RAW_PDU_99(i) == o)and(dec_RAW_PDU_99(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PREPADDING(dword32)  for record

//type bitstring BIT3 length (3)

type record stype1 {BIT3 s1, BIT3 s2}
with {encode "RAW"; variant "PREPADDING(dword32)"}

type record RAW_PDU_100 {stype1 r1, stype1 r2, stype1 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_100(in RAW_PDU_100 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_100(in octetstring stream) return RAW_PDU_100 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_dword32_for_record() runs on TempComp{
  const RAW_PDU_100    i :=   {{'111'B,'111'B},{'110'B,'000'B},{'111'B,'111'B}}
  const octetstring    o :=   '3F000000060000003F'O
 
  if ((enc_RAW_PDU_100(i) == o)and(dec_RAW_PDU_100(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  PREPADDING(word16)  for set

//type bitstring BIT3 length (3)

type set stype2 {BIT3 s1}
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU_101 {stype2 r1, stype2 r2, stype2 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_101(in RAW_PDU_101 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_101(in octetstring stream) return RAW_PDU_101 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_word16_for_set() runs on TempComp{
  const RAW_PDU_101    i :=  {{s1:='111'B},{s1:='110'B},{s1:='111'B}} 
  const octetstring    o :=  '0700060007'O
 
  if ((enc_RAW_PDU_101(i) == o)and(dec_RAW_PDU_101(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PREPADDING(word16)  for union

type hexstring HEX1 length (1)

type union utype1 {BIT3 u1, HEX1 u2}
with {encode "RAW"; variant "PREPADDING(word16)"}

type record RAW_PDU_102 {utype1 r1, utype1 r2, utype1 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_102(in RAW_PDU_102 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_102(in octetstring stream) return RAW_PDU_102 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PREPADDING_word16_for_union() runs on TempComp{
  const RAW_PDU_102    i :=   {{u1:='111'B},{u1:='010'B},{u1:='111'B}} 
  const octetstring    o :=   '0700020007'O
 
  if ((enc_RAW_PDU_102(i) == o)and(dec_RAW_PDU_102(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDING_PATTERN  for record of

type integer itype2
with {encode "RAW"; variant "FIELDLENGTH(3)"}
type record length (1) of itype2 rtype
with {encode "RAW"; variant "PREPADDING(yes), PADDING_PATTERN('1'B)"}

type record RAW_PDU_103 {itype2 r1, rtype r2}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_103(in RAW_PDU_103 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_103(in octetstring stream) return RAW_PDU_103 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_PATTERN_for_record_of() runs on TempComp{
  const RAW_PDU_103    i := {4,{7}};
  const octetstring    o := 'FC07'O;
 
  if ((enc_RAW_PDU_103(i) == o)and(dec_RAW_PDU_103(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDING_PATTERN  for set of:
type set length (2) of BIT3 rtype3
with {encode "RAW"; variant "PREPADDING(yes), PADDING_PATTERN('10000'B)"}

type record RAW_PDU_104 {BIT3 r1, rtype3 r2}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_104(in RAW_PDU_104 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_104(in octetstring stream) return RAW_PDU_104 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_PATTERN_for_set_of() runs on TempComp{
  const RAW_PDU_104    i :=  {'100'B,{'111'B, '101'B}}
  const octetstring    o :=  '842F'O
 
  if ((enc_RAW_PDU_104(i) == o)and(dec_RAW_PDU_104(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDING_PATTERN  for record:

type bitstring BIT9 length (9)

type record stype3 {BIT9 s1, BIT9 s2}
with {encode "RAW"; variant "PREPADDING(40), PADDING_PATTERN('100000'B)"}

type record RAW_PDU_105 {stype3 r1, stype3 r2, stype3 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_105(in RAW_PDU_105 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_105(in octetstring stream) return RAW_PDU_105 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_PATTERN_for_record() runs on TempComp{
  const RAW_PDU_105    i :=  {{'111000111'B,'111000111'B},{'111111111'B,'111111111'B},{'111000111'B,'111000111'B}};
  const octetstring    o :=  'C78F832008FFFF832008C78F03'O ;
 
  if ((enc_RAW_PDU_105(i) == o)and(dec_RAW_PDU_105(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//PADDING_PATTERN  for set
type hexstring HEX3 length (3)
type set stype4 {HEX3 s1}
with {encode "RAW"; variant "PREPADDING(15), PADDING_PATTERN('10001'B)"}

type record RAW_PDU_106 {stype4 r1, stype4 r2, stype4 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_106(in RAW_PDU_106 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_106(in octetstring stream) return RAW_PDU_106 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_PATTERN_for_set() runs on TempComp{
  const RAW_PDU_106    i := {{s1:='FFF'H},{s1:='FFF'H},{s1:='FFF'H}}
  const octetstring    o := 'FF9FFFCFFF03'O
 
  if ((enc_RAW_PDU_106(i) == o)and(dec_RAW_PDU_106(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDING_PATTERN  for union:
type octetstring OCT2 length (2)

type union utype2 {OCT2 u1, hexstring u2}
with {encode "RAW"; variant "PREPADDING(256),PADDING_PATTERN('11001'B)"}

type record RAW_PDU_107 {utype2 r1, utype2 r2, utype2 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_107(in RAW_PDU_107 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_107(in octetstring stream) return RAW_PDU_107 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDING_PATTERN_for_union() runs on TempComp{
  const RAW_PDU_107    i :=  {{u1:='AABB'O},{u1:='CCDD'O},{u1:='EEFF'O}}
  const octetstring    o :=  'AABB39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CECCDD39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CE39E79C73CEEEFF'O
 
  if ((enc_RAW_PDU_107(i) == o)and(dec_RAW_PDU_107(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDALL with PADDING Attribute - record
type bitstring BIT1 length (1)

type record stype5 {BIT1 s1, BIT1 s2}
with {encode "RAW"; variant "PADDING(yes), PADDALL"}

type record RAW_PDU_108 {stype5 r1, stype5 r2, stype5 r3}
with {encode "RAW"; variant ""}

external function enc_RAW_PDU_108(in RAW_PDU_108 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_108(in octetstring stream) return RAW_PDU_108 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDALL_with_PADDING_Attribute_record() runs on TempComp{
  const RAW_PDU_108    i :=  {{'1'B,'1'B},{'1'B,'1'B},{'1'B,'1'B}};
  const octetstring    o := '010101010101'O;
 
  if ((enc_RAW_PDU_108(i) == o)and(dec_RAW_PDU_108(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//PADDALL with PADDING Attribute - set

//type bitstring BIT3 length (3)

type set stype6 {BIT3 s1, BIT3 s2}
with {encode "RAW"; variant "PADDING(4), PADDALL"}

type set RAW_PDU_109 {stype6 r1, stype6 r2}
with {encode "RAW"; variant "PADDING(dword32), PADDALL"}

external function enc_RAW_PDU_109(in RAW_PDU_109 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_109(in octetstring stream) return RAW_PDU_109 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDALL_with_PADDING_Attribute_set() runs on TempComp{
  const RAW_PDU_109    i :=  {r1:={s1:='111'B,s2:='101'B},r2:={s1:='111'B,s2:='101'B}}
  const octetstring    o := '57570000'O;
 
  if ((enc_RAW_PDU_109(i) == o)and(dec_RAW_PDU_109(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

 // PADDALL with PREPADDING Attribute - record

//type hexstring HEX1 length (1)

type record stype7 {HEX1 s1, HEX1 s2}

type record RAW_PDU_110 {stype7 r1, stype7 r2, stype7 r3}
with {encode "RAW"; variant "PREPADDING(12), PADDALL"}

external function enc_RAW_PDU_110(in RAW_PDU_110 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_110(in octetstring stream) return RAW_PDU_110 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDALL_with_PREPADDING_Attribute_record() runs on TempComp{
  const RAW_PDU_110    i :=  {{'A'H,'B'H},{'A'H,'B'H},{'A'H,'B'H}} 
  const octetstring    o :=  'BAA00BBA'O
 
  if ((enc_RAW_PDU_110(i) == o)and(dec_RAW_PDU_110(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PADDALL with PREPADDING Attribute - set
//type hexstring HEX1 length (1)

type set stype8 {HEX1 s1, HEX1 s2, HEX1 s3}
with {encode "RAW"; variant "PREPADDING(12), PADDALL"}

type set RAW_PDU_111 {stype8 r1, stype8 r2}
with {encode "RAW"; variant "PREPADDING(36), PADDALL, PADDING_PATTERN('1111'B)"}

external function enc_RAW_PDU_111(in RAW_PDU_111 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_111(in octetstring stream) return RAW_PDU_111 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PADDALL_with_PREPADDING_Attribute_set() runs on TempComp{
  const RAW_PDU_111    i :=  {	r1:={s1:='A'H,s2:='B'H,s3:='C'H},
				r2:={s1:='A'H,s2:='B'H,s3:='C'H}}
  const octetstring    o :=  '0AB000FCAF000BC0'O
 
  if ((enc_RAW_PDU_111(i) == o)and(dec_RAW_PDU_111(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//==== Testing PTROFFSET  Attribute ===

// PTROFFSET is set to default base
type bitstring BIT4 length (4)
//type hexstring HEX1 length (1)
type octetstring OCT3 length (3)

group RAW_group5{

type integer INT1
with {variant "FIELDLENGTH(8)" };

type record RAW_PDU_112 {
			INT1 ptr1,
			INT1 ptr2,
			BIT4 field1,
			BIT4 field2 }

with { variant (ptr1) "POINTERTO(field1)";
       variant (ptr1) "UNIT(1)";
       variant (ptr1) "PTROFFSET(ptr1)";
       variant (ptr2) "POINTERTO(field2)";
       variant (ptr2) "UNIT(1)"
       variant (ptr2) "PTROFFSET(ptr2)"}

} with {encode "RAW" };

external function enc_RAW_PDU_112(in RAW_PDU_112 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_112(in octetstring stream) return RAW_PDU_112 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PTROFFSET_is_set_to_default_base() runs on TempComp{
  const RAW_PDU_112    i :=  {16,12,'0110'B,'1001'B} 
  const octetstring    o :=  '100C96'O
 
  if ((enc_RAW_PDU_112(i) == o)and(dec_RAW_PDU_112(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PTROFFSET is set to the beginning of record

//type bitstring BIT3 length (3)
//type hexstring HEX1 length (1)
//type octetstring OCT3 length (3)

group RAW_group6{

//type integer INT1
//with { encode "RAW"; variant "FIELDLENGTH(8)" };


type record RAW_PDU_113 {
			INT1 ptr1,
			INT1 ptr2,
			INT1 ptr3,

			BIT3 field1,
			HEX1 field2,
			OCT3 field3 }

with { variant (ptr1) "POINTERTO(field1)";
       variant (ptr1) "UNIT(1)";
       variant (ptr1) "PTROFFSET(ptr1)";
       variant (ptr2) "POINTERTO(field2)";
       variant (ptr2) "UNIT(1)";
       variant (ptr2) "PTROFFSET(ptr1)";
       variant (ptr3) "POINTERTO(field3)";
       variant (ptr3) "UNIT(1)";
       variant (ptr3) "PTROFFSET(ptr1)"}

} with {encode "RAW" };

external function enc_RAW_PDU_113(in RAW_PDU_113 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_113(in octetstring stream) return RAW_PDU_113 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PTROFFSET_is_set_to_the_beginning_of_record() runs on TempComp{
  const RAW_PDU_113    i :=  {24,27,31,'111'B,'A'H,'010203'O}
  const octetstring    o :=  '181B1FD7008101'O
 
  if ((enc_RAW_PDU_113(i) == o)and(dec_RAW_PDU_113(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// PTROFFSET is set to data field

//type bitstring BIT3 length (3)
//type hexstring HEX1 length (1)
//type octetstring OCT3 length (3)

group RAW_group7{

//type integer INT1
//with { variant "FIELDLENGTH(8)" };


type record RAW_PDU_114 {
			INT1 ptr1,
			INT1 ptr2,
			INT1 ptr3,

			BIT3 field1,
			HEX1 field2,
			OCT3 field3 }

with {  variant (ptr1) "POINTERTO(field1)";
        variant (ptr1) "UNIT(1)";
        variant (ptr1) "PTROFFSET(field1)";
        variant (ptr2) "POINTERTO(field2)";
        variant (ptr2) "UNIT(1)";
        variant (ptr2) "PTROFFSET(field1)";
        variant (ptr3) "POINTERTO(field3)";
        variant (ptr3) "UNIT(1)";
        variant (ptr3) "PTROFFSET(field1)"}

} with {encode "RAW" };

external function enc_RAW_PDU_114(in RAW_PDU_114 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_114(in octetstring stream) return RAW_PDU_114 with { extension "prototype(convert) decode(RAW)" }

testcase TC_PTROFFSET_is_set_to_data_field() runs on TempComp{
  const RAW_PDU_114    i := {0,3,7,'111'B,'A'H,'010203'O}
  const octetstring    o := '000307D7008101'O
 
  if ((enc_RAW_PDU_114(i) == o)and(dec_RAW_PDU_114(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// ==== Testing HEXORDER Attribute ===

//HEXORDER(low)  for hexstring
type hexstring RAW_PDU_115
with { encode "RAW"; variant "HEXORDER(low)"};

external function enc_RAW_PDU_115(in RAW_PDU_115 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_115(in octetstring stream) return RAW_PDU_115 with { extension "prototype(convert) decode(RAW)" }

testcase TC_HEXORDER_low_for_hexstring() runs on TempComp{
  const RAW_PDU_115    i := '1234567890'H
  const octetstring    o := '2143658709'O

  if ((enc_RAW_PDU_115(i) == o)and(dec_RAW_PDU_115(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//HEXORDER(high)  for hexstring

type hexstring RAW_PDU_116
with { encode "RAW"; variant "HEXORDER(high)"};

external function enc_RAW_PDU_116(in RAW_PDU_116 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_116(in octetstring stream) return RAW_PDU_116 with { extension "prototype(convert) decode(RAW)" }

testcase TC_HEXORDER_high_for_hexstring() runs on TempComp{
  const RAW_PDU_116    i := '1234567890'H
  const octetstring    o := '1234567890'O

  if ((enc_RAW_PDU_116(i) == o)and(dec_RAW_PDU_116(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(no)  for octetstring

type octetstring RAW_PDU_117n
with { encode "RAW"; variant "EXTENSION_BIT(no)"};

external function enc_RAW_PDU_117n(in RAW_PDU_117n pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_117n(in octetstring stream) return RAW_PDU_117n with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_no_for_octetstring() runs on TempComp{
  const RAW_PDU_117n    i :=  '1234567890'O
  const octetstring    o :=  '1234567890'O

  if ((enc_RAW_PDU_117n(i) == o)and(dec_RAW_PDU_117n(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(yes)  for octetstring

type octetstring RAW_PDU_117
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

external function enc_RAW_PDU_117(in RAW_PDU_117 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_117(in octetstring stream) return RAW_PDU_117 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_yes_for_octetstring() runs on TempComp{
  const RAW_PDU_117    i := '010203040500'O
  const octetstring    o := '010203040580'O

  if ((enc_RAW_PDU_117(i) == o)and(dec_RAW_PDU_117(o) == '010203040580'O )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(reverse)  for octetstring

type octetstring RAW_PDU_118
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

external function enc_RAW_PDU_118(in RAW_PDU_118 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_118(in octetstring stream) return RAW_PDU_118 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_reverse_for_octetstring() runs on TempComp{
  const RAW_PDU_118    i := '010203040500'O
  const octetstring    o := '818283848500'O

  if ((enc_RAW_PDU_118(i) == o)and(dec_RAW_PDU_118(o) == '818283848500'O )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(yes)  for record of octetstring

type octetstring OCT1
with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU_119
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

external function enc_RAW_PDU_119(in RAW_PDU_119 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_119(in octetstring stream) return RAW_PDU_119 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_yes_for_record_of_octetstring() runs on TempComp{
  const RAW_PDU_119    i :=  {'84'O, '00'O}
  const octetstring    o :=  '0480'O

  if ((enc_RAW_PDU_119(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(reverse)  for record of octetstring
//type octetstring OCT1
//with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU_119r
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

external function enc_RAW_PDU_119r(in RAW_PDU_119r pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_119r(in octetstring stream) return RAW_PDU_119r with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_reverse_for_record_of_octetstring() runs on TempComp{
  const RAW_PDU_119r    i :=   {'80'O}
  const octetstring    o :=   '00'O

  if ((enc_RAW_PDU_119r(i) == o)and(dec_RAW_PDU_119r(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(no)  for record of octetstring
//type octetstring OCT1
//with { encode "RAW"; variant "FIELDLENGTH(1)"};

type record of OCT1 RAW_PDU_120
with { encode "RAW"; variant "EXTENSION_BIT(no)"};

external function enc_RAW_PDU_120(in RAW_PDU_120 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_120(in octetstring stream) return RAW_PDU_120 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_no_for_record_of_octetstring() runs on TempComp{
  const RAW_PDU_120    i :=    {'84'O, '05'O}
  const octetstring    o :=    '8405'O

  if ((enc_RAW_PDU_120(i) == o)and(dec_RAW_PDU_120(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(yes)  for record of bitstring

type bitstring BIT3_
with { encode "RAW"; variant "FIELDLENGTH(3)"};

type record of BIT3_ RAW_PDU_121
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};

external function enc_RAW_PDU_121(in RAW_PDU_121 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_121(in octetstring stream) return RAW_PDU_121 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_yes_for_record_of_bitstring() runs on TempComp{
  const RAW_PDU_121    i := {'111'B, '000'B, '111'B}
  const octetstring    o := 'C301'O

  if ((enc_RAW_PDU_121(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

//EXTENSION_BIT(reverse)  for record of bitstring

//type bitstring BIT3
//with { encode "RAW"; variant "FIELDLENGTH(3)"};

type record of BIT3_ RAW_PDU_122
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};

external function enc_RAW_PDU_122(in RAW_PDU_122 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_122(in octetstring stream) return RAW_PDU_122 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_reverse_for_record_of_bitstring() runs on TempComp{
  const RAW_PDU_122    i := {'111'B, '000'B, '111'B}
  const octetstring    o := 'E700'O

  if ((enc_RAW_PDU_122(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(yes)  for set of bitstring

type set of BIT3 RAW_PDU_123
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};
 
external function enc_RAW_PDU_123(in RAW_PDU_123 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_123(in octetstring stream) return RAW_PDU_123 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_yes_for_set_of_bitstring() runs on TempComp{
  const RAW_PDU_123    i := {'111'B, '000'B, '111'B}
  const octetstring    o := 'C301'O

  if ((enc_RAW_PDU_123(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(reverse)  for set of bitstring

type set of BIT3 RAW_PDU_124
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};
 
external function enc_RAW_PDU_124(in RAW_PDU_124 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_124(in octetstring stream) return RAW_PDU_124 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_reverse_for_set_of_bitstring() runs on TempComp{
  const RAW_PDU_124    i := {'111'B, '000'B, '111'B}
  const octetstring    o := 'E700'O

  if ((enc_RAW_PDU_124(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

 

// EXTENSION_BIT(yes)  for set of hexstring

type set of hexstring RAW_PDU_125
with { encode "RAW"; variant "EXTENSION_BIT(yes)"};
 
external function enc_RAW_PDU_125(in RAW_PDU_125 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_125(in octetstring stream) return RAW_PDU_125 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_yes_for_set_of_hexstring() runs on TempComp{
  const RAW_PDU_125    i := {'F'H, '0'H, 'F'H}
  const octetstring    o := '070F'O

  if ((enc_RAW_PDU_125(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT(reverse)  for set of hexstring

type set of hexstring RAW_PDU_126
with { encode "RAW"; variant "EXTENSION_BIT(reverse)"};
 
external function enc_RAW_PDU_126(in RAW_PDU_126 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_126(in octetstring stream) return RAW_PDU_126 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_reverse_for_set_of_hexstring() runs on TempComp{
  const RAW_PDU_126    i :=  {'F'H, '00'H, 'FFF'H}
  const octetstring    o :=  '0FF87F'O;

  if ((enc_RAW_PDU_126(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 1

group RAW_group8{

type bitstring BIT1_
with { variant "FIELDLENGTH(1)" } ;

type bitstring BIT7_
with { variant "FIELDLENGTH(7)" } ;

type octetstring OCT3_
with { variant "FIELDLENGTH(3)" } ;


type record Rec1
{ BIT7_          data ,
  BIT1_          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec2
{ BIT7_          data ,
  BIT1_          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Rec3
{ BIT7_          data ,
  BIT1_          extensionbit   }
 with { variant "EXTENSION_BIT (yes)"};


type record Octet1
{ BIT7_          data ,
  BIT1_          extensionbit ,
  Rec1          rec1 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};


type record Octet2
{ BIT7_          data ,
  BIT1_          extensionbit ,
  Rec2          rec2 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};


type record Octet3
{ BIT7_          data ,
  BIT1_          extensionbit ,
  Rec3          rec3 ,
  octetstring   more_extension  optional  }
 with { variant "EXTENSION_BIT (yes)";
        variant (more_extension) "EXTENSION_BIT (yes)"};


type record RAW_PDU_127
{ OCT3_               octstr ,
  integer             length1 ,
  Octet1              oct1 ,
  Octet2              oct2 optional ,
  Octet3              oct3 optional }
   with { variant  (length1) "LENGTHTO(oct1 , oct2 , oct3   )" }

} with {encode "RAW"}

external function enc_RAW_PDU_127(in RAW_PDU_127 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_127(in octetstring stream) return RAW_PDU_127 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_EXTENSION_BIT_1() runs on TempComp{
  
const RAW_PDU_127    
  i := { octstr :=  '123456'O ,
    length1 :=      15 ,
    oct1 :=
    { data :=           '0000001'B ,
      extensionbit :=   '0'B ,
      rec1 :=
      { data :=           '0000001'B ,
        extensionbit :=   '0'B   } ,
      more_extension :=  '000080'O      } ,
    oct2 :=
    { data :=           '0000010'B ,
      extensionbit :=   '0'B ,
      rec2 :=
      { data :=           '0000010'B ,
        extensionbit :=   '0'B   } ,
      more_extension :=  '000080'O      } ,
    oct3 :=
    { data :=           '0000011'B ,
      extensionbit :=   '0'B ,
      rec3 :=
      { data :=           '0000011'B ,
        extensionbit :=   '0'B   } ,
      more_extension :=  '000080'O      } 	 }

  const octetstring   o :='1234560F010100008002020000800303000080'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 2

//external function enc_RAW_PDU_127(in RAW_PDU_127 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
//external function dec_RAW_PDU_127(in octetstring stream) return RAW_PDU_128 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_EXTENSION_BIT_2() runs on TempComp{
  const RAW_PDU_127    
    i := { octstr :=  '123456'O ,
           length1 :=      12 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } 	 }


  const octetstring o :='1234560C010100008002820303000080'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 3

testcase TC_record_with_EXTENSION_BIT_3() runs on TempComp{
  const RAW_PDU_127    
     i := { octstr :=  '123456'O ,
           length1 :=      9 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } 	 }

  const octetstring   o :='12345609010100008002820383'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

//  Test of  record with EXTENSION_BIT 4

testcase TC_record_with_EXTENSION_BIT_4() runs on TempComp{
  const RAW_PDU_127    
     i := { octstr :=  '123456'O ,
           length1 :=      6 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } 	 }

  const octetstring   o :='12345606018102820383'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 5

testcase TC_record_with_EXTENSION_BIT_5() runs on TempComp{
  const RAW_PDU_127    
     i := { octstr :=  '123456'O ,
           length1 :=      4 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit      } ,
	   oct3 :=  omit     	 }

  const octetstring   o :='1234560401810282'O


  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 6
testcase TC_record_with_EXTENSION_BIT_6() runs on TempComp{
  const RAW_PDU_127    
    i := { octstr :=  '123456'O ,
           length1 :=      2 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '1'B   } ,
		 more_extension :=  omit     } ,
	   oct2 :=  omit ,
	   oct3 :=  omit     	 }

  const octetstring   o :='123456020181'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 7
testcase TC_record_with_EXTENSION_BIT_7() runs on TempComp{
  const RAW_PDU_127    
    i := { octstr :=  '123456'O ,
           length1 :=      15 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct3 :=
	       { data :=           '0000011'B ,
	         extensionbit :=   '0'B ,
		 rec3 :=
	           { data :=           '0000011'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } 	 }

  const octetstring   o :='1234560F010100008002020000800303000080'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 8
testcase TC_record_with_EXTENSION_BIT_8() runs on TempComp{
  const RAW_PDU_127    
     i := { octstr :=  '123456'O ,
           length1 :=      5 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=  omit ,
	   oct3 :=  omit      }

  const octetstring   o :='123456050101000080'O

  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with EXTENSION_BIT 9
testcase TC_record_with_EXTENSION_BIT_9() runs on TempComp{
  const RAW_PDU_127    
     i := { octstr :=  '123456'O ,
           length1 :=      10 ,
	   oct1 :=
	       { data :=           '0000001'B ,
	         extensionbit :=   '0'B ,
		 rec1 :=
	           { data :=           '0000001'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct2 :=
	       { data :=           '0000010'B ,
	         extensionbit :=   '0'B ,
		 rec2 :=
	           { data :=           '0000010'B ,
	             extensionbit :=   '0'B   } ,
		 more_extension :=  '000080'O      } ,
	   oct3 :=  omit      }

  const octetstring   o :='1234560A01010000800202000080'O
  
  if ((enc_RAW_PDU_127(i) == o)and(dec_RAW_PDU_127(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT_GROUP(no)

group RAW_group9{

//type bitstring BIT1 length(1);
//type bitstring BIT7 length(7);

type record RAW_PDU_128 {
	BIT7_	field1,
	BIT1_	ext1,
	BIT7_	field2,
	BIT1_	ext2,
	BIT7_	field3,
	BIT1_	ext3
}with { variant "EXTENSION_BIT_GROUP(no, field1, ext3)"};

}with {encode "RAW"}

external function enc_RAW_PDU_128(in RAW_PDU_128 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_128(in octetstring stream) return RAW_PDU_128 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_GROUP_no() runs on TempComp{
  const RAW_PDU_128    
    i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B}
  const octetstring o := '7F700F'O
  
  if ((enc_RAW_PDU_128(i) == o)and(dec_RAW_PDU_128(o) == i )) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT_GROUP(yes)


group RAW_group10{

//type bitstring BIT1 length(1);
//type bitstring BIT7 length(7);

type record RAW_PDU_129 {
	BIT7_	field1,
	BIT1_	ext1,
	BIT7_	field2,
	BIT1_	ext2,
	BIT7_	field3,
	BIT1_	ext3
}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"};

}with {encode "RAW"}

external function enc_RAW_PDU_129(in RAW_PDU_129 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_129(in octetstring stream) return RAW_PDU_129 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_GROUP_yes() runs on TempComp{
  const RAW_PDU_129 i := {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B};
  const octetstring o := '7FF00F'O;
  
  if ((enc_RAW_PDU_129(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT_GROUP(yes) - two groups

group RAW_group11{

//type bitstring BIT1 length(1);
//type bitstring BIT7 length(7);

type record RAW_PDU_130 {
	BIT7_	field1,
	BIT1_	ext1,
	BIT7_	field2,
	BIT1_	ext2,
	BIT7_	field3,
	BIT1_	ext3,
	BIT7_	field4,
	BIT1_	ext4

}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"
        variant "EXTENSION_BIT_GROUP(yes, field3, ext4)"};

}with{encode "RAW"}

external function enc_RAW_PDU_130(in RAW_PDU_130 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_130(in octetstring stream) return RAW_PDU_130 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_GROUP_yes_2_groups() runs on TempComp{
  const RAW_PDU_130 i :=  {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B, '1111111'B, '0'B}
  const octetstring o := '7FF00FFF'O
  
  if ((enc_RAW_PDU_130(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

// EXTENSION_BIT_GROUP(yes, reverse) - two groups

group RAW_group12{

//type bitstring BIT1 length(1);
//type bitstring BIT7 length(7);

type record RAW_PDU_131 {
	BIT7_	field1,
	BIT1_	ext1,
	BIT7_	field2,
	BIT1_	ext2,
	BIT7_	field3,
	BIT1_	ext3,
	BIT7_	field4,
	BIT1_	ext4

}with { variant "EXTENSION_BIT_GROUP(yes, field1, ext2)"
        variant "EXTENSION_BIT_GROUP(reverse, field3, ext4)"};

}with{encode "RAW"}

external function enc_RAW_PDU_131(in RAW_PDU_131 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_131(in octetstring stream) return RAW_PDU_131 with { extension "prototype(convert) decode(RAW)" }

testcase TC_EXTENSION_BIT_GROUP_yes_reverse_2_groups() runs on TempComp{
  const RAW_PDU_131 i :=  {'1111111'B, '0'B, '1110000'B, '0'B,'0001111'B,'0'B, '1111111'B, '0'B}
  const octetstring o := '7FF08F7F'O 
  
  if ((enc_RAW_PDU_131(i) == o)) {setverdict(pass);}
  else {setverdict(fail);}
}

//==== Testing ALIGN Attribute ====

//ALIGN(right) for octetstring

type octetstring RAW_PDU_132
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "ALIGN (right)"
     };
external function enc_RAW_PDU_132(in RAW_PDU_132 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_132(in octetstring stream) return RAW_PDU_132 with { extension "prototype(convert) decode(RAW)" }

testcase TC_ALIGN_right_for_octetstring() runs on TempComp{
  const RAW_PDU_132 i := '123456'O
  const octetstring o := '12345600'O 
  
  if ((enc_RAW_PDU_132(i) == o)and((dec_RAW_PDU_132(o) == i & '00'O))) {setverdict(pass);}
  else {setverdict(fail);}
}

//ALIGN(left) for octetstring

type octetstring RAW_PDU_133
with { encode "RAW";
       variant "FIELDLENGTH(4)";
       variant "ALIGN (left)"
     };
external function enc_RAW_PDU_133(in RAW_PDU_133 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_133(in octetstring stream) return RAW_PDU_133 with { extension "prototype(convert) decode(RAW)" }

testcase TC_ALIGN_left_for_octetstring() runs on TempComp{
  const RAW_PDU_133 i := '123456'O
  const octetstring o := '00123456'O 
  
  if ((enc_RAW_PDU_133(i) == o)and((dec_RAW_PDU_133(o) == '00'O & i ))) {setverdict(pass);}
  else {setverdict(fail);}
}

// ALIGN(right) for bitstring

type bitstring RAW_PDU_134
with { encode "RAW";
       variant "FIELDLENGTH(16)";
       variant "ALIGN (right)"
     };

external function enc_RAW_PDU_134(in RAW_PDU_134 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_134(in octetstring stream) return RAW_PDU_134 with { extension "prototype(convert) decode(RAW)" }

testcase TC_ALIGN_right_for_bitstring() runs on TempComp{
  const RAW_PDU_134 i := '11111111'B
  const octetstring o := 'FF00'O
  
  if ((enc_RAW_PDU_134(i) == o)and((dec_RAW_PDU_134(o) == '00000000'B & i ))) {setverdict(pass);}
  else {setverdict(fail);}
}

// ALIGN(left) for bitstring

type bitstring RAW_PDU_135
with { encode "RAW";
       variant "FIELDLENGTH(16)";
       variant "ALIGN (left)"
     };

external function enc_RAW_PDU_135(in RAW_PDU_135 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_135(in octetstring stream) return RAW_PDU_135 with { extension "prototype(convert) decode(RAW)" }

testcase TC_ALIGN_left_for_bitstring() runs on TempComp{
  const RAW_PDU_135 i := '11111111'B
  const octetstring o := '00FF'O

  if ((enc_RAW_PDU_135(i) == o)and((dec_RAW_PDU_135(o) == i & '00000000'B ))) {setverdict(pass);}
  else {setverdict(fail);}
}

//======= Testing Compound types ======

// Test of  record with integer and octetstring

group RAW_group13{

type record RAW_PDU_136
{  integer       int ,
   octetstring   octstr }
with { variant (int) "FIELDLENGTH(8)" ;
       variant (octstr) "FIELDLENGTH(2)" } ;

}with{encode "RAW"}

external function enc_RAW_PDU_136(in RAW_PDU_136 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_136(in octetstring stream) return RAW_PDU_136 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_integer_and_octetstring() runs on TempComp{
  const RAW_PDU_136 
    i := { int :=              20 ,
    octstr :=      '1234'O   }

  const octetstring 	o := '141234'O

  if ((enc_RAW_PDU_136(i) == o)and((dec_RAW_PDU_136(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with default values in field
group RAW_group14{

type record RAW_PDU_137
{  integer       int ,
   octetstring   octstr }
with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" } ;

}with{encode "RAW"}

external function enc_RAW_PDU_137(in RAW_PDU_137 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_137(in octetstring stream) return RAW_PDU_137 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_default_values_in_field() runs on TempComp{
  const RAW_PDU_137 
    i := { int :=              20 ,
           octstr :=      '1234'O   }

  const octetstring 	o := '141234'O

  if ((enc_RAW_PDU_137(i) == o)and((dec_RAW_PDU_137(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with bitstring

group RAW_group15{

type record RAW_PDU_138
{  integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)"
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_138(in RAW_PDU_138 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_138(in octetstring stream) return RAW_PDU_138 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_bitstring() runs on TempComp{
  const RAW_PDU_138 
    i := { int :=              20 ,
      octstr :=      '1234'O ,
      bit6 :=      '111111'B ,
      bit2 :=          '00'B
    }

  const octetstring 	o := '1412343F'O

  if ((enc_RAW_PDU_138(i) == o)and((dec_RAW_PDU_138(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

//Test of  record with enumerated and fieldlength calculation

group RAW_group16{

type enumerated enum
{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
tenth }
with { variant ""};

type record RAW_PDU_139
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN    }

with {variant (int) "" ;
      variant (octstr) "FIELDLENGTH(2)" ;
      variant (bit6) "FIELDLENGTH(6)" ;
      variant (bit2) "FIELDLENGTH(2)" ;
      variant (enum1) "FIELDLENGTH(8)" ;
      variant (length1) "LENGTHTO(octN)" ;
      variant (octN) ""
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_139(in RAW_PDU_139 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_139(in octetstring stream) return RAW_PDU_139 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_enumerated_and_fieldlength_calculation() runs on TempComp{
  const RAW_PDU_139 
     i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O

         }



const octetstring 	o := '1412343F0A03123456'O


  if ((enc_RAW_PDU_139(i) == o)and((dec_RAW_PDU_139(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of record called from record

group RAW_encode1{

//type enumerated Enum2
//{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
//tenth }
//with { variant ""} ;


type record record1
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""
     }


type record RAW_PDU_140
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1    }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) ""
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_140(in RAW_PDU_140 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_140(in octetstring stream) return RAW_PDU_140 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_called_from_record() runs on TempComp{
  const RAW_PDU_140 
     i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O  ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     }

         }

  const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF'O

  if ((enc_RAW_PDU_140(i) == o)and((dec_RAW_PDU_140(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

//  Test of union called from record with CROSSTAG

group RAW_group17{

//type enumerated enum
//{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
//tenth }
//with { variant ""} ;


//type record record1
// { bitstring       bit1 ,
//   bitstring       bit3 ,
//   bitstring       bit4 ,
//   integer         int  ,
//   integer         length1 ,
//   octetstring     octN  }
//with { variant (bit1) "FIELDLENGTH(1)" ;
//       variant (bit3) "FIELDLENGTH(3)" ;
//       variant (bit4) "FIELDLENGTH(4)" ;
//       variant (int) "FIELDLENGTH(16)" ;
//       variant (length1) "LENGTHTO(octN)" ;
//       variant (octN) ""
//     }

type union optionalpart
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant (one) "" ;
       variant (two) "" ;
       variant (three) "" ;
       variant (four) "" ;
       variant (five) "" ;
     }

type record RAW_PDU_141
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart  opt_part ,
   octetstring   eop        }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) "" ;
       variant (id) "" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5       ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_141(in RAW_PDU_141 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_141(in octetstring stream) return RAW_PDU_141 with { extension "prototype(convert) decode(RAW)" }

testcase TC_union_called_from_record_with_CROSSTAG() runs on TempComp{
  const RAW_PDU_141 
     i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }

  const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O
  
if ((enc_RAW_PDU_141(i) == o)and((dec_RAW_PDU_141(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of union called from record with CROSSTAG, OTHERWISE

group RAW_group18{

//type enumerated enum
//{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
//tenth }
//with { variant ""} ;


//type record record1
// { bitstring       bit1 ,
//   bitstring       bit3 ,
//   bitstring       bit4 ,
//   integer         int  ,
//   integer         length1 ,
//   octetstring     octN  }
//with { variant (bit1) "FIELDLENGTH(1)" ;
//       variant (bit3) "FIELDLENGTH(3)" ;
//       variant (bit4) "FIELDLENGTH(4)" ;
//       variant (int) "FIELDLENGTH(16)" ;
//       variant (length1) "LENGTHTO(octN)" ;
//       variant (octN) ""
//     }



//type union optionalpart
//{ integer  one ,
// integer  two ,
// integer  three ,
// integer  four ,
// integer  five }
//with { variant (one) "" ;
//       variant (two) "" ;
//       variant (three) "" ;
//       variant (four) "" ;
//       variant (five) "" ;
//     }





type record RAW_PDU_142
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart  opt_part ,
   octetstring   eop        }

with { variant (int) "" ;
       variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (octN) ""  ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (rec1) "" ;
       variant (id) "" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   OTHERWISE      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_142(in RAW_PDU_142 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_142(in octetstring stream) return RAW_PDU_142 with { extension "prototype(convert) decode(RAW)" }

testcase TC_union_called_from_record_with_CROSSTAG_OTHERWISE() runs on TempComp{
  const RAW_PDU_142 
      i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }

  const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O

  if ((enc_RAW_PDU_142(i) == o)and((dec_RAW_PDU_142(o) == i))) {setverdict(pass);}
  else {setverdict(fail);}
}


// Test of record without specifying the default attributes for fields

group RAW_group19 {

//type enumerated enum
//{ zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
//tenth }
//with { variant ""} ;


type record record1_2
 { bitstring       bit1 ,
   bitstring       bit3 ,
   bitstring       bit4 ,
   integer         int  ,
   integer         length1 ,
   octetstring     octN  }
with { variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (bit4) "FIELDLENGTH(4)" ;
       variant (int) "FIELDLENGTH(16)" ;
       variant (length1) "LENGTHTO(octN)"
     }



type union optionalpart1
{ integer  one ,
 integer  two ,
 integer  three ,
 integer  four ,
 integer  five }
with { variant "" }


type record RAW_PDU_143
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1_2       rec1 ,
   integer       id ,
   integer       opt_part_ptr ,
   optionalpart1  opt_part ,
   octetstring   eop        }

with { variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_143(in RAW_PDU_143 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_143(in octetstring stream) return RAW_PDU_143 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_without_specifying_the_default_attributes_for_fields() runs on TempComp{

  const RAW_PDU_143
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   id :=                5 ,
           opt_part_ptr:=            1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }



const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF05010500'O

if ((enc_RAW_PDU_143(i) == o)and(dec_RAW_PDU_143(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}


// Test of record of called from record


group RAW_group20{

type record record2
 { octetstring       oct1 ,
   integer         length2 ,
   octetstring       octN  }
with { variant (oct1) "FIELDLENGTH(1)";
       variant (length2) "LENGTHTO(octN)"
     }

type record of record2 Rec2list
with { variant "" };

type record RAW_PDU_144
 { integer       length1 ,
   Rec2list      rec2list   }

with { variant (length1) "LENGTHTO(rec2list)"   } ;

}with{encode "RAW"}

external function enc_RAW_PDU_144(in RAW_PDU_144 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_144(in octetstring stream) return RAW_PDU_144 with { extension "prototype(convert) decode(RAW)" }


testcase TC_record_of_called_from_record() runs on TempComp{
  const RAW_PDU_144
    i := { length1:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     }    }
         }

  const octetstring 	o := '081202345612027890'O
 

  if ((enc_RAW_PDU_144(i) == o)and(dec_RAW_PDU_144(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}


// Test of set with TAG

group RAW_group21{

type record intrec
 { integer  tag ,
   integer  intfield }
with { variant ""} ;


type record octrec
 { integer  tag ,
   octetstring  octfield }
with { variant (octfield) "FIELDLENGTH(2)"} ;


type record bitrec
 { integer  tag ,
   bitstring  bit8field }
with { variant (bit8field) "FIELDLENGTH(8)"} ;



type set RAW_PDU_145
 { intrec       int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3     )"
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_145(in RAW_PDU_145 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_145(in octetstring stream) return RAW_PDU_145 with { extension "prototype(convert) decode(RAW)" }

testcase TC_set_with_TAG () runs on TempComp{

  const RAW_PDU_145
    i := {  octstr :=  { tag := 2 ,
	                octfield := '1234'O } ,
	    int :=   {  tag := 1 ,
                       intfield :=  15  } ,
	    bit8 :=   {  tag := 3 ,
	                bit8field :=   '11111111'B }
         }



  const octetstring 	o := '010F02123403FF'O


  if ((enc_RAW_PDU_145(i) == o)and(dec_RAW_PDU_145(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of union with TAG , first element called

group RAW_group22{

//type record intrec
// { integer  tag ,
//   integer  intfield }
//with { variant ""} ;


// type record octrec
//  { integer  tag ,
//    octetstring  octfield }
// with { variant (octfield) "FIELDLENGTH(2)"} ;


// type record bitrec
//  { integer  tag ,
//    bitstring  bit8field }
// with { variant (bit8field) "FIELDLENGTH(8)"} ;



type union RAW_PDU_146
 { intrec      int ,
   octrec   octstr ,
   bitrec     bit8  }

with { variant "TAG (
                      int ,      tag=1 ;
                      octstr ,   tag=2 ;
		      bit8 ,     tag=3     )"
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_146(in RAW_PDU_146 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_146(in octetstring stream) return RAW_PDU_146 with { extension "prototype(convert) decode(RAW)" }

testcase TC_union_with_TAG_first_element_called() runs on TempComp {
  const RAW_PDU_146
    i := { int :=   {  tag := 1 ,
                       intfield :=  15  }
         }

  const octetstring 	o := '010F'O

  if ((enc_RAW_PDU_146(i) == o)and(dec_RAW_PDU_146(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

// Test of union with TAG , second element called

//external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
//external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

// group RAW_group{
// 
// type record intrec
//  { integer  tag ,
//    integer  intfield }
// with { variant ""} ;
// 
// 
// type record octrec
//  { integer  tag ,
//    octetstring  octfield }
// with { variant (octfield) "FIELDLENGTH(2)"} ;
// 
// 
// type record bitrec
//  { integer  tag ,
//    bitstring  bit8field }
// with { variant (bit8field) "FIELDLENGTH(8)"} ;
// 
// 
// 
// type union RAW_PDU
//  { intrec      int ,
//    octrec   octstr ,
//    bitrec     bit8  }
// 
// with { variant "TAG (
//                       int ,      tag=1 ;
//                       octstr ,   tag=2 ;
// 		      bit8 ,     tag=3)"
//      } ;
// 
// }with{encode "RAW"}

testcase TC_union_with_TAG_second_element_called() runs on TempComp {
  const RAW_PDU_146
    i := {  octstr :=  { tag := 2 ,
	                octfield := '1234'O }
         }



  const octetstring 	o := '021234'O

  if ((enc_RAW_PDU_146(i) == o)and(dec_RAW_PDU_146(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

// Test of union with TAG , third element called

testcase TC_union_with_TAG_third_element_called() runs on TempComp {
  const RAW_PDU_146
    i := { bit8 :=   {  tag := 3 ,
	                bit8field :=   '11111111'B }
         }



  const octetstring 	o := '03FF'O


  if ((enc_RAW_PDU_146(i) == o)and(dec_RAW_PDU_146(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

// Test of union with TAG , third element called with OTHERWISE

group RAW_group23{

type union RAW_PDU_147
 { intrec      field1 ,
   octrec      field2 ,
   bitrec      field3}

with { variant "TAG (
                      field1,      tag=1 ;
                      field2,      tag=2 ;
		      field3,      OTHERWISE)"};

}with{encode "RAW"}

external function enc_RAW_PDU_147(in RAW_PDU_147 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_147(in octetstring stream) return RAW_PDU_147 with { extension "prototype(convert) decode(RAW)" }

testcase TC_union_with_TAG_third_element_called_with_OTHERWISE() runs on TempComp {
  const RAW_PDU_147
    i := { field3 :=   {  tag := 3 ,
	                bit8field :=   '11111111'B }
         }

  const octetstring 	o := '03FF'O


  if ((enc_RAW_PDU_147(i) == o)and(dec_RAW_PDU_147(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

//  Test of set of called from record

group RAW_group24{

// type record record2
//  { octetstring       oct1 ,
//    integer         length2 ,
//    octetstring       octN  }
// with { variant (oct1) "FIELDLENGTH(1)";
//        variant (length2) "LENGTHTO(octN)"
// 
//      }

type set of record2 Rec2list_1
with { variant "" };

type record RAW_PDU_148
 { integer       length1 ,
   Rec2list_1      rec2list   }

with { variant (length1) "LENGTHTO(rec2list)"   } ;

}with{encode "RAW"}

external function enc_RAW_PDU_148(in RAW_PDU_148 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_148(in octetstring stream) return RAW_PDU_148 with { extension "prototype(convert) decode(RAW)" }

testcase TC_set_of_called_from_record() runs on TempComp{

  const RAW_PDU_148
    i := { length1:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     }    }
         }


  const octetstring 	o := '081202345612027890'O
 
  if ((enc_RAW_PDU_148(i) == o)and(dec_RAW_PDU_148(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

// Test of record with optional field with PRESENCE

group RAW_group25{

// type enumerated enum
// { zero, first, second, third, fourth, fifth, sixth, seventh, eighth, nineth,
// tenth }
// with { variant ""} ;


// type record record1_2
//  { bitstring       bit1 ,
//    bitstring       bit3 ,
//    bitstring       bit4 ,
//    integer         int  ,
//    integer         length1 ,
//    octetstring     octN  }
// with { variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (bit4) "FIELDLENGTH(4)" ;
//        variant (int) "FIELDLENGTH(16)" ;
//        variant (length1) "LENGTHTO(octN)"
//      }


// type union optionalpart1
// { integer  one ,
//  integer  two ,
//  integer  three ,
//  integer  four ,
//  integer  five }
// with { variant "" }


// type record record2
//  { octetstring       oct1 ,
//    integer         length2 ,
//    octetstring       octN  }
// with { variant (oct1) "FIELDLENGTH(1)";
//        variant (length2) "LENGTHTO(octN)"
//      }
// 
// 
// type record of record2 Rec2list
// with { variant "" };

type record RAW_PDU_149
 { integer       int ,
   octetstring   octstr ,
   bitstring     bit6 ,
   bitstring     bit2 ,
   enum          enum1 ,
   integer       length1 ,
   octetstring   octN ,
   integer       length2 ,
   record1_2       rec1 ,
   integer       length3 ,
   Rec2list      rec2list ,
   integer       id ,
   integer       opt_part_ptr ,
   integer       presenceid ,
   optionalpart1  opt_part optional ,
   octetstring   eop   optional     }

with { variant (octstr) "FIELDLENGTH(2)" ;
       variant (bit6) "FIELDLENGTH(6)" ;
       variant (bit2) "FIELDLENGTH(2)" ;
       variant (enum1) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
       variant (length2) "LENGTHTO(rec1)" ;
       variant (length3) "LENGTHTO(rec2list)"
       variant (opt_part_ptr) "POINTERTO ( opt_part)";
       variant (opt_part) "PRESENCE (presenceid= 1)" ;
       variant (opt_part) "CROSSTAG  (
                                        one ,    id = 1 ;
                                        two ,    id = 2 ;
                                        three ,  id = 3 ;
                                        four ,   id = 4 ;
                                        five ,   id = 5      ) ";

       variant (eop) "FIELDLENGTH(1)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_149(in RAW_PDU_149 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_149(in octetstring stream) return RAW_PDU_149 with { extension "prototype(convert) decode(RAW)" }


testcase TC_record_with_optional_field_with_PRESENCE() runs on TempComp{

 const RAW_PDU_149
    i := { int :=              20 ,
           octstr :=      '1234'O ,
	   bit6 :=      '111111'B ,
	   bit2 :=          '00'B ,
	   enum1 :=         tenth ,
           length1:=            3 ,
           octN :=      '123456'O ,
           length2:=            7 ,
	   rec1 :=    {   bit1 :=      '1'B ,
	                  bit3 :=    '000'B ,
			  bit4 :=   '1111'B ,
			  int :=       4660 ,
			  length1 :=      3 ,
			  octN :=  'FFFFFF'O     } ,
	   length3:=            8 ,
	   rec2list :=  {  {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '3456'O     } ,
                           {  oct1 :=     '12'O ,
		  	      length2 :=      2 ,
			      octN :=   '7890'O     } }  ,
	   id :=                5 ,
           opt_part_ptr:=            2 ,
           presenceid := 1 ,
           opt_part :=  { five :=  5  } ,
	   eop :=             '00'O
         }

  const octetstring 	o := '1412343F0A0312345607F1341203FFFFFF0812023456120278900502010500'O

  if ((enc_RAW_PDU_149(i) == o)and(dec_RAW_PDU_149(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

// Test of  record with UNIT


group RAW_group26{

type integer INT1_1
with { variant "" } ;



type record RAW_PDU_150
{ INT1_1      length1 ,
  octetstring   octstr }
with { variant (length1) "LENGTHTO(octstr)" ;
       variant (length1) "UNIT(8)" } ;

}with{encode "RAW"}


external function enc_RAW_PDU_150(in RAW_PDU_150 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_150(in octetstring stream) return RAW_PDU_150 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_UNIT() runs on TempComp{
  const RAW_PDU_150
    i := { length1 :=           4   ,
           octstr :=      '12345678'O   }

  const octetstring 	o := '0412345678'O


  if ((enc_RAW_PDU_150(i) == o)and(dec_RAW_PDU_150(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with PTRUNIT

group RAW_group27{

type record RAW_PDU_151
{ integer      pointer1 ,
  integer      pointer2 ,
  integer      pointer3 ,
  octetstring   octstr1 ,
  octetstring   octstr2 ,
  octetstring   octstr3 }
with { variant (pointer1) "POINTERTO(octstr1)" ;
       variant (pointer1) "PTRUNIT(1)" ;
       variant (pointer2) "POINTERTO(octstr2)" ;
       variant (pointer3) "POINTERTO(octstr3)" ;
       variant (octstr1) "FIELDLENGTH(3)" ;
       variant (octstr2) "FIELDLENGTH(3)" ;
       variant (octstr3) "FIELDLENGTH(3)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_151(in RAW_PDU_151 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_151(in octetstring stream) return RAW_PDU_151 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_PTRUNIT() runs on TempComp{
  const RAW_PDU_151
    i := { pointer1 :=         24 ,
           pointer2 :=         5 ,
           pointer3 :=         7 ,
           octstr1 :=      '010203'O  ,
           octstr2 :=      '040506'O  ,
           octstr3 :=      '070809'O   }

  const octetstring 	o := '180507010203040506070809'O

  if ((enc_RAW_PDU_151(i) == o)and(dec_RAW_PDU_151(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  record with PTROFFSET



group RAW_group28{

type record RAW_PDU_152
{ integer      pointer1 ,
  integer      pointer2 ,
  integer      pointer3 ,
  octetstring   octstr1 ,
  octetstring   octstr2 ,
  octetstring   octstr3 }
with { variant (pointer1) "POINTERTO(octstr1)" ;
       variant (pointer1) "PTROFFSET(0)" ;
       variant (pointer2) "POINTERTO(octstr2)" ;
       variant (pointer3) "POINTERTO(octstr3)" ;
       variant (octstr1) "FIELDLENGTH(3)" ;
       variant (octstr2) "FIELDLENGTH(3)" ;
       variant (octstr3) "FIELDLENGTH(3)" ;
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_152(in RAW_PDU_152 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_152(in octetstring stream) return RAW_PDU_152 with { extension "prototype(convert) decode(RAW)" }

testcase TC_record_with_PTROFFSET() runs on TempComp{
  const RAW_PDU_152
    i := { pointer1 :=         3 ,
           pointer2 :=         5 ,
           pointer3 :=         7 ,
           octstr1 :=      '010203'O  ,
           octstr2 :=      '040506'O  ,
           octstr3 :=      '070809'O   }



  const octetstring 	o := '030507010203040506070809'O


  if ((enc_RAW_PDU_152(i) == o)and(dec_RAW_PDU_152(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  structured types - 1



group RAW_group29{

type record Rec1field
{ bitstring  bit7 ,
  bitstring  bit1 ,
  octetstring oct1 }
with { variant (bit7) "FIELDLENGTH (7)" ;
       variant (bit1) "FIELDLENGTH (1)" ;
       variant (oct1) "FIELDLENGTH (1)" ;
     };

type enumerated Enum1
{zero, first, second, third, fourth, fifth }
with { variant "FIELDLENGTH (8)" };


type record Rec3_1
{ integer  int ,
  octetstring octstr ,
  bitstring  bitstr   }
with { variant (octstr) "FIELDLENGTH (1)" ;
       variant (bitstr) "FIELDLENGTH (8)" ;
     };


type record of Rec3_1  Recof
with { variant "" };

type record Rec5
{ integer length1 ,
  octetstring octN  }
with { variant (length1) "LENGTHTO (octN)" };

type union Rec2content
{ Enum1   enum1 ,
  Recof   recof ,
  Rec5   rec5    }
with { variant "" };

type record Rec2data
{  octetstring     id ,
   integer       length1 ,
   octetstring    octN ,
   integer       length2 ,
   Rec2content   content  }
with { variant (id) "FIELDLENGTH (1)" ;
       variant (length1) "LENGTHTO (octN)" ;
       variant (length2) "LENGTHTO (content)" ;
       variant (content) "CROSSTAG (
                                    enum1 ,    id='01'O ;
                                    recof ,    id='02'O ;
                                    rec5 ,     id='03'O   ) "
      };

type set of Rec2data Rec2datas
      with { variant "" };



type record RAW_PDU_153
{ integer      length1 ,
  Rec1field    rec1field1 ,
  integer      length2 ,
  Rec1field    rec1field2 ,
  Rec2datas      datas  }
with { variant (length1) "LENGTHTO(rec1field1)" ;
       variant (length2) "LENGTHTO(rec1field2)"
     } ;

}with{encode "RAW"}

external function enc_RAW_PDU_153(in RAW_PDU_153 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_153(in octetstring stream) return RAW_PDU_153 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_1() runs on TempComp{
  const RAW_PDU_153
    i := {  length1 :=    2 ,
	    rec1field1 :=   { bit7 := '0000001'B ,
	                      bit1 := '1'B ,
	                      oct1:=  'FF'O } ,
	    length2 :=    2 ,
	    rec1field2 :=   { bit7 := '0000010'B ,
	                      bit1 := '1'B ,
	                      oct1:=  'FF'O } ,
            datas :={  { id := '01'O ,
	                 length1 :=   2 ,
			 octN :=  '1234'O ,
			 length2 :=   1 ,
			 content := { enum1 := fifth }    },
                       { id := '02'O ,
	                 length1 :=   2 ,
			 octN :=  '5678'O,
			 length2 :=   6 ,
			 content := { recof := { { int :=  1 ,
			                           octstr := 'FF'O ,
						   bitstr := '00000000'B  } ,
                                                 { int :=  2 ,
			                           octstr := 'FF'O ,
						   bitstr := '00000000'B    } } } } ,
                       { id := '03'O ,
	                 length1 :=   2 ,
			 octN :=  '9012'O,
			 length2 :=   6 ,
			 content := { rec5 := { length1 :=  5 ,
			                         octN := '1234567890'O  } } } } }



  const octetstring 	o := '0281FF0282FF010212340105020256780601FF0002FF000302901206051234567890'O

  

  if ((enc_RAW_PDU_153(i) == o)and(dec_RAW_PDU_153(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  structured types - 2

external function enc_RAW_PDU_154(in RAW_PDU_154 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_154(in octetstring stream) return RAW_PDU_154 with { extension "prototype(convert) decode(RAW)" }

group RAW_group30{

type octetstring end_of_optional_parameters_indicator
with { variant "FIELDLENGTH(1)"};

type integer pointer
with { variant "" };

// type integer INT1_1
// with { variant "" };

type record Rec1_1
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   INT1_1       length1 ,
   octetstring octN optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };



type record Rec2_1
{  bitstring   bit8 ,
   INT1_1     length1 ,
   octetstring octN optional    }
with { variant (bit8) "FIELDLENGTH(8)" ;
       variant (length1) "LENGTHTO(octN)" ;
     };


type record Rec3_2
{  bitstring   bit4 ,
   bitstring   bit1 ,
   bitstring   bit3 ,
   integer     int ,
   octetstring oct2 optional    }
with { variant (bit4) "FIELDLENGTH(4)" ;
       variant (bit1) "FIELDLENGTH(1)" ;
       variant (bit3) "FIELDLENGTH(3)" ;
       variant (oct2) "FIELDLENGTH(2)" ;
     };



type record Rec4
{  integer     int ,
   octetstring oct5 optional    }
with { variant (oct5) "FIELDLENGTH(5)"};




type union opt_par_union
{ octetstring  octstr ,
  Rec2_1         rec2 ,
  Rec3_2         rec3 ,
  Rec4         rec4       }
 with { variant (octstr) "FIELDLENGTH(2)" };


type record opt_par
{  integer   id ,
   integer   length1 ,
   opt_par_union  par  }
with { variant (length1) "LENGTHTO(par)" ;
       variant (par) "CROSSTAG(
                                octstr ,  id=1 ;
				rec2  ,   id=2 ;
				rec3  ,   id=3 ;
                                rec4  ,   id=4 ;  )"
     } ;


type set of opt_par optional_part
    with { variant "" };


type record RAW_PDU_154
{  pointer var_part_ptr,
   pointer opt_part_ptr,
   INT1_1 length1,
   Rec1_1 rec1 optional,
   optional_part opt_part optional,
   end_of_optional_parameters_indicator EndOP optional
} with { variant (var_part_ptr) "POINTERTO (length1)";
         variant (opt_part_ptr) "POINTERTO (opt_part)";
         variant (length1) "LENGTHTO (rec1)" };

}with{encode "RAW"}

testcase TC_structured_types_2() runs on TempComp{
  const RAW_PDU_154
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=   omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  }   } ,
	       EndOP := '00'O     }  // EndOP = omit


  const octetstring 	o := '0202000102FFFF00'O

  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=====================================
//Test of  structured types - 3
//=====================================

//group RAW_group31{

// type octetstring end_of_optional_parameters_indicator
// with { variant "FIELDLENGTH(1)"};
// 
// type integer pointer
// with { variant "" };

// type integer INT1_1
// with { variant "" };

// type record Rec1_1
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    INT1     length1 ,
//    octetstring octN optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };

// type record Rec2_1
// {  bitstring   bit8 ,
//    INT1_1     length1 ,
//    octetstring octN optional    }
// with { variant (bit8) "FIELDLENGTH(8)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };


// type record Rec3_2
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    integer     int ,
//    octetstring oct2 optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (oct2) "FIELDLENGTH(2)" ;
//      };

// type record Rec4
// {  integer     int ,
//    octetstring oct5 optional    }
// with { variant (oct5) "FIELDLENGTH(5)"};




// type union opt_par_union
// { octetstring  octstr ,
//   Rec2_1         rec2 ,
//   Rec3_2         rec3 ,
//   Rec4         rec4       }
//  with { variant (octstr) "FIELDLENGTH(2)" };


// type record opt_par
// {  integer   id ,
//    integer   length1 ,
//    opt_par_union  par  }
// with { variant (length1) "LENGTHTO(par)" ;
//        variant (par) "CROSSTAG(
//                                 octstr ,  id=1 ;
// 				rec2  ,   id=2 ;
// 				rec3  ,   id=3 ;
//                                 rec4  ,   id=4 ;  )"
//      } ;


// type set of opt_par optional_part
//     with { variant "" };


// type record RAW_PDU_155
// {  pointer var_part_ptr,
//    pointer opt_part_ptr,
//    INT1_1 length1,
//    Rec1_1 rec1 optional,
//    optional_part opt_part optional,
//    end_of_optional_parameters_indicator EndOP optional
// } with { variant (var_part_ptr) "POINTERTO (length1)";
//          variant (opt_part_ptr) "POINTERTO (opt_part)";
//          variant (length1) "LENGTHTO (rec1)" };

//}with{encode "RAW"}

//external function enc_RAW_PDU_155(in RAW_PDU_155 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
//external function dec_RAW_PDU_155(in octetstring stream) return RAW_PDU_155 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_3() runs on TempComp{
  const RAW_PDU_154
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      7 ,
	       length1 :=        5 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 3 ,
			    octN :=  '123456'O   } , // octN := omit
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  }   } ,
	       EndOP := '00'O     }  // EndOP = omit



  const octetstring 	o := '0207051F031234560102FFFF00'O

  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=====================================
// Test of  structured types - 4
//=====================================

//group RAW_group32{

// type octetstring end_of_optional_parameters_indicator
// with { variant "FIELDLENGTH(1)"};

// type integer pointer
// with { variant "" };

// type integer INT1_1
// with { variant "" };

// type record Rec1_1
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    INT1_1       length1 ,
//    octetstring octN optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };



// type record Rec2_1
// {  bitstring   bit8 ,
//    INT1_1     length1 ,
//    octetstring octN optional    }
// with { variant (bit8) "FIELDLENGTH(8)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };


// type record Rec3_2
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    integer     int ,
//    octetstring oct2 optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (oct2) "FIELDLENGTH(2)" ;
//      };

// type record Rec4
// {  integer     int ,
//    octetstring oct5 optional    }
// with { variant (oct5) "FIELDLENGTH(5)"};




// type union opt_par_union
// { octetstring  octstr ,
//   Rec2_1         rec2 ,
//   Rec3_2         rec3 ,
//   Rec4         rec4       }
//  with { variant (octstr) "FIELDLENGTH(2)" };


// type record opt_par
// {  integer   id ,
//    integer   length1 ,
//    opt_par_union  par  }
// with { variant (length1) "LENGTHTO(par)" ;
//        variant (par) "CROSSTAG(
//                                 octstr ,  id=1 ;
// 				rec2  ,   id=2 ;
// 				rec3  ,   id=3 ;
//                                 rec4  ,   id=4 ;  )"
//      } ;


// type set of opt_par optional_part
//     with { variant "" };


// type record RAW_PDU_156
// {  pointer var_part_ptr,
//    pointer opt_part_ptr,
//    INT1_1 length1,
//    Rec1_1 rec1 optional,
//    optional_part opt_part optional,
//    end_of_optional_parameters_indicator EndOP optional
// } with { variant (var_part_ptr) "POINTERTO (length1)";
//          variant (opt_part_ptr) "POINTERTO (opt_part)";
//          variant (length1) "LENGTHTO (rec1)" };
// 
// }with{encode "RAW"}

//external function enc_RAW_PDU_156(in RAW_PDU_156 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
//external function dec_RAW_PDU_156(in octetstring stream) return RAW_PDU_156 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_4() runs on TempComp{
  const RAW_PDU_154
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      7 ,
	       length1 :=        5 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 3 ,
			    octN :=  '123456'O   } , // octN := omit
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



  const octetstring 	o := '0207051F031234560102FFFF02070005123456789003048F0F123404060F123456789000'O

  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  structured types - 5

//external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
//external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

//group RAW_group{

// type octetstring end_of_optional_parameters_indicator
// with { variant "FIELDLENGTH(1)"};

// type integer pointer
// with { variant "" };

// type integer INT1
// with { variant "" };

// type record Rec1_1
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    INT1_1       length1 ,
//    octetstring octN optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };


// type record Rec2_1
// {  bitstring   bit8 ,
//    INT1_1     length1 ,
//    octetstring octN optional    }
// with { variant (bit8) "FIELDLENGTH(8)" ;
//        variant (length1) "LENGTHTO(octN)" ;
//      };


// type record Rec3_2
// {  bitstring   bit4 ,
//    bitstring   bit1 ,
//    bitstring   bit3 ,
//    integer     int ,
//    octetstring oct2 optional    }
// with { variant (bit4) "FIELDLENGTH(4)" ;
//        variant (bit1) "FIELDLENGTH(1)" ;
//        variant (bit3) "FIELDLENGTH(3)" ;
//        variant (oct2) "FIELDLENGTH(2)" ;
//      };



// type record Rec4
// {  integer     int ,
//    octetstring oct5 optional    }
// with { variant (oct5) "FIELDLENGTH(5)" };


// type union opt_par_union
// { octetstring  octstr ,
//   Rec2_1         rec2 ,
//   Rec3_2         rec3 ,
//   Rec4         rec4       }
//  with { variant (octstr) "FIELDLENGTH(2)" };


// type record opt_par
// {  integer   id ,
//    integer   length1 ,
//    opt_par_union  par  }
// with { variant (length1) "LENGTHTO(par)" ;
//        variant (par) "CROSSTAG(
//                                 octstr ,  id=1 ;
// 				rec2  ,   id=2 ;
// 				rec3  ,   id=3 ;
//                                 rec4  ,   id=4 ;  )"
//      } ;




// type set of opt_par optional_part
//     with { variant "" };


// type record RAW_PDU
// {  pointer var_part_ptr,
//    pointer opt_part_ptr,
//    INT1_1 length1,
//    Rec1_1 rec1 optional,
//    optional_part opt_part optional,
//    end_of_optional_parameters_indicator EndOP optional
// } with { variant (var_part_ptr) "POINTERTO (length1)";
//          variant (opt_part_ptr) "POINTERTO (opt_part)";
//          variant (length1) "LENGTHTO (rec1)" };
// 
// }with{encode "RAW"}

testcase TC_structured_types_5() runs on TempComp{
const RAW_PDU_154
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      4 ,
	       length1 :=        2 ,
	       rec1 :=   {  bit4 := '1111'B ,      // rec1 := omit
	                    bit1 := '1'B ,
			    bit3 := '000'B ,
			    length1 := 0 ,
			    octN :=  omit   } ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0204021F000102FFFF02070005123456789003048F0F123404060F123456789000'O


if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//==================================
// Test of  structured types - 6
//==================================

testcase TC_structured_types_6() runs on TempComp{
 
const RAW_PDU_154
	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   7 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   5 ,
					              octN := '1234567890'O } } } ,  //  octN := omit
			         { id :=   3 ,
	                           length1 :=   4 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := '1234'O } } } ,  //  oct2 := omit
			         { id :=   4 ,
	                           length1 :=   6 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := '1234567890'O } } } } ,  //  oct5 := omit
	       EndOP := '00'O     }  // EndOP = omit



const octetstring 	o := '0202000102FFFF02070005123456789003048F0F123404060F123456789000'O

if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//==================================
// Test of  structured types - 7
//==================================

testcase TC_structured_types_7() runs on TempComp{
 
  const RAW_PDU_154
      i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      2 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   {   { id :=   1 ,      // opt_part := omit
	                           length1 :=   2 ,
	                           par := { octstr := 'FFFF'O }  } ,
			         { id :=   2 ,
	                           length1 :=   2 ,
	                           par := { rec2:=  { bit8 := '00000000'B ,
				                      length1 :=   0 ,
					              octN := omit } } } ,
			         { id :=   3 ,
	                           length1 :=   2 ,
	                           par :=  { rec3 := { bit4 := '1111'B ,
				                       bit1 := '0'B ,
					               bit3 := '100'B ,
					               int :=   15 ,
					               oct2 := omit } } } ,
			         { id :=   4 ,
	                           length1 :=   1 ,
	                           par := { rec4:=  { int :=   15 ,
					              oct5 := omit } } } } ,
	       EndOP := '00'O     }  // EndOP = omit



  const octetstring 	o := '0202000102FFFF0202000003028F0F04010F00'O

  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}
//==================================
// Test of  structured types - 8
//==================================

testcase TC_structured_types_8() runs on TempComp{
 
  const RAW_PDU_154
 	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      0 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   omit ,
	       EndOP := '00'O     }  // EndOP = omit

  const octetstring 	o := '02000000'O
  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

//==================================
// Test of  structured types - 9
//==================================

testcase TC_structured_types_9() runs on TempComp{
 
  const RAW_PDU_154
 	i := { var_part_ptr :=      2 ,
	       opt_part_ptr :=      0 ,
	       length1 :=        0 ,
	       rec1 :=  omit ,
	       opt_part :=   omit ,
	       EndOP := omit     }



const octetstring 	o := '020000'O
  if ((enc_RAW_PDU_154(i) == o)and(dec_RAW_PDU_154(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}


//==================================
// Test of  structured types - 10
//==================================


group RAW_group32{

type integer Pointer
with { variant "" } ;

type octetstring EndOfOptionalPart
with { variant "FIELDLENGTH(1)" } ;

// type integer INT1_1
// with { variant "" } ;

// type bitstring BIT1_
// with { variant "FIELDLENGTH(1)" } ;
// 
// type bitstring BIT7_
// with { variant "FIELDLENGTH(7)" } ;
// 
// type octetstring OCT3_
// with { variant "FIELDLENGTH(3)" } ;

type hexstring HEX2
with { variant "FIELDLENGTH(2)" } ;

type enumerated  MessageType
  { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
   with { variant "FIELDLENGTH(8)" }


type enumerated  ParamName
  { name1(1),      name2(2),      name3(3),    name4(4) }
   with { variant "FIELDLENGTH(8)" }

type record Param1
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3_                octstr ,
  BIT7_                bit7 ,
  BIT1_                bit1 ,
  HEX2                hexstr ,
  INT1_1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param2
{ ParamName           paramName ,
  integer             paramLength ,
  OCT3_                octstr ,
  BIT7_                bit7 ,
  BIT1_                bit1 ,
  HEX2                hexstr ,
  INT1_1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param3
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3_                octstr ,
  BIT7_                bit7 ,
  BIT1_                bit1 ,
  HEX2                hexstr ,
  INT1_1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type record Param4
{ ParamName           paramName  ,
  integer             paramLength ,
  OCT3_                octstr ,
  BIT7_                bit7 ,
  BIT1_                bit1 ,
  HEX2                hexstr ,
  INT1_1                int }
with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }

type set Optional_part
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }



type record Elem1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU_155
{ Elem1      elem1 ,
  Elem2      elem2 ,
  Elem3      elem3 ,
  Elem4      elem4 ,
  Elem5      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

}with{encode "RAW"}


external function enc_RAW_PDU_155(in RAW_PDU_155 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_155(in octetstring stream) return RAW_PDU_155 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_10() runs on TempComp{
  const RAW_PDU_155
    i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 :=
		           { paramName :=         name2 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }     },
	        eop :=               '00'O            } }



  const octetstring 	o := '0112345680FF010207051234567890010612345680FF01020612345680FF01030612345680FF01040612345680FF0100'O

  if ((enc_RAW_PDU_155(i) == o)and(dec_RAW_PDU_155(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=======================================
// Test of  structured types - 11
//=======================================
testcase TC_structured_types_11() runs on TempComp{
  const RAW_PDU_155
    i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 := omit ,
		       param4 := omit ,
		       param3 := omit ,
		       param2 := omit       },
	        eop :=   omit         } }

  const octetstring 	o := '0112345680FF010207051234567890'O

  if ((enc_RAW_PDU_155(i) == o)and(dec_RAW_PDU_155(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=======================================
// Test of  structured types - 12
//=======================================
testcase TC_structured_types_12() runs on TempComp{
  const RAW_PDU_155
     i := { elem1 :=
             {  messageType :=       e1 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=               '00'O            } }



  const octetstring 	o := '0112345680FF010207051234567890010612345680FF01030612345680FF01040612345680FF0100'O


  if ((enc_RAW_PDU_155(i) == o)and(dec_RAW_PDU_155(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=======================================
// Test of  structured types - 13
//=======================================
testcase TC_structured_types_13() runs on TempComp{
  const RAW_PDU_155
    i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 := omit ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=    omit          } }



  const octetstring 	o := '0212345680FF010207051234567890010612345680FF01030612345680FF01'O
  
  if ((enc_RAW_PDU_155(i) == o)and(dec_RAW_PDU_155(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=======================================
// Test of  structured types - 14
//=======================================


group RAW_group33{

// type integer Pointer
// with { variant "" } ;
// 
// type octetstring EndOfOptionalPart
// with { variant "FIELDLENGTH(1)" } ;
// 
// type integer INT1
// with { variant "" } ;
// 
// type bitstring BIT1
// with { variant "FIELDLENGTH(1)" } ;
// 
// type bitstring BIT7
// with { variant "FIELDLENGTH(7)" } ;
// 
// type octetstring OCT3
// with { variant "FIELDLENGTH(3)" } ;
// 
// type hexstring HEX2
// with { variant "FIELDLENGTH(2)" } ;

// type enumerated  MessageType
//   { e1(1),      e2(2),      e3(3),    e4(4),    e5(5) }
//    with { variant "FIELDLENGTH(8)" }


// type enumerated  ParamName
//   { name1(1),      name2(2),      name3(3),    name4(4) }
//    with { variant "FIELDLENGTH(8)" }

// type record Param1
// { ParamName           paramName  ,
//   integer             paramLength ,
//   OCT3_                octstr ,
//   BIT7_                bit7 ,
//   BIT1_                bit1 ,
//   HEX2                hexstr ,
//   INT1_1                int }
// with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }
// 
// type record Param2
// { ParamName           paramName ,
//   integer             paramLength ,
//   OCT3                octstr ,
//   BIT7                bit7 ,
//   BIT1                bit1 ,
//   HEX2                hexstr ,
//   INT1                int }
// with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }
// 
// type record Param3
// { ParamName           paramName  ,
//   integer             paramLength ,
//   OCT3                octstr ,
//   BIT7                bit7 ,
//   BIT1                bit1 ,
//   HEX2                hexstr ,
//   INT1                int }
// with {variant (paramLength) "LENGTHTO(octstr , bit7 , bit1 , hexstr , int )" }


type record Field1
{ BIT1_    field2indic ,
  BIT7_    field2par   }
with { variant "" }



type union Field2
{ OCT3       present_ ,
  OCT3       absent   }
with { variant "" }



type record Param4_1
{ ParamName           paramName  ,
  integer             paramLength ,
  Field1                field1 ,
  Field2                field2 ,
  HEX2                hexstr ,
  INT1_1                int }
   with { variant (field2) "CROSSTAG(
                                      present_ ,       field1.field2indic = '1'B ;
				      absent ,        field1.field2indic = '0'B ; )" ;
          variant  (paramLength) "LENGTHTO(field1 , field2 , hexstr , int   )" }

type set Optional_part_1
{ Param1    param1 optional ,
  Param2    param2 optional ,
  Param3    param3 optional ,
  Param4_1    param4 optional   }
   with { variant "TAG (
                         param1 ,           paramName= name1;
                         param2 ,           paramName= name2;
                         param3 ,           paramName= name3;
                         param4 ,           paramName= name4  )"   }


type record Elem1_1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part_1      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem2_1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part_1      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem3_1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part_1      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem4_1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type record Elem5_1
{ MessageType        messageType ,
  OCT3_               octstr ,
  BIT7_               bit7 ,
  BIT1_               bit1 ,
  HEX2               hexstr ,
  INT1_1               int ,
  Pointer            pointer1 ,
  Pointer            pointer2 ,
  integer            length1 ,
  octetstring        octN ,
  Optional_part      opt_part   ,
  EndOfOptionalPart  eop   optional    }
   with { variant (pointer1) "POINTERTO(length1)";
          variant (pointer2) "POINTERTO(opt_part)" ;
	  variant (length1) "LENGTHTO(octN)"

            //Note, that optional part itself is mandatory but it may be empty!
        }


type union RAW_PDU_156
{ Elem1_1      elem1 ,
  Elem2_1      elem2 ,
  Elem3_1      elem3 ,
  Elem4_1      elem4 ,
  Elem5_1      elem5  }
with { variant "TAG (
                      elem1 ,       messageType = e1 ;
		      elem2 ,       messageType = e2 ;
		      elem3 ,       messageType = e3 ;
		      elem4 ,       messageType = e4 ;
		      elem5 ,       messageType = e5   ) "
     } ;

} with{encode "RAW"}

external function enc_RAW_PDU_156(in RAW_PDU_156 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_156(in octetstring stream) return RAW_PDU_156 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_14() runs on TempComp{
  const RAW_PDU_156
      i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     field1 :=
			          { field2indic :=  '1'B ,
				    field2par :=  '0000000'B  } ,
			     field2 :=
			          { present_ :=  'FFFFFF'O   } ,
			     hexstr :=            '12'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=   '00'O        } }

  const octetstring    o :='0212345680FF010207051234567890010612345680FF01030612345680FF01040601FFFFFF210100'O
  if ((enc_RAW_PDU_156(i) == o)and(dec_RAW_PDU_156(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

// Test of  structured types - 15

testcase TC_structured_types_15() runs on TempComp{
  const RAW_PDU_156
       i := { elem2 :=
             {  messageType :=       e2 ,
	        octstr :=            '123456'O ,
		bit7 :=              '0000000'B ,
		bit1 :=              '1'B ,
		hexstr :=            'FF'H ,
		int :=               1 ,
		pointer1 :=          2 ,
	        pointer2 :=          7 ,
	        length1 :=           5 ,
	        octN :=              '1234567890'O ,
	        opt_part :=
		     { param1 :=
		           { paramName :=         name1 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param4 :=
		           { paramName :=         name4 ,
			     paramLength :=       6 ,
	        	     field1 :=
			          { field2indic :=  '0'B ,
				    field2par :=  '0000000'B  } ,
			     field2 :=
			          { absent :=  '000000'O   } ,
			     hexstr :=            '12'H ,
			     int :=               1 }  ,
		       param3 :=
		           { paramName :=         name3 ,
			     paramLength :=       6 ,
	        	     octstr :=            '123456'O ,
			     bit7 :=              '0000000'B ,
			     bit1 :=              '1'B ,
			     hexstr :=            'FF'H ,
			     int :=               1 }  ,
		       param2 := omit       },
	        eop :=   '00'O        } }



const octetstring   o :='0212345680FF010207051234567890010612345680FF01030612345680FF01040600000000210100'O


  if ((enc_RAW_PDU_156(i) == o)and(dec_RAW_PDU_156(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
// Test of  structured types - 16
//=================================

group RAW_group34{

type bitstring BIT4_
with { variant "FIELDLENGTH(4)" } ;

type octetstring OCT2_
with { variant "FIELDLENGTH(2)" } ;

// type octetstring OCT3_
// with { variant "FIELDLENGTH(3)" } ;

type union Union2
{ OCT3_          field1 ,
  OCT2_          field2 ,
  OCT3_          field3 ,
  OCT2_          field4  }
 with { variant ""};


type union Union1
{ BIT4_          field1 ,
  BIT4_          field2  }
 with { variant ""};


type record RAW_PDU_157
{ BIT4_                id ,
  Union1             union1 ,
  Union2             union2  }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

external function enc_RAW_PDU_157(in RAW_PDU_157 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_157(in octetstring stream) return RAW_PDU_157 with { extension "prototype(convert) decode(RAW)" }

testcase TC_structured_types_16() runs on TempComp{
  const RAW_PDU_157
    i := { id :=   '0001'B ,
           union1 := { field1 := '0000'B } ,
	   union2 := { field1 := '123456'O } 	 }



  const octetstring   o :='01123456'O

  if ((enc_RAW_PDU_157(i) == o)and(dec_RAW_PDU_157(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
// Test of  structured types - 17
//=================================
testcase TC_structured_types_17() runs on TempComp{
  const RAW_PDU_157
     i := { id :=   '0111'B ,
           union1 := { field2 := '1111'B } ,
	   union2 := { field4 := '1234'O } 	 }



  const octetstring   o :='F71234'O

  if ((enc_RAW_PDU_157(i) == o)and(dec_RAW_PDU_157(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//===========================================================
//  Testing RAW update
//===========================================================

//=================================
//   Raw update test 1
//=================================


group RAW_group35{

// type bitstring BIT4
// with { variant "FIELDLENGTH(4)" } ;
// 
// type octetstring OCT2
// with { variant "FIELDLENGTH(2)" } ;

type union Union2_1
{ OCT2_          field1 ,
  OCT2_          field2 ,
  OCT2_          field3 ,
  OCT2_          field4  }
 with { variant ""};


// type union Union1
// { BIT4_          field1 ,
//   BIT4_          field2  }
//  with { variant ""};


type record RAW_PDU_158
{ Union2_1 union2 ,
  Union1 union1,
  BIT4_ id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

external function enc_RAW_PDU_158(in RAW_PDU_158 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_158(in octetstring stream) return RAW_PDU_158 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_1() runs on TempComp{
  const RAW_PDU_158
    i := {  union2 := { field4 := '1234'O } ,
            union1 := { field2 := '1111'B },
            id := '0111'B }

  const octetstring   o :='12347F'O
 
  if ((enc_RAW_PDU_158(i) == o )and(dec_RAW_PDU_158(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 2
//=================================
testcase TC_Raw_update_test_2() runs on TempComp{
  const RAW_PDU_158
    i := {  union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            id := '0001'B }

  const octetstring   o :='12341F'O

  if ((enc_RAW_PDU_158(i) == o )and(dec_RAW_PDU_158(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 3
//=================================
group RAW_group36{

type bitstring BIT8
with { variant "FIELDLENGTH(8)"};

type record RAW_PDU_159
{ Union2_1             union2 ,
  Union1 union1,
  BIT8 outfiller,
  BIT4_ id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

external function enc_RAW_PDU_159(in RAW_PDU_159 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_159(in octetstring stream) return RAW_PDU_159 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_3() runs on TempComp{

  const RAW_PDU_159
    i := {  union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            outfiller := '00001000'B,
            id := '0001'B }

  const octetstring   o :='12348F10'O

  if ((enc_RAW_PDU_159(i) == o )and(dec_RAW_PDU_159(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   Raw update test 4
//=================================
group RAW_group37{

type record RAW_PDU_160
{ Union2_1  union2 ,
  BIT8    outfiller,
  Union1  union1,
  BIT4_ id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}
 

external function enc_RAW_PDU_160(in RAW_PDU_160 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_160(in octetstring stream) return RAW_PDU_160 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_4() runs on TempComp{

  const RAW_PDU_160
     i := {  union2 := { field1 := '1234'O } ,
            outfiller := '00001000'B,
            union1 := { field1 := '1111'B },
            id := '0001'B }


  const octetstring   o :='1234081F'O

  if ((enc_RAW_PDU_160(i) == o )and(dec_RAW_PDU_160(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   Raw update test 5
//=================================
group RAW_group38{

type record RAW_PDU_161
{ BIT8    outfiller,
  Union2_1  union2 ,
  Union1  union1,
  BIT4_ id }
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

 
external function enc_RAW_PDU_161(in RAW_PDU_161 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_161(in octetstring stream) return RAW_PDU_161 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_5() runs on TempComp{

  const RAW_PDU_161
     i := {  outfiller := '00001000'B,
            union2 := { field1 := '1234'O } ,
            union1 := { field1 := '1111'B },
            id := '0001'B }


  const octetstring   o :='0812341F'O


  if ((enc_RAW_PDU_161(i) == o )and(dec_RAW_PDU_161(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 6
//=================================
group RAW_group39{

type record RAW_PDU_162
{ Union2_1  union2 ,
  BIT4_    id,
  Union1  union1}
   with { variant  (union2) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )" } ;

}with{encode "RAW"}

 
external function enc_RAW_PDU_162(in RAW_PDU_162 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_162(in octetstring stream) return RAW_PDU_162 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_6() runs on TempComp{

  const RAW_PDU_162
        i := {  union2 := { field1 := '1234'O },
            id := '0001'B,
            union1 := { field1 := '1111'B }
        }

  const octetstring   o :='1234F1'O


  if ((enc_RAW_PDU_162(i) == o )and(dec_RAW_PDU_162(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 7
//=================================
testcase TC_Raw_update_test_7() runs on TempComp{

  const RAW_PDU_162
     i := {  union2 := { field4 := '1234'O },
            id := '0101'B,
            union1 := { field2 := '1111'B }
             }


  const octetstring   o :='1234F5'O


  if ((enc_RAW_PDU_162(i) == o )and(dec_RAW_PDU_162(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 8
//=================================


group RAW_group40{

 
type record RAW_PDU_163
{ Union2_1  union2_1,
  Union2_1  union2_2,
  Union1  union1_1,
  BIT4_    id,
  Union1  union1_2,
  BIT4_    id2}
  with { variant  (union2_1) "CROSSTAG(
                                       field1 ,       id = '0001'B ;
				       field2 ,       id = '0010'B ;
				       field3 ,       id = '0011'B ;
				       field4 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   }    )"  ;
           variant  (union1_1) "CROSSTAG(
                                       field1 ,   {   id = '0001'B ,
				                      id = '0010'B ,
				                      id = '0011'B     } ;
				       field2 ,    {  id = '0100'B ,
				                      id = '0101'B ,
				                      id = '0111'B   })" ;
          variant (union2_2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)";
          variant (union1_2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          } ;

}with{encode "RAW"}

external function enc_RAW_PDU_163(in RAW_PDU_163 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_163(in octetstring stream) return RAW_PDU_163 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_8() runs on TempComp{

  const RAW_PDU_163
    i := {  union2_1 := {field1 := '1234'O },
            union2_2 := { field1 := '1234'O},
            union1_1 := { field1 := '1111'B },
            id := '0001'B,
            union1_2 := { field1 := '1111'B},
            id2 := '0001'B
             }


  const octetstring   o :='123412341F1F'O


  if ((enc_RAW_PDU_163(i) == o )and(dec_RAW_PDU_163(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   Raw update test 9 (OTHERWISE)
//=================================
group RAW_group41{

type union Union3
{ BIT4_ field1,
  OCT2_ field2
} with { variant ""};


type record RAW_PDU_164
{ BIT4_    id,
  Union3  union3,
  Union1  union1,
  BIT4_    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)"
          } ;

}with{encode "RAW"}

external function enc_RAW_PDU_164(in RAW_PDU_164 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_164(in octetstring stream) return RAW_PDU_164 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_9() runs on TempComp{

  const RAW_PDU_164
      i := {  id := '0001'B,
            union3 := {field1 := '1110'B},
            union1 := { field1 := '1111'B},
            id2 := '0001'B
             }

  const octetstring   o :='E11F'O

  if ((enc_RAW_PDU_164(i) == o )and(dec_RAW_PDU_164(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   Raw update test 10
//=================================
group RAW_group42{

group shortening{

type union Union2_2
{ OCT2          field1 ,
  OCT2          field2 };


} with {variant ""}

type record RAW_PDU_165
{ Union2_2  union2,
  BIT4_    id,
  Union3  union3,
  Union1  union1,
  BIT4_    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)";
          variant (union2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)"} ;

}with{encode "RAW"}

external function enc_RAW_PDU_165(in RAW_PDU_165 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_165(in octetstring stream) return RAW_PDU_165 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_10() runs on TempComp{

  const RAW_PDU_165
     i := {  union2 := {field1 := '1234'O},
            id := '0001'B,
            union3 := {field1 := '1110'B},
            union1 := { field1 := '1111'B},
            id2 := '0001'B
             }


  const octetstring   o :='1234E11F'O

  if ((enc_RAW_PDU_165(i) == o )and(dec_RAW_PDU_165(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   Raw update test 11
//=================================

group RAW_group43{

type record RAW_PDU_166
{ union {
   octetstring field1,
   octetstring field2
  }       union2,
  BIT4_    id,
  Union3  union3,
  Union1  union1,
  BIT4_    id2}
   with { variant (union1) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)" ;
          variant (union3) "CROSSTAG( field1, id = '0001'B;
                                      field2, OTHERWISE)";
          variant (union2) "CROSSTAG(field1 , id2 = '0001'B ;
                                      field2 , OTHERWISE)";
          variant (union2.field1, union2.field2) "FIELDLENGTH(2)"
          } ;

}with{encode "RAW"}

external function enc_RAW_PDU_166(in RAW_PDU_166 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_166(in octetstring stream) return RAW_PDU_166 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_11() runs on TempComp{
  const RAW_PDU_166
  i := {  union2 := {field1 := '1234'O},
    id := '0001'B,
    union3 := {field1 := '1110'B},
    union1 := { field1 := '1111'B},
    id2 := '0001'B
  }


  const octetstring   o :='1234E11F'O

  if ((enc_RAW_PDU_166(i) == o )and(dec_RAW_PDU_166(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 12
//=================================

group RAW_group44{

type union Code {
  integer field1,
  integer field2,
  integer field3
} with { variant "FIELDLENGTH(8)"};

type record RAW_PDU_167{
  Code code,
  bitstring ABCxxxxx,
  integer PDU_length,
  octetstring id optional
} with { variant (PDU_length) "FIELDLENGTH(16)";
  variant (ABCxxxxx) "FIELDLENGTH(8)";
  variant (id) "PRESENCE( {
       ABCxxxxx = '10000000'B,
       ABCxxxxx = '10100000'B} )";
  variant (code) "CROSSTAG(
      field1, id = omit;
      field2, id = '02'O;
      field3, id = '03'O; )"};

}with{encode "RAW"}

external function enc_RAW_PDU_167(in RAW_PDU_167 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_167(in octetstring stream) return RAW_PDU_167 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_12() runs on TempComp{
const RAW_PDU_167
    i := {  code := { field1 := 16},
            ABCxxxxx := '00000000'B,
            PDU_length := 16,
            id := omit }

const octetstring   o :='10001000'O

log ("enc_RAW_PDU_167(i)=     "  , enc_RAW_PDU_167(i)) ;
log ("dec_RAW_PDU_167(o)=     "  , dec_RAW_PDU_167(o)) ;

if ((enc_RAW_PDU_167(i) == o )and(dec_RAW_PDU_167(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 13
//=================================

testcase TC_Raw_update_test_13() runs on TempComp{
const RAW_PDU_167
     i := {  code := { field2 := 16},
            ABCxxxxx := '10000000'B,
            PDU_length := 16,
            id := '02'O }


const octetstring   o :='1080100002'O

log ("enc_RAW_PDU_167(i)=     "  , enc_RAW_PDU_167(i)) ;
log ("dec_RAW_PDU_167(o)=     "  , dec_RAW_PDU_167(o)) ;

if ((enc_RAW_PDU_167(i) == o )and(dec_RAW_PDU_167(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 14
//=================================

group RAW_group45{

type union Code_1 {
  enumerated {e1a (0), e1b (1), e1c (2)} E1,
  enumerated {e2a (1), e2b (2), e2c (3)} E2,
  enumerated {e3a (2), e3b (3), e3c (4), e3d (5)} E3
} with { variant (E1,E2,E3) "FIELDLENGTH(32)";
         variant (E1,E2,E3) "BYTEORDER(last)";
         variant (E1,E2,E3) "COMP(2scompl)"};

type integer UINT24 (0..16777215)
with {variant "FIELDLENGTH(24)";
      variant "BYTEORDER(last)"};

type enumerated Identifier {
  id_E1 (0),
  id_E2 (1),
  id_E3 (2)
} with {variant "FIELDLENGTH(32)";
        variant "BYTEORDER(last)";
        variant "COMP(2scompl)"};

type record RAW_PDU_168{
  Code_1 code,
  bitstring ABCxxxxx,
  UINT24 PDU_length,
  Identifier id optional,
  octetstring payload optional
  } with { variant (ABCxxxxx) "FIELDLENGTH(8)";
           variant (id) "PRESENCE( {
              ABCxxxxx = '10000000'B,
              ABCxxxxx = '10100000'B} )";
           variant (code) "CROSSTAG(
             E1, id = omit;
             E2, id = id_E2;
             E3, id = id_E3; )";
            variant (PDU_length) "LENGTHTO(code,ABCxxxxx,PDU_length,id,payload)"};

}with{encode "RAW"}

external function enc_RAW_PDU_168(in RAW_PDU_168 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_168(in octetstring stream) return RAW_PDU_168 with { extension "prototype(convert) decode(RAW)" }

testcase TC_Raw_update_test_14() runs on TempComp{
const RAW_PDU_168
    i := {  code := {E1 := e1c},
            ABCxxxxx := '00000000'B,
            PDU_length := 8,
            id := omit,
            payload := omit}


const octetstring   o :='0000000200000008'O ;

if ((enc_RAW_PDU_168(i) == o )and(dec_RAW_PDU_168(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

//=================================
//   Raw update test 15
//=================================

testcase TC_Raw_update_test_15() runs on TempComp{
const RAW_PDU_168
    i := {  code := {E2 := e2b},
            ABCxxxxx := '10000000'B,
            PDU_length := 14,
            id := id_E2,
            payload := 'ABCD'O}


const octetstring   o :='000000028000000E00000001ABCD'O ;
 
if ((enc_RAW_PDU_168(i) == o )and(dec_RAW_PDU_168(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   Raw update test 16
//=================================

testcase TC_Raw_update_test_16() runs on TempComp{
const RAW_PDU_168
    i := {  code := {E3 := e3b},
            ABCxxxxx := '10100000'B,
            PDU_length := 14,
            id := id_E3,
            payload := 'ABCD'O}


const octetstring   o :='00000003A000000E00000002ABCD'O ;

if ((enc_RAW_PDU_168(i) == o )and(dec_RAW_PDU_168(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}


//=================================
//   group raw attribute test 1
//=================================

group RAW_group46 {
  type integer RAW_PDU_169
} with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( 2scompl ) "
     };

external function enc_RAW_PDU_169(in RAW_PDU_169 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_169(in octetstring stream) return RAW_PDU_169 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_1() runs on TempComp{
  const RAW_PDU_169 		i := -2
  const octetstring 	o := 'FE'O


  if ((enc_RAW_PDU_169(i) == o)and(dec_RAW_PDU_169(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   group raw attribute test 2
//=================================

type integer RAW_PDU_170
with {  encode "RAW";
        variant  "BITORDERINOCTET(msb)";
        variant  "BYTEORDER(last)";
        variant  "ALIGN(left)";
        variant  "BITORDERINFIELD(msb)";
        variant  "COMP(signbit)";
        variant  "FIELDLENGTH(20)" };
external function enc_RAW_PDU_170(in RAW_PDU_170 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_170(in octetstring stream) return RAW_PDU_170 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_2() runs on TempComp{
const RAW_PDU_170 		i := -234
const octetstring 	o := 'EA0008'O

if ((enc_RAW_PDU_170(i) == o)and(dec_RAW_PDU_170(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   group raw attribute test 3
//=================================


group RAW_group47 {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        group grp_v4 {
          group grp_v5 {
            group grp_v6 {
              type integer RAW_PDU_171
            } with { variant "BITORDERINOCTET(msb)" }
          } with { variant "BYTEORDER(last)" }
        } with { variant "ALIGN(left)" }
      } with { variant "BITORDERINFIELD(msb)" }
    } with { variant "COMP(signbit)" }
  } with { variant "FIELDLENGTH(20)" }
} with { encode "RAW" }

external function enc_RAW_PDU_171(in RAW_PDU_171 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_171(in octetstring stream) return RAW_PDU_171 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_3() runs on TempComp{
  const RAW_PDU_171 		i := -234
  const octetstring 	o := 'EA0008'O


  if ((enc_RAW_PDU_171(i) == o)and(dec_RAW_PDU_171(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   group raw attribute test 4
//=================================


group RAW_group48 {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        group grp_v4 {
          group grp_v5 {
            group grp_v6 {
              type integer RAW_PDU_172
              with { variant "" }
            } with { variant "FIELDLENGTH(20)"; variant "COMP(signbit)" }
          } with { variant "BITORDERINFIELD(msb)"; variant "ALIGN(left)" }
        } with { variant "BITORDERINOCTET(msb)"; variant "BYTEORDER(last)" }
      } with { variant "BITORDERINOCTET(lsb)"; variant "BYTEORDER(first)" }
    } with { variant "FIELDLENGTH(10)"; variant "COMP(2scompl)" }
  } with { variant "BITORDERINFIELD(lsb)"; variant "ALIGN(right)" }

} with { encode "RAW" }

external function enc_RAW_PDU_172(in RAW_PDU_172 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_172(in octetstring stream) return RAW_PDU_172 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_4() runs on TempComp{
 
  const RAW_PDU_172 		i := -234
  const octetstring 	o := 'EA0008'O

  if ((enc_RAW_PDU_172(i) == o)and(dec_RAW_PDU_172(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}

//=================================
//   group raw attribute test 5
//=================================

group RAW_group49 {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        type integer RAW_PDU_173
        with { encode "RAW"; variant "" }
      } with { encode "RAW"; variant "FIELDLENGTH(20)"; variant "COMP(signbit)" }
    } with { encode "RAW"; variant "BITORDERINFIELD(msb)"; variant "ALIGN(left)" }
  } with { encode "RAW"; variant "BITORDERINOCTET(msb)"; variant "BYTEORDER(last)" }
} with { encode "RAW" }

external function enc_RAW_PDU_173(in RAW_PDU_173 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_173(in octetstring stream) return RAW_PDU_173 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_5() runs on TempComp{
  const RAW_PDU_173 		i := -234
  const octetstring 	o := 'EA0008'O

  if ((enc_RAW_PDU_173(i) == o)and(dec_RAW_PDU_173(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

//=================================
//   group raw attribute test 6
//=================================


group RAW_group50 {
  group grp_v1 {
    group grp_v2 {
      group grp_v3 {
        type integer RAW_PDU_174
        with { variant "" }
      } with { variant override "FIELDLENGTH(32)"  }
    } with { variant "FIELDLENGTH(10)" }
  } with { variant override "FIELDLENGTH(8)"; variant "FIELDLENGTH(2)" }
} with { encode "RAW" }

external function enc_RAW_PDU_174(in RAW_PDU_174 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_174(in octetstring stream) return RAW_PDU_174 with { extension "prototype(convert) decode(RAW)" }

testcase TC_group_raw_attribute_test_6() runs on TempComp{
  const RAW_PDU_174 		i := 255
  const octetstring 	o := 'FF'O

  if ((enc_RAW_PDU_174(i) == o)and(dec_RAW_PDU_174(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================
//   group raw attribute test 7
//=================================
external function enc_RAW_PDU_175(in RAW_PDU_175 pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU_175(in octetstring stream) return RAW_PDU_175 with { extension "prototype(convert) decode(RAW)" }

group RAW_group51{
  group grp1 {
    type record RAW_PDU_175
    { integer   int1 ,
      integer   int2 ,
      integer   int3 ,
      integer   int4   }
     with { variant (int1,int2,int3,int4) "FIELDLENGTH(4)";
            variant (int1,int2) "PADDING(yes)";
            variant (int3,int4) "PADDING(no)"; }
  } with { variant "FIELDLENGTH(3)" }
} with {encode "RAW" };

testcase TC_group_raw_attribute_test_7() runs on TempComp{
const RAW_PDU_175
	i := {  int1 :=    1  ,
	        int2 :=    2  ,
		int3 :=    3  ,
		int4 :=    4       }

const octetstring 	o := '010243'O

if ((enc_RAW_PDU_175(i) == o)and(dec_RAW_PDU_175(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

}

//=============================================================
//   Testing Enc/Dec functions of implicit message encoding 
//=============================================================
//=================================
//   Fast enc/dec function
//=================================


type integer RAW_PDU_176 with { encode "RAW"; variant "FIELDLENGTH(16)" };

external function enc_RAW_PDU_176(in RAW_PDU_176 pdu, out octetstring stream) with { extension "prototype(fast) encode(RAW)" }
external function dec_RAW_PDU_176(in octetstring stream, out RAW_PDU_176 pdu) with { extension "prototype(fast) decode(RAW)" }

testcase TC_Fast_enc_dec_function() runs on TempComp{
  const RAW_PDU_176 		i := 255
  const octetstring 	o := 'FF00'O

  var octetstring encoded_pdu;
  var RAW_PDU_176 decoded_pdu;

  enc_RAW_PDU_176(i, encoded_pdu);
  dec_RAW_PDU_176(o, decoded_pdu);

  if ( encoded_pdu == o and decoded_pdu == i ) {setverdict(pass);}
  else {setverdict(fail);}
}
//=================================================
//  Implicit message encoding: prototype backtrack
//=================================================

external function dec_RAW_PDU_177(in octetstring stream, out RAW_PDU_177 pdu) return integer
  with { extension "prototype(backtrack) decode(RAW) errorbehavior(ALL:WARNING)" }

type integer RAW_PDU_177 with { encode "RAW"; variant "FIELDLENGTH(16)" };


testcase TC_Backtrack_decode_function() runs on TempComp{
  const RAW_PDU_177 		i := 255
  const octetstring o1 := 'FF00'O
  const octetstring o2 := '12'O

  var RAW_PDU_177 decoded_pdu;
  var integer ret_val;

  ret_val := dec_RAW_PDU_177(o1, decoded_pdu);
  if (ret_val==0 and decoded_pdu==i) {setverdict(pass);}
  else {setverdict(fail);}

  ret_val := dec_RAW_PDU_177(o2, decoded_pdu);
  if (ret_val==1) {setverdict(pass);} else {setverdict(fail);}
}

//=================================================
//   Sliding decode function
//=================================================


type integer RAW_PDU_178 with { encode "RAW"; variant "FIELDLENGTH(16)" };

external function dec_RAW_PDU_178(inout octetstring stream, out RAW_PDU_178 pdu) return integer
  with { extension "prototype(sliding) decode(RAW) errorbehavior(ALL:WARNING)" }

testcase TC_Sliding_decode_function() runs on TempComp{
  const RAW_PDU_178 		i := 255
  var octetstring o1 := 'FF00'O;
  var octetstring o2 := '12'O;
  var RAW_PDU_178 decoded_pdu;
  var integer ret_val;

  ret_val := dec_RAW_PDU_178(o1, decoded_pdu);
  if (ret_val==0 and decoded_pdu==i) {setverdict(pass);}
  else {setverdict(fail);}

  ret_val := dec_RAW_PDU_178(o2, decoded_pdu);
  if (ret_val>0) {setverdict(pass);} else {setverdict(fail);}
}

//---------------------------------------------------------------------*
// Testing limits of codec
//---------------------------------------------------------------------*

//=================================================
//    Decoding empty octetstring to PDU
//=================================================

type record RAW_PDU_179 {
  integer f1,
  octetstring f2,
  boolean f3
} with { encode "RAW" variant "" }

external function decodePDU(inout octetstring os, out RAW_PDU_179 pdu) return integer
with { extension "prototype(sliding) decode(RAW) errorbehavior(ALL:WARNING)" }

testcase TC_Decoding_empty_octetstring() runs on TempComp{
  var octetstring os := ''O;
  var RAW_PDU_179 pdu;
  var integer ret_val := decodePDU(os, pdu);
  if (ret_val>0) {setverdict(pass);} else {setverdict(fail);}
}

//---------------------------------------------------------------------*
// Testing encoding/decoding of big integers
//---------------------------------------------------------------------*
//=================================================
//   encoding/decoding of big integer variables  
//=================================================

type integer myint2
with {
  variant "FIELDLENGTH(128)"
  variant "COMP(nosign)"
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" }

type integer myint3
with {
  variant "FIELDLENGTH(96)"
  variant "COMP(signbit)"
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" }

external function enc_raw3(in myint3 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw3(in octetstring r) return myint3
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function enc_raw2(in myint2 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw2(in octetstring r) return myint2
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }

testcase TC_encoding_decoding_of_big_integers() runs on TempComp{
  var myint3 v1 := -4294967296
  var myint3 v2 := -2147483647
  var myint3 v3 := 34359738368
  var myint3 v4 := 4398046511104
  var myint3 v5 := -140737488355328
  var myint3 v6 := 4294967296
  var myint3 v7 := 4294967295
  var myint3 v8 := -4294967295
  var myint3 v9 := 4294967297
  var myint3 v10 := -4294967297
  var myint3 v11 := 2147483647
  var myint3 v12 := -2147483648
  var myint3 v13 := 2147483648
  var myint3 v14 := -2147483649
  var myint3 v15 := 2147483649
  var myint2 v16 := -4294967296
  var myint2 v17 := 2147483647
  var myint2 v18 := 34359738368
  var myint2 v19 := 4398046511104
  var octetstring o
  o := enc_raw3(v1);if (v1 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v2);if (v2 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v3);if (v3 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v4);if (v4 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(-140737488355328);if (v5 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v6);if (v6 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v7);if (v7 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v8);if (v8 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v9);if (v9 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v10);if (v10 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v11);if (v11 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v12);if (v12 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v13);if (v13 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw3(v14);if (v14 == dec_raw3(o)) {setverdict(pass)} else {setverdict(fail)}
} 
//=================================================
// Encoding/decoding records with big integer fields
//=================================================
 
external function enc_raw(in rec_raw1 r) return octetstring
  with { extension "encode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
external function dec_raw(in octetstring r) return rec_raw1
  with { extension "decode(RAW) prototype(convert) errorbehavior(ALL:WARNING)" }
  
type integer myint1
with {
  variant "FIELDLENGTH(256)"
  variant "COMP(2scompl)" 
  variant "BITORDERINFIELD(lsb)"
  variant "PADDING(dword32)"
  encode "RAW" } // The script eats the trailing '}' in a new line.

type record rec_raw1 {
  myint1 int1,
  myint1 int2
} with { variant "" encode "RAW" }

 
testcase TC_encoding_decoding_records_with_big_integer_fields() runs on TempComp{
  var rec_raw1 myrec1 := {int1 := -12345678910111213141516, int2 := -3}
  var rec_raw1 myrec2 := {int1 := -11111111111111111111111, int2 := -11111111111111111111111}
  var rec_raw1 myrec3 := {int1 := -2147483648, int2 := -4294967296}
  var rec_raw1 myrec4 := {int1 := 2147483648, int2 := -4294967296}
  var rec_raw1 myrec5 := {int1 := -2147483649, int2 := 2147483649}
  var rec_raw1 myrec6 := {int1 := -1234, int2 := -4321}
  var octetstring o
  o := enc_raw(myrec1);if (myrec1 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec2);if (myrec2 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec3);if (myrec3 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec4);if (myrec4 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec5);if (myrec5 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
  o := enc_raw(myrec6);if (myrec6 == dec_raw(o)) {setverdict(pass)} else {setverdict(fail)}
}

//=================================================
//  Multiple optional fields (R8G FOA bug)
//=================================================

external function enc_PDU_GTPCv2(in PDU_GTPCv2 pdu) return octetstring
with { extension "prototype(convert)" extension "encode(RAW)" }

external function dec_PDU_GTPCv2(in octetstring stream) return PDU_GTPCv2
with { extension "prototype(convert)" extension "decode(RAW)" }

type bitstring BIT5 length(5) with { encode "RAW"  variant "FIELDLENGTH(5)" };

type octetstring OCT1_ length(1) with { encode "RAW"  variant "FIELDLENGTH(1)" };
type octetstring OCT4 length(4) with { encode "RAW"  variant "FIELDLENGTH(4)" };
type integer LIN1 (0..255) with { encode "RAW"  variant "FIELDLENGTH(8)" };

type integer LIN2_BO_LAST (0..65535) with { encode "RAW"  variant "FIELDLENGTH(16), COMP(nosign), BYTEORDER(last)" };

type record Cause {
    OCT1_             elementIdentifier, //dec 2, '02'O  
    LIN2_BO_LAST      lengthIndicator,
    BIT4              instance,
    BIT4              spare,
    OCT1_             causeValue,
    BIT1              cS,
    BIT1              bCE,
    BIT1              pCE,
    BIT5              spare2,
    OCT1_             typeOfOffendingIE optional,
    LIN2_BO_LAST      lengthIndicator2 optional,
    BIT4              instanceOfOffendingIE optional,
    BIT4              spare3 optional
} with { encode "RAW" 
    variant "PRESENCE (elementIdentifier = '02'O; )" 
    variant (lengthIndicator) "LENGTHTO(causeValue,cS,bCE,pCE,spare2,typeOfOffendingIE,
    lengthIndicator2,instanceOfOffendingIE,spare3 )" };

type record Recovery {
    OCT1_              elementIdentifier,  // dec 3, '03'O 
    LIN2_BO_LAST      lengthIndicator,
    BIT4              instance,
    BIT4              spare,
    integer           recoveryValue
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(recoveryValue)"
    variant "PRESENCE (elementIdentifier = '03'O; )" }; 

type set of  ProtocolID_or_ContainerID   ProtocolIDs_and_ContainerIDs;

type record ProtocolID_or_ContainerID {
    OCT2               protocolID_or_ContainerID,
    LIN1               lengthIndicator,
    octetstring        protID_orContID_Contents
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO (protID_orContID_Contents)"};

type record ProtocolConfigOptions {
    OCT1_                         elementIdentifier, // dec 78 '4E'O;
    LIN2_BO_LAST                 lengthIndicator,
    BIT4                         instance,
    BIT4                         spare,
    BIT3                         configProtocol,
    BIT4                         spare2,  //'0000'B
    BIT1                         extensionField,   //'1'B
    ProtocolIDs_and_ContainerIDs protocolIDs_and_ContainerIDs optional
} with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(configProtocol,spare2,extensionField,protocolIDs_and_ContainerIDs)"
    variant "PRESENCE (elementIdentifier = '4E'O; )" };

type record PrivateExtension {
    OCT1_                         elementIdentifier, // dec 255, 'FF'O
    LIN2_BO_LAST                 lengthIndicator,
    BIT4                         instance,
    BIT4                         spare,
    integer                      enterpriseID,
    octetstring                  proprietartyValue 
}  with { encode "RAW" 
    variant (lengthIndicator) "LENGTHTO(enterpriseID,proprietartyValue)"; 
    variant "PRESENCE (elementIdentifier = 'FF'O;)"; };

type set DeleteSessionResponse {
    Cause                                   cause,
    Recovery                                recovery optional,
    ProtocolConfigOptions                   protocolConfigOptions optional, 
    PrivateExtension                        privateExtension optional };

type union GTPCv2_PDUs {
    DeleteSessionResponse                        deleteSessionResponse };

type record PDU_GTPCv2 {
    BIT3                           spare,   //0 
    BIT1                           t_Bit,
    BIT1                           p_Bit,
    BIT3                           version,  //'010'B
    OCT1_                           messageType,
    LIN2_BO_LAST                   lengthf, 
    OCT4                           tEID optional,
    OCT3                           sequenceNumber,
    OCT1_                           spare3, // 0
    GTPCv2_PDUs                    gtpcv2_pdu,
    PDU_GTPCv2                     piggybackPDU_GTPCv2 optional
}  with { encode "RAW" 
    variant (tEID) "PRESENCE(t_Bit = '1'B)";
    variant (piggybackPDU_GTPCv2) "PRESENCE(p_Bit = '1'B)";   
    variant (lengthf) "LENGTHTO(tEID,sequenceNumber,spare3,gtpcv2_pdu)";
    variant (gtpcv2_pdu) "CROSSTAG(
    deleteSessionResponse,                             messageType = '25'O;  //37
    )"; };

testcase TC_Multiple_optional_fields() runs on TempComp{
  var PDU_GTPCv2 vl_temp := dec_PDU_GTPCv2( '48250013800000000249BF000200020010000300010011'O );
  setverdict(pass);
}

//===========================================
//  CONTROL PART
//===========================================
control {
  execute (TC_FIELDLENGTH_16_for_integer());
  execute (TC_FIELDLENGTH_8_for_integer());
  execute (TC_FIELDLENGTH_4_for_integer());
  execute (TC_FIELDLENGTH_16_for_integer_2());
  execute (TC_FIELDLENGTH_32_for_integer_1_bit_long());
  execute (TC_Default_FIELDLENGTH_for_integer());
  execute (TC_FIELDLENGTH_8_for_bitstring());
  execute (TC_FIELDLENGTH_8_for_bitstring_4_bits_long());
  execute (TC_FIELDLENGTH_4_for_bitstring());
  execute (TC_FIELDLENGTH_16_for_bitstring());
  execute (TC_FIELDLENGTH_24_for_bitstring());
  execute (TC_FIELDLENGTH_0_for_bitstring());
  execute (TC_DEFAULT_FIELDLENGTH_for_bitstring());
  execute (TC_FIELDLENGTH_32_for_bitstring_4_bits_long());
  execute (TC_FIELDLENGTH_1_for_octetstring());
  execute (TC_FIELDLENGTH_2_for_octetstring());
  execute (TC_FIELDLENGTH_2_and_BYTEORDER_first_for_octetstring());
  execute (TC_FIELDLENGTH_2_and_BYTEORDER_last_for_octetstring());
  execute (TC_FIELDLENGTH_4_and_BYTEORDER_first_for_octetstring());
  execute (TC_FIELDLENGTH_4_for_octetstring_3_octets_long());
  execute (TC_FIELDLENGTH_5_for_octetstring_2_octets_long());
  execute (TC_FIELDLENGTH_4_and_BYTEORDER_last_for_octetstring());
  execute (TC_FIELDLENGTH_4_and_BYTEORDER_last_for_octetstring_3_octets_long());
  execute (TC_Default_FIELDLENGTH_for_octetstring());
  execute (TC_FIELDLENGTH_0_for_octetstring());
  execute (TC_FIELDLENGTH_4_for_hexstring());
  execute (TC_FIELDLENGTH_8_for_hexstring());
  execute (TC_DEFAULT_FIELDLENGTH_for_hexstring());
  execute (TC_FIELDLENGTH_0_for_hexstring());
  execute (TC_FIELDLENGTH_12_for_hexstring_2_hex_long());
  execute (TC_FIELDLENGTH_4_for_enumerated());
  execute (TC_FIELDLENGTH_32_for_enumerated());
  execute (TC_Default_FIELDLENGTH_for_enumerated());
  execute (TC_FIELDLENGTH_with_length_restriction_bitstring());
  execute (TC_FIELDLENGTH_with_length_restriction_hexstring());
  execute (TC_FIELDLENGTH_with_length_restriction_octetstring());
  execute (TC_FIELDLENGTH_with_length_restriction_record());
  execute (TC_FIELDLENGTH_with_length_restriction_record_of());
  execute (TC_FIELDLENGTH_with_length_restriction_set());
  execute (TC_FIELDLENGTH_with_length_restriction_set_of());
  execute (TC_FIELDLENGTH_with_length_restriction_and_align_bitstring());
  execute (TC_FIELDLENGTH_with_length_restriction_and_align_hexstring());
  execute (TC_FIELDLENGTH_with_length_restriction_and_align_octetstring());
  execute (TC_BYTEORDER_first_for_integer_0());
  execute (TC_BYTEORDER_first_for_integer_1());
  execute (TC_BYTEORDER_first_for_integer_18());
  execute (TC_BYTEORDER_first_and_fieldlength_8_for_integer());
  execute (TC_BYTEORDER_first_and_fieldlength_16_for_integer());
  execute (TC_BYTEORDER_last_for_integer_0());
  execute (TC_BYTEORDER_last_for_integer_1());
  execute (TC_BYTEORDER_last_for_integer_18());
  execute (TC_BYTEORDER_last_and_fieldlength_8_for_integer());
  execute (TC_BYTEORDER_last_and_fieldlength_16_for_integer());
  execute (TC_BYTEORDER_first_for_bitstring());
  execute (TC_BYTEORDER_last_for_bitstring());
  execute (TC_BYTEORDER_first_for_octetstring());
  execute (TC_BYTEORDER_last_for_octetstring());
  execute (TC_BYTEORDER_first_for_enumerated());
  execute (TC_BYTEORDER_last_for_enumerated());
  execute (TC_BYTEORDER_first_for_hexstring());
  execute (TC_BYTEORDER_last_for_hexstring());
  execute(TC_BITORDERINFIELD_lsb_for_integer_8());
  execute(TC_BITORDERINFIELD_msb_for_integer_8());
  execute(TC_BITORDERINFIELD_lsb_for_integer_16());
  execute(TC_BITORDERINFIELD_msb_for_integer_16());
  execute(TC_BITORDERINFIELD_lsb_for_octetstring_1());
  execute(TC_BITORDERINFIELD_msb_for_octetstring_1());
  execute(TC_BITORDERINFIELD_lsb_for_octetstring_2());
  execute(TC_BITORDERINFIELD_msb_for_octetstring_2());
  execute(TC_BITORDERINFIELD_lsb_for_bitstring_8());
  execute(TC_BITORDERINFIELD_msb_for_bitstring_8()); 
  execute(TC_BITORDERINFIELD_lsb_for_bitstring_16());
  execute(TC_BITORDERINFIELD_msb_for_bitstring_16()); 
  execute(TC_BITORDERINFIELD_lsb_for_enumerated_4());
  execute(TC_BITORDERINFIELD_msb_for_enumerated_8());
  execute(TC_BITORDERINFIELD_lsb_for_hexstring()); 
  execute(TC_BITORDERINFIELD_msb_for_hexstring());
  execute(TC_BITORDERINOCTET_lsb_for_integer_8());
  execute(TC_BITORDERINOCTET_msb_for_integer_8());
  execute(TC_BITORDERINOCTET_lsb_for_integer_16());
  execute(TC_BITORDERINOCTET_msb_for_integer_16());
  execute(TC_BITORDERINOCTET_lsb_for_octetstring_1());
  execute(TC_BITORDERINOCTET_msb_for_octetstring_1());
  execute(TC_BITORDERINOCTET_lsb_for_octetstring_2());
  execute(TC_BITORDERINOCTET_msb_for_octetstring_2()); 
  execute(TC_BITORDERINOCTET_lsb_for_bitstring_8()); 
  execute(TC_BITORDERINOCTET_msb_for_bitstring_8());
  execute(TC_BITORDERINOCTET_lsb_for_bitstring_16());
  execute(TC_BITORDERINOCTET_msb_for_bitstring_16());
  execute(TC_BITORDERINOCTET_lsb_for_enumerated());
  execute(TC_BITORDERINOCTET_msb_for_enumerated());         
  execute(TC_BITORDERINOCTET_lsb_for_hexstring());
  execute(TC_BITORDERINOCTET_msb_for_hexstring());
  execute(TC_COMP_nosign_for_positive_integer_8());
  execute(TC_COMP_signbit_for_positive_integer_8());
  execute(TC_COMP_signbit_for_negative_integer_8()); 
  execute(TC_COMP_2scompl_for_positive_integer_8());
  execute(TC_COMP_2scompl_for_negative_integer_8());
  execute(TC_PADDING_for_integer()); //100
  execute(TC_PADDING_for_bitstring());
  execute(TC_PADDING_for_enumerated());
  execute(TC_PADDING_for_hexstring());
  execute(TC_PREPADDING_yes_for_bitstring());
  execute(TC_PREPADDING_yes_for_hexstring());
  execute(TC_PREPADDING_word16_for_octetstring());
  execute(TC_PREPADDING_word16_for_record_of());
  execute(TC_PREPADDING_dword32_for_set_of());
  execute(TC_PREPADDING_dword32_for_record());
  execute(TC_PREPADDING_word16_for_set());
  execute(TC_PREPADDING_word16_for_union());
  execute(TC_PADDING_PATTERN_for_record_of());
  execute(TC_PADDING_PATTERN_for_set_of());
  execute(TC_PADDING_PATTERN_for_record());
  execute(TC_PADDING_PATTERN_for_set());
  execute(TC_PADDING_PATTERN_for_union());
  execute(TC_PADDALL_with_PADDING_Attribute_record());
  execute(TC_PADDALL_with_PADDING_Attribute_set());
  execute(TC_PADDALL_with_PREPADDING_Attribute_record());
  execute(TC_PADDALL_with_PREPADDING_Attribute_set());
  execute(TC_PTROFFSET_is_set_to_default_base());//120
  execute(TC_PTROFFSET_is_set_to_the_beginning_of_record());
  execute(TC_PTROFFSET_is_set_to_data_field());
  execute(TC_HEXORDER_low_for_hexstring());
  execute(TC_HEXORDER_high_for_hexstring());
  execute(TC_EXTENSION_BIT_no_for_octetstring());
  execute(TC_EXTENSION_BIT_yes_for_octetstring());
  execute(TC_EXTENSION_BIT_reverse_for_octetstring());
  execute(TC_EXTENSION_BIT_yes_for_record_of_octetstring());
  execute(TC_EXTENSION_BIT_no_for_record_of_octetstring());
  execute(TC_EXTENSION_BIT_yes_for_record_of_bitstring());
  execute(TC_EXTENSION_BIT_reverse_for_record_of_bitstring());
  execute(TC_EXTENSION_BIT_yes_for_set_of_bitstring());
  execute(TC_EXTENSION_BIT_reverse_for_set_of_bitstring());
  execute(TC_EXTENSION_BIT_yes_for_set_of_hexstring());
  execute(TC_EXTENSION_BIT_reverse_for_set_of_hexstring());
  execute(TC_record_with_EXTENSION_BIT_1());
  execute(TC_record_with_EXTENSION_BIT_2());
  execute(TC_record_with_EXTENSION_BIT_3());
  execute(TC_record_with_EXTENSION_BIT_4());
  execute(TC_record_with_EXTENSION_BIT_5());
  execute(TC_record_with_EXTENSION_BIT_6());
  execute(TC_record_with_EXTENSION_BIT_7());
  execute(TC_record_with_EXTENSION_BIT_8());
  execute(TC_record_with_EXTENSION_BIT_9());
  execute(TC_EXTENSION_BIT_GROUP_no());
  execute(TC_EXTENSION_BIT_GROUP_yes());
  execute(TC_EXTENSION_BIT_GROUP_yes_2_groups());
  execute(TC_EXTENSION_BIT_GROUP_yes_reverse_2_groups());
  execute(TC_ALIGN_right_for_octetstring());
  execute(TC_ALIGN_left_for_octetstring());
  execute(TC_ALIGN_right_for_bitstring());
  execute(TC_ALIGN_left_for_bitstring());
  execute(TC_record_with_integer_and_octetstring());
  execute(TC_record_with_default_values_in_field());
  execute(TC_record_with_bitstring());
  execute(TC_record_with_enumerated_and_fieldlength_calculation());
  execute(TC_record_called_from_record());
  execute(TC_union_called_from_record_with_CROSSTAG());
  execute(TC_union_called_from_record_with_CROSSTAG_OTHERWISE());
  execute(TC_record_without_specifying_the_default_attributes_for_fields());
  execute(TC_record_of_called_from_record());
  execute(TC_set_with_TAG());
  execute(TC_union_with_TAG_first_element_called());
  execute(TC_union_with_TAG_second_element_called());
  execute(TC_union_with_TAG_third_element_called());
  execute(TC_union_with_TAG_third_element_called_with_OTHERWISE());
  execute(TC_set_of_called_from_record());
  execute(TC_record_with_optional_field_with_PRESENCE());
  execute(TC_record_with_UNIT());
  execute(TC_record_with_PTRUNIT());
  execute(TC_record_with_PTROFFSET());
  execute(TC_structured_types_1());
  execute(TC_structured_types_2());
  execute(TC_structured_types_3());
  execute(TC_structured_types_4());
  execute(TC_structured_types_5());
  execute(TC_structured_types_6());
  execute(TC_structured_types_7());
  execute(TC_structured_types_8());
  execute(TC_structured_types_9());
  execute(TC_structured_types_10());
  execute(TC_structured_types_11());
  execute(TC_structured_types_12());
  execute(TC_structured_types_13());
  execute(TC_structured_types_14());
  execute(TC_structured_types_15());
  execute(TC_structured_types_16());
  execute(TC_structured_types_17());
  execute(TC_Raw_update_test_1());
  execute(TC_Raw_update_test_2());
  execute(TC_Raw_update_test_3());
  execute(TC_Raw_update_test_4());
  execute(TC_Raw_update_test_5());
  execute(TC_Raw_update_test_6());
  execute(TC_Raw_update_test_7());
  execute(TC_Raw_update_test_8());
  execute(TC_Raw_update_test_9());
  execute(TC_Raw_update_test_10());
  execute(TC_Raw_update_test_11());
  execute(TC_Raw_update_test_12());
  execute(TC_Raw_update_test_13());
  execute(TC_Raw_update_test_14());
  execute(TC_Raw_update_test_15());
  execute(TC_Raw_update_test_16());
  execute(TC_group_raw_attribute_test_1());
  execute(TC_group_raw_attribute_test_2()); 
  execute(TC_group_raw_attribute_test_3());
  execute(TC_group_raw_attribute_test_4());
  execute(TC_group_raw_attribute_test_5());
  execute(TC_group_raw_attribute_test_6());
  execute(TC_group_raw_attribute_test_7());
  execute(TC_Fast_enc_dec_function());
  execute(TC_Backtrack_decode_function());
  execute(TC_Sliding_decode_function());
  execute(TC_Decoding_empty_octetstring());
  execute(TC_encoding_decoding_of_big_integers());
  execute(TC_encoding_decoding_records_with_big_integer_fields());
  execute(TC_Multiple_optional_fields()); //FOA bug
}

<RESULT>

Overall verdict: pass

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(1)  for longer integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(1)  for longer integer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(1)"};

const RAW_PDU 		i := 15
const octetstring 	o := '0F'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.  FIELDLENGTH(4)  for longer bitstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-   FIELDLENGTH(4)  for longer bitstring>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type bitstring RAW_PDU
with { encode "RAW"; variant "FIELDLENGTH(4)"};

const RAW_PDU 		i := '11111111'B
const octetstring 	o := 'FF'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.   FIELDLENGTH(2)  for hexstring longer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    FIELDLENGTH(2)  for hexstring longer>

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type hexstring RAW_PDU
with {encode "RAW";
      variant "FIELDLENGTH(2)"};

const RAW_PDU 		i := '1234'H
const octetstring 	o := '1234'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i)  == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h2.Testing COMP Attribute
.*---------------------------------------------------------------------*

.*---------------------------------------------------------------------*
:h3.   COMP ( nosign ) for negative integer
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-    COMP ( nosign ) for negative integer >

<STATIC>

external function enc_RAW_PDU(in RAW_PDU pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_RAW_PDU(in octetstring stream) return RAW_PDU with { extension "prototype(convert) decode(RAW)" }

type integer RAW_PDU
with { encode "RAW";
       variant "FIELDLENGTH(8)" ;
       variant "COMP( nosign ) "
     };

const RAW_PDU 		i := -2
const octetstring 	o := '02'O

<TTCN_TC:EXEC>

log ("enc_RAW_PDU(i)=     "  , enc_RAW_PDU(i)) ;
log ("dec_RAW_PDU(o)=     "  , dec_RAW_PDU(o)) ;

if ((enc_RAW_PDU(i) == o)and(dec_RAW_PDU(o) == i)) {setverdict(pass);}
  else {setverdict(fail);}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. HO79315: Segfault on unbound octetstring
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC- HO79315: Segfault on unbound octetstring>

<STATIC>

type octetstring raw_pdu_octetstring with { encode "RAW"; variant "FIELDLENGTH(1)"};

external function enc_raw_pdu_octetstring(in raw_pdu_octetstring pdu) return octetstring with { extension "prototype(convert) encode(RAW)" }
external function dec_raw_pdu_octetstring(in octetstring stream) return raw_pdu_octetstring with { extension "prototype(convert) decode(RAW)" }

<TTCN_TC:EXEC>

  var raw_pdu_octetstring i;
  const octetstring o := '0F'O;
  if ((enc_raw_pdu_octetstring(i) == o)and(dec_raw_pdu_octetstring(o) == i)) {setverdict(pass);}
  else {setverdict(fail,"enc_raw_pdu_octetstring(i)= ", enc_raw_pdu_octetstring(i), "; dec_raw_pdu_octetstring(o)= ", dec_raw_pdu_octetstring(o));}

<RESULT>

Overall verdict: error

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. HQ49956: RAW coder: wrong encoding when msb fieldorder.
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC-HQ49956: RAW coder: wrong encoding when msb fieldorder.>

<STATIC>

  type component Test_CT{};

<TTCN_TC:PURE_EXEC>

  external function enc_PDU(in PDU pl_pdu) return octetstring 
  with {
    extension "prototype(convert)"
    extension "encode(RAW)"
  };
  external function dec_PDU(in octetstring pl_octetstring) return PDU
  with {
    extension "prototype(convert)"
    extension "decode(RAW)"
  }
    
  type hexstring HEX1 length(1) with {encode "RAW";variant "FIELDLENGTH(1)"};
  type hexstring HEX5 length(5) with {encode "RAW";variant "FIELDLENGTH(5)"};
  type octetstring OCT1 length(1) with {encode "RAW";variant "FIELDLENGTH(1)"};

  type record My_Type{
    OCT1          id,
    HEX1          spare,
    HEX5          hex,
    octetstring   o
  } with {
    encode "RAW";
    variant(spare,hex) "FIELDORDER(msb)";
  }
  
  type record PDU {
    OCT1     msg_type,
    U        u
  } with {
    encode "RAW";
    variant (u) "CROSSTAG(h1,      msg_type = '01'O;
                          h5,      msg_type = '02'O;
                          my_type, msg_type = '03'O;
                          unknown, OTHERWISE;)";
  }
  
  type union U {
    HEX1          h1,
    HEX5          h5,
    My_Type       my_type,
    octetstring   unknown

  } with {encode "RAW";}


  
testcase TC_02() runs on Test_CT{
  var PDU vl_pdu := {
      msg_type := '03'O,
      u := {
        my_type := {
          id := '01'O,
          spare := 'F'H,
          hex := 'ABCDE'H,
          o := '123456'O
        }
      }
    }

    var octetstring vl_encoded := enc_PDU(vl_pdu);
    var PDU vl_decoded := dec_PDU(vl_encoded);
    log("Encoded pdu:",vl_encoded); 
    if(vl_pdu == vl_decoded){
      setverdict(pass);  
    } else {
      setverdict(fail);
      log(match(vl_pdu, vl_decoded));
    }
}

control{
  execute(TC_02());
}

<RESULT>
  
Overall verdict: pass

<END_TC>  
  
:exmp.
.*---------------------------------------------------------------------*
:h1.REFERENCES
.*---------------------------------------------------------------------*
:nl. Requirement specification(s):
:nl.-------------------------------
:list.
:li. 8/ETH/RUS-2003:0087 Uen - Requirement Specification for TITAN's encoder/decoder functions
:elist.

:etext.
