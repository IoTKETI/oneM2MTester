.******************************************************************************
.* Copyright (c) 2000-2017 Ericsson Telecom AB
.* All rights reserved. This program and the accompanying materials
.* are made available under the terms of the Eclipse Public License v1.0
.* which accompanies this distribution, and is available at
.* http://www.eclipse.org/legal/epl-v10.html
.*
.* Contributors:
.*   Balasko, Jeno
.*   Baranyi, Botond
.*   Bartha, Norbert
.*   Beres, Szabolcs
.*   Delic, Adam
.*   Kovacs, Ferenc
.*   Szabados, Kristof
.*
.******************************************************************************/
:text.
:lang eng.

.* EDML webpage:       http://cpi.ericsson.se/dwaxe/
.* EDML2PDF converter: http://dwaxe.ericsson.se/x2pdf
.* EDML user guide:    http://www.lmc.ericsson.se/~lmcmarg/isit/edml_ug.html

.* Document header information
:docname.Test Description
:docno.24/152 91-CRL 113 200/5 Uen
:rev.C
:date.2015-04-27

:prep.ETH/RZX Norbert Bartha (ethnba)
:appr.ETH/RZX (Csaba Koppany)
:checked.EKRISZA

:title.Test description of the TTCN-3 Logging, the BigInteger handling, 
IPv6 address handling,module parameter handling, macro handling
:contents level=2.
.*---------------------------------------------------------------------*
:h1.Introduction
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Revision history
.*---------------------------------------------------------------------*
:xmp tab=2.
REV   DATE         PREPARED   CHANGE
__________________________________________________
PA1   2007-12-03   ETHNBA     New document for TITAN R7.2
PA5   2012-11-10   ETHBAAT    Preprocessor macro test
PA6   2014-04-01   ETHBAAT    TR: HQ20070: modulepar cannot be component, test port or default
:exmp.
.*---------------------------------------------------------------------*
:h2.Purpose
.*---------------------------------------------------------------------*
The purpose of this Test Description is to define and describe the function
test activity for the listed functionality of the TTCN-3 executor including
the relevant configuration options and the configuration file parser as follows:
:li D='1.'Logging
:li D='2.'Big Integer handling
:li D='3.'IPv6 address handling
:li D='4.'Module parameter handling
:li D='5.'Macro definition handling in the section DEFINE

:nl.SA-1/x: Unknown object.
:p.The specification of the test cases can be found in this document.
.*---------------------------------------------------------------------*
:h1.Test environment
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h2.Hardware
.*---------------------------------------------------------------------*
No specific hardware requirement.
.*---------------------------------------------------------------------*
:h2.Software
.*---------------------------------------------------------------------*
Tests shall be carried out on the following platforms:
:list.
:li D='1.'.Solaris 8 (Sun OS 5.8) (gcc 3.0.4)
:li D='2.'.SUSE Linux Enterprise server 8 (2.4.19-4GB) (gcc 3.2)
:li D='3.'.CYGWIN_NT-5.0 (Cygwin DLL: 1.5.12) on Windows 2000 (gcc 3.3.3)
:elist.
.*---------------------------------------------------------------------*
:h2.Configuration
.*---------------------------------------------------------------------*
The test environment had been setup in CVS. The tester program is stored in:
:nl.TTCNv3/function_test/Tools/SAtester.pl
:nl.Test cases are stored with extension .script in the directory:
:nl.TTCNv3/function_test/Semantic_Analyser/
.*---------------------------------------------------------------------*
:h2.Installation
.*---------------------------------------------------------------------*
Install proper TITAN binaries on the used platforms and make sure that
your environment settings are correct:
:list.
:li D='1.'.TTCN3_DIR is set
:li D='2.'.$TTCN3_DIR/bin is added to the PATH variable
:li D='3.'.$TTCN3_DIR/lib is added to the LD_LIBRARY_PATH variable
:li D='4.'.Perl 5.6.0 or higher is available on the platform
:li D='5.'.Create a symlink to your Perl binary into the directory where the
test cases are stored:
:nl.ln -s <your Perl> perl
:elist.
.*---------------------------------------------------------------------*
:h2.Test Tools
.*---------------------------------------------------------------------*
A tester program had been written in Perl especially for the Semantic Analyser
tests. For the list of command line parameters, type 'SAtester.pl -help', for the
complete documentation, type 'SAtester.pl -doc'.
:p.Test cases are specified in the Test Description documents in EDML format.
The tester program parses these files and generates the TTCN-3/ASN.1 modules, then
calls the compiler to compile them. The result printout is then matched against
different patterns to be able to set the verdict. Test cases contain not only
the source modules, but the patterns as well.
:p.The tester program allows one-by-one execution of test cases and batched
execution as well.
:p.NOTE: the tester program requires Perl 5.6.0 or higher.
.*---------------------------------------------------------------------*
:h2.Test scope
.*---------------------------------------------------------------------*
Ref [1]: SA-1/x: Unknown object
:nl.Explanation: all unknown objects shall be detected by SA.
.*---------------------------------------------------------------------*
:h2.Test strategy
.*---------------------------------------------------------------------*
Test cases are based on TTCN-3 BNF according to the followings:
:list.
:li D='1.'.For each 'basic' definition a complete coverage is done (e.g. for
expressions, assignments, etc.). 'Basic' means that the definition is
used in several places.
:li D='2.'.For each definition a complete coverage is done, except for basic
definitions, in which case only 1-2 examples are covered, not the
whole basic definition. This is to avoid testing all possible subcases
for all possible places it may appear.
:nl.NOTE: a complete coverage means that all occurances are tested where
the specific definition may occur. This is however not complete. Only
one occurance is tested for each construct.
:li D='3.'.Test case names are contsructed following the path in the BNF in TTCN-3
and following the possible notations/subtyping in ASN.1.
:elist.
.*---------------------------------------------------------------------*
:h2.Status
.*---------------------------------------------------------------------*
The following structures are not covered:
:list.
:li D='-'.sub-structures that causes parse error due to limited support of that
part of the language (e.g. interleave construct)
:elist.
.*---------------------------------------------------------------------*
:h1.Test cases
.*---------------------------------------------------------------------*
.*---------------------------------------------------------------------*
:h3.Splitting logfiles - allowed settings1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Splitting logfiles - allowed settings1>

<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

external function checkFile(charstring filename, integer fileSizeInBytes) return boolean;

type component TempComp {}

testcase TC() runs on TempComp{
  var charstring testline := "TEST LOGLINE -------------------------- TEST LOGLINE > NO : ";
  
  
  for(var integer i := 0; i < 1000; i := i + 1)
  {
    log(testline & int2str(i));
  }
  
  if( checkFile("Temp1.log", 10240) and 
  checkFile("Temp2.log", 10240) and
  checkFile("Temp3.log", 10240) and
  checkFile("Temp4.log", 10240) and
  checkFile("Temp5.log", 10240) and
  checkFile("Temp6.log", 10240) and
  checkFile("Temp7.log", 10240) and
  checkFile("Temp8.log", 10240) and
  checkFile("Temp9.log", 10240) and
  checkFile("Temp10.log", 10240) and 
  (not checkFile("Temp11.log", 0)))
  {
    setverdict(pass);
  }
  else {setverdict(fail);}

}

control {

	execute (TC());

}

}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 10
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.Splitting logfiles - allowed settings2
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Splitting logfiles - allowed settings2>

<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

external function checkFile(charstring filename, integer fileSizeInBytes) return boolean;

type component TempComp {}

testcase TC() runs on TempComp{
  var charstring testline := "TEST LOGLINE -------------------------- TEST LOGLINE > NO : ";
  
  
  for(var integer i := 0; i < 1000; i := i + 1)
  {
    log(testline & int2str(i));
  }
  
  
  
  if( checkFile("Temp6.log", 10240) and 
  checkFile("Temp7.log", 10240) and
  checkFile("Temp8.log", 10240) and
  checkFile("Temp9.log", 10240) and
  checkFile("Temp10.log", 10240) and
  (not checkFile("Temp11.log", 0)))
  {
    setverdict(pass);
  }
  else {setverdict(fail);}

}

control {

	execute (TC());

}

}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 5
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.Splitting logfiles - LogFileSize>0 & LogFileNumber=1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Splitting logfiles - LogFileSize>0 & LogFileNumber=1>

<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

external function checkFile(charstring filename, integer fileSizeInBytes) return boolean;

type component TempComp {}

testcase TC() runs on TempComp{
  var charstring testline := "TEST LOGLINE -------------------------- TEST LOGLINE > NO : ";
  
  
  for(var integer i := 0; i < 1000; i := i + 1)
  {
    log(testline & int2str(i));
  }
  
  
  
  if( checkFile("Temp.log", 0) and  
  (not checkFile("Temp1.log", 0)))
  {
    setverdict(pass);
  }
  else {setverdict(fail);}

}

control {

	execute (TC());

}

}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 10
LogFileNumber := 1
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.


.*---------------------------------------------------------------------*
:h3.Splitting logfiles - LogFileSize=0 & LogFileNumber>1
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Splitting logfiles - LogFileSize=0 & LogFileNumber>1>

<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

external function checkFile(charstring filename, integer fileSizeInBytes) return boolean;

type component TempComp {}

testcase TC() runs on TempComp{
  var charstring testline := "TEST LOGLINE -------------------------- TEST LOGLINE > NO : ";
  
  
  for(var integer i := 0; i < 1000; i := i + 1)
  {
    log(testline & int2str(i));
  }
  
  
  
  if( checkFile("Temp.log", 0) and  
  (not checkFile("Temp1.log", 0)))
  {
    setverdict(pass);
  }
  else {setverdict(fail);}

}

control {

	execute (TC());

}

}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 0
LogFileNumber := 2
DiskFullAction := error
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Splitting logfiles - LogFileNumber=1 & DiskFullAction= Delete
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC -  Splitting logfiles - LogFileNumber=1 & DiskFullAction= Delete>

<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

external function checkFile(charstring filename, integer fileSizeInBytes) return boolean;

type component TempComp {}

testcase TC() runs on TempComp{
  var charstring testline := "TEST LOGLINE -------------------------- TEST LOGLINE > NO : ";
  
  
  for(var integer i := 0; i < 1000; i := i + 1)
  {
    log(testline & int2str(i));
  }
  
  
  
  if( checkFile("Temp.log", 0) and  
  (not checkFile("Temp1.log", 0)))
  {
    setverdict(pass);
  }
  else {setverdict(fail);}

}

control {

	execute (TC());

}

}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
[LOGGING]
LogSourceInfo := Yes
Logfile := "Temp%i.log"
LogFileSize := 0
LogFileNumber := 2
DiskFullAction := delete
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Big integers - Big integers in configuration files
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Big integers - Big integers in configuration files>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component TempComp { }
modulepar integer par0 := 1000000000000000000000000, par1, par2, par3, par4, par5, par6, par7, par8, par9, par10, par11, par12, par13, par14
testcase TC() runs on TempComp {
  if (par0 == par1) { setverdict(pass) } else { setverdict(fail) }
  if (par0 == par2) { setverdict(pass) } else { setverdict(fail) }
  if (par0 == par8) { setverdict(pass) } else { setverdict(fail) }
  if (par0 == par9) { setverdict(pass) } else { setverdict(fail) }
  if (par1 == 1000000000000000000000000) { setverdict(pass) } else { setverdict(fail) }
  if (par8 == 1000000000000000000000000) { setverdict(pass) } else { setverdict(fail) }
  if (par1 == par2) { setverdict(pass) } else { setverdict(fail) }
  if (par1 == par8) { setverdict(pass) } else { setverdict(fail) }
  if (par1 == par9) { setverdict(pass) } else { setverdict(fail) }
  if (par3 == -1000000000000000000000000)  { setverdict(pass) } else { setverdict(fail) }
  if (par10 == -1000000000000000000000000) { setverdict(pass) } else { setverdict(fail) }
  if (par5 == 0)  { setverdict(pass) } else { setverdict(fail) }
  if (par12 == 0) { setverdict(pass) } else { setverdict(fail) }
  if (par7 == 1)  { setverdict(pass) } else { setverdict(fail) }
  if (par14 == 1) { setverdict(pass) } else { setverdict(fail) }
  if (par6 == 1000000000000000000000000000000000000000000000000)  { setverdict(pass) } else { setverdict(fail) }
  if (par13 == 1000000000000000000000000000000000000000000000000) { setverdict(pass) } else { setverdict(fail) }
}

control {
  execute(TC());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
par1 := 1000000000000000000000000
par2 := +1000000000000000000000000
par3 := -1000000000000000000000000
par4 := 1000000000000000000000000 + 1000000000000000000000000
par5 := 1000000000000000000000000 - 1000000000000000000000000
par6 := 1000000000000000000000000 * 1000000000000000000000000
par7 := 1000000000000000000000000 / 1000000000000000000000000
par8 := ${DEFINE1, integer}
par9 := +${DEFINE1, integer}
par10 := -${DEFINE1, integer}
par11 := ${DEFINE1, integer} + 1000000000000000000000000
par12 := ${DEFINE1, integer} - 1000000000000000000000000
par13 := ${DEFINE1, integer} * 1000000000000000000000000
par14 := ${DEFINE1, integer} / 1000000000000000000000000
[DEFINE]
DEFINE1 := 1000000000000000000000000
[LOGGING]
FileMask := LOG_ALL
ConsoleMask := WARNING | ERROR | TESTCASE | STATISTICS
[EXECUTE]
Temp
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3.Big integers - Various integers in configuration files (single mode)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Big integers - Various integers in configuration files (single mode)>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component TempComp { }
modulepar {
  // Small integer parameters.
  integer s_mp1
  integer s_mp2
  integer s_mp3
  integer s_mp4
  integer s_mp5
  integer s_mp6
  integer s_mp7
  integer s_mp8
  integer s_mp9
  integer s_mp10
  integer s_mp11
  integer s_mp12
  integer s_mp13
  integer s_mp14
  integer s_mp15
  integer s_mp16
  integer s_mp17

  // Big integer parameters.
  integer b_mp1
  integer b_mp2
  integer b_mp3
  integer b_mp4
  integer b_mp5
  integer b_mp6
  integer b_mp7
  integer b_mp8
  integer b_mp9
  integer b_mp10
  integer b_mp11
  integer b_mp12
  integer b_mp13
  integer b_mp14
  integer b_mp15
  integer b_mp16
  integer b_mp17
  integer b_mp18
  integer b_mp19
  integer b_mp20
  integer b_mp21
  integer b_mp22
  integer b_mp23
  integer b_mp24
  integer b_mp25

  // Others.
  universal charstring c_mp1
}
testcase TC() runs on TempComp {
  if (s_mp1 == 9)    { setverdict(pass) } else { setverdict(fail) }
  if (s_mp2 == 1)    { setverdict(pass) } else { setverdict(fail) }
  if (s_mp3 == -2)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp4 == -20)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp5 == 25)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp6 == 15)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp7 == -19)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp8 == 19)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp9 == 50)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp10 == -15) { setverdict(pass) } else { setverdict(fail) }
  if (s_mp11 == 15)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp12 == -25) { setverdict(pass) } else { setverdict(fail) }
  if (s_mp13 == 3)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp14 == -4)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp15 == -4)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp16 == 4)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp17 == 0)   { setverdict(pass) } else { setverdict(fail) }

  if (b_mp1 == 222222222222222)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp2 == 0)                     { setverdict(pass) } else { setverdict(fail) }
  if (b_mp3 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp4 == 111111111111111)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp5 == 0)                     { setverdict(pass) } else { setverdict(fail) }
  if (b_mp6 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp7 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp8 == 111111111111111)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp9 == 111111111111110)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp10 == 111111111111120)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp11 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp12 == -2222222222222222222) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp13 == 5555555555555555555)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp14 == -1111111111111111111) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp15 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp16 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp17 == -2222222222222222222) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp18 == -2)                   { setverdict(pass) } else { setverdict(fail) }
  if (b_mp19 == 2222222222222222220)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp20 == 12345678910111213141516171819202122)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp21 == -12345678910111213141516171819202122) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp22 == 24691357820222426283032343638404244)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp23 == 0)                                    { setverdict(pass) } else { setverdict(fail) }
  if (b_mp24 == 197530862561779410264258749107233952) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp25 == 771604931881950821344760738700132)    { setverdict(pass) } else { setverdict(fail) }

  if (c_mp1 == char(12, 24, 36, 48)) { setverdict(pass) } else { setverdict(fail) }
}
control {
  execute(TC())
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[LOGGING]
LogFileNumber := 16
LogFileSize := 512
DiskFullAction := Retry(2)
ConsoleMask := LOG_ALL | TTCN_DEBUG
SourceInfoFormat := Single

[MAIN_CONTROLLER]
NumHCs := 2

[EXECUTE]
Temp.control

[MODULE_PARAMETERS]
#############################
## Small integer expressions.
#############################
s_mp1 := + - 1 * 2 * 3 * 4 / - + 2 + -3 // 9
s_mp2 := -1 * -1 // 1
s_mp3 := -1 * 2 // -2
s_mp4 := 5 * -4 // -20
s_mp5 := 5 * 5 // 25
s_mp6 := +15 // 15
s_mp7 := -19 // -19
s_mp8 := (19) // 19
s_mp9 := 45 + 5 // 50
s_mp10 := -20 + 5 // -15
s_mp11 := 20 - 5 // 15
s_mp12 := -20 - 5 // -25
s_mp13 := 15 / 5 // 3
s_mp14 := 20 / -5 // -4
s_mp15 := -20 / 5 // -4
s_mp16 := -20 / -5 // 4
s_mp17 := 1 + 2 + -3 + 0 - 5 * 5 + (10 / 2) * 5 // 0

###########################
## Big integer expressions.
###########################
b_mp1 := 111111111111111 + 111111111111111 // 222222222222222
b_mp2 := 111111111111111 - 111111111111111 // 0
b_mp3 := -111111111111111 // -111111111111111
b_mp4 := +111111111111111 // 111111111111111
b_mp5 := 111111111111111 * 111111111111111 / 111111111111111 - 111111111111111 // 0
b_mp6 := -(+111111111111111) // -111111111111111
b_mp7 := -111111111111111 / 1 // -111111111111111
b_mp8 := 1 * 111111111111111 // 111111111111111
b_mp9 := 111111111111111 - 1 // 111111111111110
b_mp10 := 111111111111111 + 9 // 111111111111120
b_mp11 := ${C1, integer} // 2222222222222222222
b_mp12 := +(-${C1, integer}) // -2222222222222222222
b_mp13 := ${C1, integer} + ${C2, integer} // 5555555555555555555
b_mp14 := ${C1, integer} - ${C2, integer} // -1111111111111111111
b_mp15 := ${C1, integer} * 1 // 2222222222222222222
b_mp16 := ${C1, integer} / 1 // 2222222222222222222
b_mp17 := -1 * ${C1, integer} // -2222222222222222222
b_mp18 := -${C1, integer} / 1111111111111111111 // -2
b_mp19 := ${C1, integer} + -${C1, integer} / 1111111111111111111 // 2222222222222222220
b_mp20 := ${C3, integer}
b_mp21 := -${C3, integer}
b_mp22 := ${C3, integer} + ${C3, integer}
b_mp23 := ${C3, integer} - ${C3, integer}
b_mp24 := ${C3, integer} * ${C4, integer}
b_mp25 := ${C3, integer} / ${C4, integer}

c_mp1 := char(12, 24, 36, 48)

[DEFINE]
C1 := 2222222222222222222
C2 := 3333333333333333333
C3 := 12345678910111213141516171819202122
C4 := 16
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

.*---------------------------------------------------------------------*
:h3.Big integers - Various integers in configuration files (parallel mode)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Big integers - Various integers in configuration files (parallel mode)>
<EXECUTE_PARALLEL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component TempComp { }
modulepar {
  // Small integer parameters.
  integer s_mp1
  integer s_mp2
  integer s_mp3
  integer s_mp4
  integer s_mp5
  integer s_mp6
  integer s_mp7
  integer s_mp8
  integer s_mp9
  integer s_mp10
  integer s_mp11
  integer s_mp12
  integer s_mp13
  integer s_mp14
  integer s_mp15
  integer s_mp16
  integer s_mp17

  // Big integer parameters.
  integer b_mp1
  integer b_mp2
  integer b_mp3
  integer b_mp4
  integer b_mp5
  integer b_mp6
  integer b_mp7
  integer b_mp8
  integer b_mp9
  integer b_mp10
  integer b_mp11
  integer b_mp12
  integer b_mp13
  integer b_mp14
  integer b_mp15
  integer b_mp16
  integer b_mp17
  integer b_mp18
  integer b_mp19
  integer b_mp20
  integer b_mp21
  integer b_mp22
  integer b_mp23
  integer b_mp24
  integer b_mp25

  // Others.
  universal charstring c_mp1
}
testcase TC() runs on TempComp {
  if (s_mp1 == 9)    { setverdict(pass) } else { setverdict(fail) }
  if (s_mp2 == 1)    { setverdict(pass) } else { setverdict(fail) }
  if (s_mp3 == -2)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp4 == -20)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp5 == 25)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp6 == 15)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp7 == -19)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp8 == 19)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp9 == 50)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp10 == -15) { setverdict(pass) } else { setverdict(fail) }
  if (s_mp11 == 15)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp12 == -25) { setverdict(pass) } else { setverdict(fail) }
  if (s_mp13 == 3)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp14 == -4)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp15 == -4)  { setverdict(pass) } else { setverdict(fail) }
  if (s_mp16 == 4)   { setverdict(pass) } else { setverdict(fail) }
  if (s_mp17 == 0)   { setverdict(pass) } else { setverdict(fail) }

  if (b_mp1 == 222222222222222)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp2 == 0)                     { setverdict(pass) } else { setverdict(fail) }
  if (b_mp3 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp4 == 111111111111111)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp5 == 0)                     { setverdict(pass) } else { setverdict(fail) }
  if (b_mp6 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp7 == -111111111111111)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp8 == 111111111111111)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp9 == 111111111111110)       { setverdict(pass) } else { setverdict(fail) }
  if (b_mp10 == 111111111111120)      { setverdict(pass) } else { setverdict(fail) }
  if (b_mp11 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp12 == -2222222222222222222) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp13 == 5555555555555555555)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp14 == -1111111111111111111) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp15 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp16 == 2222222222222222222)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp17 == -2222222222222222222) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp18 == -2)                   { setverdict(pass) } else { setverdict(fail) }
  if (b_mp19 == 2222222222222222220)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp20 == 12345678910111213141516171819202122)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp21 == -12345678910111213141516171819202122) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp22 == 24691357820222426283032343638404244)  { setverdict(pass) } else { setverdict(fail) }
  if (b_mp23 == 0)                                    { setverdict(pass) } else { setverdict(fail) }
  if (b_mp24 == 197530862561779410264258749107233952) { setverdict(pass) } else { setverdict(fail) }
  if (b_mp25 == 771604931881950821344760738700132)    { setverdict(pass) } else { setverdict(fail) }

  if (c_mp1 == char(12, 24, 36, 48)) { setverdict(pass) } else { setverdict(fail) }
}
control {
  execute(TC())
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[LOGGING]
LogFileNumber := 16
LogFileSize := 512
DiskFullAction := Retry(2)
ConsoleMask := LOG_ALL | TTCN_DEBUG
SourceInfoFormat := Single

[MAIN_CONTROLLER]
// Cannot be used with `ttcn3_start'...
// NumHCs := 2

[EXECUTE]
Temp.control

[MODULE_PARAMETERS]
#############################
## Small integer expressions.
#############################
s_mp1 := + - 1 * 2 * 3 * 4 / - + 2 + -3 // 9
s_mp2 := -1 * -1 // 1
s_mp3 := -1 * 2 // -2
s_mp4 := 5 * -4 // -20
s_mp5 := 5 * 5 // 25
s_mp6 := +15 // 15
s_mp7 := -19 // -19
s_mp8 := (19) // 19
s_mp9 := 45 + 5 // 50
s_mp10 := -20 + 5 // -15
s_mp11 := 20 - 5 // 15
s_mp12 := -20 - 5 // -25
s_mp13 := 15 / 5 // 3
s_mp14 := 20 / -5 // -4
s_mp15 := -20 / 5 // -4
s_mp16 := -20 / -5 // 4
s_mp17 := 1 + 2 + -3 + 0 - 5 * 5 + (10 / 2) * 5 // 0

###########################
## Big integer expressions.
###########################
b_mp1 := 111111111111111 + 111111111111111 // 222222222222222
b_mp2 := 111111111111111 - 111111111111111 // 0
b_mp3 := -111111111111111 // -111111111111111
b_mp4 := +111111111111111 // 111111111111111
b_mp5 := 111111111111111 * 111111111111111 / 111111111111111 - 111111111111111 // 0
b_mp6 := -(+111111111111111) // -111111111111111
b_mp7 := -111111111111111 / 1 // -111111111111111
b_mp8 := 1 * 111111111111111 // 111111111111111
b_mp9 := 111111111111111 - 1 // 111111111111110
b_mp10 := 111111111111111 + 9 // 111111111111120
b_mp11 := ${C1, integer} // 2222222222222222222
b_mp12 := +(-${C1, integer}) // -2222222222222222222
b_mp13 := ${C1, integer} + ${C2, integer} // 5555555555555555555
b_mp14 := ${C1, integer} - ${C2, integer} // -1111111111111111111
b_mp15 := ${C1, integer} * 1 // 2222222222222222222
b_mp16 := ${C1, integer} / 1 // 2222222222222222222
b_mp17 := -1 * ${C1, integer} // -2222222222222222222
b_mp18 := -${C1, integer} / 1111111111111111111 // -2
b_mp19 := ${C1, integer} + -${C1, integer} / 1111111111111111111 // 2222222222222222220
b_mp20 := ${C3, integer}
b_mp21 := -${C3, integer}
b_mp22 := ${C3, integer} + ${C3, integer}
b_mp23 := ${C3, integer} - ${C3, integer}
b_mp24 := ${C3, integer} * ${C4, integer}
b_mp25 := ${C3, integer} / ${C4, integer}

c_mp1 := char(12, 24, 36, 48)

[DEFINE]
C1 := 2222222222222222222
C2 := 3333333333333333333
C3 := 12345678910111213141516171819202122
C4 := 16
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

.*---------------------------------------------------------------------*
:h3.BeginTestCase and EndTestCase in configuration files
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - BeginTestCase and EndTestCase in configuration files>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
external function check_script_out(integer phase, charstring to_match) return boolean
type component EmptyComp { }
testcase FailTC() runs on EmptyComp { setverdict(fail) }
testcase PassTC() runs on EmptyComp {
  // Check for BeginTestCase.  Not committed due to a memleak reported in TR 961.
  // if (check_script_out(0, "Temp.PassTC")) { setverdict(pass) }
  // else { setverdict(fail) }
  setverdict(pass)
}
control {
  execute(PassTC())
  // Check for EndTestCase.  We have an additional verdict at the end.  Enable
  // this test, when TR961 is fixed.
  // if (check_script_out(1, "Temp.PassTC pass")) { execute(PassTC()) }
  // else { execute(FailTC()) }
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[EXTERNAL_COMMANDS]
#BeginTestCase := "./begin_script.sh"
#EndTestCase := "./end_script.sh"
[EXECUTE]
Temp.control
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. IPv6 addresses
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - IPv6 addresses> 
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component EmptyComp {};
testcase PassTC() runs on EmptyComp {
  setverdict(pass)
}
control {
  execute(PassTC())
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[GROUPS]
first := *
second := 1.0.0.0.0.0.0, a.b.c.d.e.f, identifier

#based on http://tools.ietf.org/html/rfc3513

myGroup := FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
myGroup := 1080:0:0:0:8:800:200C:417

myGroup := 1080:0:0:0:8:800:200C:417A  #a unicast address
myGroup :=  1080::8:800:200C:417A       #a unicast address
  
myGroup := FF01:0:0:0:0:0:0:101        #a multicast address
myGroup :=FF01::101                   #a multicast address
 
myGroup := 0:0:0:0:0:0:0:1             #the loopback address
myGroup := ::1                         #the loopback address
 
myGroup := 0:0:0:0:0:0:0:0             #the unspecified addresses
myGroup := ::                          #the unspecified addresses

myGroup := 0:0:0:0:0:0:13.1.68.3 
myGroup := ::13.1.68.3

myGroup := 0:0:0:0:0:FFFF:129.144.52.38 
myGroup := ::FFFF:129.144.52.38


#The following are NOT legal representations of the above prefix: BUT they are eaten >(

myGroup := FF02:0:0:0:0:0:0:101 #means all NTP servers on the same link as the sender.

myGroup := FF05:0:0:0:0:0:0:101 #means all NTP servers in the same site as the  sender.

myGroup := FF0E:0:0:0:0:0:0:101 #means all NTP servers in the internet.

myGroup := FF00:0:0:0:0:0:0:0 #FF0Reserved Multicast Addresses:

myGroup := FF01:0:0:0:0:0:0:1 #All Nodes Addresses:
myGroup := FF02:0:0:0:0:0:0:1 #All Nodes Addresses:

myGroup := FF01:0:0:0:0:0:0:2 #All Routers Addresses:
myGroup := FF02:0:0:0:0:0:0:2 #All Routers Addresses:
myGroup := FF05:0:0:0:0:0:0:2 #All Routers Addresses:

myGroup := FF02:0:0:0:0:1:FF00:0000
myGroup := FF02:0:0:0:0:1:FFFF:FFFF

myGroup := b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.

[COMPONENTS]
# This section consists of rules restricting the location of created PTCs.
myComponent_0 := host1
* := host1
myComponent_1 := 1.0.0.0
myComponent_2 := 1.0.0.0.0.0.0.0
myComponent_3 := a.b.c.d.e.f

myComponent_4 := FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
myComponent_5 := 1080:0:0:0:8:800:200C:417A
myComponent_6 := 1080:0:0:0:8:800:200C:417
myComponent_7 := FF01:0:0:0:0:0:0:101

myComponent_8 := 1080:0:0:0:8:800:200C:417A  #a unicast address
myComponent_9 :=  1080::8:800:200C:417A       #a unicast address
  
myComponent_10 := FF01:0:0:0:0:0:0:101        #a multicast address
myComponent_11 :=FF01::101                   #a multicast address
 
myComponent_12 := 0:0:0:0:0:0:0:1             #the loopback address
myComponent_13 := ::1                         #the loopback address
 
myComponent_14 := 0:0:0:0:0:0:0:0             #the unspecified addresses
myComponent_15 := ::                          #the unspecified addresses

myComponent_16 := 0:0:0:0:0:0:13.1.68.3 
myComponent_17 := ::13.1.68.3

myComponent_18 := 0:0:0:0:0:FFFF:129.144.52.38 
myComponent_19 := ::FFFF:129.144.52.38

#The following are NOT legal representations of the above prefix: BUT they are eaten >(
myComponent_20 :=  FF01:0:0:0:0:0:0:101

myComponent_21 := FF02:0:0:0:0:0:0:101 #means all NTP servers on the same link as the sender.

myComponent_22 := FF05:0:0:0:0:0:0:101 #means all NTP servers in the same site as the  sender.

myComponent_23 := FF0E:0:0:0:0:0:0:101 #means all NTP servers in the internet.

myComponent_24 := FF00:0:0:0:0:0:0:0 #FF0Reserved Multicast Addresses:

myComponent_25 := FF01:0:0:0:0:0:0:1 #All Nodes Addresses:
myComponent_26 := FF02:0:0:0:0:0:0:1 #All Nodes Addresses:

myComponent_27 := FF01:0:0:0:0:0:0:2 #All Routers Addresses:
myComponent_28 := FF02:0:0:0:0:0:0:2 #All Routers Addresses:
myComponent_29 := FF05:0:0:0:0:0:0:2 #All Routers Addresses:

myComponent_30 := FF02:0:0:0:0:1:FF00:0000
myComponent_31 := FF02:0:0:0:0:1:FFFF:FFFF

myComponent_32 := b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.

[MAIN_CONTROLLER]
TCPPort := 5555
# It's not necessary to give a full pattern for IPv6 addresses, the pattern
# was not full for even IPv4.  E.g. `LocalAddress := 1.1.localhost.1' is
# possible, but invalid.  It's not checked by the parser.

LocalAddress := ::1  #fe80::c002:37ff:fe6c:0%fastethernet0/0

#based on http://tools.ietf.org/html/rfc3513

LocalAddress := FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
LocalAddress := 1080:0:0:0:8:800:200C:417A
LocalAddress := 1080:0:0:0:8:800:200C:417
LocalAddress := FF01:0:0:0:0:0:0:101

LocalAddress := 1080:0:0:0:8:800:200C:417A  #a unicast address
LocalAddress :=  1080::8:800:200C:417A       #a unicast address
  
LocalAddress := FF01:0:0:0:0:0:0:101        #a multicast address
LocalAddress :=FF01::101                   #a multicast address
 
LocalAddress := 0:0:0:0:0:0:0:1             #the loopback address
LocalAddress := ::1                         #the loopback address
 
LocalAddress := 0:0:0:0:0:0:0:0             #the unspecified addresses
LocalAddress := ::                          #the unspecified addresses

LocalAddress := 0:0:0:0:0:0:13.1.68.3 
LocalAddress := ::13.1.68.3

LocalAddress := 0:0:0:0:0:FFFF:129.144.52.38 
LocalAddress := ::FFFF:129.144.52.38

#The following are NOT legal representations of the above prefix: BUT they are eaten >(
LocalAddress :=  FF01:0:0:0:0:0:0:101

LocalAddress := FF02:0:0:0:0:0:0:101 #means all NTP servers on the same link as the sender.

LocalAddress := FF05:0:0:0:0:0:0:101 #means all NTP servers in the same site as the  sender.

LocalAddress := FF0E:0:0:0:0:0:0:101 #means all NTP servers in the internet.

LocalAddress := FF00:0:0:0:0:0:0:0 #FF0Reserved Multicast Addresses:

LocalAddress := FF01:0:0:0:0:0:0:1 #All Nodes Addresses:
LocalAddress := FF02:0:0:0:0:0:0:1 #All Nodes Addresses:

LocalAddress := FF01:0:0:0:0:0:0:2 #All Routers Addresses:
LocalAddress := FF02:0:0:0:0:0:0:2 #All Routers Addresses:
LocalAddress := FF05:0:0:0:0:0:0:2 #All Routers Addresses:

LocalAddress := FF02:0:0:0:0:1:FF00:0000
LocalAddress := FF02:0:0:0:0:1:FFFF:FFFF

LocalAddress := b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.

[DEFINE]
# This section consists of rules restricting the location of created PTCs.
d_0 := host1
d_1 := 1
d_2 := 1.0
d_3 := 1.0.0.0
d_4 := 1.0.0.0.0.0.0.0
d_5 := a.b.c.d.e.f

d_7 := FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
d_8 := 1080:0:0:0:8:800:200C:417A
d_9 := 1080:0:0:0:8:800:200C:417
d_10 := FF01:0:0:0:0:0:0:101

d_11 := 0:0:0:0:0:0:13.1.68.3 
d_12 := ::13.1.68.3

d_13 := 0:0:0:0:0:FFFF:129.144.52.38 
d_14 := ::FFFF:129.144.52.38

d_unicast_0 := 1080:0:0:0:8:800:200C:417A  #a unicast address
d_unicast_1 :=  1080::8:800:200C:417A       #a unicast address
  
d_multicast_0 := FF01:0:0:0:0:0:0:101        #a multicast address
d_multicast_1 :=FF01::101                   #a multicast address
 
d_loopback_0 := 0:0:0:0:0:0:0:1             #the loopback address
d_loopback_1 := ::1                         #the loopback address
 
d_unspecified_0 := 0:0:0:0:0:0:0:0             #the unspecified addresses
d_unspecified_1 := ::                          #the unspecified addresses

#The following are NOT legal representations of the above prefix: BUT they are eaten >(
d_illegal_0 :=  FF01:0:0:0:0:0:0:101

d_illegal_1 := FF02:0:0:0:0:0:0:101 #means all NTP servers on the same link as the sender.

d_illegal_2 := FF05:0:0:0:0:0:0:101 #means all NTP servers in the same site as the  sender.

d_illegal_3 := FF0E:0:0:0:0:0:0:101 #means all NTP servers in the internet.

d_illegal_4 := FF00:0:0:0:0:0:0:0 #FF0Reserved Multicast Addresses:

d_illegal_5 := FF01:0:0:0:0:0:0:1 #All Nodes Addresses:
d_illegal_6 := FF02:0:0:0:0:0:0:1 #All Nodes Addresses:

d_illegal_7 := FF01:0:0:0:0:0:0:2 #All Routers Addresses:
d_illegal_8 := FF02:0:0:0:0:0:0:2 #All Routers Addresses:
d_illegal_9 := FF05:0:0:0:0:0:0:2 #All Routers Addresses:

d_illegal_10 := FF02:0:0:0:0:1:FF00:0000
d_illegal_11 := FF02:0:0:0:0:1:FFFF:FFFF

[EXECUTE]
Temp.control
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. HP36538 space needed before ":=" in config files
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - HP36538 space needed before ":=" in config files>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {
type component EmptyComp {};
testcase PassTC() runs on EmptyComp {
  setverdict(pass)
}
control {
  execute(PassTC())
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[DEFINE]
d_something_0 := 5 d_something_1:= 5
d_something_2 :=5 d_something_3:=5

d_something_4 = 5 d_something_5= 5
d_something_6 =5 d_something_7=5

d_ipv6_0:=1:2:3:4:5 d_ipv6_1:=1:2:3:4:5%3
d_ipv6_2:=::1 d_ipv6_3=::1

[EXECUTE]
Temp.control
<END_MODULE>
<RESULT>
Overall verdict: pass
<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Module Parameters - assignment - negative tests
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Module Parameters - assignment - negative tests>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer ROI;
type record Rec {
  integer field1
}

type set of integer SOI;
type set MySet {
  integer field1
}

type enumerated MyEnum {
  ENUM_1, ENUM_2
}

type union MyUnion {
  integer asdf
}

modulepar integer tsp_integer;
modulepar float tsp_float;
modulepar boolean tsp_boolean;
modulepar objid tsp_objid;
modulepar verdicttype tsp_verdict;
modulepar bitstring tsp_bitstring;
modulepar hexstring tsp_hexstring;
modulepar octetstring tsp_octetstring;
modulepar charstring tsp_charstring;
modulepar universal charstring tsp_universal_charstring;
modulepar MyEnum tsp_enumerated;
modulepar Rec tsp_record;
modulepar ROI tsp_record_of;
modulepar MySet tsp_set;
modulepar SOI tsp_set_of;
modulepar anytype tsp_anytype;
modulepar MyUnion tsp_union;
//modulepar MyComp_CT tsp_component; TR: HQ20070: modulepar cannot be component, test port or default
//modulepar default tsp_default;

type component MyComp_CT { }

testcase tc_fail() runs on MyComp_CT {
  setverdict(fail);
}

control {
  execute(tc_fail());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
///////////////////////////////////////////
// Type mismatch tests                  //
/////////////////////////////////////////
// Integer
tsp_integer := 1.0
tsp_integer := true
tsp_integer := objid {0 4 0 12345 6789}
tsp_integer := none 
tsp_integer := '1010101'B 
tsp_integer := 'ABC'H 
tsp_integer := 'AB'O 
tsp_integer := "abc" 
tsp_integer := char(0, 0, 1, 113); 
tsp_integer := {1, 2, 3}
tsp_integer := {[0] := 1, [1] := 2, [2] := 3}
tsp_integer := {field1 := 1, field2 := 2, field3 := 3}
tsp_integer := ENUM_1

// Float 
tsp_float := 1
tsp_float := 1000000000000
tsp_float := true
tsp_float := objid {0 4 0 12345 6789}
tsp_float := none 
tsp_float := '1010101'B 
tsp_float := 'ABC'H 
tsp_float := 'AB'O 
tsp_float := "abc" 
tsp_float := char(0, 0, 1, 113); 
tsp_float := {1, 2, 3}
tsp_float := {[0] := 1, [1] := 2, [2] := 3}
tsp_float := {field1 := 1, field2 := 2, field3 := 3}
tsp_float := ENUM_1

// Boolean
tsp_boolean := 1
tsp_boolean := 1000000000000
tsp_boolean := 1.0
tsp_boolean := objid {0 4 0 12345 6789}
tsp_boolean := none 
tsp_boolean := '1010101'B 
tsp_boolean := 'ABC'H 
tsp_boolean := 'AB'O 
tsp_boolean := "abc" 
tsp_boolean := char(0, 0, 1, 113); 
tsp_boolean := {1, 2, 3}
tsp_boolean := {[0] := 1, [1] := 2, [2] := 3}
tsp_boolean := {field1 := 1, field2 := 2, field3 := 3}
tsp_boolean := ENUM_1 

// Objid
tsp_objid := 1
tsp_objid := 1000000000000
tsp_objid := 1.0
tsp_objid := true
tsp_objid := none 
tsp_objid := '1010101'B 
tsp_objid := 'ABC'H 
tsp_objid := 'AB'O 
tsp_objid := "abc"
tsp_objid := char(0, 0, 1, 113); 
tsp_objid := {1, 2, 3}
tsp_objid := {[0] := 1, [1] := 2, [2] := 3}
tsp_objid := {field1 := 1, field2 := 2, field3 := 3}
tsp_objid := ENUM_1 

// Verdict
tsp_verdict := 1
tsp_verdict := 1000000000000
tsp_verdict := 1.0
tsp_verdict := true
tsp_verdict := objid {0 4 0 12345 6789}
tsp_verdict := '1010101'B 
tsp_verdict := 'ABC'H 
tsp_verdict := 'AB'O 
tsp_verdict := "abc"
tsp_verdict := char(0, 0, 1, 113); 
tsp_verdict := {1, 2, 3}
tsp_verdict := {[0] := 1, [1] := 2, [2] := 3}
tsp_verdict := {field1 := 1, field2 := 2, field3 := 3}
tsp_verdict := ENUM_1 

//  Bitstring
tsp_bitstring := 1
tsp_bitstring := 1000000000000
tsp_bitstring := 1.0
tsp_bitstring := true
tsp_bitstring := objid {0 4 0 12345 6789}
tsp_bitstring := none 
tsp_bitstring := 'ABC'H 
tsp_bitstring := 'AB'O 
tsp_bitstring := "abc"
tsp_bitstring := char(0, 0, 1, 113); 
tsp_bitstring := {1, 2, 3}
tsp_bitstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_bitstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_bitstring := ENUM_1 

// Hexstring  
tsp_hexstring := 1
tsp_hexstring := 1000000000000
tsp_hexstring := 1.0
tsp_hexstring := true
tsp_hexstring := objid {0 4 0 12345 6789}
tsp_hexstring := none 
tsp_hexstring := '1010101'B 
tsp_hexstring := 'AB'O 
tsp_hexstring := "abc"
tsp_hexstring := char(0, 0, 1, 113); 
tsp_hexstring := {1, 2, 3}
tsp_hexstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_hexstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_hexstring := ENUM_1 

// Octetstring 
tsp_octetstring := 1
tsp_octetstring := 1000000000000
tsp_octetstring := 1.0
tsp_octetstring := true
tsp_octetstring := objid {0 4 0 12345 6789}
tsp_octetstring := none 
tsp_octetstring := '1010101'B 
tsp_octetstring := 'ABC'H 
tsp_octetstring := "abc"
tsp_octetstring := char(0, 0, 1, 113)
tsp_octetstring := {1, 2, 3}
tsp_octetstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_octetstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_octetstring := ENUM_1 

// Charstring
tsp_charstring := 1
tsp_charstring := 1000000000000
tsp_charstring := 1.0
tsp_charstring := true
tsp_charstring := objid {0 4 0 12345 6789}
tsp_charstring := none 
tsp_charstring := '1010101'B 
tsp_charstring := 'ABC'H 
tsp_charstring := 'AB'O 
tsp_charstring := char(0, 0, 1, 113) 
tsp_charstring := {1, 2, 3}
tsp_charstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_charstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_charstring := ENUM_1 

// Universal charstring
tsp_universal_charstring := 1
tsp_universal_charstring := 1000000000000
tsp_universal_charstring := 1.0
tsp_universal_charstring := true
tsp_universal_charstring := objid {0 4 0 12345 6789}
tsp_universal_charstring := none 
tsp_universal_charstring := '1010101'B 
tsp_universal_charstring := 'ABC'H 
tsp_universal_charstring := 'AB'O 
tsp_universal_charstring := {1, 2, 3}
tsp_universal_charstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_universal_charstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_universal_charstring := ENUM_1 

// Enumerated
tsp_enumerated := 1
tsp_enumerated := 1000000000000
tsp_enumerated := 1.0
tsp_enumerated := true
tsp_enumerated := objid {0 4 0 12345 6789}
tsp_enumerated := none 
tsp_enumerated := '1010101'B 
tsp_enumerated := 'ABC'H 
tsp_enumerated := 'AB'O 
tsp_enumerated := "abc" 
tsp_enumerated := char(0, 0, 1, 113) 
tsp_enumerated := {1, 2, 3}
tsp_enumerated := {[0] := 1, [1] := 2, [2] := 3}
tsp_enumerated := {field1 := 1, field2 := 2, field3 := 3}

// Record 
tsp_record := 1
tsp_record := 1000000000000
tsp_record := 1.0
tsp_record := true
tsp_record := objid {0 4 0 12345 6789}
tsp_record := none 
tsp_record := '1010101'B 
tsp_record := 'ABC'H 
tsp_record := 'AB'O 
tsp_record := "abc" 
tsp_record := char(0, 0, 1, 113); 
tsp_record := {1, 2, 3}
tsp_record := {[0] := 1, [1] := 2, [2] := 3}
tsp_record := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_record := ENUM_1 

// Record of
tsp_record_of := 1
tsp_record_of := 1000000000000
tsp_record_of := 1.0
tsp_record_of := true
tsp_record_of := objid {0 4 0 12345 6789}
tsp_record_of := none 
tsp_record_of := '1010101'B 
tsp_record_of := 'ABC'H 
tsp_record_of := 'AB'O 
tsp_record_of := "abc" 
tsp_record_of := char(0, 0, 1, 113); 
tsp_record_of := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_record_of:= ENUM_1 

// Set 
tsp_set := 1
tsp_set := 1000000000000
tsp_set := 1.0
tsp_set := true
tsp_set := objid {0 4 0 12345 6789}
tsp_set := none 
tsp_set := '1010101'B 
tsp_set := 'ABC'H 
tsp_set := 'AB'O 
tsp_set := "abc" 
tsp_set := char(0, 0, 1, 113); 
tsp_set := {1, 2, 3}
tsp_set := {[0] := 1, [1] := 2, [2] := 3}
tsp_set := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_set := ENUM_1 

// Set of
tsp_set_of := 1
tsp_set_of := 1000000000000
tsp_set_of := 1.0
tsp_set_of := true
tsp_set_of := objid {0 4 0 12345 6789}
tsp_set_of := none 
tsp_set_of := '1010101'B 
tsp_set_of := 'ABC'H 
tsp_set_of := 'AB'O 
tsp_set_of := "abc" 
tsp_set_of := char(0, 0, 1, 113); 
tsp_set_of := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_set_of := ENUM_1 

// Anytype 
tsp_anytype := 1
tsp_anytype := 1000000000000
tsp_anytype := 1.0
tsp_anytype := true
tsp_anytype := objid {0 4 0 12345 6789}
tsp_anytype := '1010101'B 
tsp_anytype := 'ABC'H 
tsp_anytype := 'AB'O 
tsp_anytype := "abc"
tsp_anytype := char(0, 0, 1, 113); 
tsp_anytype := {1, 2, 3}
tsp_anytype := {[0] := 1, [1] := 2, [2] := 3}
tsp_anytype := {field1 := 1, field2 := 2, field3 := 3}
tsp_anytype := ENUM_1 

// Union 
tsp_union := 1
tsp_union := 1000000000000
tsp_union := 1.0
tsp_union := true
tsp_union := objid {0 4 0 12345 6789}
tsp_union := '1010101'B 
tsp_union := 'ABC'H 
tsp_union := 'AB'O 
tsp_union := "abc"
tsp_union := char(0, 0, 1, 113); 
tsp_union := {}
tsp_union := {1, 2, 3}
tsp_union := {[0] := 1, [1] := 2, [2] := 3}
tsp_union := {field1 := 1, field2 := 2, field3 := 3}
tsp_union := ENUM_1 

[EXECUTE]
Temp.control
<END_MODULE>

<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_integer'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_float'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_boolean'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_objid'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_verdict'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_bitstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_hexstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_octetstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_charstring'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_universal_charstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_enumerated'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_record'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_record.nonexistent1'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_record_of'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_set'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_set.nonexistent1'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_set_of'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_anytype'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_anytype.field3'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_union'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_union.field3'
<END_RESULT>
<RESULT COUNT 1>
(?im)Test execution summary: 0 test case was executed. Overall verdict: none
<END_RESULT>
<RESULT COUNT 1>

<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Module parameters - concatenation - negative tests 
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Module parameters - concatenation - negative tests>
<EXECUTE>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer ROI;
type record of ROI ROROI;

type set of integer SOI;
type set of SOI SOSOI;

// Record of
modulepar ROI tsp_ROI;
modulepar ROROI tsp_ROROI;

// Set of
modulepar SOI tsp_SOI;
modulepar SOSOI tsp_SOSOI;

type enumerated MyEnum {
  ENUM_1, ENUM_2
}

type record Rec {
  integer field1,
  integer field2
}

type record MySet {
  integer field1,
  integer field2
}


modulepar integer tsp_integer;
modulepar float tsp_float;
modulepar boolean tsp_boolean;
modulepar objid tsp_objid;
modulepar verdicttype tsp_verdict;
modulepar bitstring tsp_bitstring;
modulepar hexstring tsp_hexstring;
modulepar octetstring tsp_octetstring;
modulepar charstring tsp_charstring;
modulepar universal charstring tsp_universal_charstring;
modulepar MyEnum tsp_enumerated;
modulepar Rec tsp_record;
modulepar MySet tsp_set;
modulepar anytype tsp_anytype;
//modulepar MyComp_CT tsp_component; TR: HQ20070: modulepar cannot be component, test port or default
//modulepar default tsp_default;

type component MyComp_CT {
}
testcase tc_fail() runs on MyComp_CT {
  setverdict(fail);
}

control {
  execute(tc_fail());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]

// record of
tsp_ROI &= 1
tsp_ROI &= 1000000000000
tsp_ROI &= 1.0
tsp_ROI &= true
tsp_ROI &= objid {0 4 0 12345 6789}
tsp_ROI &= none 
tsp_ROI &= '1010101'B 
tsp_ROI &= 'ABC'H 
tsp_ROI &= 'AB'O 
tsp_ROI &= "abc" 
tsp_ROI &= char(0, 0, 1, 113); 
tsp_ROI &= { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_ROI &= ENUM_1 

tsp_ROI &= {2.5, 3.4} 
tsp_ROI &= {pass} 
tsp_ROI &= {[0] := 2, [1] := 3.4} 
tsp_ROROI &= 1
tsp_ROROI &= {1}

// set of
tsp_SOI &= 1
tsp_SOI &= 1000000000000
tsp_SOI &= 1.0
tsp_SOI &= true
tsp_SOI &= objid {0 4 0 12345 6789}
tsp_SOI &= none 
tsp_SOI &= '1010101'B 
tsp_SOI &= 'ABC'H 
tsp_SOI &= 'AB'O 
tsp_SOI &= "abc" 
tsp_SOI &= char(0, 0, 1, 113); 
tsp_SOI &= { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_SOI &= ENUM_1 

tsp_SOI &= {2.5, 3.4} 
tsp_SOI &= {pass} 
tsp_SOI &= {[0] := 2, [1] := 3.4} 
tsp_SOSOI &= 1
tsp_SOSOI &= {1}

tsp_integer &= 1
tsp_float &= 2.0
tsp_boolean &= true
tsp_objid &= objid {0 4 0 12345 6789}
tsp_verdict &= pass
tsp_bitstring &= '1010101'B
tsp_hexstring &= 'ABC'H
tsp_octetstring &= 'AB'O
tsp_charstring &= "abc"
tsp_universal_charstring &= char(0, 0, 1, 113)
tsp_enumerated &= ENUM_1
tsp_record &= 1
tsp_set &= 1
tsp_anytype &= 1
//tsp_component &= null
//tsp_default &= null;

tsp_integer &= {1}
tsp_float &= {2.0}
tsp_boolean &= {true}
tsp_objid &= {objid {0 4 0 12345 6789}}
tsp_verdict &= {pass}
tsp_bitstring &= {'1010101'B}
tsp_hexstring &= {'ABC'H}
tsp_octetstring &= {'AB'O}
tsp_charstring &= {"abc"}
tsp_universal_charstring &= {char(0, 0, 1, 113)}
tsp_enumerated &= {ENUM_1}
tsp_record &= {field1 := 1, field2 := 2}
tsp_set &= {field1 := 1, field2 := 2}
tsp_anytype &= {integer := 3}
//tsp_component &= {null}
//tsp_default &= {null};

[EXECUTE]
Temp.control
<END_MODULE>
<RESULT COUNT 28>
(?im)Error while concatenating parameter field 'tsp_ROI'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while setting parameter field 'tsp_ROI\[0\]'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_ROROI'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_ROROI\[0\]'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while concatenating parameter field 'tsp_SOI'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while setting parameter field 'tsp_SOI\[0\]'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_SOSOI'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_SOSOI\[0\]'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_integer'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_float'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_boolean'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_objid'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_verdict'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_bitstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_hexstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_octetstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_charstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_universal_charstring'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_enumerated'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_record'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_set'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_anytype'
<END_RESULT>

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Module Parameters - assignment - negative tests (parallel)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Module Parameters - assignment - negative tests (parallel)>
<EXECUTE_PARALLEL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer ROI;
type record Rec {
  integer field1
}

type set of integer SOI;
type set MySet {
  integer field1
}

type enumerated MyEnum {
  ENUM_1, ENUM_2
}

type union MyUnion {
  integer asdf
}

modulepar integer tsp_integer;
modulepar float tsp_float;
modulepar boolean tsp_boolean;
modulepar objid tsp_objid;
modulepar verdicttype tsp_verdict;
modulepar bitstring tsp_bitstring;
modulepar hexstring tsp_hexstring;
modulepar octetstring tsp_octetstring;
modulepar charstring tsp_charstring;
modulepar universal charstring tsp_universal_charstring;
modulepar MyEnum tsp_enumerated;
modulepar Rec tsp_record;
modulepar ROI tsp_record_of;
modulepar MySet tsp_set;
modulepar SOI tsp_set_of;
modulepar anytype tsp_anytype;
modulepar MyUnion tsp_union;
//modulepar MyComp_CT tsp_component; TR: HQ20070: modulepar cannot be component, test port or default
//modulepar default tsp_default;

type component MyComp_CT { }

testcase tc_fail() runs on MyComp_CT {
  setverdict(fail);
}

control {
  execute(tc_fail());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]
///////////////////////////////////////////
// Type mismatch tests                  //
/////////////////////////////////////////
// Integer
tsp_integer := 1.0
tsp_integer := true
tsp_integer := objid {0 4 0 12345 6789}
tsp_integer := none 
tsp_integer := '1010101'B 
tsp_integer := 'ABC'H 
tsp_integer := 'AB'O 
tsp_integer := "abc" 
tsp_integer := char(0, 0, 1, 113); 
tsp_integer := {1, 2, 3}
tsp_integer := {[0] := 1, [1] := 2, [2] := 3}
tsp_integer := {field1 := 1, field2 := 2, field3 := 3}
tsp_integer := ENUM_1

// Float 
tsp_float := 1
tsp_float := 1000000000000
tsp_float := true
tsp_float := objid {0 4 0 12345 6789}
tsp_float := none 
tsp_float := '1010101'B 
tsp_float := 'ABC'H 
tsp_float := 'AB'O 
tsp_float := "abc" 
tsp_float := char(0, 0, 1, 113); 
tsp_float := {1, 2, 3}
tsp_float := {[0] := 1, [1] := 2, [2] := 3}
tsp_float := {field1 := 1, field2 := 2, field3 := 3}
tsp_float := ENUM_1

// Boolean
tsp_boolean := 1
tsp_boolean := 1000000000000
tsp_boolean := 1.0
tsp_boolean := objid {0 4 0 12345 6789}
tsp_boolean := none 
tsp_boolean := '1010101'B 
tsp_boolean := 'ABC'H 
tsp_boolean := 'AB'O 
tsp_boolean := "abc" 
tsp_boolean := char(0, 0, 1, 113); 
tsp_boolean := {1, 2, 3}
tsp_boolean := {[0] := 1, [1] := 2, [2] := 3}
tsp_boolean := {field1 := 1, field2 := 2, field3 := 3}
tsp_boolean := ENUM_1 

// Objid
tsp_objid := 1
tsp_objid := 1000000000000
tsp_objid := 1.0
tsp_objid := true
tsp_objid := none 
tsp_objid := '1010101'B 
tsp_objid := 'ABC'H 
tsp_objid := 'AB'O 
tsp_objid := "abc"
tsp_objid := char(0, 0, 1, 113); 
tsp_objid := {1, 2, 3}
tsp_objid := {[0] := 1, [1] := 2, [2] := 3}
tsp_objid := {field1 := 1, field2 := 2, field3 := 3}
tsp_objid := ENUM_1 

// Verdict
tsp_verdict := 1
tsp_verdict := 1000000000000
tsp_verdict := 1.0
tsp_verdict := true
tsp_verdict := objid {0 4 0 12345 6789}
tsp_verdict := '1010101'B 
tsp_verdict := 'ABC'H 
tsp_verdict := 'AB'O 
tsp_verdict := "abc"
tsp_verdict := char(0, 0, 1, 113); 
tsp_verdict := {1, 2, 3}
tsp_verdict := {[0] := 1, [1] := 2, [2] := 3}
tsp_verdict := {field1 := 1, field2 := 2, field3 := 3}
tsp_verdict := ENUM_1 

//  Bitstring
tsp_bitstring := 1
tsp_bitstring := 1000000000000
tsp_bitstring := 1.0
tsp_bitstring := true
tsp_bitstring := objid {0 4 0 12345 6789}
tsp_bitstring := none 
tsp_bitstring := 'ABC'H 
tsp_bitstring := 'AB'O 
tsp_bitstring := "abc"
tsp_bitstring := char(0, 0, 1, 113); 
tsp_bitstring := {1, 2, 3}
tsp_bitstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_bitstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_bitstring := ENUM_1 

// Hexstring  
tsp_hexstring := 1
tsp_hexstring := 1000000000000
tsp_hexstring := 1.0
tsp_hexstring := true
tsp_hexstring := objid {0 4 0 12345 6789}
tsp_hexstring := none 
tsp_hexstring := '1010101'B 
tsp_hexstring := 'AB'O 
tsp_hexstring := "abc"
tsp_hexstring := char(0, 0, 1, 113); 
tsp_hexstring := {1, 2, 3}
tsp_hexstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_hexstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_hexstring := ENUM_1 

// Octetstring 
tsp_octetstring := 1
tsp_octetstring := 1000000000000
tsp_octetstring := 1.0
tsp_octetstring := true
tsp_octetstring := objid {0 4 0 12345 6789}
tsp_octetstring := none 
tsp_octetstring := '1010101'B 
tsp_octetstring := 'ABC'H 
tsp_octetstring := "abc"
tsp_octetstring := char(0, 0, 1, 113)
tsp_octetstring := {1, 2, 3}
tsp_octetstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_octetstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_octetstring := ENUM_1 

// Charstring
tsp_charstring := 1
tsp_charstring := 1000000000000
tsp_charstring := 1.0
tsp_charstring := true
tsp_charstring := objid {0 4 0 12345 6789}
tsp_charstring := none 
tsp_charstring := '1010101'B 
tsp_charstring := 'ABC'H 
tsp_charstring := 'AB'O 
tsp_charstring := char(0, 0, 1, 113) 
tsp_charstring := {1, 2, 3}
tsp_charstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_charstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_charstring := ENUM_1 

// Universal charstring
tsp_universal_charstring := 1
tsp_universal_charstring := 1000000000000
tsp_universal_charstring := 1.0
tsp_universal_charstring := true
tsp_universal_charstring := objid {0 4 0 12345 6789}
tsp_universal_charstring := none 
tsp_universal_charstring := '1010101'B 
tsp_universal_charstring := 'ABC'H 
tsp_universal_charstring := 'AB'O 
tsp_universal_charstring := {1, 2, 3}
tsp_universal_charstring := {[0] := 1, [1] := 2, [2] := 3}
tsp_universal_charstring := {field1 := 1, field2 := 2, field3 := 3}
tsp_universal_charstring := ENUM_1 

// Enumerated
tsp_enumerated := 1
tsp_enumerated := 1000000000000
tsp_enumerated := 1.0
tsp_enumerated := true
tsp_enumerated := objid {0 4 0 12345 6789}
tsp_enumerated := none 
tsp_enumerated := '1010101'B 
tsp_enumerated := 'ABC'H 
tsp_enumerated := 'AB'O 
tsp_enumerated := "abc" 
tsp_enumerated := char(0, 0, 1, 113) 
tsp_enumerated := {1, 2, 3}
tsp_enumerated := {[0] := 1, [1] := 2, [2] := 3}
tsp_enumerated := {field1 := 1, field2 := 2, field3 := 3}

// Record 
tsp_record := 1
tsp_record := 1000000000000
tsp_record := 1.0
tsp_record := true
tsp_record := objid {0 4 0 12345 6789}
tsp_record := none 
tsp_record := '1010101'B 
tsp_record := 'ABC'H 
tsp_record := 'AB'O 
tsp_record := "abc" 
tsp_record := char(0, 0, 1, 113); 
tsp_record := {1, 2, 3}
tsp_record := {[0] := 1, [1] := 2, [2] := 3}
tsp_record := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_record := ENUM_1 

// Record of
tsp_record_of := 1
tsp_record_of := 1000000000000
tsp_record_of := 1.0
tsp_record_of := true
tsp_record_of := objid {0 4 0 12345 6789}
tsp_record_of := none 
tsp_record_of := '1010101'B 
tsp_record_of := 'ABC'H 
tsp_record_of := 'AB'O 
tsp_record_of := "abc" 
tsp_record_of := char(0, 0, 1, 113); 
tsp_record_of := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_record_of:= ENUM_1 

// Set 
tsp_set := 1
tsp_set := 1000000000000
tsp_set := 1.0
tsp_set := true
tsp_set := objid {0 4 0 12345 6789}
tsp_set := none 
tsp_set := '1010101'B 
tsp_set := 'ABC'H 
tsp_set := 'AB'O 
tsp_set := "abc" 
tsp_set := char(0, 0, 1, 113); 
tsp_set := {1, 2, 3}
tsp_set := {[0] := 1, [1] := 2, [2] := 3}
tsp_set := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_set := ENUM_1 

// Set of
tsp_set_of := 1
tsp_set_of := 1000000000000
tsp_set_of := 1.0
tsp_set_of := true
tsp_set_of := objid {0 4 0 12345 6789}
tsp_set_of := none 
tsp_set_of := '1010101'B 
tsp_set_of := 'ABC'H 
tsp_set_of := 'AB'O 
tsp_set_of := "abc" 
tsp_set_of := char(0, 0, 1, 113); 
tsp_set_of := { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_set_of := ENUM_1 

// Anytype 
tsp_anytype := 1
tsp_anytype := 1000000000000
tsp_anytype := 1.0
tsp_anytype := true
tsp_anytype := objid {0 4 0 12345 6789}
tsp_anytype := '1010101'B 
tsp_anytype := 'ABC'H 
tsp_anytype := 'AB'O 
tsp_anytype := "abc"
tsp_anytype := char(0, 0, 1, 113); 
tsp_anytype := {1, 2, 3}
tsp_anytype := {[0] := 1, [1] := 2, [2] := 3}
tsp_anytype := {field1 := 1, field2 := 2, field3 := 3}
tsp_anytype := ENUM_1 

// Union 
tsp_union := 1
tsp_union := 1000000000000
tsp_union := 1.0
tsp_union := true
tsp_union := objid {0 4 0 12345 6789}
tsp_union := '1010101'B 
tsp_union := 'ABC'H 
tsp_union := 'AB'O 
tsp_union := "abc"
tsp_union := char(0, 0, 1, 113); 
tsp_union := {}
tsp_union := {1, 2, 3}
tsp_union := {[0] := 1, [1] := 2, [2] := 3}
tsp_union := {field1 := 1, field2 := 2, field3 := 3}
tsp_union := ENUM_1 


[EXECUTE]
Temp.control
<END_MODULE>

<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_integer'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_float'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_boolean'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_objid'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_verdict'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_bitstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_hexstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_octetstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_charstring'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_universal_charstring'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_enumerated'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_record'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_record.nonexistent1'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_record_of'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while setting parameter field 'tsp_set'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_set.nonexistent1'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_set_of'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_anytype'
<END_RESULT>
<RESULT COUNT 26>
(?im)Error while setting parameter field 'tsp_union'
<END_RESULT>

<RESULT COUNT 1>
(?im)There were errors during configuring HCs.
<END_RESULT>
<RESULT COUNT 1>

<END_RESULT>
<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h3. Module parameters - concatenation - negative tests (parallel)
.*---------------------------------------------------------------------*
:xmp tab=0.

<TC - Module parameters - concatenation - negative tests (parallel)>
<EXECUTE_PARALLEL>
<MODULE TTCN Temp Temp.ttcn>
module Temp {

type record of integer ROI;
type record of ROI ROROI;

type set of integer SOI;
type set of SOI SOSOI;

// Record of
modulepar ROI tsp_ROI;
modulepar ROROI tsp_ROROI;

// Set of
modulepar SOI tsp_SOI;
modulepar SOSOI tsp_SOSOI;

type enumerated MyEnum {
  ENUM_1, ENUM_2
}

type record Rec {
  integer field1,
  integer field2
}

type record MySet {
  integer field1,
  integer field2
}


modulepar integer tsp_integer;
modulepar float tsp_float;
modulepar boolean tsp_boolean;
modulepar objid tsp_objid;
modulepar verdicttype tsp_verdict;
modulepar bitstring tsp_bitstring;
modulepar hexstring tsp_hexstring;
modulepar octetstring tsp_octetstring;
modulepar charstring tsp_charstring;
modulepar universal charstring tsp_universal_charstring;
modulepar MyEnum tsp_enumerated;
modulepar Rec tsp_record;
modulepar MySet tsp_set;
modulepar anytype tsp_anytype;
//modulepar MyComp_CT tsp_component; TR: HQ20070: modulepar cannot be component, test port or default
//modulepar default tsp_default;

type component MyComp_CT {
}
testcase tc_fail() runs on MyComp_CT {
  setverdict(fail);
}

control {
  execute(tc_fail());
}
}
<END_MODULE>
<MODULE CFG Temp Temp.cfg>
[MODULE_PARAMETERS]

// record of
tsp_ROI &= 1
tsp_ROI &= 1000000000000
tsp_ROI &= 1.0
tsp_ROI &= true
tsp_ROI &= objid {0 4 0 12345 6789}
tsp_ROI &= none 
tsp_ROI &= '1010101'B 
tsp_ROI &= 'ABC'H 
tsp_ROI &= 'AB'O 
tsp_ROI &= "abc" 
tsp_ROI &= char(0, 0, 1, 113); 
tsp_ROI &= { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_ROI &= ENUM_1 

tsp_ROI &= {2.5, 3.4} 
tsp_ROI &= {pass} 
tsp_ROI &= {[0] := 2, [1] := 3.4} 
tsp_ROROI &= 1
tsp_ROROI &= {1}

// set of
tsp_SOI &= 1
tsp_SOI &= 1000000000000
tsp_SOI &= 1.0
tsp_SOI &= true
tsp_SOI &= objid {0 4 0 12345 6789}
tsp_SOI &= none 
tsp_SOI &= '1010101'B 
tsp_SOI &= 'ABC'H 
tsp_SOI &= 'AB'O 
tsp_SOI &= "abc" 
tsp_SOI &= char(0, 0, 1, 113); 
tsp_SOI &= { nonexistent1 := 1, nonexistent2 := 2, nonexistent3 := 3}
tsp_SOI &= ENUM_1 

tsp_SOI &= {2.5, 3.4} 
tsp_SOI &= {pass} 
tsp_SOI &= {[0] := 2, [1] := 3.4} 
tsp_SOSOI &= 1
tsp_SOSOI &= {1}

tsp_integer &= 1
tsp_float &= 2.0
tsp_boolean &= true
tsp_objid &= objid {0 4 0 12345 6789}
tsp_verdict &= pass
tsp_bitstring &= '1010101'B
tsp_hexstring &= 'ABC'H
tsp_octetstring &= 'AB'O
tsp_charstring &= "abc"
tsp_universal_charstring &= char(0, 0, 1, 113)
tsp_enumerated &= ENUM_1
tsp_record &= 1
tsp_set &= 1
tsp_anytype &= 1
//tsp_component &= null
//tsp_default &= null;

tsp_integer &= {1}
tsp_float &= {2.0}
tsp_boolean &= {true}
tsp_objid &= {objid {0 4 0 12345 6789}}
tsp_verdict &= {pass}
tsp_bitstring &= {'1010101'B}
tsp_hexstring &= {'ABC'H}
tsp_octetstring &= {'AB'O}
tsp_charstring &= {"abc"}
tsp_universal_charstring &= {char(0, 0, 1, 113)}
tsp_enumerated &= {ENUM_1}
tsp_record &= {field1 := 1, field2 := 2}
tsp_set &= {field1 := 1, field2 := 2}
tsp_anytype &= {integer := 3}
//tsp_component &= {null}
//tsp_default &= {null};

[EXECUTE]
Temp.control
<END_MODULE>
<RESULT COUNT 28>
(?im)Error while concatenating parameter field 'tsp_ROI'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while setting parameter field 'tsp_ROI\[0\]'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_ROROI'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_ROROI\[0\]'
<END_RESULT>
<RESULT COUNT 28>
(?im)Error while concatenating parameter field 'tsp_SOI'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while setting parameter field 'tsp_SOI\[0\]'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_SOSOI'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while setting parameter field 'tsp_SOSOI\[0\]'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_integer'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_float'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_boolean'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_objid'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_verdict'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_bitstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_hexstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_octetstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_charstring'
<END_RESULT>
<RESULT COUNT 2>
(?im)Error while concatenating parameter field 'tsp_universal_charstring'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_enumerated'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_record'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_set'
<END_RESULT>
<RESULT COUNT 4>
(?im)Error while concatenating parameter field 'tsp_anytype'
<END_RESULT>

<END_TC>

:exmp.

.*---------------------------------------------------------------------*
:h1.Abbreviations
.*---------------------------------------------------------------------*
:list.
:li D='ASN.1'.Abstract Syntax Notation 1
:li D='EDML'.Ericsson Document Markup Language
:li D='SA'.Semantic Analyser
:li D='TTCN-3'.Test and Test Control Notation version 3
:elist.

.*---------------------------------------------------------------------*
:h1.References
.*---------------------------------------------------------------------*
:list.
:li D='[1]'.ETH/RZ-2005:0120 Uen
:nl.Requirement Specification for the TITAN TTCN-3 Executor
:li D='[2]'.1/174 02-FCPCA 101 42 Uen
:nl.Statement of Compliance for TITAN project
:li D='[3]'.ETSI ES 201 873-1, v3.0.0 Mockup v1 (2004-03):
:nl.Testing and Test Control Notation version 3.,
:nl.Part 1: TTCN-3 Core Language
:elist.

.*---------------------------------------------------------------------*
:h1.Terminology
.*---------------------------------------------------------------------*
:list.
:li D='TITAN'.Ericsson's TTCN-3 Test Environment
:elist.

:etext.

